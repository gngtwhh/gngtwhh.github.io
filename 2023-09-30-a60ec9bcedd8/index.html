<!DOCTYPE html><html lang="zh-CN" data-theme="dark"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>C语言教程-9-运算符及其优先级和求值顺序 | WAHAHA's blog</title><meta name="author" content="WAHAHA"><meta name="copyright" content="WAHAHA"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#0d0d0d"><meta name="description" content="进一步扩充常用运算符,并讨论优先级和求值顺序">
<meta property="og:type" content="article">
<meta property="og:title" content="C语言教程-9-运算符及其优先级和求值顺序">
<meta property="og:url" content="https://gngtwhh.github.io/2023-09-30-a60ec9bcedd8/index.html">
<meta property="og:site_name" content="WAHAHA&#39;s blog">
<meta property="og:description" content="进一步扩充常用运算符,并讨论优先级和求值顺序">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://gngtwhh.github.io/img/avatar.jpg">
<meta property="article:published_time" content="2023-09-30T14:37:41.611Z">
<meta property="article:modified_time" content="2023-10-27T18:29:09.677Z">
<meta property="article:author" content="WAHAHA">
<meta property="article:tag" content="C">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://gngtwhh.github.io/img/avatar.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://gngtwhh.github.io/2023-09-30-a60ec9bcedd8/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'C语言教程-9-运算符及其优先级和求值顺序',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-10-28 02:29:09'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><script>(()=>{
  const $loadingBox = document.getElementById('loading-box')
  const $body = document.body
  const preloader = {
    endLoading: () => {
      $body.style.overflow = ''
      $loadingBox.classList.add('loaded')
    },
    initLoading: () => {
      $body.style.overflow = 'hidden'
      $loadingBox.classList.remove('loaded')
    }
  }

  preloader.initLoading()
  window.addEventListener('load',() => { preloader.endLoading() })

  if (false) {
    document.addEventListener('pjax:send', () => { preloader.initLoading() })
    document.addEventListener('pjax:complete', () => { preloader.endLoading() })
  }
})()</script><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">54</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">32</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">13</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 文章</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tools/"><i class="fa-fw fas fa-solid fa-wrench"></i><span> 工具</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background: transparent"><nav id="nav"><span id="blog-info"><a href="/" title="WAHAHA's blog"><img class="site-icon" src="/img/logo.png"/></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 文章</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tools/"><i class="fa-fw fas fa-solid fa-wrench"></i><span> 工具</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">C语言教程-9-运算符及其优先级和求值顺序</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-09-30T14:37:41.611Z" title="发表于 2023-09-30 22:37:41">2023-09-30</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-10-27T18:29:09.677Z" title="更新于 2023-10-28 02:29:09">2023-10-28</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/C%E8%AF%AD%E8%A8%80%E6%95%99%E7%A8%8B/">C语言教程</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">6.8k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>21分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="C语言教程-9-运算符及其优先级和求值顺序"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p>注意,本章讲解的<code>优先级</code>,<code>求值顺序</code>,<code>副作用</code>极其重要,甚至一些十分熟悉C语言的老手也可能会犯相关的错误!</p>
<h1 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h1><h2 id="什么是运算符"><a href="#什么是运算符" class="headerlink" title="什么是运算符"></a>什么是运算符</h2><p>我们在前面讲解过<code>表达式</code>,<code>语句</code>的概念,也讲解并使用了一些基本的<code>运算符</code>,例如四则运算,赋值运算符等.</p>
<p>这一部分我们将会详细扩充一些运算符,并仔细讲解运算符与表达式求值的一些重要细节.</p>
<p>运算符和表达式不可分割,我们再来看一下标准中对<code>表达式</code>的描述:</p>
<p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230923162451089.png"></p>
<p>再看一下Microsoft文档中关于操作数的描述:</p>
<img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230930224827531.png" alt="image-20230930224827531" style="zoom:40%;" />	

<p>也就是说,<code>运算符</code>及其<code>操作数</code>的序列组成一个表达式.单一的运算符无法发挥作用,必须至少有一个对应的操作数才能构成一个表达式.至于<code>操作数</code>的概念很好理解,简单来说就是参与运算的各种值.</p>
<p>下面来详细细分一下C语言中的各种运算符.</p>
<h2 id="基本运算符"><a href="#基本运算符" class="headerlink" title="基本运算符"></a>基本运算符</h2><p>我们之前已经大量的使用了这些运算符.</p>
<h3 id="赋值运算符-x3D"><a href="#赋值运算符-x3D" class="headerlink" title="赋值运算符: &#x3D;"></a>赋值运算符: &#x3D;</h3><p>C语言中,一个单独的<code>=</code>并不意味着”等于”,这和<code>Visual Baisc</code>等语言并不相同,他是一个赋值运算符.例如:</p>
<p><code>a = 3;</code></p>
<p>用于将&#x3D;右边的值<code>3</code>赋给左边的变量<code>a</code>.也就是说,&#x3D;左边是一个变量名,右侧是将要赋给该变量的值.</p>
<p>赋值行为是从右向左的.</p>
<p>进一步注意,我们需要区分变量名和变量值的区别,尽管他们的区别可能微乎其微,但是如果我们有:</p>
<p><code>i=i+1;</code></p>
<p>显然这个合法的语句在数学上行不通,但是,C语言中,这代表着把变量i的值加上1,然后将新值重新赋值给i变量.</p>
<p>另一方面,类似这样的语句是错误的:</p>
<p><code>3 = a;</code></p>
<p>因为3是一个常量,你不能对其进行修改—无论是从语法上还是从逻辑上都不正确.很显然,3就是3,我们当然不能把3”赋值”为4.实际上,我们判断这样的语句是否合法,看的是<code>=</code>左边是否为一个<code>左值</code>,更准确的说,是<code>可修改的左值</code>.</p>
<h4 id="数据对象-左值-右值"><a href="#数据对象-左值-右值" class="headerlink" title="数据对象,左值,右值"></a>数据对象,左值,右值</h4><p>这部分可参考C Primer Plus第六版的对应内容!</p>
<p>赋值表达式的实际效果是将某个值存储到某个指定的内存位置上,这一段指定的数据存储空间称之为<code>数据对象</code>,也许有些朋友了解过面向对象和面向过程的区别,请不要混淆,这里的”对象”指的是操作的焦点.C标准只有在这时才会使用<code>对象</code>这个术语.</p>
<p>C语言中,所谓<code>左值</code>就是用于标识特定数据对象的名称或表达式,所以,对象指的是实际的数据存储,而左值实际上是一个用于标识或定位存储位置的标签.例如<code>a=3;</code>中a就是标识了变量a的位置,编译器根据这个标签找到变量a的存储位置,最后把值3存储进去.</p>
<p>此外,上面还提到了表达式,而不仅仅只是一个简单名称,这意味着,只要能够正确标识一个位置,就是一个左值.关于这部分内容,我们需要学习到后面才能知道,例如可以使用<code>数组下标运算符</code>指定数组元素等,我们先不急.</p>
<p>我们还提到了<code>可修改的左值</code>,之所以说这个,是因为C标准中新增了(2023年早就已经不是新增了)<code>const</code>限定符,用const创建的变量的值不可变(我们之前讲解使用常量时提到过).那么,用const修饰过的变量自然不能作为<code>=运算符</code>的左操作数.</p>
<p>而至于<code>a=3;</code>中的3,相应的,是一个<code>右值</code>.右值指的是能赋给可修改左值的量,且本身不是左值.</p>
<p>总的来说,使用一个<code>=运算符</code>需要两个操作数,左侧(左操作数)必须为一个可修改的左值,而右侧(右操作数)既可以是左值也可以是一个右值,当然,一个不可修改的左值也可以作为右操作数.</p>
<h3 id="加法运算符"><a href="#加法运算符" class="headerlink" title="加法运算符: +"></a>加法运算符: +</h3><p>+的使用非常显而易见,但是我们需要注意的是,+的左右两个操作数无论是否为右值,最后加法运算的结果(也就是这个表达式的值)一定是一个右值.</p>
<p>例如:</p>
<p><code>a+b</code>中,a和b都是左值,但是a+b计算出来的值,也就是表达式a+b是一个右值.</p>
<h3 id="减法运算符"><a href="#减法运算符" class="headerlink" title="减法运算符: -"></a>减法运算符: -</h3><p>同理,它用于减法运算,和+一样,需要两个操作数.</p>
<p>+和-都需要两个操作数,所以他们都是<code>二元运算符</code>.</p>
<h3 id="符号运算符-和"><a href="#符号运算符-和" class="headerlink" title="符号运算符: +和-"></a>符号运算符: +和-</h3><p>这里和加法,减法运算符使用相同的符号,但是一定注意,他们是不同的!</p>
<p>因为我们可以有这样的一个表达式:</p>
<p><code>+a</code></p>
<p>或者</p>
<p><code>-a</code></p>
<p>这意味这此处的+或-仅仅需要一个操作数,所以他们都是<code>一元运算符</code>,其作用也很简单—取相反数.</p>
<p>不过在过去,<code>+a</code>是不被允许的.</p>
<h3 id="乘法和除法运算符-和-x2F"><a href="#乘法和除法运算符-和-x2F" class="headerlink" title="乘法和除法运算符: *和&#x2F;"></a>乘法和除法运算符: *和&#x2F;</h3><p>关于这两个表达式之前就说过了,他们也是<code>二元运算符</code>.需要注意的是,别忘了除法运算符有<code>截断</code>这个特性(整数除法结果的小数部分被丢弃).</p>
<h2 id="重点-运算符优先级和求值顺序"><a href="#重点-运算符优先级和求值顺序" class="headerlink" title="重点:运算符优先级和求值顺序"></a>重点:运算符优先级和求值顺序</h2><p>我们现在仅讲解了基本运算符,我们拿这些简单的运算符进行举例.</p>
<h3 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h3><p>优先级和数学上运算符优先级的意义是类似的,与数学相似,无论是加减乘除,还是赋值等运算符都有不同的优先级,如果一个表达式有多个运算符,我们首先根据优先级来确定表达式的运算顺序.</p>
<p>考虑下面的代码:</p>
<p><code>sum = 12.0 + 40.0 * n / part;</code></p>
<p>假设n的值为2,part的值为4.</p>
<p>这条语句中的赋值运算符右面有加法,乘法和除法运算符,先算哪一个?这里无需废话,和数学一样,先算乘除法,再算加减法,但是这是我们一眼看出来的,如果是C编译器来处理这段代码,则必须有提前规定好的运算顺序,也就是<code>先算乘除法,再算加减法</code>.</p>
<p>C语言中对此问题有着明确的规定,为每一个运算符都规定了各自的<code>优先级</code>,优先级高的运算符(乘除法)先执行运算,然后返回的结果再继续和优先级低的运算符(加减法)结合执行运算,这样,上面的代码如何运算就非常明确.</p>
<p>如果两个运算符的优先级相同怎么办?如果他们处理同一个运算符对象,则根据他们在语句中出现的顺序而言,<code>大多数运算符都是从左向右依次运算(=运算符除外)</code>.</p>
<p>如此,上面的语句是如此执行:</p>
<p>40.0 * n        首先计算*或&#x2F;,发现他们处理同一个操作数n,则根据从左向右结合的顺序,先计算*,结果是80.0</p>
<p>80.0 &#x2F; part     然后计算&#x2F;,结果为40.0</p>
<p>12.0 + 40.0     最终结果为52.0</p>
<p>到目前为止,我们学习过的运算符的优先级:</p>
<img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231004211804464.png" alt="image-20231004211804464" style="zoom:45%;" />

<p>注意对于C语言而言,符号运算符和加减法运算符是不同的,首先他们的操作数的数量就不同.</p>
<h3 id="求值顺序"><a href="#求值顺序" class="headerlink" title="求值顺序"></a>求值顺序</h3><p>为了解决运算顺序,C语言明确规定了运算符的优先级,但是这并没有规定所有的顺序,来看下面的代码:</p>
<p><code>y = 6 * 12 + 5 * 20;</code></p>
<p>当运算符共享一个运算对象时,优先级确定了求值顺序,再进一步,如果优先级相同(例如乘除),那么结合性进一步确定求值顺序.</p>
<p>但是,上面这个语句中,有两个乘法运算.显然这两个乘法比加法先进行运算,但是问题来了:这两个乘法先算哪个.</p>
<p>实际上,C语言<code>并未规定</code>这两个乘法先计算哪一个,这取决于具体实现—意味着不同的电脑(计算机),甚至是一台电脑上不同的编译器运行出来的结果也不相同—有可能先算前者的实现在A硬件上效率更高,在B硬件上反而更适合先算后者.这种未明确规定的行为叫做<code>未定义行为</code>,这里就是一个关于<code>求值顺序</code>的未定义行为,他们十分重要!</p>
<p>许多朋友可能认为这并不是一个问题,事实上非常重要,<strong>不清晰的代码甚至可能引发严重的问题</strong>(我们会在后面介绍到其他运算符后并重新讲解<code>副作用</code>时进行举例).</p>
<p>不过,就上面的这样代码而言,先算后算并没有影响,因为4个操作数都是常数,也就不存在副作用的影响,最终的结果显然不变.</p>
<h2 id="其他算数运算符"><a href="#其他算数运算符" class="headerlink" title="其他算数运算符"></a>其他算数运算符</h2><p>学习这节之前,要学会进制转换,并尽量了解原码,补码和反码.</p>
<h3 id="求模运算符"><a href="#求模运算符" class="headerlink" title="求模运算符: %"></a>求模运算符: %</h3><p>%运算符用于求<code>a除以b的余数</code>,该运算符要求左右两个操作数<code>必须</code>均为整数.</p>
<p>关于正数,没有任何问题.</p>
<p>对于负数而言,例如<code>-8%3</code>,其结果要多注意一下.</p>
<p>我们有公式:<code>A % B = A - A / B * B</code></p>
<p>或者可以简单记忆规律:</p>
<p><strong>取模运算结果的正负是由左操作数的正负决定的.如果%左操作数是正数,那么取模运算的结果是非负数;如果%左操作数是负数，那么取模运算的结果是负数或0</strong></p>
<h3 id="位运算符-amp-lt-lt-gt-gt"><a href="#位运算符-amp-lt-lt-gt-gt" class="headerlink" title="位运算符: &amp;,|,^,&lt;&lt;,&gt;&gt;"></a>位运算符: &amp;,|,^,&lt;&lt;,&gt;&gt;</h3><p>位运算的位,指的是二进制位,也就是说,位运算直接以二进制来处理操作数.</p>
<h4 id="按位与-amp"><a href="#按位与-amp" class="headerlink" title="按位与: &amp;"></a>按位与: &amp;</h4><p>二者皆为1,结果才为1,否则为0</p>
<p>例如 <code>3 &amp; 1</code>的结果为<code>1</code></p>
<p>即二进制011和001按位<code>与</code>运算,结果为001,也就是十进制1</p>
<h4 id="按位或"><a href="#按位或" class="headerlink" title="按位或: |"></a>按位或: |</h4><p>二者皆为0,结果才为0,否则为1</p>
<p>例如 <code>3 | 2</code>的结果为<code>3</code></p>
<p>即二进制011和010按位<code>或</code>运算,结果为011,也就是十进制3</p>
<h4 id="按位异或"><a href="#按位异或" class="headerlink" title="按位异或: ^"></a>按位异或: ^</h4><p>二者相同为0,不同为1</p>
<p>例如 <code>4 ^ 2</code>的结果为<code>6</code></p>
<p>即二进制100和010按位<code>异或</code>运算,结果为110,也就是十进制<code>6</code></p>
<h4 id="左移运算符-lt-lt"><a href="#左移运算符-lt-lt" class="headerlink" title="左移运算符: &lt;&lt;"></a>左移运算符: &lt;&lt;</h4><p>该运算符将操作数(以二进制处理)每一位向左移动(即向高位移动)k位,右边空出来的k位(即低位)用0填充,高位溢出的k位丢弃</p>
<p>例如 <code>3 &lt;&lt; 2</code>的结果为<code>12</code></p>
<p>这里以一个字节的移位来举例</p>
<p>即3的二进制00000011向左移动2位,结果为00001100,其中最左边的2个0丢弃,最右边填充2个0,也就是十进制<code>12</code></p>
<p>实际上,由于是对二进制移位,对m左移k位相当于m乘以2^k.例如3&lt;&lt;2的结果就是3*2^2,也就是12</p>
<p>如果不能理解,尝试假设十进制移位,将m进行十进制左移k位相当于乘以10^k,例如3&lt;&lt;(base10)2的结果就是3*10^2,也就是300</p>
<p>关于负数,左移会影响其符号位.</p>
<h4 id="右移运算符-gt-gt"><a href="#右移运算符-gt-gt" class="headerlink" title="右移运算符: &gt;&gt;"></a>右移运算符: &gt;&gt;</h4><p>这里要注意,尽量对正数进行右移,而不要对负数进行右移.</p>
<p>原因是:由于整数在计算机中以补码存储,最高位为符号位,那么就会有两种不同的右移—<code>算数右移</code>和<code>逻辑右移</code>.</p>
<h5 id="算数右移"><a href="#算数右移" class="headerlink" title="算数右移:"></a>算数右移:</h5><p>右移k位时,高位空出来的k位以原操作数的符号位填充,以保持结果的符号不变.</p>
<h5 id="逻辑右移"><a href="#逻辑右移" class="headerlink" title="逻辑右移:"></a>逻辑右移:</h5><p>右移k位时,高位空出来的k位以0填充.</p>
<h5 id="C语言的实现"><a href="#C语言的实现" class="headerlink" title="C语言的实现"></a>C语言的实现</h5><p>C语言中,右移取决于具体实现,尽管<code>大部分实现(编译器)为算数右移</code>,但是不能保证所有的机器&#x2F;编译器都是这样.</p>
<p>也就是说,C语言中,对于有符号数的右移操作,这是一个<code>未定义行为</code>.我们尽量避免对有符号数(负数)进行右移操作.</p>
<h4 id="移位运算符的问题"><a href="#移位运算符的问题" class="headerlink" title="移位运算符的问题"></a>移位运算符的问题</h4><p>关于左移和右移的另一个问题是,如果我们指定移动的位数为负数(例如<code>&lt;&lt; -3</code>),或者大于等于左操作数原本的二进制位数(例如,int为32位,但是我们<code>&lt;&lt; 33</code>)</p>
<p>那么<code>该行为未定义</code>,具体请查阅文档.例如,某些实现中,对int值进行<code>&lt;&lt; -3</code>被处理为<code>&lt;&lt; 32 + (-3)</code>也就是<code>&lt;&lt; 29</code></p>
<h2 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h2><p>与&amp;&amp;,或||,非!</p>
<p>注意位运算的&amp;和|是单独的一个&amp;和|,与逻辑运算符没有任何关系</p>
<p>在讲解循环的时候,已经讲解了逻辑运算符,已经基本包含所有问题,同时讲解了<code>短路效应</code>,短路效应可能引发的问题会在后面<code>副作用</code>的讲解中描述.</p>
<h2 id="比较-关系-运算符"><a href="#比较-关系-运算符" class="headerlink" title="比较(关系)运算符"></a>比较(关系)运算符</h2><p>&#x3D;&#x3D;,&lt;&#x3D;,&gt;&#x3D;,&lt;,&gt;,!&#x3D;</p>
<p>同样在前面已经讲解.</p>
<p>需要注意的是,比较运算符常常和逻辑运算符搭配,例如:</p>
<p><code>if(a &gt;= 0 &amp;&amp; a &lt;= 100)</code></p>
<p>这里仍需要注意<code>优先级</code>的问题,逻辑运算符的优先级整体低于比较运算符(除了<code>非!</code>),所以,先判断a的两个范围,即<code>是否大于等于0</code>和<code>是否小于等于100</code>,最后取并集,也就是是否在0~100内.</p>
<p>实际上也就是<code>if( ( a &gt;= 0 ) &amp;&amp; ( a &lt;= 100 ) )</code></p>
<p>一般情况下,<code>()</code>的优先级全场最高(虽然标准中并未将其定义为运算符,但是一般将其称为”括号运算符”),我们可以使用<code>()</code>来改变优先级.</p>
<h2 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h2><p>不仅仅有<code>=运算符</code>这个最基本的赋值运算符,为了简化代码,C语言还有其他的几种赋值运算符,我们将其称为<code>复合赋值运算符</code>.我们直接来看<code>标准</code>中的描述:</p>
<img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231004230937705.png" alt="image-20231004230937705" style="zoom:50%;" />	

<p>就是这些,写代码时如果有类似的赋值,直接使用复合赋值运算符即可.</p>
<h2 id="自增自减运算符"><a href="#自增自减运算符" class="headerlink" title="自增自减运算符"></a>自增自减运算符</h2><p>这两个运算符本来是用于简化形如<code>a=a+1</code>和<code>a=a-1</code>这样的表达式的,但是实际上,有些其他语言的开发者甚至认为C语言的这两个运算符的特性带来的弊大于利.</p>
<h3 id="和–运算符"><a href="#和–运算符" class="headerlink" title="++和–运算符"></a>++和–运算符</h3><p>正如上面所写,用于简化形如<code>a=a+1</code>和<code>a=a-1</code>这样的表达式.</p>
<p><code>a=a+1</code>就等价于单独的<code>++a</code>或者<code>a++</code></p>
<p><code>a=a-1</code>就等价于单独的<code>--a</code>或者<code>a--</code></p>
<p>++和–有一个操作数,并允许该操作数放在左边(前缀自增&#x2F;自减,例如a++)或放在右边(后缀自增&#x2F;自减,例如–a)</p>
<h4 id="前缀和后缀的重要区别与副作用"><a href="#前缀和后缀的重要区别与副作用" class="headerlink" title="前缀和后缀的重要区别与副作用"></a>前缀和后缀的重要区别与副作用</h4><p>前缀和后缀两种写法在单独使用时没有任何区别(一般编译器都会进行优化).</p>
<p>但是如果将其放在表达式中,就会出现区别.考虑下面两个语句:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a=<span class="number">3</span>,b=<span class="number">3</span>,c,d;</span><br><span class="line"><span class="comment">// 第一条语句</span></span><br><span class="line">c = ++a;</span><br><span class="line"><span class="comment">// 第二条语句</span></span><br><span class="line">d = b++;</span><br></pre></td></tr></table></figure>

<p>读者认为执行完后a,b,c,d的值各自是什么?</p>
<p>答案是: a为4,b为4,c为4,d为3</p>
<p>是否出乎你的预料?</p>
<p>实际上是这样的,从结果上来看:</p>
<p>1.前缀<code>++a</code>返回的结果为a自增后的值,也就是4,将其赋值给c,a最终为4</p>
<p>2.后缀<code>b++</code>返回的结果为b自增前的值,也就是3,将其赋值给d,b最终也为4</p>
<p>也就是说,前缀和后缀都会将操作数自增,但是这个表达式作为一个整体,返回的值是不一样的.</p>
<p>有的人可能会这么理解:<code>&quot;++a是先自增,再返回值;a++是先返回值,再自增&quot;</code></p>
<p>从初学的角度和前后缀写法表现出的结果来看,这么理解情有可原,但是!这样的理解绝对错误!</p>
<p>错误的原因在于认为返回值这个操作先于自增运算.</p>
<p>事实上,任意的运算符,都会返回一个值,也就是运算结果,例如<code>1+1</code>返回一个<code>2</code>作为运算结果,而任何运算符,都是要先将其运算彻底完成,最终将特定的某一个值作为这个表达式的值返回.</p>
<p>有关这个问题,在后面的<code>指针自增运算和解引用</code>还会进行讲解!</p>
<p>为了讲明前缀和后缀的运算过程,我们直接写出其(类似,这里相当于模拟了一个函数)等价的代码:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//++a类似等价于下面的几行代码:</span></span><br><span class="line">a = a + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> a;</span><br><span class="line"></span><br><span class="line"><span class="comment">//a++类似等价于下面的几行代码:</span></span><br><span class="line">temp = a;</span><br><span class="line">a = a + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> temp;</span><br></pre></td></tr></table></figure>

<p>我们实际上把++a或a++这两个表达式的值使用return语句来表示,相信各位能够理解我这里的意思,而不是去错误的疯狂思考为什么和return是”等价的”.</p>
<p>显然,我们可以看出:</p>
<p>1.对于<code>++a</code>,我们单纯的将其值加1,然后将a返回即可,所以,<code>++a</code>的值为a的新值.</p>
<p>2.对于<code>a++</code>,我们<code>创建</code>了一个<code>副本</code>(也就是temp,由于演示,a不一定是int)来保存a原来的值,然后a的值加1,最后返回temp,也就是a原来的值.此时,a已经是新值了,但是<code>++a</code>的值为a的旧值.</p>
<p>以上拿++来讲解,–是完全同理的.</p>
<p>上面已经讲解的十分明白了,如果各位感兴趣,可以去看《C和指针》这本书中相关的讲解.</p>
<p>尽管++和–的主要目的是将操作数的值加1或减1,但是我个人仍然愿意将其归为这个运算符的<code>副作用</code>,毕竟,其要组成表达式,表达式的值<code>通常</code>是重点关注的对象.但是,巧就巧在这里我们既要关心自增,又要使用其返回的值.</p>
<p>那么,我个人倾向于将++a或–a等视作”有副作用的表达式”,也就是说,<code>我更关心这个表达式最终的值</code>,而这几个表达式的主要作用—将a自增或自减1—我认为是<code>副作用</code>,因为对这个表达式进行求值是不可逆的(当然可以再减回去或加回去,你知道我不是这个意思),<code>它们让a的值发生了变化</code>!</p>
<p>这里再次出现了<code>副作用</code>的概念,虽然大部分资料均为有这个名词的描述,可能甚至根本不关心,但是由于初学者的许多代码(无论是他们自己写的,或者是某些烂书&#x2F;烂资料&#x2F;烂题中出现的)常常会纠结表达式的<code>副作用</code>及引出的相关一些<code>未定义行为</code>,从而导致理解和使用的错误,本教程要对这个问题进行详细讨论!</p>
<h2 id="其他运算符"><a href="#其他运算符" class="headerlink" title="其他运算符"></a>其他运算符</h2><h3 id="sizeof运算符"><a href="#sizeof运算符" class="headerlink" title="sizeof运算符"></a>sizeof运算符</h3><p>是的,这是一个运算符,可能许多朋友认为他是一个函数,但是他确确实实是一个运算符.</p>
<p>sizeof运算符用于求运算对象的大小,结果以字节为单位.</p>
<p>运算对象可以是<code>类型</code>或<code>表达式</code>.</p>
<p>例如:</p>
<p><code>sizeof(int)</code>在32位机器下的结果为<code>4</code>—大多数情况下int占用4字节</p>
<p><code>sizeof(char)</code>的结果为<code>1</code>—char类型占用1字节</p>
<p>若有<code>char a=2;</code>那么<code>sizeof(a)</code>的结果为1—char类型的变量占用1字节</p>
<p>之所以说sizeof不是函数,是因为我们可以这样写:</p>
<p>若有<code>char a=2;</code>那么可以写<code>sizeof a</code>,省略了<code>小括号()</code></p>
<p>但是需要注意,sizeof作用于类型的时候,必须加上<code>小括号()</code>:</p>
<img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231004235532383.png" alt="image-20231004235532383" style="zoom:50%;" />

<p>上图可以看出编译器报错了.</p>
<p>注意,sizeof运算符返回的结果并不是<code>int</code>,而是<code>size_t</code>:</p>
<p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231004235749893.png" alt="image-20231004235749893" style="zoom:50%;" />	我们只要记住他是一个无符号的整数即可,而且通常printf时最好使用%llu来输出:</p>
<img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231004235906154.png" alt="image-20231004235906154" style="zoom:50%;" />

<p>上图为CLion的截图,CLion对这里的%d做出了警告,当然,因为sizeof(int)和sizeof(char)的值太小了,实际上用%d也无妨,但是,最好还是规范代码.</p>
<h3 id="逗号运算符"><a href="#逗号运算符" class="headerlink" title="逗号运算符: ,"></a>逗号运算符: ,</h3><p>逗号运算符<code>,</code>用于将多个表达式连接起来,构成一个更大的表达式—可以叫它<code>逗号表达式</code>.</p>
<p>需要注意的两点是,<code>逗号运算符是全局优先级最低的运算符,并且其结合律为从左向右</code>.</p>
<p>另外重要的一点是,<code>最后一个子表达式的值作为整个逗号表达式的值来返回</code>.</p>
<h4 id="使用示例1"><a href="#使用示例1" class="headerlink" title="使用示例1:"></a>使用示例1:</h4><p>我们可以利用逗号运算符将不相关的,功能相似的几步操作放在一起.例如:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> a, b, c;</span><br><span class="line">    a = b = c = <span class="number">4</span>; <span class="comment">// 由于各个赋值运算符的优先级相同,且结合律为从右向左,所以先执行c=4,然后b=c=4,最后a=b=4</span></span><br><span class="line">    a++, b++, c++; <span class="comment">//   逗号表达式的优先级最低,且结合律为从左向右,所以先执行a++,然后b++,最后c++</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d %d %d\n&quot;</span>, a, b, c); <span class="comment">// 5 5 5</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面这段代码举了一个最简单的例子,我们想要把a,c,c的值都自增1,并且互不影响,就可以这么写在用一条语句中,使用逗号运算符进行连接.</p>
<h4 id="使用示例2"><a href="#使用示例2" class="headerlink" title="使用示例2:"></a>使用示例2:</h4><p>必须指出的是,一定要注意<code>互不影响</code>这个问题,如果各个表达式的求值之间有影响,那么就需要慎重考虑,甚至运行结果可能不是我们想要的.例如举一个没有什么实际意义的例子:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">3</span>, b = <span class="number">4</span>;</span><br><span class="line">    a = b + <span class="number">1</span>, <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, a); <span class="comment">// 输出结果为5</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>尽管这段代码没有什么实际意义,但是足以说明问题.</p>
<p>前面已说明,逗号运算符的优先级全场最低,所以第5行的语句中有两个被逗号运算符连接起来的表达式:</p>
<p><code>a = b + 1</code>和<code>printf(&quot;%d&quot;,a)</code></p>
<p>第二个表达式调用了printf()函数,它叫做<code>函数调用表达式</code>,这里的<code>小括号()</code>前面加上一个函数标识符(中间可能有参数)代表一个<code>函数调用</code>.</p>
<p>前面同样已说明,逗号运算符的结合性是从左向右,那么我们应该先计算<code>a = b + 1</code>,让a的值变为<code>5</code>,然后在调用printf()函数将a的值输出,所以最终的输出结果是<code>5</code>.</p>
<p>这里同样可以认为对a赋值实际上产生了一个副作用,然后这个副作用影响到了后面的表达式的继续求值—对printf的调用仍然认为是对表达式求值,只是这里的表达式是一个<code>函数调用表达式</code>.导致输出的a不再是原来的<code>3</code>.</p>
<h4 id="使用示例3"><a href="#使用示例3" class="headerlink" title="使用示例3:"></a>使用示例3:</h4><p>如果你还是对这里的副作用的影响没有什么重视的话,下面的代码可能让你重新思考:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">3</span>, b;</span><br><span class="line">    b = (++a, a);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, b); <span class="comment">// 输出结果为4</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我知道很多人可能会骂我,说我用一个很不好的(甚至是极差的)代码作为例子来讲解,但是,为了说明轻视副作用可能导致的危害,我还是要以一些不良的代码作为反面教材.</p>
<p>我们前面的示例1和示例2都在主要关注由逗号运算符连接起来的两个子表达式,在示例3中,我们的代码的关注点是<code>逗号表达式</code>整体的值!</p>
<p>显然,(++a,a)的两个子表达式之间的副作用有互相影响—即++a执行后,对a的求值结果将会是一个自增后的新值.</p>
<p>前面已经说明:<code>最后一个子表达式的值作为整个逗号表达式的值来返回</code>.那么,<code>++a,a</code>这个表达式的最终的值就是最后一个表达式<code>a</code>的值,由于<code>++a</code>使a变为4,则表达式<code>a</code>的值为<code>4</code>,进而最终赋值给b的值为<code>4</code>.</p>
<p>所以,最后输出的结果为<code>4</code>.</p>
<p>这个示例示范了如何求整个逗号表达式的值,并进一步的说明了副作用的问题.如果<code>++a</code>不是我们的本意,那么就很可能存在一个难以察觉的bug.</p>
<p><code>我们要万分小心,仅仅是初学到现在,我们就已经遇到了好几种运算符的副作用可能引发的潜在问题!---即使你自己完全没有意识到!</code></p>
<h4 id="进一步拓展-低级错误引发的bug"><a href="#进一步拓展-低级错误引发的bug" class="headerlink" title="进一步拓展-低级错误引发的bug"></a>进一步拓展-低级错误引发的bug</h4><p>注:上面的讲解可能有点牵强,实际上,更常见的出乎我们本意的代码是这样:</p>
<p>将 <code>a == 3</code>错误地写成 <code>a = 3</code>,原来的表达式用于检验a的值是否为3—根据实际情况返回1或者0.</p>
<p>但是 <code>a = 3</code>却是直接将a的值覆盖为3,然后这个表达式返回<code>=</code>右边的值,也就是3,C语言中,3为非0值,意味着这个表达式的永远为真!这才算得上是一个非常容易犯的低级错误—导致了一个可能很难察觉的bug—也许大多数情况下他本来就是<code>真</code>,所以短时间很难发觉这个bug!</p>
<p>所以,很多人愿意将上面的表达式这样写: <code>3 == a</code>,因为 <code>3 = a</code>的写法根本无法通过编译!</p>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>其他的运算符暂时不予讲解,学了后面的知识才能进行讲解.</p>
<p>例如<code>成员访问运算符</code>等.</p>
<br>

<p>本章进行了运算符,优先级,求值顺序的讲解.同时在关键的前缀&#x2F;后缀++或–的讲解中描述了什么是<code>副作用</code>,由于在许多方面都会有体现,并且碍于目前讲到的知识不足,这里不方便展开讲解,所以在后面的各个知识点的讲解中会穿插进行讲解.</p>
<p>​																	—WAHAHA 2023.10.4</p>
<br>

<br>

<p>上一篇:<a href="../2023-09-27-0671b7d09817">C语言教程-8-跳转控制和嵌套</a></p>
<p>下一篇:<a href="../2023-10-20-b7fda0df05ff">C语言教程-10-数组</a></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://gngtwhh.github.io">WAHAHA</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://gngtwhh.github.io/2023-09-30-a60ec9bcedd8/">https://gngtwhh.github.io/2023-09-30-a60ec9bcedd8/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://gngtwhh.github.io" target="_blank">WAHAHA's blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/C/">C</a></div><div class="post_share"><div class="social-share" data-image="/img/avatar.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/reward/wechat_reward.jpg" target="_blank"><img class="post-qr-code-img" src="/img/reward/wechat_reward.jpg" alt="wechat"/></a><div class="post-qr-code-desc">wechat</div></li><li class="reward-item"><a href="/img/reward/alipay_reward.png" target="_blank"><img class="post-qr-code-img" src="/img/reward/alipay_reward.png" alt="alipay"/></a><div class="post-qr-code-desc">alipay</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023-09-30-d0939b85fcd0/" title="程序结构分析"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">程序结构分析</div></div></a></div><div class="next-post pull-right"><a href="/2023-09-30-4deceb66e98f/" title="C语言教程-1_2-关键概念"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">C语言教程-1_2-关键概念</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2023-09-08-79dbc5fa8424/" title="C语言贪吃蛇"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-09-08</div><div class="title">C语言贪吃蛇</div></div></a></div><div><a href="/2023-10-06-b45ef26d6ec3/" title="C语言教程-11-字符串"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-10-06</div><div class="title">C语言教程-11-字符串</div></div></a></div><div><a href="/2023-10-20-b7fda0df05ff/" title="C语言教程-10-数组"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-10-20</div><div class="title">C语言教程-10-数组</div></div></a></div><div><a href="/2023-10-31-82eafac4349b/" title="C语言教程-12_1-初识函数"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-10-31</div><div class="title">C语言教程-12_1-初识函数</div></div></a></div><div><a href="/2023-11-01-def693eb5bf8/" title="C语言教程-12_2-深入分析函数和面向过程初识"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-11-01</div><div class="title">C语言教程-12_2-深入分析函数和面向过程初识</div></div></a></div><div><a href="/2023-11-01-39a6f8c668c3/" title="C语言教程-12_3-函数的其他用法和特性"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-11-01</div><div class="title">C语言教程-12_3-函数的其他用法和特性</div></div></a></div></div></div><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="twikoo-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">WAHAHA</div><div class="author-info__description">一个爱折腾的蒟蒻</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">54</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">32</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">13</div></a></div><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/gngtwhh" target="_blank" title="Github"><i class="fab fa-brands fa-github"></i></a><a class="social-icon" href="mailto:2784126850@qq.com" target="_blank" title="Email"><i class="fas fa-solid fa-envelope"></i></a></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">1.</span> <span class="toc-text">运算符</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">1.1.</span> <span class="toc-text">什么是运算符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">1.2.</span> <span class="toc-text">基本运算符</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6-x3D"><span class="toc-number">1.2.1.</span> <span class="toc-text">赋值运算符: &#x3D;</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%AF%B9%E8%B1%A1-%E5%B7%A6%E5%80%BC-%E5%8F%B3%E5%80%BC"><span class="toc-number">1.2.1.1.</span> <span class="toc-text">数据对象,左值,右值</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A0%E6%B3%95%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">1.2.2.</span> <span class="toc-text">加法运算符: +</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%8F%E6%B3%95%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">1.2.3.</span> <span class="toc-text">减法运算符: -</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%A6%E5%8F%B7%E8%BF%90%E7%AE%97%E7%AC%A6-%E5%92%8C"><span class="toc-number">1.2.4.</span> <span class="toc-text">符号运算符: +和-</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B9%98%E6%B3%95%E5%92%8C%E9%99%A4%E6%B3%95%E8%BF%90%E7%AE%97%E7%AC%A6-%E5%92%8C-x2F"><span class="toc-number">1.2.5.</span> <span class="toc-text">乘法和除法运算符: *和&#x2F;</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%87%8D%E7%82%B9-%E8%BF%90%E7%AE%97%E7%AC%A6%E4%BC%98%E5%85%88%E7%BA%A7%E5%92%8C%E6%B1%82%E5%80%BC%E9%A1%BA%E5%BA%8F"><span class="toc-number">1.3.</span> <span class="toc-text">重点:运算符优先级和求值顺序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%98%E5%85%88%E7%BA%A7"><span class="toc-number">1.3.1.</span> <span class="toc-text">优先级</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B1%82%E5%80%BC%E9%A1%BA%E5%BA%8F"><span class="toc-number">1.3.2.</span> <span class="toc-text">求值顺序</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E7%AE%97%E6%95%B0%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">1.4.</span> <span class="toc-text">其他算数运算符</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B1%82%E6%A8%A1%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">1.4.1.</span> <span class="toc-text">求模运算符: %</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%8D%E8%BF%90%E7%AE%97%E7%AC%A6-amp-lt-lt-gt-gt"><span class="toc-number">1.4.2.</span> <span class="toc-text">位运算符: &amp;,|,^,&lt;&lt;,&gt;&gt;</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8C%89%E4%BD%8D%E4%B8%8E-amp"><span class="toc-number">1.4.2.1.</span> <span class="toc-text">按位与: &amp;</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8C%89%E4%BD%8D%E6%88%96"><span class="toc-number">1.4.2.2.</span> <span class="toc-text">按位或: |</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8C%89%E4%BD%8D%E5%BC%82%E6%88%96"><span class="toc-number">1.4.2.3.</span> <span class="toc-text">按位异或: ^</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B7%A6%E7%A7%BB%E8%BF%90%E7%AE%97%E7%AC%A6-lt-lt"><span class="toc-number">1.4.2.4.</span> <span class="toc-text">左移运算符: &lt;&lt;</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%B3%E7%A7%BB%E8%BF%90%E7%AE%97%E7%AC%A6-gt-gt"><span class="toc-number">1.4.2.5.</span> <span class="toc-text">右移运算符: &gt;&gt;</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%AE%97%E6%95%B0%E5%8F%B3%E7%A7%BB"><span class="toc-number">1.4.2.5.1.</span> <span class="toc-text">算数右移:</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%80%BB%E8%BE%91%E5%8F%B3%E7%A7%BB"><span class="toc-number">1.4.2.5.2.</span> <span class="toc-text">逻辑右移:</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#C%E8%AF%AD%E8%A8%80%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.4.2.5.3.</span> <span class="toc-text">C语言的实现</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A7%BB%E4%BD%8D%E8%BF%90%E7%AE%97%E7%AC%A6%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">1.4.2.6.</span> <span class="toc-text">移位运算符的问题</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">1.5.</span> <span class="toc-text">逻辑运算符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%AF%94%E8%BE%83-%E5%85%B3%E7%B3%BB-%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">1.6.</span> <span class="toc-text">比较(关系)运算符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">1.7.</span> <span class="toc-text">赋值运算符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%87%AA%E5%A2%9E%E8%87%AA%E5%87%8F%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">1.8.</span> <span class="toc-text">自增自减运算符</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%92%8C%E2%80%93%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">1.8.1.</span> <span class="toc-text">++和–运算符</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%89%8D%E7%BC%80%E5%92%8C%E5%90%8E%E7%BC%80%E7%9A%84%E9%87%8D%E8%A6%81%E5%8C%BA%E5%88%AB%E4%B8%8E%E5%89%AF%E4%BD%9C%E7%94%A8"><span class="toc-number">1.8.1.1.</span> <span class="toc-text">前缀和后缀的重要区别与副作用</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">1.9.</span> <span class="toc-text">其他运算符</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#sizeof%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">1.9.1.</span> <span class="toc-text">sizeof运算符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%97%E5%8F%B7%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">1.9.2.</span> <span class="toc-text">逗号运算符: ,</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B1"><span class="toc-number">1.9.2.1.</span> <span class="toc-text">使用示例1:</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B2"><span class="toc-number">1.9.2.2.</span> <span class="toc-text">使用示例2:</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B3"><span class="toc-number">1.9.2.3.</span> <span class="toc-text">使用示例3:</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9B%E4%B8%80%E6%AD%A5%E6%8B%93%E5%B1%95-%E4%BD%8E%E7%BA%A7%E9%94%99%E8%AF%AF%E5%BC%95%E5%8F%91%E7%9A%84bug"><span class="toc-number">1.9.2.4.</span> <span class="toc-text">进一步拓展-低级错误引发的bug</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B6%E4%BB%96"><span class="toc-number">1.9.3.</span> <span class="toc-text">其他</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023-11-30-9ab73a7c6d7f/" title="Bellman-Ford算法">Bellman-Ford算法</a><time datetime="2023-11-30T04:17:16.275Z" title="发表于 2023-11-30 12:17:16">2023-11-30</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023-11-29-81439dc74e5e/" title="迪杰斯特拉算法">迪杰斯特拉算法</a><time datetime="2023-11-28T17:02:01.138Z" title="发表于 2023-11-29 01:02:01">2023-11-29</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023-11-26-270f21643ff7/" title="C语言教程-13_2-指针类型与指针运算">C语言教程-13_2-指针类型与指针运算</a><time datetime="2023-11-26T06:00:49.353Z" title="发表于 2023-11-26 14:00:49">2023-11-26</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023-11-19-354e7a2c8c35/" title="PE文件分析">PE文件分析</a><time datetime="2023-11-19T04:33:35.287Z" title="发表于 2023-11-19 12:33:35">2023-11-19</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023-11-17-10666f346238/" title="C语言教程-13_1-初识指针">C语言教程-13_1-初识指针</a><time datetime="2023-11-17T05:32:46.016Z" title="发表于 2023-11-17 13:32:46">2023-11-17</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2023 By WAHAHA</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">Hi, welcome to my <a href="https://gngtwhh.github.io/">blog</a>!</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><div class="js-pjax"><script>(()=>{
  const init = () => {
    twikoo.init(Object.assign({
      el: '#twikoo-wrap',
      envId: 'https://wahahablog.netlify.app/.netlify/functions/twikoo',
      region: '',
      onCommentLoaded: function () {
        btf.loadLightbox(document.querySelectorAll('#twikoo .tk-content img:not(.tk-owo-emotion)'))
      }
    }, null))
  }

  const getCount = () => {
    const countELement = document.getElementById('twikoo-count')
    if(!countELement) return
    twikoo.getCommentsCount({
      envId: 'https://wahahablog.netlify.app/.netlify/functions/twikoo',
      region: '',
      urls: [window.location.pathname],
      includeReply: false
    }).then(function (res) {
      countELement.textContent = res[0].count
    }).catch(function (err) {
      console.error(err);
    });
  }

  const runFn = () => {
    init()
    
  }

  const loadTwikoo = () => {
    if (typeof twikoo === 'object') {
      setTimeout(runFn,0)
      return
    } 
    getScript('https://cdn.jsdelivr.net/npm/twikoo/dist/twikoo.all.min.js').then(runFn)
  }

  if ('Twikoo' === 'Twikoo' || !false) {
    if (false) btf.loadComment(document.getElementById('twikoo-wrap'), loadTwikoo)
    else loadTwikoo()
  } else {
    window.loadOtherComment = () => {
      loadTwikoo()
    }
  }
})()</script></div><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-fluttering-ribbon.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = false;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script id="click-show-text" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-show-text.min.js" data-mobile="false" data-text="C语言,是世界上,最美的,语言" data-fontsize="15px" data-random="false" async="async"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div class="no-result" id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>